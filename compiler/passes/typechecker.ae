use "@/passes/generic_pass.ae"
use "@/ast.ae"
use "@/utils.ae"
use "lib/map.ae"

// This pass actually goes through the AST and checks the types of all the nodes.
// Any remaining unresolved types should be resolved after this

struct TypeChecker {
    o: &GenericPass

    cur_func: &Function
    in_loop: bool
    can_yield: bool
}

// Some convenience accessors from the GenericPass
def TypeChecker::error(&this, err: &Error): &Error => .o.error(err)
def TypeChecker::scope(&this): &Scope => .o.scope()


def TypeChecker::check_block(&this, node: &AST, is_expr: bool, hint: &Type) {
    let block = node.u.block
    block.scope = Scope::new(.scope())
    let could_yield = .can_yield
    .can_yield = could_yield or is_expr

    .o.push_scope(block.scope)
    let stmts = block.statements
    let yield_span = Span::default()
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt)
        if stmt.type != Yield then continue
        if node.etype? {
            .error(Error::new_hint(
                stmt.span, "Cannot yield multiple times in a block",
                yield_span, "Previously yielded here"
            ))
        }
        node.etype = stmt.etype
        yield_span = stmt.span
    }
    .o.pop_scope()
    .can_yield = could_yield

}

def TypeChecker::check_method_call(&this, method: &Function, node: &AST) {
    let callee = node.u.call.callee
    if callee.type != ASTType::Member and callee.type != ASTType::NSLookup {
        .error(Error::new(callee.span, "Method call is not to a member, internal compiler error"))
        return
    }

    // Due to the way we handle typechecking, we might run this function twice
    // on the same node. This is fine, but we need to make sure we don't double
    // add the method argument twice implicitly.
    if node.u.call.added_method_arg return
    node.u.call.added_method_arg = true

    if callee.type != ASTType::Member return
    if method.params.size == 0 {
        // This should ideally never happen.
        .error(Error::new(callee.span, "Instance method should have `this` argument, internal error"))
        return
    }
    let method_param = (method.params.at(0) as &Variable).type

    let member = callee.u.member
    let first_arg = member.lhs

    println(`member is pointer: {member.is_pointer:d}, method param base: {method_param.base}`)
    if member.is_pointer and method_param.base != Pointer {
        first_arg = AST::new_unop(ASTType::Dereference, first_arg.span, first_arg)
    } else if not member.is_pointer and method_param.base == Pointer {
        first_arg = AST::new_unop(ASTType::Address, first_arg.span, first_arg)
    }
    node.u.call.args.push_front(Argument::new(null, Span::default(), first_arg))
}

def TypeChecker::check_call(&this, node: &AST): &Type {
    let callee = node.u.call.callee
    let args = node.u.call.args

    // FIXME: this is a fucking abonimation
    if callee.type == ASTType::Identifier {
        callee.u.ident.is_function = false
        let name = callee.u.ident.name

        if name.eq("print") or name.eq("println") {
            for let i = 0; i < args.size; i += 1 {
                let arg = args.at(i) as &Argument
                .check_expression(arg.expr, hint: null)
            }
            return .o.get_base_type(Void, node.span)
        }
    }

    let res = match callee.type {
        Member => .check_member(callee, is_being_called: true)
        else => .check_expression(callee, hint: null)
    }
    if not res? return null

    if res.base != BaseType::Function {
        .error(Error::new(callee.span, `Cannot call a non-function type: {res.str()}`))
        return null
    }

    let func = res.u.func
    let params = func.params

    if func.orig? and func.orig.is_method {
        .check_method_call(func.orig, node)
    }

    if func.params.size < args.size {
        .error(Error::new(node.span, `Too many arguments, expected {func.params.size} but got {args.size}`))
    }

    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable
        // Normal case
        if i < args.size {
            let arg = args.at(i) as &Argument

            if arg.label? and not arg.label.eq(param.sym.name) {
                .error(Error::new(arg.label_span, `Argument label '{arg.label}' does not match parameter name '{param.sym.name}'`))
            }

            let arg_type = .check_expression(arg.expr, hint: param.type)
            if arg_type? and not arg_type.eq(param.type) {
                println(`span is {arg.expr.span.str()}`)
                .error(Error::new(arg.expr.span, `Argument {param.sym.name} has type {arg_type.str()} but expected {param.type.str()}`))
            }

        // Default argument case
        } else if param.default_value? {

            // FIXME: We should not be evaluating the default argument here during every call,
            // we should be evaluating it at the time of checking the function declaration and using
            // a cached value here
            let new_arg = Argument::new(label: null, label_span: Span::default(), expr: param.default_value)
            // Plus the default argument to the list of arguments
            args.push(new_arg)

        } else {
            .error(Error::new(node.span, `Missing required argument {param.sym.name}`))
        }
    }

    if func.orig? {
        node.u.call.is_function_pointer = false
        node.u.call.func = func.orig
    }

    return func.return_type

}

def TypeChecker::check_pointer_arith(&this, node: &AST, _lhs: &Type, _rhs: &Type): &Type {
    .error(Error::new(node.span, "Pointer arithmetic not implemented"))
    return null
}

def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    match node.type {
        Plus | Minus | Multiply | Divide => {
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                return .check_pointer_arith(node, lhs, rhs)
            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else {
                return lhs
            }
        }
        PlusEquals | MinusEquals | DivideEquals | MultiplyEquals => {
            if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            let lhs_node = node.u.binary.lhs
            if not lhs_node.is_lvalue() {
                .error(Error::new(node.span, "Left hand side of assignment must be assignable"))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            return lhs
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            if not lhs.is_numeric_or_char() or not rhs.is_numeric_or_char() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric or char types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        Equals | NotEquals => {
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if lhs.base == BaseType::Structure {
                .error(Error::new(node.span, "Cannot compare structs directly"))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        And | Or => {
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                .error(Error::new_note(
                    node.span, "Operands must be boolean",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        Modulus | BitwiseOr | BitwiseAnd | BitwiseXor | LeftShift | RightShift => {
            if not lhs.is_integer() or not rhs.is_integer() {
                .error(Error::new_note(
                    node.span, "Operator requires integer types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return lhs
        }
        else => panic(`Internal error: unhandled op in check_binary_op: {node.type}`)
    }
}

def TypeChecker::check_format_string(&this, node: &AST): &Type {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs

    if parts.size != exprs.size + 1 {
        .error(Error::new(node.span, "Number of format string parts does not match number of expressions"))
    }

    for let i = 0; i < exprs.size; i += 1 {
        let expr = exprs.at(i) as &AST
        let typ = .check_expression(expr, hint: null)
        if not typ? continue

        match typ.base {
            Bool | Char | I8 | I16 | I32 | I64 | U8 | U16 |
            U32 | U64 | F32 | F64 | Pointer => {}
            else => .error(Error::new(
                expr.span, `Only strings / builtin types can be formatted, got type '{typ.str()}'`
            ))
        }
    }

    // FIXME: make string a "base" type so we can attach methods to it
    let base = .o.get_base_type(BaseType::Char, node.span)
    let typ = Type::new_resolved(BaseType::Pointer, node.span)
    typ.u.ptr = base
    return typ
}

def TypeChecker::check_member(&this, node: &AST, is_being_called: bool): &Type {
    let lhs = .check_expression(node.u.member.lhs, hint: null)
    if not lhs? return null

    // How would this work for strings?
    let is_pointer = false
    if lhs.base == BaseType::Pointer {
        is_pointer = true
        lhs = lhs.u.ptr
    }

    if lhs.base == BaseType::Structure {
        let struc = lhs.u.struc
        let field = struc.get_field(node.u.member.rhs_name)
        if field? {
            node.u.member.is_pointer = is_pointer
            return field.type
        }
    }

    if lhs.can_have_methods() {
        let method = lhs.methods.get(node.u.member.rhs_name) as &Function
        if method? {
            if not is_being_called {
                .error(Error::new(node.span, "Cannot access method without calling it"))
                return null
            }
            node.u.member.is_pointer = is_pointer
            node.resolved_symbol = method.sym
            return method.type
        }
    }

    .error(Error::new(node.span, `Type {lhs.str()} has no member named '{node.u.member.rhs_name}'`))
    return null
}


// This is just here so we can use early exits in the actual check_expression
// function, and still always assign the type to the node's etype field
def TypeChecker::check_expression(&this, node: &AST, hint: &Type): &Type {
    let typ = .check_expression_helper(node, hint)
    node.etype = typ
    return typ
}

def TypeChecker::check_expression_helper(&this, node: &AST, hint: &Type): &Type {
    match node.type {
        ASTType::IntLiteral => {
            if node.u.num_literal.suffix? {
                return .o.resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_integer() then return hint
            return .o.get_base_type(BaseType::I32, node.span)
        }
        ASTType::FloatLiteral => {
            if node.u.num_literal.suffix? {
                return .o.resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_float() then return hint
            return .o.get_base_type(BaseType::F32, node.span)
        }
        ASTType::StringLiteral => {
            // FIXME: make string a "base" type so we can attach methods to it
            let base = .o.get_base_type(BaseType::Char, node.span)
            let typ = Type::new_resolved(BaseType::Pointer, node.span)
            typ.u.ptr = base
            return typ
        }
        ASTType::Null => {
            // FIXME: make untyped_ptr a "base" type so we can attach methods to it
            let base = .o.get_base_type(BaseType::Void, node.span)
            let typ = Type::new_resolved(BaseType::Pointer, node.span)
            typ.u.ptr = base
            return typ
        }
        ASTType::Cast => {
            let typ = .check_expression(node.u.cast.lhs, hint: null)
            if not typ? return null
            let target = .o.resolve_type(node.u.cast.to)
            if not target? return null
            // FIXME: Disallow invalid casts
            return target
        }
        ASTType::FormatStringLiteral => {
            return .check_format_string(node)
        }
        ASTType::CharLiteral => {
            return .o.get_base_type(BaseType::Char, node.span)
        }
        ASTType::BoolLiteral => {
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        ASTType::Negate => {
            let typ = .check_expression(node.u.unary, hint)
            if not typ? return null
            if not typ.is_numeric() {
                .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                return null
            }
            return typ
        }
        ASTType::IsNotNull => {
            let typ = .check_expression(node.u.unary, hint: null)
            if not typ? return null
            if typ.base != BaseType::Pointer {
                .error(Error::new(node.span, `Can only use ? on pointer types, got {typ.str()}`))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        ASTType::Not => {
            let typ = .check_expression(node.u.unary, hint: .o.get_base_type(BaseType::Bool, node.span))
            if not typ? return null
            if typ.base != BaseType::Bool {
                .error(Error::new(node.span, `Cannot negate non-boolean type: {typ.str()}`))
                return null
            }
            return typ
        }
        ASTType::Address => {
            let typ = .check_expression(node.u.unary, hint: null)
            if not typ? return null
            let ptr = Type::new_resolved(BaseType::Pointer, node.span)
            ptr.u.ptr = typ
            return ptr
        }
        ASTType::Dereference => {
            let typ = .check_expression(node.u.unary, hint: null)
            if not typ? return null
            if typ.base != BaseType::Pointer {
                .error(Error::new(node.span, `Cannot dereference non-pointer type: {typ.str()}`))
                return null
            }
            return typ.u.ptr
        }
        ASTType::Member => return .check_member(node, is_being_called: false)
        ASTType::SizeOf => {
            let typ = .o.resolve_type(node.u.size_of_type)
            if not typ? return null
            node.u.size_of_type = typ
            return .o.get_base_type(BaseType::U32, node.span)
        }
        ASTType::If => {
            .check_if(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Block => {
            .check_block(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Match => {
            .check_match(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Identifier | ASTType::NSLookup => {
            let item = .o.resolve_scoped_identifier(node, hint)
            if not item? {
                .error(Error::new(node.span, "Couldn't find this identifier"))
                return null
            }

            match item.type {
                Function => return item.u.func.type
                Variable => return item.u.var.type
                Structure => {
                    .error(Error::new(node.span, "Cannot use a struct name as an expression"))
                    return null
                }
                Enum => {
                    .error(Error::new(node.span, "Cannot use an enum name as an expression"))
                    return null
                }
                Namespace => {
                    .error(Error::new(node.span, "Cannot use a namespace as an expression"))
                    return null
                }
                TypeDef => {
                    // Fixme: How will this work with struct constructors?
                    .error(Error::new(node.span, "Cannot use a type name as an expression"))
                    return null
                }
            }
        }
        ASTType::Call => return .check_call(node)

        // Binary operators
        Plus |
        Minus |
        Multiply |
        Divide |
        LessThan |
        LessThanEquals |
        GreaterThan |
        GreaterThanEquals |
        Equals |
        NotEquals |
        PlusEquals |
        MinusEquals |
        MultiplyEquals |
        DivideEquals |
        And |
        Or |
        Modulus |
        BitwiseOr |
        BitwiseAnd |
        BitwiseXor |
        LeftShift |
        RightShift => {
            let lhs = .check_expression(node.u.binary.lhs, hint: null)
            let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
            if not lhs? or not rhs? return null
            return .check_binary_op(node, lhs, rhs)
        }

        Assignment => {
            let lhs = .check_expression(node.u.binary.lhs, hint: null)
            let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
            if not lhs? or not rhs? return null

            if not node.u.binary.lhs.is_lvalue() {
                .error(Error::new(node.u.binary.lhs.span, "Must be an l-value"))
            }
            if not lhs.eq(rhs) {
                .error(Error::new(
                    node.span, `Variable type does not match assignment type, Expected type '{lhs.str()}', got '{rhs.str()}'`
                ))
            }
            return lhs
        }

        else => {
            .error(Error::new(node.span, "Invalid expression in TypeChecker::check_expression"))
            return .o.error_type
        }
    }
}

def TypeChecker::check_match_for_enum(&this, enum_: &Enum, node: &AST, is_expr: bool, hint: &Type) {
    let mapping = Map::new()
    defer mapping.free()

    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond = _case.cond
        let name: string

        let cond_type = .check_expression(cond, hint: enum_.type)
        if not cond_type.eq(enum_.type) {
            .error(Error::new_hint(
                cond.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{enum_.type.str()}'`
            ))
        }
        if cond_type.base != BaseType::Enum {
            .error(Error::new(cond.span, "Expected an enum value"))
            continue
        }

        name = cond.resolved_symbol.name
        let prev = mapping.get(name) as &MatchCase
        if prev? {
            .error(Error::new_hint(
                cond.span, "Duplicate condition name in match",
                prev.cond.span, "This condition was previously used here"
            ))
        }
        mapping.insert(name, _case)
        if _case.body? {
            .check_expression_statement(node,  _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt
    if mapping.num_items != enum_.fields.size {
        if not defolt? {
            .error(Error::new_note(
                node.span, "Match does not cover all cases",
                `Only {mapping.num_items} of {enum_.fields.size} cases are covered`
            ))
        } else {
            .check_expression_statement(node, defolt, is_expr, hint)
        }
    } else {
        if defolt? {
            .error(Error::new(node.u.match_stmt.defolt_span, "`else` case is not needed for this match"))
        }
    }

    if is_expr and not node.etype? {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_match(&this, node: &AST, is_expr: bool, hint: &Type) {
    let expr = node.u.match_stmt.expr
    let expr_type = .check_expression(expr, hint: null)
    if not expr_type? {
        .error(Error::new(node.span, "Match statement must have a valid expression"))
        return
    }

    if expr_type.base == BaseType::Enum {
        let enum_ = expr_type.u.enum_
        .check_match_for_enum(enum_, node, is_expr, hint)
        return
    }

    if not expr_type.is_integer() and
        expr_type.base != BaseType::Char {
        .error(Error::new_note(
            expr.span, "This type cannot be matched on",
            `Expression type is '{expr_type.str()}'`
        ))
    }

    // Here we have either i32 or char
    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond_type = .check_expression(_case.cond, hint: expr_type)
        if not cond_type? then continue
        if not cond_type.eq(expr_type) {
            .error(Error::new_hint(
                cond_type.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{cond_type.str()}'`
            ))
        }
        if _case.cond.type != ASTType::IntLiteral and
            _case.cond.type != ASTType::CharLiteral and
            _case.cond.type != ASTType::StringLiteral {
            .error(Error::new(_case.cond.span, "Match condition must use only literals"))
        }
        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt

    if not defolt? {
        .error(Error::new(node.span, "`else` case is missing"))
    } else {
        .check_expression_statement(node, defolt, is_expr, hint)
    }

    // FIXME: check if we early return in here...
    if is_expr and not node.etype? {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}


def TypeChecker::check_if(&this, node: &AST, is_expr: bool, hint: &Type) {
    let cond_type = .check_expression(node.u.if_stmt.cond, hint: .o.get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    let body = node.u.if_stmt.body
    .check_expression_statement(node, body, is_expr, hint)
    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_expression_statement(node, else_stmt, is_expr, hint)
    } else if is_expr {
        .error(Error::new(node.span, "If expressions must have an else branch"))
    }
    node.etype = body.etype
}
def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool, hint: &Type) {
    match body.type {
        // If this is an expression-statement, a non-block should also be an expression
        ASTType::Match => .check_match(body, is_expr, hint)
        ASTType::If => .check_if(body, is_expr, hint)

        ASTType::Block => .check_block(body, is_expr: is_expr, hint)
        else => {
            if is_expr {
                .check_expression(body, hint)
            } else {
                .check_statement(body)
            }
        }
    }

    node.returns = node.returns and body.returns
    if not is_expr return

    // For now, we'll allow expression statements to early-return from the function.
    // Maybe this should be disallowed?
    let ret = body.etype
    if body.returns {
        // Do nothing
    } else if not ret? {
        .error(Error::new(body.span, "Must yield a value in this branch"))
    } else if not node.etype? {
        node.etype = ret
    } else if not node.etype.eq(ret) {
        .error(Error::new_note(
            body.span, "Yield type of branch doesn't match previous branches",
            `Expected type '{node.etype.str()}', got '{ret.str()}'`
        ))
    }
}


def TypeChecker::check_while(&this, node: &AST) {
    let was_in_loop = .in_loop
    .in_loop = true
    let cond = node.u.loop.cond
    let body = node.u.loop.body

    let cond_type = .check_expression(cond, hint: .o.get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(body)
    .in_loop = was_in_loop
}

def TypeChecker::check_for(&this, node: &AST) {
    let was_in_loop = .in_loop
    .o.push_scope(Scope::new(.scope()))
    .in_loop = true

    let init = node.u.loop.init
    let cond = node.u.loop.cond
    let step = node.u.loop.step
    let body = node.u.loop.body

    if init? then .check_statement(init)

    if cond? {
        let cond_type = .check_expression(cond, hint: .o.get_base_type(BaseType::Bool, node.span))
        if cond_type? and cond_type.base != BaseType::Bool {
            .error(Error::new_note(
                cond.span, "Condition must be a boolean",
                `Got type '{cond_type.str()}'`
            ))
        }
    }

    if step? then .check_expression(step, hint: null)
    .check_statement(body)
    .in_loop = was_in_loop
    .o.pop_scope()
}

def TypeChecker::check_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            if not .cur_func? {
                .error(Error::new(node.span, "Cannot return from outside a function"))
                return
            }

            let expected = .cur_func.return_type
            if expected.base == BaseType::Void {
                if node.u.unary? {
                    .error(Error::new(node.span, "Cannot return a value from a void function"))
                }
            } else if node.u.unary? {
                let res = .check_expression(node.u.unary, hint: null)
                if res? and not res.eq(expected) {
                    .error(Error::new(node.span, `Return type {res.str()} does not match function return type {expected.str()}`))
                }
            } else {
                .error(Error::new(node.span, "Expected a return value for non-void function"))
            }

        }
        ASTType::Yield => {
            if not .can_yield {
                .error(Error::new(node.span, "Cannot yield here"))
            }
            node.etype = .check_expression(node.u.unary, hint: null)
        }
        ASTType::Import => {
            .handle_import_statement(node)
        }
        ASTType::Break | ASTType::Continue => {
            if not .in_loop {
                .error(Error::new(node.span, `{node.type} statement outside of loop`))
            }
        }
        ASTType::If => .check_if(node, is_expr: false, hint: null)
        ASTType::While => .check_while(node)
        ASTType::For => .check_for(node)
        ASTType::Block => .check_block(node, is_expr: false, hint: null)
        ASTType::Match => .check_match(node, is_expr: false, hint: null)
        ASTType::VarDeclaration => {
            let var = node.u.var_decl.var
            let res = .scope().lookup_local(var.sym.name)
            if res? {
                .error(Error::new(node.span, `Variable {var.sym.name} already exists in this scope`))
                return
            }

            let sym = var.sym
            .scope().insert(var.sym.name, sym)

            if var.type? {
                var.type = .o.resolve_type(var.type)
            }

            let init = node.u.var_decl.init
            if init? {
                let res = .check_expression(init, hint: var.type)
                if res? and var.type? and not res.eq(var.type) {
                    .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {res.str()}`))
                } else if not var.type? {
                    var.type = res
                }
            } else if not var.type? {
                .error(Error::new(node.span, `Variable {var.sym.name} has no type and no initializer`))
            }
        }
        else => .check_expression(node, hint: null)
    }
}

def TypeChecker::check_function(&this, ns: &Namespace, func: &Function) {
    // todo: check params, return type
    let new_scope = Scope::new(ns.scope)

    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable

        let default_expr = param.default_value
        if default_expr? {
            // NOTE: This `.check_expression()` call uses the scope _outside_ of the function.
            //       We don't check the new scope here on purpose: the default value needs to be
            //       valid outside the scope of this function, which is where it will be evaluated.
            let default_type = .check_expression(default_expr, hint: null)

            if default_type? and not default_type.eq(param.type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }

        new_scope.items.insert(param.sym.name, param.sym)
    }

    .cur_func = func

    .o.push_scope(new_scope)
    .check_statement(func.body)
    .o.pop_scope()
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)

    for let i = 0; i < ns.imports.size; i += 1 {
        let import = ns.imports.at(i) as &AST
        .handle_import_statement(import)
    }

    for let i = 0; i < ns.functions.size; i += 1 {
        let func = ns.functions.at(i) as &Function
        .check_function(ns, func)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .check_namespace(iter.value())
    }
    .o.pop_namespace()
    .o.pop_scope()
}

// Insert all the imported items defined in the Import AST statement into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST) {
    let path = node.u.import_path

    // NOTE: This is a little weird, but the first part of the import can either be a symbol in
    //       some namespace (global / parent), or it can be in the current scope. To handle these
    //       cases, we just manually import the first part from these different locations, and then
    //       loop over the rest of the parts.
    let part = path.parts.at(0) as &ImportPart
    let name = part.name
    let base = match path.type {
        FromRootNamespace => {
            yield .o.program.global.find_importable_symbol(name)
        }
        FromParentNamespace => {
            let cur = .o.ns()
            for let i = 0; i < path.parent_count; i += 1 {
                if not cur.parent? {
                    // This should never happen, because the parser is responsible for handling this
                    .error(Error::new(node.span, "Cannot import from parent of root namespace")).panic()
                    return
                }
                cur = cur.parent
            }
            yield cur.find_importable_symbol(name)
        }

        // This is the special case: a `Symbol` can't hold a scope, so we can't just
        // wrap all 3 cases into a symbol and avoid the manual lookup.
        FromCurrentScope => {
            yield .o.scope().lookup_recursive(name)
        }
    }

    if not base? {
        .error(Error::new(part.span, `Couldn't import {name}`))
        return
    }

    for let i = 1; i < path.parts.size; i += 1 {
        let part = path.parts.at(i) as &ImportPart
        let name = part.name
        let new_base = .o.lookup_in_symbol(base, name)

        if not new_base? {
            .error(Error::new(part.span, `Invalid import, namespace {name} does not exist`))
            return
        }
        base = new_base
    }

    println(`imported symbol {base.display} with type {base.type} into namespace {.o.ns().sym.display}`)
    .scope().insert(base.name, base)
}

def TypeChecker::run(program: &Program) {
    let pass = TypeChecker(
        o: GenericPass::new(program),
        cur_func: null,
        in_loop: false,
        can_yield: false,
    )
    pass.check_namespace(program.global)
}
