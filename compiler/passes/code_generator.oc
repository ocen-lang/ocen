//* Generate C code from the AST

import std::mem
import std::buffer::Buffer
import std::vector::Vector
import std::span::Span
import @types::{ Type, BaseType }
import @ast::nodes::*
import @ast::program::{ Program, Namespace }
import @ast::operators::{ Operator }
import @ast::scopes::{ Scope, Symbol}
import @errors::Error
import @passes::generic_pass::GenericPass

struct CodeGenerator {
    o: &GenericPass
    out: Buffer
    yield_vars: &Vector<str>
    indent: u32 = 0
}

def CodeGenerator::gen_indent(&this) {
    for let i = 0; i < .indent; i += 1 {
        .out += "  "
    }
}

def str::replace(&this, other: str) {
    let s: str = *this
    mem::free(s)
    *this = other
}

// Some convenience accessors from the GenericPass
def CodeGenerator::error(&this, err: &Error): &Error => .o.error(err)
def CodeGenerator::scope(&this): &Scope => .o.scope()

def CodeGenerator::gen_debug_info(&this, span: Span, force: bool = false) {
    if not .o.program.gen_debug_info and not force return

    let loc = span.start
    .out <<= `\n#line {loc.line} "{loc.filename}"\n`
}

def CodeGenerator::get_op(&this, node: &AST): str => match node.type {
    BinaryOp => match node.u.binary.op {
        And => "&&",
        Assignment | IndexAssign => "=",
        BitwiseAnd => "&",
        BitwiseOr => "|",
        BitwiseXor => "^",
        Divide => "/",
        Equals => "==",
        GreaterThan => ">",
        GreaterThanEquals => ">=",
        LeftShift => "<<",
        LessThan => "<",
        LessThanEquals => "<=",
        Minus => "-",
        Modulus => "%",
        Multiply => "*",
        NotEquals => "!=",
        Or => "||",
        Plus => "+",
        PlusEquals => "+=",
        MinusEquals => "-=",
        MultiplyEquals => "*=",
        DivideEquals => "/=",
        RightShift => ">>",
        LeftShiftEquals => "<<=",
        RightShiftEquals => ">>=",
        else => std::panic(`Unknown binary op type in get_op: {node.u.binary.op}`)
    }
    UnaryOp => match node.u.unary.op {
        PreDecrement => "--",
        PreIncrement => "++",
        PostDecrement => "--",
        PostIncrement => "++",
        else => std::panic(`Unknown unary op type in get_op: {node.u.unary.op}`)
    }
    else => std::panic(`Unknown op type in get_op: {node.type}`)
}

namespace cls {
    // FIXME: We currently assign some symbol names based on uid in Typechecker, that should be done here
    def ctx_type(func: &Function): str => `{func.sym.out_name()}Ctx`
    const ctx_name: str = "_C"
    const fn_field_name: str = "fn"
}

def CodeGenerator::gen_start_expr_statement(&this) => .out += "({"
def CodeGenerator::gen_end_expr_statement(&this) =>   .out += "})"

// NOTE: This function doesn't actually "need" to return a boolean, this is just to make the call in
//       gen_call a little nicer so we can match on the callee name.
def CodeGenerator::gen_internal_print(&this, node: &AST, newline_after: bool, is_stderr: bool): bool {
    let callee = node.u.call.callee
    if is_stderr {
        .out += "fprintf(stderr, "
    } else {
        .out += "printf("
    }

    let args = node.u.call.args
    let first = args.at(0)
    if first.expr.type == FormatStringLiteral {
        .gen_format_string_variadic(first.expr, newline_after)
        .out += ")"
        return true
    }

    for let i = 0; i < args.size; i += 1 {
        if i > 0 then .out += ", "
        let arg = args.at(i)
        .gen_expression(arg.expr)
        if i == 0 and newline_after then .out += "\"\\n\""
    }
    .out += ")"

    return true
}

//* Generate all the escape sequences in format string part
def CodeGenerator::gen_format_string_part(&this, part: str) {
    let len = part.len()
    for let i = 0; i < len; i += 1 {
        match part[i] {
            '\\' => {
                // This should be safe
                i += 1
                match part[i] {
                    // We want to unescape these
                    '`' | '{' | '}' => {}
                    // Anything else should remain escaped
                    else => .out += '\\'
                }
                .out += part[i]
            }
            '"' => {
                // If we have double quotes in a string we should escape it
                .out += '\\'
                .out += part[i]
            }
            '%' => {
                // Percent signs are special in printf, we need to do "%%"
                .out += '%'
                .out += part[i]
            }
            '\n' => {
                // We want to keep newlines in strings
                .out += "\\n"
            }
            else => .out += part[i]
        }
    }
}

//* Generate all the escape sequences for string literals
def CodeGenerator::gen_string_literal(&this, literal: str) {
    let len = literal.len()
    for let i = 0; i < len; i += 1 {
        match literal[i] {
            '\n' => {
                // We want to keep newlines in strings
                .out += "\\n"
            }
            else => .out += literal[i]
        }
    }
}

def CodeGenerator::format_string_custom_specifier(&this, type: &Type, expr: &AST) {
    if type.base == Structure {
        let struc = type.u.struc
        if struc? and struc.format_spec? {
            .out += struc.format_spec
            return
        }
    }

    .error(Error::new(
        expr.span, `Invalid type in CodeGenerator::format_string_custom_specifier: '{type.str()}'`
    ))
    .out += "%s" // Placeholder, we'll error out later anyway
}

def CodeGenerator::format_string_custom_argument(&this, type: &Type, expr: &AST) {
    if type.base == Structure {
        let struc = type.u.struc
        if struc? and struc.format_args? {
            for c in struc.format_args.chars() {
                if c == '$' {
                    .out += "("
                    .gen_expression(expr)
                    .out += ")"
                } else {
                    .out += c
                }
            }
            return
        }
    }

    .error(Error::new(
        expr.span, `Invalid type in CodeGenerator::format_string_custom_argument: '{type.str()}'`
    ))
    .gen_expression(expr) // Placeholder, we'll error out later anyway
}

def CodeGenerator::gen_format_string_variadic(&this, node: &AST, newline_after: bool) {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs
    let specs = node.u.fmt_str.specs

    .out += '"'
    for let i = 0; i < exprs.size; i += 1 {
        let part = parts.at(i)
        let expr = exprs.at(i)

        .gen_format_string_part(part)

        let spec = specs.at(i)
        if spec? {
            .out += "%"
            .out += spec
            continue
        }

        let expr_type = expr.etype.unaliased()
        match expr_type.base {
            I8 | I16 | I32 => .out += "%d"
            U8 | U16 | U32 => .out += "%u"
            I64 => .out += "%\" PRId64 \""
            U64 => .out += "%\" PRIu64 \""
            Bool => .out += "%s"
            F32 | F64 => .out += "%f"
            Char => .out += "%c"
            Pointer => match expr_type.u.ptr.base {
                Char => .out += "%s"
                else => .out += "%p"
            }
            else => .format_string_custom_specifier(expr_type, expr)
        }
    }
    // Put the last part:
    let part = parts.back()
    .gen_format_string_part(part)
    if newline_after then .out += "\\n"
    .out += '"'

    for expr in exprs.iter() {
        let expr_type = expr.etype.unaliased()
        .out += ", "

        match expr_type.base {
            I8 | I16 | I32 | U8 | U16 | U32 | I64 |
            U64 | F32 | F64 | Char | Pointer => {
                .gen_expression(expr)
            }
            Bool => {
                .out += "(("
                .gen_expression(expr)
                .out += ") ? \"true\" : \"false\")"
            }
            else => .format_string_custom_argument(expr_type, expr)
        }
    }
}

def CodeGenerator::gen_format_string(&this, node: &AST) {
    if .o.program.did_cache_symbols {
        .out += .o.program.cached_symbols.fmt_string_fn.full_name
    } else {
        .error(Error::new(node.span, "Can't use format string without using stdlib"))
        .out += "unknown"
    }
    .out += "("
    .gen_format_string_variadic(node, newline_after: false)
    .out += ")"
}

def CodeGenerator::gen_vector_literal(&this, node: &AST) {
    assert node.type == VectorLiteral
    let vec_lit = node.u.vec_literal
    assert vec_lit.vec_type?

    let new_method = vec_lit.vec_type.methods["new"]
    let push_method = vec_lit.vec_type.methods["push"]

    let var = `_vc{.o.program.uid++}`

    .gen_start_expr_statement()
    .out += "\n"
    .indent += 1
    .gen_indent()
    .gen_type_and_name(new_method.return_type, var)
    .out += " = "
    .out += new_method.sym.out_name()

    // FIXME: Make this use default param
    let size = vec_lit.elements.size
    if size == 0 then size = 8

    .out <<= `({size});\n`
    for expr in vec_lit.elements.iter() {
        .gen_indent()
        .out += push_method.sym.out_name()
        .out <<= `({var}, `
        .gen_expression(expr)
        .out += ");\n"
    }
    .gen_indent()
    .out += var
    .out += ";"
    .gen_end_expr_statement()
    .indent -= 1
}

def CodeGenerator::gen_map_literal(&this, node: &AST) {
    assert node.type == MapLiteral
    let map_lit = node.u.map_literal
    assert map_lit.map_type?

    let new_method = map_lit.map_type.methods["new"]
    let insert_method = map_lit.map_type.methods["insert"]

    let var = `_mc{.o.program.uid++}`

    .gen_start_expr_statement()
    .out += "\n"
    .indent += 1
    .gen_indent()
    .gen_type_and_name(new_method.return_type, var)
    .out += " = "
    .out += new_method.sym.out_name()

    // FIXME: Make this use default param
    let size = map_lit.elements.size
    if size == 0 then size = 8

    .out <<= `({size});\n`
    for expr in map_lit.elements.iter() {
        .gen_indent()
        .out += insert_method.sym.out_name()
        .out <<= `({var}, `
        .gen_expression(expr.key)
        .out += ", "
        .gen_expression(expr.value)
        .out += ");\n"
    }
    .gen_indent()
    .out += var
    .out += ";"
    .gen_end_expr_statement()
    .indent -= 1
}

def CodeGenerator::gen_yield_expression(&this, expr: &AST) {
    let yield_var = .yield_vars.back()
    .gen_indent()
    if not expr.returns {
        .out += yield_var
        .out += " = "
    }
    .gen_expression(expr)
    .out += ";\n"
    .gen_indent()
    .out <<= `goto _l_{yield_var};\n`
}

def CodeGenerator::gen_constant(&this, node: &AST) {
    let const_ = node.u.var_decl
    if const_.sym.is_dead return

    if not const_.sym.is_extern {
        .gen_indent()
        .out += "#define "
        .out += const_.sym.out_name()
        .out += " ("
        .gen_expression(node.u.var_decl.default_value)
        .out += ")\n"
    }
}

def CodeGenerator::gen_constants(&this, ns: &Namespace) {
    for const_ in ns.constants.iter() {
        .gen_constant(const_)
    }

    for child in ns.namespaces.iter_values() {
        .gen_constants(child)
    }
}

def CodeGenerator::gen_global_variables(&this, ns: &Namespace) {
    for node in ns.variables.iter() {
        let var = node.u.var_decl
        if var.sym.is_dead continue
        if not var.sym.is_extern {
            .gen_var_declaration(node)
            .out += ";\n"
        }
    }

    for child in ns.namespaces.iter_values() {
        .gen_global_variables(child)
    }
}

def CodeGenerator::gen_control_body(&this, node: &AST, body: &AST) {
    if body.type == ASTType::Block {
        .gen_block(body)

    } else {
        let is_elif = body.type == ASTType::If
        if not is_elif then .out += "{\n"
        .indent += 1
        // In this case, we're implicitly yielding the result of the body.
        if node.etype? and body.type != ASTType::Yield {
            .gen_yield_expression(body)
        } else {
            .gen_statement(body)
        }
        .indent -= 1

        .gen_indent()
        if not is_elif then .out += "}"
    }
}

def CodeGenerator::gen_in_yield_context(&this, node: &AST) {
    // Using a GCC extension for statement expressions
    // https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html

    let yield_var = `__yv_{.o.program.uid++}`
    .yield_vars.push(yield_var)

    let ret_type = node.etype

    .gen_start_expr_statement()
    .gen_type_and_name(ret_type, yield_var)
    .out += ";\n"

    if node.type == Block {
        .gen_block(node, with_braces: false)
    } else {
        .indent += 1
        .gen_statement(node)
        .indent -= 1
    }

    .out += "\n"
    .out <<= f"_l_{yield_var}:\n"
    .gen_indent()
    .out += yield_var
    .out += ";"
    .gen_end_expr_statement()

    .yield_vars.pop()
}

def CodeGenerator::gen_enum_constructor(&this, variant: &EnumVariant, args: &Vector<&Argument> = null) {
    let enom = variant.parent

    // Simple case, no values
    if not enom.has_values {
        .out += variant.sym.out_name()
        return
    }

    .out <<= `({enom.sym.out_name()})\{`
    .out <<= `.tag={variant.sym.out_name()},`

    let shared_fields = enom.shared_fields
    let i = 0
    for null; i < shared_fields.size; i += 1 {
        let arg = args.at(i)
        let field = shared_fields.at(i)
        .out <<= `.{field.sym.out_name()}=`
        .gen_expression(arg.expr)
        .out += ", "
    }
    if args? and i < args.size {
        .out <<= `.{variant.sym.out_name()}=\{`
        for null; i < args.size; i += 1 {
            let arg = args.at(i)
            .gen_expression(arg.expr)
            .out += ", "
        }
        .out += "}"
    }
    .out += "}"
}

def CodeGenerator::gen_constructor(&this, node: &AST, struc: &Structure) {
    .out <<= `({struc.sym.out_name()})\{`
    let fields = struc.fields
    let args = node.u.call.args

    if struc.is_union {
        assert args.size == 1, "Should have been checked in the type checker"
        let arg = args[0]
        assert arg.label?, "Should have been checked in the type checker"

        let field: &Variable = null
        for f in fields.iter() {
            if f.sym? and f.sym.name.eq(arg.label) {
                field = f
                break
            }
        }
        assert field?, "Should have been checked in the type checker"
        .out <<= `.{field.sym.out_name()}=`
        .gen_expression(arg.expr)

    } else {
        for let i = 0; i < args.size; i += 1 {
            if i != 0 then .out += ", "
            let arg = args.at(i)
            let field = fields.at(i)
            .out <<= `.{field.sym.out_name()}=`
            .gen_expression(arg.expr)
        }
    }

    .out += "}"
}

def CodeGenerator::gen_create_new(&this, node: &AST) {
    assert node.type == CreateNew, `Expected CreateNew, got {node.type}`
    let child = node.u.child
    let var_name = `_new_{.o.program.uid++}`

    // @new XYZ =>  {
    //     let a = alloc_fn(allocator, sizeof(typeof(XYZ)))
    //     *a = XYZ
    //     yield a
    // }
    .gen_start_expr_statement()
    .gen_type_and_name(node.etype, var_name)
    .out += " = "
    .out += .o.program.cached_symbols.mem_alloc_fn.out_name()
    .out += "("
    .out += .o.program.cached_symbols.mem_allocator.out_name()
    .out += ", sizeof("
    .gen_type(child.etype)
    .out <<= `)); *{var_name} = `
    .gen_expression(child)
    .out <<= `; {var_name}; `
    .gen_end_expr_statement()

    var_name.free()
}

def CodeGenerator::gen_call_args(&this, args: &Vector<&Argument>, is_variadic_format: bool) {
    for let i = 0; i < args.size; i += 1 {
        if i != 0 then .out += ", "
        let arg = args.at(i)

        if (
            i == args.size - 1 and
            is_variadic_format and
            arg.expr.type == FormatStringLiteral
        ) {
            .gen_format_string_variadic(arg.expr, newline_after: false)
        } else {
            .gen_expression(arg.expr)
        }
    }
}

def CodeGenerator::gen_closure_call(&this, node: &AST, sym: &Symbol) {
    let callee = node.u.call.callee

    .gen_expression(callee)
    .out <<= f".{cls::fn_field_name}("
    .gen_expression(callee)
    .out += "."
    .out += cls::ctx_name
    if node.u.call.args.size > 0 {
        .out += ", "
        .gen_call_args(node.u.call.args, is_variadic_format: false)
    }
    .out += ")"
}

//! Generate an expression. If `is_top_level` is true, don't put parens around it.
def CodeGenerator::gen_expression(&this, node: &AST, is_top_level: bool = false) {
    match node.type {
        IntLiteral => {
            let num_lit = &node.u.num_literal
            if node.etype.base != I32 and node.etype.base != U32 {
                .out += "(("
                .gen_type(node.etype)
                .out += ")"
                .out += num_lit.text
                .out += ")"
            } else {
                .out += num_lit.text
            }
        }
        CreateClosure => {
            let func = node.u.closure
            .gen_start_expr_statement()
            let ctx_name = `{cls::ctx_name}{.o.program.uid++}`
            let ctx_typ = cls::ctx_type(func)

            .out <<= `{ctx_typ} *{ctx_name} = alloca(sizeof({ctx_typ}));`
            for it in func.closed_vars.iter() {
                let var = it.value.u.closed_var.orig
                .out += ctx_name
                .out += "->"
                .out += var.sym.out_name()
                .out += " = &"
                .out += var.sym.out_name()
                .out += ";"
            }

            let cls_name = `_ci{.o.program.uid++}`
            .out <<= `{func.type.sym.out_name()} {cls_name} = \{`
            .out <<= `.{cls::ctx_name}={ctx_name}, .{cls::fn_field_name}=&{func.sym.out_name()}\};`
            .out += cls_name
            .out += ";"
            .gen_end_expr_statement()
        }
        FloatLiteral => {
            let num_lit = &node.u.num_literal
            .out += num_lit.text
            if node.etype.base == F32 {
                .out += "f"
            }
        }
        ArrayLiteral => {
            let elements = node.u.array_literal.elements
            .out += "{"
            for let i = 0; i < elements.size; i += 1 {
                if i != 0 then .out += ", "
                let expr = elements.at(i)
                .gen_expression(expr)
            }
            .out += "}"
        }
        VectorLiteral => .gen_vector_literal(node)
        MapLiteral => .gen_map_literal(node)
        FormatStringLiteral => .gen_format_string(node)
        StringLiteral => {
            let str_lit = node.u.string_literal
            .out += "\""
            .gen_string_literal(str_lit)
            .out += "\""
        }
        CharLiteral => {
            let char_lit = node.u.char_literal
            .out += "'"
            .out += char_lit
            .out += "'"
        }
        If => {
            let branches = node.u.if_stmt.branches
            let els = node.u.if_stmt.els

            // If we only have 1 branch, an else statemenet, and both the
            // bodies are expressions (not blocks), we can generate the
            // ternary operator for code simplicity.
            if (
                branches.size == 1 and
                branches[0].body.type != Block and
                els? and els.type != Block
            ) {
                let branch = branches[0]
                .out += "("
                .gen_expression(branch.cond)
                .out += " ? "
                .gen_expression(branch.body)
                .out += " : "
                .gen_expression(els)
                .out += ")"

            // We tried our best to make code nice, let's fall back:
            } else {
                .gen_in_yield_context(node)
            }
        }
        Match => .gen_in_yield_context(node)
        Block => .gen_in_yield_context(node)
        Member => {
            let sym = node.resolved_symbol
            if sym? and sym.type == Function {
                // Method call
                .out += sym.out_name()
                return
            }

            let lhs = node.u.member.lhs
            .gen_expression(lhs)
            if node.u.member.is_pointer {
                .out += "->"
            } else {
                .out += "."
            }
            .out += node.u.member.rhs_name
        }
        TryMember => {
            let lhs = node.u.member.lhs
            let rhs_name = node.u.member.rhs_name

            let tmp_var = `_t{.o.program.uid++}`
            .gen_start_expr_statement()
            .gen_type_and_name(lhs.etype, tmp_var)
            .out += " = "
            .gen_expression(lhs)
            .out += "; "
            .out <<= `{tmp_var} ? {tmp_var}->{rhs_name} : NULL;`
            .gen_end_expr_statement()
            tmp_var.free()
        }
        Identifier | NSLookup | Specialization | OverloadedOperator => {
            let sym = node.resolved_symbol
            if not sym? {
                .error(Error::new(node.span, "Symbol not found in CodeGenerator::gen_expression"))
                return
            }
            match sym.type {
                Function | Variable | Constant => .out += sym.out_name()
                EnumVariant => .gen_enum_constructor(sym.u.enum_var)
                ClosedVariable => {
                    let var = sym.u.closed_var.orig
                    .out <<= f"(*{cls::ctx_name}->"
                    .out += var.sym.out_name()
                    .out += ")"
                }
                else => assert false, `Unhandled symbol type: {sym.type}`
            }
        }
        Call => {
            let callee = node.u.call.callee

            // FIXME: Re-do abomination of hacky-IO with some sort of variadics?
            if callee.type == Identifier {
                let matched = match callee.u.ident.name {
                    "print" => .gen_internal_print(node, newline_after: false, is_stderr: false)
                    "println" => .gen_internal_print(node, newline_after: true, is_stderr: false)
                    "eprint" => .gen_internal_print(node, newline_after: false, is_stderr: true)
                    "eprintln" => .gen_internal_print(node, newline_after: true, is_stderr: true)
                    else => false
                }
                if matched then return
            }

            let sym = callee.symbol()
            if sym? {
                match node.u.call.call_type {
                    StructConstructor => {
                        assert sym.type == Structure
                        .gen_constructor(node, sym.u.struc)
                        return
                    }
                    EnumConstructor => {
                        assert sym.type == EnumVariant
                        .gen_enum_constructor(sym.u.enum_var, node.u.call.args)
                        return
                    }
                    Closure => {
                        .gen_closure_call(node, sym)
                        return
                    }

                    // Fallthrough
                    else => {}
                }
            }

            .gen_expression(callee)

            let is_variadic_format = (
                sym? and
                sym.type == Function and
                sym.u.func? and
                sym.u.func.is_variadic_format
            )

            .out += "("
            .gen_call_args(node.u.call.args, is_variadic_format)
            .out += ")"
        }
        BoolLiteral => {
            let bool_lit = node.u.bool_literal
            .out += if bool_lit then "true" else "false"
        }
        CreateNew => .gen_create_new(node)
        UnaryOp => match node.u.unary.op {
            Address => {
                let expr = node.u.unary.expr
                .out += "&"
                .gen_expression(expr)
            }
            Dereference => {
                let expr = node.u.unary.expr
                .out += "(*"
                .gen_expression(expr)
                .out += ")"
            }
            Negate => {
                let expr = node.u.unary.expr
                .out += "-"
                .gen_expression(expr)
            }
            BitwiseNot => {
                let expr = node.u.unary.expr
                .out += "~"
                .gen_expression(expr)
            }
            Not => {
                let expr = node.u.unary.expr
                .out += "!("
                .gen_expression(expr)
                .out += ")"
            }
            IsNotNull => {
                let expr = node.u.unary.expr
                .out += "((bool)"

                let type = expr.etype
                // FIXME: Is there a better place to do this? We generally want to treat
                //        the closure as the full struct when passing it around, but specifically
                //        for null-checks we want to only look at the function pointer.
                if type? and type.base == Closure {
                    .gen_expression(expr)
                    .out += "."
                    .out += cls::fn_field_name

                } else {
                    .gen_expression(expr)
                }

                .out += ")"
            }
            PreIncrement | PreDecrement => {
                .out += .get_op(node)
                .gen_expression(node.u.unary.expr)
            }

            PostIncrement | PostDecrement => {
                .gen_expression(node.u.unary.expr)
                .out += .get_op(node)
            }
            else => .error(Error::new(node.span, `Unhandled unary op type in CodeGenerator: {node.u.unary.op}`))
        }
        Cast => {
            let expr = node.u.cast.lhs
            let type = node.etype // Use resolved type
            .out += "(("
            .out += .get_type_name_string(type, name: "", is_func_def: false)
            .out += ")"
            .gen_expression(expr)
            .out += ")"
        }
        SizeOf => {
            .out += "((u32)sizeof("
            .gen_type(node.u.size_of_type)
            .out += "))"
        }
        Null => match node.etype.base {
            // Closures behave like a function pointer in ocen, but are actually a
            // struct in the output C. We need special handling here.
            // Zero-initialize the struct, including the pointer
            Closure => .out <<= f"(({node.etype.sym.out_name()})\{0\})"
            else => .out += "NULL"
        }
        BinaryOp => match node.u.binary.op {
            Index => {
                let lhs = node.u.binary.lhs
                let rhs = node.u.binary.rhs
                .gen_expression(lhs)
                .out += "["
                .gen_expression(rhs)
                .out += "]"
            }
            And |
            BitwiseAnd |
            BitwiseOr |
            BitwiseXor |
            Divide |
            GreaterThan |
            GreaterThanEquals |
            LeftShift |
            LeftShiftEquals |
            RightShiftEquals |
            LessThan |
            LessThanEquals |
            Minus |
            Modulus |
            Multiply |
            NotEquals |
            Or |
            Plus |
            RightShift => {
                let lhs = node.u.binary.lhs
                let rhs = node.u.binary.rhs
                if not is_top_level then .out += "("
                .gen_expression(lhs)
                .out += " "
                .out += .get_op(node)
                .out += " "
                .gen_expression(rhs)
                if not is_top_level then .out += ")"
            }
            Equals |
            Assignment |
            IndexAssign |
            PlusEquals |
            MinusEquals |
            DivideEquals |
            MultiplyEquals => {
                .gen_expression(node.u.binary.lhs)
                .out += .get_op(node)
                .gen_expression(node.u.binary.rhs)
            }
            else => .error(Error::new(node.span, `Unhandled binary op type in CodeGenerator: {node.u.binary.op}`))
        }

        else => .error(Error::new(node.span, `Unhandled expression type in CodeGenerator: {node.type}`))
    }
}

def CodeGenerator::gen_var_declaration(&this, node: &AST) {
    let var = node.u.var_decl

    if var.is_atomic {
        .out += "_Atomic "
    }

    .gen_type_and_name(var.type, var.sym.out_name())
    if node.u.var_decl.default_value? {
        .out += " = "
        .gen_expression(node.u.var_decl.default_value)

    // Can't do {0} for atomic types...
    } else if not var.is_atomic {
        match var.type.base {
            Array | Structure => .out += " = {0}"
            else => {}
        }
    }
}

def CodeGenerator::gen_match_case_body(&this, node: &AST, body: &AST) {
    if body.type == ASTType::Block {
        .out += " "
        .gen_block(body)

    // The body is a call that exits, we don't need to yield it
    } else if body.type == ASTType::Call and body.returns {
        .out += " "
        .gen_expression(body)
        .out += ";"

    // In this case, we're implicitly yielding the result of the body.
    } else if node.etype? and body.type != ASTType::Yield {
        .out += " {\n"
        .indent += 1
        .gen_yield_expression(body)
        .indent -= 1
        .gen_indent()
        .out += "}"

    } else {
        .out += " {\n"
        .indent += 1
        .gen_statement(body)
        .indent -= 1
        .gen_indent()
        .out += "}"
    }
}

def CodeGenerator::gen_custom_match(&this, node: &AST) {
    let stmt = node.u.match_stmt
    .gen_indent()
    .out += "{\n"

    let match_var = `__match_var_{.o.program.uid++}`

    .indent += 1
    .gen_indent()
    .gen_type_and_name(stmt.expr.etype, match_var)
    .out += " = "
    .gen_expression(stmt.expr)
    .out += ";\n"

    let cases = stmt.cases
    .gen_indent()

    for let i = 0; i < cases.size; i++ {
        let _case = cases[i]

        .out += "if ("
        let first = true
        for cond in _case.conds.iter() {
            if not first then .out += " || "
            first = false
            if cond.cmp_fn? {
                .out += cond.cmp_fn.sym.out_name()
                .out += "("
                .out += match_var
                .out += ", "
                .gen_expression(cond.expr)
                .out += ")"

            } else {
                .out += f"({match_var} == "
                .gen_expression(cond.expr)
                .out += ")"
            }
        }
        .out += ")"
        .gen_match_case_body(node, _case.body)
        .out += " else "
    }
    if stmt.defolt? {
        .gen_match_case_body(node, stmt.defolt)
    }
    .out += "\n"

    .indent -= 1
    .gen_indent()
    .out += "}\n"
}

def CodeGenerator::gen_match_enum(&this, node: &AST) {
    let match_stmt = &node.u.match_stmt
    let expr = match_stmt.expr
    assert expr.etype? and expr.etype.base == Enum

    let enom = expr.etype.u.enom
    let shared_fields = enom.shared_fields

    let var_name = ""
    if enom.has_values {
        .gen_indent()
        var_name = `_m{.o.program.uid++}`
        .gen_type_and_name(expr.etype, var_name)
        .out += " = "
        .gen_expression(expr)
        .out += ";\n"

        .gen_indent()
        .out += "switch ("
        .out += var_name
        .out += ".tag) {\n"
    } else {
        .out += "switch (("
        .gen_expression(expr)
        .out += ")) {\n"
    }

    let uid = .o.program.uid++
    .indent += 1
    for let i = 0; i < match_stmt.cases.size; i += 1 {
        let _case = match_stmt.cases[i]

        let has_args = _case.conds.size > 0 and _case.conds[0].args?

        if has_args {
            let args = _case.conds[0].args
            .gen_indent()
            .out += "{\n"
            .indent += 1
            for arg in args.iter() {
                if not arg.var.sym.name.eq("_") {
                    .gen_indent()
                    .gen_type_and_name(arg.var.type, arg.var.sym.out_name())
                    .out += ";\n"
                }
            }
        }

        for let j = 0; j < _case.conds.size; j++ {
            let cond = _case.conds[j]

            let resolved = cond.expr.resolved_symbol
            assert resolved? and resolved.type == EnumVariant
            let variant = resolved.u.enum_var

            .gen_indent()
            .out += "case "
            .out += variant.sym.out_name()
            .out += ":\n"

            .indent += 1
            if cond.args? {
                let args = cond.args
                for let i = 0; i < args.size; i += 1 {
                    let arg = args.at(i)
                    if arg.is_shared {
                        .gen_indent()
                        // TODO: Allow different variable name here
                        .out += arg.var.sym.out_name()
                        .out += " = "
                        .out += var_name
                        .out += "."
                        // TODO: It's possible the shared field might be called something else?
                        //       We should have MatchCondArg store the &Variable pointing to shared field
                        //       and use the name from it.
                        .out += arg.var.sym.out_name()
                        .out += ";\n"

                    } else {
                        .gen_indent()
                        .out += arg.var.sym.out_name()
                        .out += " = "
                        .out += var_name
                        .out += "."
                        .out += variant.sym.out_name()
                        .out <<= f".{arg.var.sym.out_name()};\n"
                    }
                }
                .gen_indent()
                .out += f"goto m_{uid}_{i};\n"
            }
            .indent -= 1
        }


        if _case.body? {
            .gen_indent()
            .out += f"m_{uid}_{i}:\n"
            .indent += 1
            .gen_indent()
            .gen_control_body(node, _case.body)
            .out += " break;\n"
            .indent -= 1

        }
        if has_args {
            .indent -= 1
            .gen_indent()
            .out += "}\n"
        }
    }

    if match_stmt.defolt? {
        .gen_indent()
        .out += "default:\n"
        .indent += 1
        .gen_indent()
        .gen_control_body(node, match_stmt.defolt)
        .out += " break;\n"
        .indent -= 1
    }

    .indent -= 1
    .gen_indent()
    .out += "}"
}

//! Generate an if-else statement when we are matching a boolean
def CodeGenerator::gen_match_bool(&this, node: &AST) {
    let stmt = node.u.match_stmt

    let true_case = stmt.cases[0]
    let false_case = stmt.cases[1]

    let true_expr = true_case.conds[0].expr
    assert true_expr.type == BoolLiteral, "Expected a boolean literal in gen_match_bool"
    if not true_expr.u.bool_literal {
        let tmp = true_case
        true_case = false_case
        false_case = tmp
    }

    .gen_indent()
    .out += "if ("
    .gen_expression(stmt.expr)
    .out += ") "
    .gen_control_body(node, true_case.body)
    .out += " else "
    .gen_control_body(node, false_case.body)
}

def CodeGenerator::gen_match(&this, node: &AST) {
    let stmt = node.u.match_stmt

    if stmt.is_custom_match {
        .gen_custom_match(node)
        return
    }


    match stmt.expr.etype.base {
        Bool => {
            .gen_match_bool(node)
            return
        }
        Enum => {
            .gen_match_enum(node)
            return
        }
        else => {}
    }

    .gen_indent()
    .out += "switch ("
    .gen_expression(stmt.expr)
    .out += ") {\n"

    let cases = stmt.cases
    .indent += 1
    for _case in cases.iter() {
        for cond in _case.conds.iter() {
            .gen_indent()
            .out += "case "
            .gen_expression(cond.expr)
            .out += ":"
        }
        if _case.body? {
            .gen_match_case_body(node, _case.body)
            .out += " break;\n"

        } else {
            .out += "\n"
        }
    }
    if stmt.defolt? {
        .gen_indent()
        .out += "default:"
        .gen_match_case_body(node, stmt.defolt)
        .out += " break;\n"
    }
    .indent -= 1
    .gen_indent()
    .out += "}\n"
}

def CodeGenerator::gen_defers_upto(&this, end_scope: &Scope) {
    let first = true
    for let cur = .scope(); cur?; cur = cur.parent {
        for let i = 0; i < cur.defers.size; i += 1 {
            if first {
                first = false
                .gen_indent()
                .out += "/* defers */\n"
            }

            // Note: We want to run the defers in reverse order
            let idx = cur.defers.size - i - 1
            let stmt = cur.defers.at(idx)
            .gen_statement(stmt)
        }
        if cur == end_scope then break
    }
}

def CodeGenerator::gen_statement(&this, node: &AST) {
    .gen_debug_info(node.span)
    match node.type {
        ASTType::Return => {
            let upto = .scope()
            for let cur = .scope(); cur? and cur.cur_func?; cur = cur.parent {
                upto = cur
            }
            .gen_defers_upto(upto)
            .gen_indent()

            let expr = node.u.ret.expr
            if expr? {
                if not expr.returns {
                    .out += "return "
                }
                .gen_expression(expr, is_top_level: true)
                .out += ";\n"
            } else {
                .out += "return;\n"
            }
        }
        ASTType::Yield => .gen_yield_expression(node.u.child)
        ASTType::Import => {}
        ASTType::Break | ASTType::Continue => {
            let loop_count = .scope().loop_count
            let upto = .scope()
            for let cur = .scope(); cur? and cur.loop_count == loop_count; cur = cur.parent {
                upto = cur
            }
            .gen_defers_upto(upto)

            .gen_indent()
            if node.type == ASTType::Break {
                .out += "break;\n"
            } else {
                .out += "continue;\n"
            }
        }
        ASTType::VarDeclaration => {
            .gen_indent()
            .gen_var_declaration(node)
            .out += ";\n"
        }
        ASTType::Block => {
            .gen_indent()
            .gen_block(node)
            .out += "\n"
        }
        ASTType::Defer => {
            .scope().defers.push(node.u.child)
        }
        ASTType::If => {
            .gen_indent()

            let branches = node.u.if_stmt.branches
            for let i = 0; i < branches.size; i += 1 {
                let branch = branches[i]
                if i > 0 then .out += " else "
                .out += "if ("
                .gen_expression(branch.cond, is_top_level: true)
                .out += ") "
                .gen_control_body(node, branch.body)
            }

            let else_body = node.u.if_stmt.els

            if else_body? {
                .out += " else "
                .gen_control_body(node, else_body)
                .out += "\n"
            } else {
                .out += "\n"
            }
        }
        ASTType::Match => .gen_match(node)
        ASTType::While => {
            let cond = node.u.loop.cond
            let body = node.u.loop.body
            .gen_indent()
            .out += "while ("
            .gen_expression(cond, is_top_level: true)
            .out += ") "
            .gen_block(body)
            .out += "\n"
        }
        ASTType::For => {
            let init = node.u.loop.init
            let cond = node.u.loop.cond
            let step = node.u.loop.step
            let body = node.u.loop.body
            .gen_indent()
            .out += "for ("
            if init? {
                if init.type == ASTType::VarDeclaration {
                    .gen_var_declaration(init)
                } else {
                    .gen_expression(init, is_top_level: true)
                }
            }
            .out += "; "
            if cond? then .gen_expression(cond, is_top_level: true)
            .out += "; "
            if step? then .gen_expression(step, is_top_level: true)
            .out += ") "
            .gen_block(body)
            .out += "\n"
        }
        ASTType::Assert => {
            let expr = node.u.assertion.expr
            .gen_indent()
            .out += "if(!("
            .gen_expression(expr, is_top_level: true)
            .out += ")) { ae_assert_fail("
            {
                .out += "\""
                .out <<= expr.span.start.str()
                let expr_str = .o.program.get_source_text(expr.span)
                .out += ": Assertion failed: `"
                let len = expr_str.len()
                for let i = 0; i < len; i += 1 {
                    match expr_str[i] {
                        '"' => .out += "\\\""
                        else => .out += expr_str[i]
                    }
                }
                .out += "`\""
            }
            .out += ", "
            if node.u.assertion.msg? {
                .gen_expression(node.u.assertion.msg)
            } else {
                .out += "NULL"
            }
            .out += ");"

            // If we have an explicit `assert false`, insert an exit after it to
            // make GCCs static analyzer happy
            if expr.type == BoolLiteral and expr.u.bool_literal == false {
                .out += " exit(1);"
            }
            .out += " }\n"
        }
        else => {
            .gen_indent()
            .gen_expression(node, is_top_level: true)
            .out += ";\n"
        }
    }
}

def CodeGenerator::gen_block(&this, node: &AST, with_braces: bool = true) {
    if with_braces then .out += "{\n"
    let scope = node.u.block.scope
    .o.push_scope(node.u.block.scope)

    let statements = node.u.block.statements
    .indent += 1
    for statement in statements.iter() {
        .gen_statement(statement)
    }

    if not node.returns {
        .gen_defers_upto(scope)
    }

    .indent -= 1
    .gen_indent()

    if with_braces then .out += "}"
    .o.pop_scope()
}

def CodeGenerator::helper_gen_function_type(
    &this,
    top: &Type,
    cur: &Type,
    acc: str,
    is_func_def: bool,
    param_prefix: str = null,           // To add extra dummy parameters (for closures)
    params: &Vector<&Variable> = null,  // To override the function's parameters
): str {
    let args_str = Buffer::make()
    if not params? {
        params = cur.u.func.params
    }

    if {
        param_prefix? => {
            args_str <<= param_prefix
            if params.size > 0 {
                args_str += ", "
            }
        }
        params.size == 0 => {
            args_str += "void"
        }
    }

    for let i = 0; i < params.size; i += 1 {
        if i != 0 then args_str += ", "
        let var = params.at(i)
        let arg_str = .get_type_name_string(var.type, var.sym.out_name(), is_func_def: false)
        args_str <<= arg_str
    }
    if cur.u.func.is_variadic then args_str += ", ..."

    if is_func_def and cur == top {
        // This allows us to also create function declarations
        acc.replace(`{acc}({args_str.str()})`)
    } else {
        acc.replace(`(*{acc})({args_str.str()})`)
    }
    mem::free(args_str.data)
    return .helper_gen_type(
        top,
        cur.u.func.return_type,
        acc,
        is_func_def: false
    )
}

def CodeGenerator::helper_gen_type(&this, top: &Type, cur: &Type, acc: str, is_func_def: bool): str {
    match cur.base {
        // These should all be terminal types
        Void | Bool | Char |
        I8   | I16  | I32  | I64 |
        U8   | U16  | U32  | U64 |
        F32  | F64 => acc.replace(`{cur.base.str()} {acc}`)
        Structure => acc.replace(`{cur.u.struc.sym.out_name()} {acc}`)
        Enum => acc.replace(`{cur.u.enom.sym.out_name()} {acc}`)

        Alias => acc = .helper_gen_type(top, cur.u.ptr, acc, is_func_def: false)

        Closure => acc.replace(`{cur.sym.out_name()} {acc}`)
        FunctionPtr => acc = .helper_gen_function_type(top, cur, acc, is_func_def)

        Pointer => {
            let needs_parens = (cur.u.ptr? and cur.u.ptr.base == BaseType::Array)
            if cur.u.ptr.base == BaseType::FunctionPtr {
                // No need to add extra * for function pointers
            } else if needs_parens {
                acc.replace(`(*{acc})`)
            } else {
                acc.replace(`*{acc}`)
            }
            acc = .helper_gen_type(top, cur.u.ptr, acc, is_func_def: false)
        }

        Array => {
            // Need to evaluate the expression into a string...
            let prev_buffer: Buffer = .out

            .out = Buffer::make()

            let arr_typ = &cur.u.arr
            if arr_typ.size_expr? {
                .gen_expression(arr_typ.size_expr)
            } else if arr_typ.size_known {
                .out <<= `{arr_typ.size}`
            } else {
                .error(Error::new(cur.span, "Array size not known at compile time"))
            }

            acc.replace(`{acc}[{.out.str()}]`)
            mem::free(.out.data)

            .out = prev_buffer
            acc = .helper_gen_type(top, cur.u.arr.elem_type, acc, is_func_def: false)
        }
        else => .error(Error::new(cur.span, `Unhandled type found in CodeGenerator::helper_gen_type: {cur.base}: {cur.str()}`))
    }
    return acc
}

//! Create the type-name string (eg: `int foo[10]`) and return it
def CodeGenerator::get_type_name_string(&this, type: &Type, name: str, is_func_def: bool): str {
    assert type != null
    let final = .helper_gen_type(type, type, name.copy(), is_func_def)
    final.strip_trailing_whitespace()
    return final
}

//! Codegen the type-name string
def CodeGenerator::gen_type_and_name(&this, type: &Type, name: str) {
    .out <<= .get_type_name_string(type, name, is_func_def: false)
}

def CodeGenerator::gen_type(&this, type: &Type) {
    // A type is just equivalent to the type-name string with no name
    .gen_type_and_name(type, name: "")
}

def CodeGenerator::gen_function_body(&this, func: &Function) {
    let ret_type = func.return_type
    if func.is_arrow {
        .out += "{\n"
        .indent += 1
        .gen_indent()

        if ret_type.base != Void {
            .out += "return "
            .gen_expression(func.body)
            .out += ";"
        } else {
            .gen_statement(func.body)
        }

        .indent -= 1
        .gen_indent()
        .out += "}"

    } else {
        .gen_block(func.body)
    }
}

def CodeGenerator::gen_function(&this, func: &Function) {
    if func.kind == Method {
        let parent_sym = func.parent_type.sym
        if parent_sym.is_templated() then return
    }
    if func.sym.is_templated() then return
    if func.sym.is_dead then return

    .gen_debug_info(func.sym.span)
    .gen_function_decl(func)
    .out += " "
    .gen_function_body(func)
    .out += "\n\n"
}

def CodeGenerator::gen_function_decl(&this, func: &Function) {
    let funfull_name = func.sym.out_name()
    let s = .get_type_name_string(func.type, funfull_name, true)
    .out <<= s
}

def CodeGenerator::gen_functions(&this, ns: &Namespace) {
    let functions = ns.functions;
    .o.push_scope(ns.scope)

    for func in functions.iter() {
        if func.sym.is_extern then continue
        if func.sym.is_templated() then {
            for instance in func.sym.template.instances.iter() {
                let sym = instance.resolved
                assert sym.type == Function
                let func = sym.u.func
                .gen_function(func)
            }
        } else {
            .gen_function(func)
        }
    }

    for child in ns.namespaces.iter_values() {
        .gen_functions(child)
    }
    .o.pop_scope()
}

// FIXME: How does this workn with gen_function_decl?
def CodeGenerator::gen_function_decl_toplevel(&this, func: &Function) {
    if func.sym.is_extern return

    if func.kind == Method{
        let parent_sym = func.parent_type.sym
        if parent_sym.is_templated() then return
    }

    if func.sym.is_templated() then {
        for instance in func.sym.template.instances.iter() {
            let sym = instance.resolved
            assert sym.type == Function
            let func = sym.u.func
            if func.sym.is_dead then continue

            .gen_function_decl(func)
            if func.exits then .out += " __attribute__((noreturn))"
            // .out += " asm(\""
            // .out += func.sym.display
            // .out += "\")"
            .out += ";\n"
        }
        return
    }

    if func.sym.is_dead then return
    .gen_function_decl(func)
    if func.exits then .out += " __attribute__((noreturn))"
    // if not func.sym.out_name().eq("main") {
    //     .out += " asm(\""
    //     .out += func.sym.display
    //     .out += "\")"
    // }
    .out += ";\n"
}

def CodeGenerator::gen_function_decls(&this, ns: &Namespace) {
    for func in ns.functions.iter() {
        .gen_function_decl_toplevel(func)
    }

    for child in ns.namespaces.iter_values() {
        .gen_function_decls(child)
    }
}

//* Auto-generate `dbg()` method for enums
def CodeGenerator::gen_enum_dbg_method(&this, enom: &Enum) {
    let dbg_it = enom.type.methods.get_item("dbg")
    if not dbg_it? {
        return
    }

    .gen_function_decl(dbg_it.value)
    .out += " {\n"
    .indent += 1
    .gen_indent()

    if enom.has_values {
        .out += "switch (this.tag) {\n"
    } else {
        .out += "switch (this) {\n"
    }

    .indent += 1
    for variant in enom.variants.iter() {
        .gen_indent()
        .out += "case "
        .out += variant.sym.out_name()
        .out <<= `: return "{variant.sym.name}";\n`
    }
    // This is mostly for extern enums, but is also useful for cases
    // where a perhaps incorrect value was cast to the enum type.
    .gen_indent()
    .out <<= `default: return "<unknown>";\n`

    .indent -= 1
    .gen_indent()
    .out += "}\n"
    .indent -= 1
    .out += "}\n\n"
}

def CodeGenerator::gen_struct_typedef(&this, struc: &Structure) {
    if struc.sym.is_extern return
    if struc.sym.is_dead return

    let strufull_name = struc.sym.out_name()
    if struc.is_union {
        .out <<= `typedef union {strufull_name} {strufull_name};\n`
    } else {
        .out <<= `typedef struct {strufull_name} {strufull_name};\n`
    }
}

def CodeGenerator::gen_closure_type_typedef(&this, sym: &Symbol) {
    if sym.is_dead return
    let name = sym.out_name()
    .out <<= `typedef struct {name} {name};\n`
}

def CodeGenerator::gen_closure_type_def(&this, sym: &Symbol) {
    if sym.is_dead return
    let name = sym.out_name()
    let type = sym.u.type_def
    .out <<= `struct {name} \{\n`
    .out <<= `  void *{cls::ctx_name};\n`
    .out += "  "

    let acc = cls::fn_field_name.copy()
    .out <<= .helper_gen_function_type(
        type,
        type,
        acc,
        is_func_def: false,
        param_prefix: `void *_{cls::ctx_name}`
    )
    .out += ";\n};\n"
}

def CodeGenerator::gen_closure_typedef(&this, clos: &Function) {
    if clos.sym.is_dead return
    let name = clos.sym.out_name()
    let type_name = cls::ctx_type(clos)
    .out <<= `typedef struct {type_name} {type_name};\n`
}

def CodeGenerator::gen_closure_def(&this, clos: &Function) {
    if clos.sym.is_dead return
    let name = clos.sym.out_name()

    let type_name = cls::ctx_type(clos)
    .out <<= `struct {type_name} \{\n`

    let dummy_ptr_type: Type
    dummy_ptr_type.base = Pointer

    for it in clos.closed_vars.iter() {
        let sym = it.value
        assert sym.type == ClosedVariable
        .out += "  "
        let var = sym.u.closed_var.orig

        dummy_ptr_type.u.ptr = var.type
        .gen_type_and_name(&dummy_ptr_type, var.sym.out_name())
        .out += ";\n"
    }
    .out += "};\n"
}

def CodeGenerator::gen_closure_func_decl(&this, clos: &Function) {
    if clos.sym.is_dead return
    let name = clos.sym.out_name()
    let type = clos.type

    let acc = name.copy()
    .out += .helper_gen_function_type(
        type,
        type,
        acc,
        is_func_def: true,
        param_prefix: `void *_{cls::ctx_name}`,
        params: clos.params
    )
    .out += ";\n"
}

def CodeGenerator::gen_closure_func(&this, clos: &Function) {
    if clos.sym.is_dead return
    let name = clos.sym.out_name()
    let type = clos.type

    let ctx = cls::ctx_name
    let ctx_type = cls::ctx_type(clos)

    let acc = name.copy()
    .out += .helper_gen_function_type(
        type,
        type,
        acc,
        is_func_def: true,
        param_prefix: `void *_{ctx}`,
        params: clos.params
    )
    .out += " {\n"
    .out <<= `  {ctx_type} *{ctx} = ({ctx_type} *)_{ctx};\n`
    .gen_function_body(clos)
    .out += "\n}\n\n"
}


def CodeGenerator::gen_sym_typedef(&this, sym: &Symbol) => match sym.type {
    Structure => .gen_struct_typedef(sym.u.struc)
    Enum => .gen_enum_typedef(sym.u.enom)
    Closure => .gen_closure_typedef(sym.u.func)
    ClosureType => .gen_closure_type_typedef(sym)
    else => assert false, `Unhandled symbol type in CodeGenerator::gen_typedef: {sym.type}`
}

def CodeGenerator::gen_sym_def(&this, sym: &Symbol) => match sym.type {
    Structure => .gen_struct_def(sym.u.struc)
    Enum => .gen_enum_def(sym.u.enom)
    Closure => .gen_closure_def(sym.u.func)
    ClosureType => .gen_closure_type_def(sym)
    else => assert false, `Unhandled symbol type in CodeGenerator::gen_def: {sym.type}`
}

def CodeGenerator::gen_enum_typedef(&this, enom: &Enum) {
    if enom.sym.is_extern return
    if enom.sym.is_dead return

    let name = enom.sym.out_name()
    if enom.has_values {
        .out <<= f"typedef enum {name}__kind {name}__kind;\n"
        .out <<= f"typedef struct {name} {name};\n"
    } else {
        .out <<= f"typedef enum {name} {name};\n"
    }
}

def CodeGenerator::gen_struct_def(&this, struc: &Structure) {
    if struc.sym.is_extern return
    if struc.sym.is_dead then return

    let strufull_name = struc.sym.out_name()
    if struc.is_union {
        .out <<= `union {strufull_name} \{\n`
    } else {
        .out <<= `struct {strufull_name} \{\n`
    }

    for field in struc.fields.iter() {
        .out += "  "
        if field.is_atomic {
            .out += "_Atomic "
        }
        .gen_type_and_name(field.type, field.sym.out_name())
        .out += ";\n"
    }
    .out += "};\n\n"
}

def CodeGenerator::gen_enum_def(&this, enom: &Enum) {
    if enom.sym.is_dead then return

    let name = enom.sym.out_name()
    defer .gen_enum_dbg_method(enom)

    if enom.sym.is_extern return

    // If we don't have any fields, we can just generate a simple enum
    if enom.has_values {
        .out <<= f"enum {name}__kind \{\n"
    } else {
        .out <<= f"enum {name} \{\n"
    }
    for variant in enom.variants.iter() {
        .out <<= f"  {variant.sym.out_name()},\n"
    }
    .out += "};\n\n"

    if enom.has_values {
        .out <<= f"struct {name} \{\n"
        .out <<= f"  {name}__kind tag;\n"
        for field in enom.shared_fields.iter() {
            .out += "  "
            .gen_type_and_name(field.type, field.sym.out_name())
            .out += ";\n"
        }
        .out += "  union {\n"
        for variant in enom.variants.iter() {
            if variant.specific_fields.size > 0 {
                .out += "    struct {\n"
                for let i = 0; i < variant.specific_fields.size; i += 1 {
                    // TODO: Move this to a resuable method later...
                    let field = variant.specific_fields[i]
                    let name = field.sym.out_name()
                    .out += "      "
                    .gen_type_and_name(field.type, name)
                    .out += ";\n"
                }
                .out <<= f"    \} {variant.sym.out_name()};\n"
            }
        }
        .out += "  };\n"
        .out += "};\n\n"
    }
}

def CodeGenerator::generate(&this): str {
    for include in .o.program.c_includes.iter() {
        .out <<= `#include "{include}"\n`
    }
    .out += "\n"

    for it in .o.program.c_embeds.iter() {
        .out <<= `/* Embed: {it.key} */\n`
        .out += it.value
        .out += "\n\n"
    }

    .out += "/* Constants */\n"
    .gen_constants(.o.program.global)

    .out += "/* Typedefs */\n"
    for sym in .o.program.ordered_symbols.iter() {
        .gen_sym_typedef(sym)
    }
    .out += "\n"

    .out += "/* Structs */\n"
    for sym in .o.program.ordered_symbols.iter() {
        .gen_sym_def(sym)
    }

    .out += "/* function declarations */\n"
    .gen_function_decls(.o.program.global)
    for clos in .o.program.closures.iter() {
        .gen_closure_func_decl(clos)
    }

    .gen_global_variables(.o.program.global)

    .out += "/* function implementations */\n"
    .gen_functions(.o.program.global)
    for clos in .o.program.closures.iter() {
        .gen_closure_func(clos)
    }

    return .out.str()
}

def CodeGenerator::make(program: &Program): CodeGenerator {
    return CodeGenerator(
        o: GenericPass::new(program),
        out: Buffer::make(),
        yield_vars: Vector<str>::new()
    )
}

def CodeGenerator::run(program: &Program): str {
    let pass = CodeGenerator::make(program)
    return pass.generate()
}