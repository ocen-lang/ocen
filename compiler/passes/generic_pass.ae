use "lib/vector.ae"
use "@/ast/nodes.ae"
use "@/ast/scopes.ae"

// This is a helper class to use in passes to accomplish common tasks like managing
// scopes / namespaces, resolving types, and inserting symbols into scopes.
//
// To use this, you should add a field to your pass struct like this:
//     struct MyPass {
//         o: &GenericPass
//         ...
//     }
//
// Then, initialize it with `my_pass.o = GenericPass::new(program)`. After this, you
// can use the methods on it like `.o.push_scope(scope)` etc. inside the pass methods.

struct GenericPass {
    scope_stack: &Vector
    namespace_stack: &Vector
    program: &Program
    error_type: &Type
}

def GenericPass::new(program: &Program): &GenericPass {
    let pass = calloc(1, sizeof(GenericPass)) as &GenericPass
    pass.scope_stack = Vector::new()
    pass.namespace_stack = Vector::new()
    pass.program = program
    return pass
}

def GenericPass::push_scope(&this, scope: &Scope) {
    .scope_stack.push(scope)
}

def GenericPass::push_namespace(&this, ns: &Namespace) {
    .namespace_stack.push(ns)
}

def GenericPass::pop_scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.pop() as &Scope
}

def GenericPass::pop_namespace(&this): &Namespace {
    if .namespace_stack.size == 0 return null
    return .namespace_stack.pop() as &Namespace
}

def GenericPass::scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.at(.scope_stack.size - 1) as &Scope
}

def GenericPass::ns(&this): &Namespace {
    if .namespace_stack.size == 0 return null
    return .namespace_stack.at(.namespace_stack.size - 1) as &Namespace
}

def GenericPass::error(&this, err: &Error): &Error {
    .program.errors.push(err)
    return err
}

def GenericPass::insert_into_scope_checked(&this, item: &Symbol) {
    let prev = .scope().lookup_local(item.name)
    if prev? {
        .error(Error::new_hint(
            item.span, `Name {item.name} already exists in scope`,
            prev.span, `Previous use of {item.name}`
        ))
        return
    }
    println("Inserting %s into scope", item.name)
    .scope().insert(item.name, item)
}

def GenericPass::get_base_type(&this, base: BaseType, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(base.str())
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(span, `Internal compiler error, couldn't find base type {base}`))
        return .error_type
    }
}

def GenericPass::get_type_by_name(&this, name: string, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(name)
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(span, `Internal compiler error, couldn't find type {name}`))
        return .error_type
    }
}

def GenericPass::lookup_in_symbol(&this, sym: &Symbol, name: string, error: bool): &Symbol => match sym.type {
    SymbolType::Namespace => {
        let ns = sym.u.ns
        let res = ns.find_importable_symbol(name)
        if error and not res? {
            .error(Error::new(sym.span, `Could not find symbol {name} in namespace {sym.display}`))
        }
        yield res
    }
    SymbolType::Structure => {
        let struc = sym.u.struc
        let method = struc.type.methods.get(name) as &Function
        if error and not method? {
            .error(Error::new(sym.span, `Could not find method {name} in structure {sym.display}`))
        }
        if not method? return null
        yield method.sym
    }
    SymbolType::TypeDef => {
        let type_def = sym.u.type_def
        let method = type_def.methods.get(name) as &Function
        if error and not method? {
            .error(Error::new(sym.span, `Could not find method {name} in type {sym.display}`))
        }
        if not method? return null
        yield method.sym
    }
    SymbolType::Enum => {
        let enum_ = sym.u.enum_
        let field = enum_.get_field(name) as &Variable
        if error and not field? {
            .error(Error::new(sym.span, `Could not find field {name} in enum {sym.display}`))
        }
        if not field? return null
        yield field.sym
    }
    else => {
        .error(Error::new(sym.span, `Can't lookup a name inside a {sym.type}`))
        return null
    }
}