use "lib/vector.ae"
use "@/ast.ae"
use "@/scopes.ae"

// This is a helper class to use in passes to accomplish common tasks like managing
// scopes / namespaces, resolving types, and inserting symbols into scopes.
//
// To use this, you should add a field to your pass struct like this:
//     struct MyPass {
//         o: &GenericPass
//         ...
//     }
//
// Then, initialize it with `my_pass.o = GenericPass::new(program)`. After this, you
// can use the methods on it like `.o.push_scope(scope)` etc. inside the pass methods.

struct GenericPass {
    scope_stack: &Vector
    namespace_stack: &Vector
    program: &Program
    error_type: &Type
}

def GenericPass::new(program: &Program): &GenericPass {
    let pass = calloc(1, sizeof(GenericPass)) as &GenericPass
    pass.scope_stack = Vector::new()
    pass.namespace_stack = Vector::new()
    pass.program = program
    return pass
}

def GenericPass::push_scope(&this, scope: &Scope) {
    .scope_stack.push(scope)
}

def GenericPass::push_namespace(&this, ns: &Namespace) {
    .namespace_stack.push(ns)
}

def GenericPass::pop_scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.pop() as &Scope
}

def GenericPass::pop_namespace(&this): &Namespace {
    if .namespace_stack.size == 0 return null
    return .namespace_stack.pop() as &Namespace
}

def GenericPass::scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.at(.scope_stack.size - 1) as &Scope
}

def GenericPass::ns(&this): &Namespace {
    if .namespace_stack.size == 0 return null
    return .namespace_stack.at(.namespace_stack.size - 1) as &Namespace
}

def GenericPass::error(&this, err: &Error): &Error {
    .program.errors.push(err)
    return err
}

def GenericPass::insert_into_scope_checked(&this, item: &Symbol) {
    let prev = .scope().lookup_local(item.name)
    if prev? {
        .error(Error::new_hint(
            item.span, `Name {item.name} already exists in scope`,
            prev.span, `Previous use of {item.name}`
        ))
        return
    }
    .scope().insert(item.name, item)
}

def GenericPass::resolve_type(&this, old: &Type): &Type {
    let resolved = old
    match old.base {
        Pointer => {
            resolved.u.ptr = .resolve_type(old.u.ptr)
        }
        Function => {
            let func = old.u.func
            for let i = 0; i < func.params.size; i += 1 {
                let var = func.params.at(i) as &Variable
                var.type = .resolve_type(var.type)
            }
            func.return_type = .resolve_type(func.return_type)
        }
        Unresolved => {
            let res = .resolve_scoped_identifier(old.u.unresolved, hint: null)
            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = res.u.type_def
                    SymbolType::Structure => resolved = res.u.struc.type
                    SymbolType::Enum => resolved = res.u.enum_.type
                    else => {
                        .error(Error::new(res.span, `Cannot use {res.type} as a type`))
                        resolved = null
                    }
                }
            } else {
                .error(Error::new(old.u.unresolved.span, "Could not find type with this name"))
                resolved = null
            }
        }
        else => {
            .error(Error::new(old.span, `Unhandled type in resolve {old.base}`))
            resolved = null
        }
    }
    return resolved
}

def GenericPass::resolve_scoped_identifier(&this, node: &AST, hint: &Type): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            let lhs_span = node.u.lookup.lhs.span
            let lhs = .resolve_scoped_identifier(node.u.lookup.lhs, hint: null) // hint only works for the first lookup
            if not lhs? {
                .error(Error::new(lhs_span, "couldn't resolve scope lookup lhs"))
                return null
            }

            let name = node.u.lookup.rhs_name
            let res = lhs.lookup_symbol(name)
            if not res? {
                .error(Error::new(lhs_span, `Needs to be a namespace to lookup, got '{lhs.type}'`))
            }
            node.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = .scope().lookup_recursive(name)

            // If we know that the type of this identifier is supposed to be a particular enum,
            // then we can look up the field in that enum implicitly.
            if not res? and hint? {
                if hint.base == Enum {
                    let enum_ = hint.u.enum_
                    let field = enum_.get_field(name) as &Variable
                    if field? {
                        res = field.sym
                    }
                }
            }

            node.resolved_symbol = res
            return res
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def GenericPass::get_base_type(&this, base: BaseType, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(base.str())
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(span, "Internal compiler error, couldn't find base type"))
        return .error_type
    }
}