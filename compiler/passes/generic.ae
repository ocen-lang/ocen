use "lib/vector.ae"
use "@/ast.ae"
use "@/scopes.ae"

struct GenericPass {
    scope_stack: &Vector
    program: &Program
    error_type: &Type
}

def GenericPass::new(program: &Program): &GenericPass {
    let pass = calloc(1, sizeof(GenericPass)) as &GenericPass
    pass.scope_stack = Vector::new()
    pass.program = program
    return pass
}

def GenericPass::push_scope(&this, scope: &Scope) {
    .scope_stack.push(scope)
}

def GenericPass::pop_scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.pop() as &Scope
}

def GenericPass::scope(&this): &Scope {
    if .scope_stack.size == 0 return null
    return .scope_stack.at(.scope_stack.size - 1) as &Scope
}

def GenericPass::error(&this, err: &Error): &Error {
    .program.errors.push(err)
    return err
}

def GenericPass::insert_into_scope_checked(&this, name: string, item: &Symbol, span: Span) {
    let prev = .scope().lookup_local(name)
    if prev? {
        .error(Error::new_hint(
            span, `Name {name} already exists in scope`,
            prev.span(), `Previous use of {name}`
        ))
    } else {
        .scope().insert(name, item)
    }
}

def GenericPass::resolve_type(&this, old: &Type): &Type {
    let resolved = old
    match old.base {
        // Otherwise...
        Pointer => {
            resolved.u.ptr = .resolve_type(old.u.ptr)
        }
        Function => {
            let func = old.u.func
            for let i = 0; i < func.params.size; i += 1 {
                let var = func.params.at(i) as &Variable
                var.type = .resolve_type(var.type)
            }
            func.return_type = .resolve_type(func.return_type)
        }
        Unresolved => {
            let res = .resolve_scoped_identifier(old.u.unresolved, hint: null)
            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = res.u.type_def
                    SymbolType::Structure => resolved = res.u.struc.type
                    SymbolType::Enum => resolved = res.u.enum_.type
                    else => {
                        .error(Error::new(res.span(), `Cannot use {res.type} as a type`))
                        resolved = null
                    }
                }
            } else {
                .error(Error::new(old.u.unresolved.span, "Could not find type with this name"))
                resolved = null
            }
        }
        else => {
            .error(Error::new(old.span, `Unhandled type in resolve {old.base}`))
            resolved = null
        }
    }
    return resolved
}

def GenericPass::resolve_scoped_identifier(&this, node: &AST, hint: &Type): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            let lhs = .resolve_scoped_identifier(node.u.lookup.lhs, hint: null) // hint only works for the first lookup
            if not lhs? {
                .error(Error::new(node.u.lookup.lhs.span, "couldn't resolve scope lookup lhs"))
                return null
            }

            let name = node.u.lookup.rhs_name
            match lhs.type {
                SymbolType::Namespace => {
                    let ns = lhs.u.ns
                    let res = ns.find_importable_symbol(name)
                    node.resolved_symbol = res
                    return res
                }
                SymbolType::Structure => {
                    let struc = lhs.u.struc
                    let method = struc.type.methods.get(name) as &Function
                    if not method? return null
                    node.resolved_symbol = Symbol::from_function(name, method)
                    return node.resolved_symbol
                }
                SymbolType::TypeDef => {
                    let type_def = lhs.u.type_def
                    let method = type_def.methods.get(name) as &Function
                    if not method? return null
                    node.resolved_symbol = Symbol::from_function(name, method)
                    return node.resolved_symbol
                }
                SymbolType::Enum => {
                    let enum_ = lhs.u.enum_
                    let name = node.u.lookup.rhs_name
                    let field = enum_.get_field(name) as &Variable
                    if not field? return null
                    node.resolved_symbol = Symbol::from_variable(field)
                    return node.resolved_symbol
                }
                else => {
                    .error(Error::new(node.u.lookup.lhs.span, `needs to be a namespace to lookup, got '{lhs.type}'`))
                    return null
                }
            }
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = .scope().lookup_recursive(name)

            // If we know that the type of this identifier is supposed to be a particular enum,
            // then we can look up the field in that enum implicitly.
            if not res? and hint? {
                if hint.base == Enum {
                    let enum_ = hint.u.enum_
                    let field = enum_.get_field(name) as &Variable
                    if field? {
                        res = Symbol::from_variable(field)
                    }
                }
            }

            node.resolved_symbol = res
            return res
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def GenericPass::get_base_type(&this, base: BaseType, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(base.str())
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(Span::default(), "Internal compiler error, couldn't find base type"))
        return .error_type
    }
}