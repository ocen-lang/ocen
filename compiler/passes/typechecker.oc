//* Resolve and check types in the AST
//*
//* This pass actually goes through the AST and checks the types of all the nodes.
//* Any remaining unresolved types should be resolved after this

import std::mem
import std::buffer::{ Buffer }
import std::map::{ Map }
import std::span::{ Span }
import std::vector::{ Vector }

import @passes::visitor::{ Visitor }
import @ast::nodes::{ AST, ASTType, Structure, Function, Variable }
import @ast::operators::{ Operator, OperatorOverload }
import @ast::nodes::{
    ImportPart, Import, Argument, MatchCond, MatchCondArg, MatchCase,
    Enum, EnumVariant, Specialization
}
import @ast::program::{ Program, Namespace, get_deep_copy }
import @ast::scopes::{ Scope, Symbol, SymbolType, TemplateInstance, ReferenceType, ClosedVariable }
import @errors::{ Error }
import @lexer::{ Lexer }
import @parser::{ Parser }
import @passes::generic_pass::{ GenericPass }
import @types::{ Type, BaseType, FunctionType, UnresolvedTemplate, ArrayType }

struct TypeChecker {
    o: &GenericPass
    unchecked_functions: &Vector<&Function>

    //! Used for checking if we should add a reference to a symbol when resolving it
    in_template_instance: bool
}

// Some convenience accessors from the GenericPass
def TypeChecker::error(&this, err: &Error): &Error => .o.error(err)
def TypeChecker::scope(&this): &Scope => .o.scope()

def TypeChecker::get_base_type(&this, base: BaseType, span: Span): &Type => .o.program.get_base_type(base, span)
def TypeChecker::get_type_by_name(&this, name: str, span: Span): &Type => .o.program.get_type_by_name(name, span)

def TypeChecker::set_resolved_symbol(&this, node: &AST, sym: &Symbol) {
    node.resolved_symbol = sym

    // Import statements themselves don't add a reference to the symbol
    if node.type == Import return
    let ref_type = ReferenceType::Normal

    let span = match node.type {
        Identifier => node.span
        Import | Specialization => {
            // Don't add references for these
            return
        }
        OverloadedOperator => {
            ref_type = OperatorOverload
            yield node.u.operator_span
        }
        // Want to find the span of the actual identifier
        NSLookup => node.u.lookup.rhs_span
        Member | TryMember => {
            if sym.name == "this" and node.u.member.dot_shorthand {
                ref_type = DotShorthand
            }
            yield node.u.member.rhs_span
        }
        VarDeclaration => sym.span
        else => {
            assert false, `Unhandled node type in set_resolved_symbol: {node.type}`
        }
    }

    if sym? and not .in_template_instance {
        sym.add_reference(ref_type, span)
    }
}

def TypeChecker::get_closure_type(&this, params: &Vector<&Variable>, return_type: &Type, old: &Type): &Type {
    let canon = .o.program.find_closure_type(params, return_type)
    if not canon? {
        // FIXME: Use a better span that's passed in
        let span = if old? then old.span else Span::default()

        if old? {
            let func_ty = old.u.func
            canon = Type::shallow_copy(old)
            canon.u.func = FunctionType(func_ty.orig, params, return_type, func_ty.is_variadic)

        } else {
            canon = Type::new_resolved(Closure, span)
            canon.u.func = FunctionType(null, params, return_type, false)
        }

        let closure_name = `_ClosureTy_{.o.program.closure_types.size}`
        .o.program.closure_types.push(canon)

        let sym = Symbol::new(ClosureType, ns: null, closure_name, closure_name, closure_name, span)
        sym.u.type_def = canon
        canon.sym = sym
    }
    return canon
}

def TypeChecker::resolve_type(
    &this,
    old: &Type,
    allow_incomplete: bool = false, // Allow checking types like `Foo<i32, T>` without T being resolved
    error: bool = true,             // Whether to error if the type cannot be resolved
    resolve_templates: bool = true  // Don't try to resolve the templates, just resolve the base and params
): &Type {

    // Shorter names for parameters to make recursive calls easier to read
    let p_a = allow_incomplete
    let p_e = error
    let p_r = resolve_templates

    let resolved = old
    if not old? return null

    match old.base {
        Pointer => {
            let ptr = .resolve_type(old.u.ptr, p_a, p_e, p_r)
            if not ptr? return null
            match ptr.base {
                Char => resolved = .o.program.get_type_by_name("str", old.span)
                Void => resolved = .o.program.get_type_by_name("untyped_ptr", old.span)
                else => {
                    resolved = Type::shallow_copy(old)
                    resolved.u.ptr = ptr
                }
            }
        }
        Alias => {
            if not old.u.ptr? {
                .error(Error::new_note(
                    old.span, "This type does not point to anything",
                    "Cannot use a typedef for a type when defining any of it's members.\nUse fully qualified type for all field / method definitions."
                ))
                return null
            }
            return .resolve_type(old.u.ptr, p_a, p_e, p_r)
        }
        Closure | FunctionPtr => {
            let checked_params = Vector<&Variable>::new()

            let func = old.u.func
            for var in func.params.iter() {
                // Note: it's okay to overwrite here since `var` has `parsed_type` already
                var.type = .resolve_type(var.type, p_a, p_e, p_r)
                if not var.type? return null
                checked_params.push(var)
            }

            let return_type = .resolve_type(func.return_type, p_a, p_e, p_r)
            if not return_type? return null

            // We want all closures to point to the same "canonical" closure type
            if old.base == Closure {
                resolved = .get_closure_type(checked_params, return_type, old)

            } else {
                resolved = Type::shallow_copy(old)
                resolved.u.func = FunctionType(func.orig, checked_params, return_type, func.is_variadic)
            }
        }
        Unresolved => {
            let node = old.u.unresolved
            let res = .resolve_scoped_identifier(node, p_e, hint: null, p_r)

            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = .resolve_type(res.u.type_def, p_a, p_e, p_r)
                    SymbolType::Structure => {
                        let struc = res.u.struc
                        if res.is_templated() and not allow_incomplete {
                            if error {
                                .error(Error::new(old.span, `Cannot use templated struct {struc.sym.name} as a type`))
                            }
                            return resolved
                        }
                        resolved = res.u.struc.type
                        if node.type == Specialization and res.is_templated() {
                            assert not resolve_templates, "Should have been errored in resolve_scoped_identifier"
                            let type = Type::new_resolved(UnresolvedTemplate, node.span)
                            type.u.unresolved_spec = UnresolvedTemplate(resolved, node.u.spec.template_args)
                            resolved = type
                        }
                    }
                    SymbolType::Function => {
                        let func = res.u.func
                        if res.is_templated() and not allow_incomplete {
                            if error {
                                .error(Error::new(old.span, `Cannot use templated function {func.sym.name} as a type`))
                            }
                            return resolved
                        }
                        resolved = res.u.func.type
                        if node.type == Specialization and res.is_templated() {
                            assert not resolve_templates, "Should have been errored in resolve_scoped_identifier"
                            let type = Type::new_resolved(UnresolvedTemplate, node.span)
                            type.u.unresolved_spec = UnresolvedTemplate(resolved, node.u.spec.template_args)
                            resolved = type
                        }
                    }
                    SymbolType::Enum => {
                        let enom = res.u.enom
                        if res.is_templated() and not allow_incomplete {
                            if error {
                                .error(Error::new(old.span, `Cannot use templated enum {enom.sym.name} as a type`))
                            }
                            return resolved
                        }
                        resolved = res.u.enom.type
                        if node.type == Specialization and res.is_templated() {
                            assert not resolve_templates, "Should have been errored in resolve_scoped_identifier"
                            let type = Type::new_resolved(UnresolvedTemplate, node.span)
                            type.u.unresolved_spec = UnresolvedTemplate(resolved, node.u.spec.template_args)
                            resolved = type
                        }
                    }
                    else => {
                        if error {
                            .error(Error::new(res.span, `Cannot use {res.display} as a type`))
                            resolved = null
                        }
                    }
                }
            } else {
                if error {
                    resolved = null
                }
            }
        }
        Array => {
            let arr = old.u.arr
            let elem_type = .resolve_type(arr.elem_type, p_a, p_e, p_r)
            let res = .check_expression(arr.size_expr)
            resolved = Type::shallow_copy(old)
            resolved.u.arr.elem_type = elem_type

            .try_infer_array_size(&resolved.u.arr)
        }
        VectorShorthand => {
            if not (.o.program.did_cache_symbols and .o.program.cached_symbols.std_vector?) {
                .error(Error::new(old.span, "Vector shorthand not available"))
                resolved = null
            } else {
                let std_vector = .o.program.cached_symbols.std_vector
                let elem_type = .resolve_type(old.u.ptr, p_a, p_e, p_r)
                if not elem_type? return null

                let res = .resolve_templated_symbol(std_vector, $[elem_type], old.span)
                assert res.type == Structure
                old.sym = res
                resolved = Type::new_resolved(Pointer, old.span)
                resolved.u.ptr = res.u.struc.type
            }
        }
        MapShorthand => {
            if not (.o.program.did_cache_symbols and .o.program.cached_symbols.std_map?) {
                .error(Error::new(old.span, "Map shorthand not available"))
                resolved = null
            } else {
                let std_map = .o.program.cached_symbols.std_map
                let key_type = .resolve_type(old.u.map_types.key, p_a, p_e, p_r)
                let value_type = .resolve_type(old.u.map_types.value, p_a, p_e, p_r)
                if not (key_type? and value_type?) return null

                let res = .resolve_templated_symbol(std_map, $[key_type, value_type], old.span)
                assert res.type == Structure
                old.sym = res
                resolved = Type::new_resolved(Pointer, old.span)
                resolved.u.ptr = res.u.struc.type
            }
        }
        Structure | Char | Bool | Void | I8 | I16 |
        I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 |
        Enum => {}

        else => {
            if error {
                .error(Error::new(old.span, `Unhandled type in resolve {old.base.str()}`))
                resolved = null
            }
        }
    }
    return resolved
}

def TypeChecker::try_infer_array_size(&this, arr_typ: &ArrayType) {
    let size_expr = arr_typ.size_expr

    if size_expr.type == ASTType::IntLiteral {
        if size_expr.u.num_literal.suffix? {
            .error(Error::new(size_expr.span, "Array size literal cannot have a suffix"))
        }
        arr_typ.size_known = true
        arr_typ.size = size_expr.u.num_literal.text.to_u32()
    }

    // FIXME: We also want to be able to check based on constant expressions, however
    // we don't have a way to actually evaluate constant expressions yet since we just
    // pass that onto the C compiler.
}

def TypeChecker::resolve_templated_methods(&this, old_type: &Type, cur_type: &Type) {
    // let old_type = old.type
    // let cur_type = cur.type

    let old_methods = old_type.methods
    let cur_methods = cur_type.methods

    let parent_ns = old_type.sym.ns

    for iter in old_methods.iter() {
        let name = iter.key
        let method = iter.value

        let new_method = get_deep_copy<Function>(.o.program, method, parent_ns, Parser::parse_function)
        new_method.operator_overloads = method.operator_overloads
        new_method.parent_type = cur_type
        cur_methods.insert(name, new_method)

        new_method.sym.update_parent(cur_type.sym)
        parent_ns.functions.push(new_method)

        if not method.is_static {
            let this_param = new_method.params.at(0)
            if this_param.type.base == Pointer {
                this_param.type.u.ptr = cur_type
            } else {
                this_param.type = cur_type
            }
        }

        new_method.scope = .scope()
        .check_function_declaration(new_method)

        // NOTE: We don't want to check these functions right now, since we could still be in the process
        // of setting up the namespaces / imports / etc. We'll check them later at the end of the program.
        .unchecked_functions.push(new_method)
    }
}

//! Internal use only. Should call resolve_template_symbol instead
def TypeChecker::resolve_templated_struct(&this, struc: &Structure, instance: &TemplateInstance) {
    let sym = instance.resolved
    let resolved_struc = get_deep_copy<Structure>(.o.program, struc, struc.sym.ns, Parser::parse_struct)
    resolved_struc.sym.template = null
    resolved_struc.sym = sym
    sym.u.struc = resolved_struc
    // Copy over formatting information
    resolved_struc.format_spec = struc.format_spec
    resolved_struc.format_args = struc.format_args

    let typ = Type::new_resolved(Structure, sym.span)
    typ.u.struc = resolved_struc
    resolved_struc.type = typ
    typ.sym = sym
    typ.template_instance = instance

    .resolve_struct(resolved_struc)
    .resolve_templated_methods(struc.type, resolved_struc.type)
}

def TypeChecker::resolve_templated_enum(&this, enom: &Enum, instance: &TemplateInstance) {
    let sym = instance.resolved
    let resolved_enom = get_deep_copy<Enum>(.o.program, enom, enom.sym.ns, Parser::parse_enum)
    resolved_enom.sym.template = null
    resolved_enom.sym = sym
    sym.u.enom = resolved_enom

    let typ = Type::new_resolved(Enum, sym.span)
    typ.u.enom = resolved_enom
    resolved_enom.type = typ
    typ.sym = sym
    typ.template_instance = instance

    for variant in resolved_enom.variants.iter() {
        let variant_sym = variant.sym
        variant_sym.update_parent(sym)
    }

    for field in resolved_enom.shared_fields.iter() {
        let field_sym = field.sym
        field_sym.update_parent(sym)
    }

    .resolve_enum(resolved_enom)
    .resolve_templated_methods(enom.type, resolved_enom.type)
}

//! Internal use only. Should call resolve_template_symbol instead
def TypeChecker::resolve_templated_function(&this, func: &Function, instance: &TemplateInstance) {
    let sym = instance.resolved
    let resolved_func = get_deep_copy<Function>(.o.program, func, func.sym.ns, Parser::parse_function)
    resolved_func.operator_overloads = func.operator_overloads
    resolved_func.sym.template = null
    resolved_func.sym = sym
    if func.parent_type? {
        sym.update_parent(func.parent_type.sym)
    }
    sym.u.func = resolved_func
    resolved_func.scope = .scope()

    .check_function_declaration(resolved_func)
    resolved_func.type.template_instance = instance

    .unchecked_functions.push(resolved_func)
}


def TypeChecker::find_template_instance(&this, template_instances: &Vector<&TemplateInstance>, args: &Vector<&Type>): &Symbol {
    for instance in template_instances.iter() {
        if instance.matches(args) return instance.resolved
    }
    return null
}

def TypeChecker::resolve_templated_symbol(&this, sym: &Symbol, template_args: &Vector<&Type>, span: Span): &Symbol {
    let template_params = sym.template.params
    if template_params.size != template_args.size {
        .error(Error::new(span, `Invalid number of template arguments for {sym.name}`))
        return null
    }

    // If we've already resolved this template, just return the symbol
    {
        let found = .find_template_instance(sym.template.instances, template_args)
        if found? return found
    }

    let parent_ns = sym.ns

    // Want to also build a new display name for the specialization
    let new_display_name = Buffer::make()
    new_display_name += sym.display
    new_display_name += "<"

    // This is the scope that we'll use to resolve the template parameters
    let scope = Scope::new(sym.ns.scope)
    .o.push_scope(scope)

    // NOTE: If we have Foo<T> and we instantiate Foo<Bar>, we don't want to add to `Bar` for all the
    //       `T`s we see in the struct members, and in all attached methods. This is completely unhelpful
    //       since this is not an explicit usage of `Bar` in the source, and is not what the user intended
    //       to find when they search for references to `Bar`.
    let was_in_template_instance = .in_template_instance
    .in_template_instance = true
    defer .in_template_instance = was_in_template_instance

    // Add the template arguments to the scope with corresponding names
    for let i = 0; i < template_params.size; i += 1 {
        let sym = template_params.at(i)
        let arg = template_args.at(i)

        if i > 0 then new_display_name += ", "
        new_display_name += arg.str()

        let cur_sym = Symbol::new(
            TypeDef,
            ns: null,
            sym.name, // name
            sym.name, // display
            sym.name, // out_name
            sym.span,
        )
        cur_sym.u.type_def = arg
        .o.insert_into_scope_checked(cur_sym)
    }

    new_display_name += ">"

    // NOTE: We need to do `new_with_parent` to properly set the namespaced names of the symbol
    let new_out_name = `{sym.name}__{sym.template.instances.size}`
    let new_sym = Symbol::new_with_parent(sym.type, parent_ns, parent_ns.sym, new_out_name, sym.span)
    new_sym.display = new_display_name.str()

    let instance = TemplateInstance::new(template_args, parent: sym, resolved: new_sym)
    sym.template.instances.push(instance)

    match sym.type {
        Structure => .resolve_templated_struct(sym.u.struc, instance)
        Enum => .resolve_templated_enum(sym.u.enom, instance)
        Function => .resolve_templated_function(sym.u.func, instance)
        else => {
            .error(Error::new(span, `Cannot specialize non-templated symbol {sym.name}`))
            return null
        }
    }
    .o.pop_scope()

    return new_sym
}


def TypeChecker::resolve_scoped_identifier(&this, node: &AST, error: bool = true, hint: &Type = null, resolve_templates: bool = true): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            let lhs_span = node.u.lookup.lhs.span
            let lhs = .resolve_scoped_identifier(node.u.lookup.lhs, error, hint: null, resolve_templates)
            if not lhs? return null

            let name = node.u.lookup.rhs_name
            if not name? return null

            let res = .o.find_in_symbol_or_error(lhs, name, node.span, error)
            .set_resolved_symbol(node, res)
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res: &Symbol = null

            // If we know that the type of this identifier is supposed to be a particular enum,
            // then we can look up the field in that enum implicitly.
            if hint? {
                match hint.base {
                    Enum => {
                        let enom = hint.u.enom
                        let variant = enom.get_variant(name)
                        if variant? {
                            res = variant.sym
                        }
                    }
                    else => {}
                }
            }

            if not res? {
                res = .scope().lookup_recursive(name)
            }

            if not res? {
                // FIXME: We only check the current function's closure_scope. This doesn't
                //        allow us to have nested closures, which is a limitation.
                let scope = .scope()
                if scope.cur_func? {
                    let cur_func = scope.cur_func
                    if cur_func.kind == Closure {
                        let tmp = scope.cur_func.closure_scope.lookup_recursive(name)
                        if {
                            not tmp? => {}
                            tmp.type != Variable => {
                                // FIXME: Functions/globals?
                                .error(Error::new(node.span, f"Can't close over non-variable {name}"))
                            }
                            else => {
                                let it = cur_func.closed_vars.get_item(name)
                                if it? {
                                    res = it.value
                                } else {
                                    let closed_sym = Symbol::new(ClosedVariable, ns: null, name, name, name, node.span)
                                    closed_sym.u.closed_var = ClosedVariable(tmp.u.var, cur_func)
                                    cur_func.closed_vars.insert(name, closed_sym)
                                    res = closed_sym
                                }
                            }
                        }
                    }
                }
            }

            .set_resolved_symbol(node, res)
            if error and not res? {
                .error(Error::new(node.span, f"Couldn't find this identifier: {name}"))
            }
            return res
        }
        ASTType::Specialization => {
            let base = .resolve_scoped_identifier(node.u.spec.base, error, hint, resolve_templates)
            if not base? return null

            base = base.remove_alias()
            if not base.is_templated() {
                .error(Error::new(node.span, `Cannot specialize non-templated symbol {base.name}`))
                return null
            }

            let args = node.u.spec.parsed_template_args
            let resolved_args = Vector<&Type>::new(capacity: args.size)
            let failed = false
            for let i = 0; i < args.size; i += 1 {
                let resolved_arg = .resolve_type(args.at(i), allow_incomplete: true, error, resolve_templates)
                if not resolved_arg? {
                    failed = true
                    continue
                }
                resolved_args.push(resolved_arg)
            }
            if failed return null
            node.u.spec.template_args = resolved_args

            if not resolve_templates {
                .set_resolved_symbol(node, base)
                return base
            }

            return .resolve_templated_symbol(base, resolved_args, node.span)
        }
        else => {
            if error {
                .error(Error::new(node.span, `Don't know how to resolve node type {node.type}`))
            }
            return null
        }
    }
}

def TypeChecker::check_block(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let block = &node.u.block

    let scope = Scope::new(.scope())
    scope.can_yield = scope.can_yield or is_expr
    block.scope = scope

    .o.push_scope(block.scope)
    let stmts = block.statements
    let yield_span = Span::default()
    for stmt in stmts.iter() {
        .check_statement(stmt)
        if stmt.returns then node.returns = true

        if stmt.type != Yield then continue
        if node.etype? {
            .error(Error::new_hint(
                stmt.span, "Cannot yield multiple times in a block",
                yield_span, "Previously yielded here"
            ))
        }
        node.etype = stmt.etype
        yield_span = stmt.span
        node.u.block.final_stmt = stmt
    }
    .o.pop_scope()
}

def TypeChecker::check_method_call(&this, method: &Function, node: &AST) {
    let callee = node.u.call.callee
    if callee.type != ASTType::Member and callee.type != ASTType::NSLookup {
        .error(Error::new(callee.span, "Method call is not to a member, internal compiler error"))
        return
    }

    if callee.type != ASTType::Member return
    if method.params.size == 0 {
        // This should ideally never happen.
        .error(Error::new(callee.span, "Instance method should have `this` argument, internal error"))
        return
    }
    let method_param = (method.params.at(0)).type
    if not method_param? return

    let member = callee.u.member
    let first_arg = member.lhs

    if member.is_pointer and method_param.base != Pointer {
        first_arg = AST::new_unop(Dereference, first_arg.span, first_arg)
    } else if not member.is_pointer and method_param.base == Pointer {
        first_arg = AST::new_unop(Address, first_arg.span, first_arg)
    }
    node.u.call.args.push_front(Argument::new(first_arg))
}

def TypeChecker::check_union_constructor(&this, node: &AST, params: &Vector<&Variable>) {
    let args = node.u.call.args
    if args.size != 1 {
        .error(Error::new(node.span, `Union constructors must have exactly one field`))
        for arg in args.iter() {
            .check_expression(arg.expr)
        }
        return
    }

    let arg = args[0]
    if not arg.label? {
        .error(Error::new(arg.expr.span, `Union constructors must have a label for the field`))
        .check_expression(arg.expr)
        return
    }

    let param: &Variable = null
    for p in params.iter() {
        if p.sym? and p.sym.name.eq(arg.label) {
            param = p
            break
        }
    }
    if not param? {
        .error(Error::new(arg.expr.span, `Unknown field {arg.label} in union constructor`))
        .check_expression(arg.expr)
        return
    }

    let arg_type = .check_expression(arg.expr, hint: param.type)
    if arg_type? and not arg_type.eq(param.type) {
        .error(Error::new_hint(
            arg.expr.span, f"Expected `{arg.label}` with type {param.type.str()}, but got {arg_type.str()}",
            param.sym.span, "Parameter defined here"
        ))
    }
}

def TypeChecker::check_constructor(&this, node: &AST): &Type {
    node.u.call.call_type = StructConstructor

    let callee = node.u.call.callee
    let type_sym = callee.resolved_symbol.remove_alias()

    assert type_sym.type == Structure, `Got non-struct type in check_constructor: {type_sym.type}`
    let struc = type_sym.u.struc

    let params = struc.fields
    if {
        struc.is_union => .check_union_constructor(node, params)
        else => .check_call_args(node, params)
    }


    return struc.type
}

def TypeChecker::check_enum_constructor(&this, node: &AST): &Type {
    node.u.call.call_type = EnumConstructor

    let callee = node.u.call.callee
    let type_sym = callee.resolved_symbol.remove_alias()

    assert type_sym.type == EnumVariant, `Got non-struct type in check_constructor: {type_sym.type}`
    let variant = type_sym.u.enum_var
    let enom = variant.parent

    let num_expected_fields = variant.num_fields()
    let params = Vector<&Variable>::new()
    for let i = 0; i < num_expected_fields; i += 1 {
        let field = variant.get_field_by_idx(i)
        params.push(field)
    }

    let args = node.u.call.args
    if num_expected_fields == 0 and args.size == 0 {
        let span = node.u.call.open_paren_span + node.u.call.close_paren_span
        .error(Error::new(span, `Unnecessary empty constructor for {variant.sym.display}, no fields expected`))
        return variant.parent.type
    }

    .check_call_args(node, params)
    params.clear()
    return enom.type
}

def TypeChecker::check_call_args_labelled(&this, node: &AST, params: &Vector<&Variable>, start: u32) {
    let args = node.u.call.args
    let callee = node.u.call.callee
    let new_args = Vector<&Argument>::new()

    let kwargs = Map<str, &Argument>::new()
    let expected_params = Map<str, &Variable>::new()

    for let i = 0; i < params.size; i++ {
        let param = params.at(i)
        if not param.sym? {
            .error(Error::new(param.type.span, "Not allowed to have unlabeled parameter here"))
            continue
        }
        expected_params[param.sym.name] = param
        if i < start {
            let arg = args[i]
            kwargs[param.sym.name] = arg
            new_args.push(args[i])
        }
    }

    for let i = start; i < args.size; i++ {
        let arg = args.at(i)
        // TODO: At parsing time, try and get implicit labels for unlabeled arguments such as for identifiers
        if not arg.label? {
            .error(Error::new(arg.expr.span, "Can't have positional arguments after labelled arguments"))
            continue
        }
        let param_item = expected_params.get_item(arg.label)
        let kwarg_item = kwargs.get_item(arg.label)

        let expected_type: &Type = null
        if {
            not param_item? => .error(Error::new(
                arg.label_span, f"Unknown labelled argument `{arg.label}`"
            ))
            kwarg_item? => .error(Error::new_hint(
                arg.label_span, f"Duplicate argument for parameter `{arg.label}`",
                kwarg_item.value.expr.span, "Previously specified here"
            ))
            else => {
                kwargs[arg.label] = arg
                expected_type = param_item.value.type
            }
        }
        let arg_type = .check_expression(arg.expr, hint: expected_type)
        if arg_type? and expected_type? and not arg_type.eq(expected_type) {
            .error(Error::new_hint(
                arg.expr.span, f"Expected `{arg.label}` with type {expected_type.str()}, but got {arg_type.str()}",
                param_item.value.sym.span, "Parameter defined here"
            ))
        }
    }

    for let i = start; i < params.size; i++ {
        let param = params.at(i)
        assert param.sym?, f"Expected a symbol for parameter {i}"

        let item = kwargs.get_item(param.sym.name)
        if item? {
            new_args.push(item.value)

        } else if param.default_value? {
            let new_arg = Argument::new(param.default_value)
            new_args.push(new_arg)

        } else {
            // Currently... this can never be reached, since we only go to this function AFTER
            // we have seen a default arg. In the future, we might want to allow all arguments to
            // be unordered as long as the positional ones are provided somewhere, and in that case
            // this check would be necessary.
            .error(Error::new_hint(
                node.u.call.close_paren_span, f"Missing required argument `{param.sym.name}` of type {param.type.str()}",
                param.sym.span, "Parameter defined here"
            ))
        }
    }

    args.free()
    kwargs.free()
    expected_params.free()
    node.u.call.args = new_args
}


def TypeChecker::check_call_args(&this, node: &AST, params: &Vector<&Variable>, is_variadic: bool = false) {
    let args = node.u.call.args

    for let i = 0; i < params.size; i++ {
        let param = params.at(i)

        // We would only get here if we have not gone through the labelled arguments yet
        if i >= args.size {
            if param.default_value? {
                let new_arg = Argument::new(param.default_value)
                args.push(new_arg)
            } else {
                if param.sym? {
                    .error(Error::new_hint(
                        node.u.call.close_paren_span, f"Missing required argument `{param.sym.name}` of type {param.type.str()}",
                        param.sym.span, "Parameter defined here"
                    ))
                } else {
                    .error(Error::new(node.u.call.close_paren_span, `Missing required field {i} of type {param.type.str()}`))
                }
            }
            continue
        }

        let arg = args.at(i)
        if arg.label? {
            if {
                not param.sym? => .error(Error::new(
                    arg.label_span, "Cannot use a labelled argument for a non-labeled parameter"
                ))
                not arg.label.eq(param.sym.name) =>{
                    // If we have started looking at the default arguments, we can start allowing
                    // unordered arguments when they are labelled
                    // param.default_value? => {
                    if is_variadic {
                        .error(Error::new(
                            arg.label_span, `Variadic functions not allowed with default arguments`,
                        ))
                    }

                    .check_call_args_labelled(node, params, i)
                    break
                }
                // Fallthrough
                else => {}
            }
        }

        let arg_type = .check_expression(arg.expr, hint: param.type)
        if not arg_type? or not param.type? {
            continue
        }
        if not param.type.can_assign(arg_type) {
            if param.sym? {
                .error(Error::new_hint(
                    arg.expr.span, f"Expected `{param.sym.name}` with type {param.type.str()}, but got {arg_type.str()}",
                    param.sym.span, "Parameter defined here"
                ))
            } else {
                .error(Error::new(arg.expr.span, `Expected field {i} with type {param.type.str()}, but got {arg_type.str()}`))
            }
        }
    }

    // The arguments might have been updated by `check_call_args_labelled`, so we need to re-fetch them
    args = node.u.call.args

    if is_variadic {
        for let i = params.size; i < args.size; i++ {
            let arg = args.at(i)
            let arg_type = .check_expression(arg.expr)
            if not arg_type? {
                continue
            }
        }
    } else {
        for let i = params.size; i < args.size; i++ {
            let arg = args.at(i)
            let arg_type = .check_expression(arg.expr)
            .error(Error::new(arg.expr.span, `Unexpected argument, expected only {params.size}`))
        }
    }
}

def TypeChecker::check_call(&this, node: &AST, hint: &Type = null): &Type {
    let callee = node.u.call.callee
    let args = node.u.call.args

    let res = match callee.type {
        Member => .check_member(callee, is_being_called: true, is_try: false)
        TryMember => .check_member(callee, is_being_called: true, is_try: true)
        Identifier | NSLookup | Specialization => {
            let sym = .resolve_scoped_identifier(callee, error: true, hint)
            yield match sym? {
                true => {
                    sym = sym.remove_alias()
                    .set_resolved_symbol(callee, sym)

                    yield match sym.type {
                        Structure | TypeDef => {
                            node.u.call.call_type = StructConstructor
                            return .check_constructor(node)
                        }
                        EnumVariant => {
                            node.u.call.call_type = EnumConstructor
                            return .check_enum_constructor(node)
                        }
                        else => .check_expression(callee)
                    }
                }
                false => .o.error_type
            }
        }
        else => .check_expression(callee)
    }

    node.u.call.call_type = Normal
    if res? {
        if res.base == BaseType::Pointer and res.u.ptr.base == BaseType::FunctionPtr {
            res = res.u.ptr

        } else if not res.base.is_callable() {
            .error(Error::new(callee.span, `Cannot call a non-function type: {res.str()}`))
            // Mark this node as an error, we'll exit after checking the arguments
            res = .o.error_type
        }

    // Don't exit quite yet... we need to check the call args
    } else {
        res = .o.error_type
    }


    // If we have an error, still type-check the arguments, but don't try to
    // compare them against anything.
    if res.base == Error {
        for arg in args.iter() {
            .check_expression(arg.expr)
        }
        return null
    }

    let func = res.u.func
    if func.orig? and func.orig.exits then node.returns = true
    let params = func.params

    if func.orig? and func.orig.kind == Method and not func.orig.is_static {
        .check_method_call(func.orig, node)
    }

    if res.base == Closure {
        node.u.call.call_type = Closure
    }

    .check_call_args(node, params, func.is_variadic)

    let is_variadic_format = func.orig? and func.orig.is_variadic_format
    if is_variadic_format and args.size >= params.size {
        let args = node.u.call.args

        let param = params.back()
        let arg = args.at(params.size - 1).expr

        if not param.type.is_str() {
            .error(Error::new(
                func.orig.sym.span, "Variadic-format function must have last positional argument of type 'str'"
            ))
        }
        match arg.type {
            StringLiteral | FormatStringLiteral => {}

            // If the type is NOT a string, we should have errored already (variadic-format functions
            // check for this). However, if it IS a string, but not a string literal, then we want to
            // complain since printf-like functions require a string literal.
            else => if arg.etype == .get_type_by_name("str", arg.span) {
                .error(Error::new(
                    arg.span, "Expected a string literal for variadic-format function"
                ))
            }
        }

        // For variadic arguments, if they are enums we should call the dbg function on them
        for let i = params.size; i < args.size; i++ {
            let arg = args[i]
            .call_dbg_on_enum_value(&arg.expr)
        }
    }

    if func.orig? {
        node.u.call.is_function_pointer = false
        node.u.call.func = func.orig
    }

    return func.return_type
}

def TypeChecker::check_pointer_arith(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    let op = node.u.binary.op
    if op == Operator::Plus or op == Operator::Minus {
        if lhs.base == BaseType::Pointer and rhs.is_integer() {
            return lhs
        }
        if lhs.is_integer() and rhs.base == BaseType::Pointer {
            return rhs
        }
        if lhs.eq(rhs) and lhs.base == BaseType::Pointer {
            if op == Operator::Minus {
                return .get_base_type(BaseType::I64, node.span)
            }
        }
    }
    .error(Error::new(node.span, "Invalid pointer arithmetic"))
    return null
}

def TypeChecker::find_and_replace_overloaded_op(&this, op: Operator, node: &AST, arg1: &AST, arg2: &AST, arg3: &AST = null): &Type {
    if op.needs_lhs_pointer_for_overload() {
        // Auto-address for a value if it's not a pointer
        if arg1.is_lvalue() and arg1.etype.base != Pointer {
            arg1 = AST::new_unop(Address, arg1.span, arg1)
            if not .check_expression(arg1)? return null
        }
    }

    let overload: OperatorOverload
    overload.op = op
    if arg1? overload.type1 = arg1.etype
    if arg2? overload.type2 = arg2.etype
    if arg3? overload.type3 = arg3.etype
    let func = .o.program.operator_overloads.get(overload, defolt: null)
    if not func? return null

    let callee = AST::new(OverloadedOperator, node.u.binary.op_span)
    callee.u.operator_span = match node.type {
        BinaryOp => node.u.binary.op_span
        UnaryOp => node.u.unary.op_span
        else => node.span
    }
    .set_resolved_symbol(callee, func.sym)

    let args = Vector<&Argument>::new()
    if arg1? args.push(Argument::new(arg1))
    if arg2? args.push(Argument::new(arg2))
    if arg3? args.push(Argument::new(arg3))

    node.type = Call
    node.u.call.callee = callee
    node.u.call.args = args
    node.etype = func.return_type
    return func.return_type
}

def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    let op = node.u.binary.op
    let res = .find_and_replace_overloaded_op(op, node, node.u.binary.lhs, node.u.binary.rhs)
    if res? return res

    match op {
        Plus | Minus | Multiply | Divide => {
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                return .check_pointer_arith(node, lhs, rhs)

            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null

            } else if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else {
                return lhs
            }
        }
        PlusEquals | MinusEquals | DivideEquals | MultiplyEquals => {
            let lhs_node = node.u.binary.lhs
            if not lhs_node.is_lvalue() {
                .error(Error::new(node.span, "Left hand side of assignment must be assignable"))
                return null
            }
            if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            return lhs
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            lhs = lhs.unaliased()
            if not lhs.is_numeric_or_char() and lhs.base != BaseType::Pointer {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        Equals => {
            let is_invalid = if {
                not lhs.eq(rhs) => true
                lhs.base == Structure => true
                lhs.base == Enum => match lhs.u.enom.has_values {
                    true => {
                        .error(Error::new(node.span, f"Operator `{op}` does not support non-trivial enum `{lhs.str()}`"))
                        return .get_base_type(BaseType::Bool, node.span)
                    }
                    false => false
                }
                else => false
            }
            if is_invalid {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        NotEquals => {
            let is_invalid = if {
                not lhs.eq(rhs) => true
                lhs.base == Structure => true
                lhs.base == Enum and lhs.u.enom.has_values => true
                else => false
            }
            if is_invalid {
                // Try using the == operator and negating the result
                let res = .find_and_replace_overloaded_op(Equals, node, node.u.binary.lhs, node.u.binary.rhs)
                if {
                    res? => {
                        let copy = AST::new(UnaryOp, node.span)
                        *copy = *node
                        *node = *AST::new_unop(Not, node.span, copy)
                        .check_expression(node)
                    }
                    lhs.base == Enum => .error(Error::new(
                        node.span, f"Operator `{op}` does not support non-trivial enum `{lhs.str()}`"
                    ))
                    else => .error(Error::new(
                        node.span, f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                    ))
                }
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        And | Or => {
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        BitwiseXor => {
            if not lhs.eq(rhs) {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if lhs.base != BaseType::Bool and not lhs.is_integer() {
                .error(Error::new(node.span, "Operator requires integer types"))
            }
            return lhs
        }
        Modulus | BitwiseOr | BitwiseAnd | LeftShift | RightShift | LeftShiftEquals | RightShiftEquals => {
            if not lhs.is_integer() or not rhs.is_integer() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }

            let lhs_node = node.u.binary.lhs
            match op {
                LeftShiftEquals | RightShiftEquals => if not lhs_node.is_lvalue() {
                    .error(Error::new(lhs_node.span, f"Must be an l-value"))
                    return null
                },
                else => {}
            }

            return lhs
        }
        else => std::panic(`Internal error: unhandled op in check_binary_op: {node.type}`)
    }
}

enum Formattable {
    No        // Cannot be formatted
    NotHere   // Only in simple expressions
    Yes       // Yes
}

def TypeChecker::is_formattable(&this, typ: &Type, expr: &AST): Formattable {
    match typ.base {
        Bool | Char | I8 | I16 | I32 | I64 | U8 | U16 |
        U32 | U64 | F32 | F64 | Pointer => {}
        Enum => if {
            typ.u.enom.has_values => return No
            else => return Yes
        }
        else => {
            let can_format = false
            if typ.base == Structure {
                let struc = typ.u.struc
                if struc? and struc.format_spec? {
                    can_format = true
                }
            }

            if can_format {
                // These checks are to try to avoid side-effects when formatting our custom types. Eg:
                //      println(`{get_sv()}`)
                // would end up calling get_sv() twice when we generate:
                //      printf("%.*s", get_sv().len, get_sv().data).
                // These are just some heuristics to try to avoid that, but it's not perfect.
                match expr.type {
                    Identifier | Member | NSLookup => return Yes
                    else => return NotHere
                }

            } else {
                return No
            }
        }
    }
    return Yes
}

def TypeChecker::check_format_string(&this, node: &AST): &Type {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs

    if parts.size != exprs.size + 1 {
        .error(Error::new(node.span, "Number of format string parts does not match number of expressions"))
    }

    for let i = 0; i < exprs.size; i += 1 {
        let expr = exprs.at(i)
        let typ = .check_expression(expr)
        if not typ? continue

        typ = .call_dbg_on_enum_value(&expr)
        exprs.data[i] = expr

        if not typ? continue
        typ = typ.unaliased()

        match .is_formattable(typ, expr) {
            No => .error(Error::new(
                expr.span, `Type '{typ.str()}' cannot be formatted automatically`
            ))
            NotHere => .error(Error::new_note(
                expr.span, `Can only format {typ.sym.display} in simple expressions`,
                "Try moving the expression into a variable and formatting that instead"
            ))
            else => {}
        }

    }

    return .get_type_by_name("str", node.span)
}

def TypeChecker::check_member(&this, node: &AST,  is_being_called: bool, is_try: bool, hint: &Type = null): &Type {
    let lhs = .check_expression(node.u.member.lhs)
    if not lhs? return null

    if is_try {
        if not lhs.base == Pointer {
            .error(Error::new(node.u.member.lhs.span, "Cannot use ?. on non-pointer LHS"))
        }
    }

    // How would this work for strings?
    let is_pointer = false
    if lhs.base == BaseType::Pointer {
        is_pointer = true

        if not lhs.u.ptr? {
            .error(Error::new(lhs.span, "Got unresolved type"))
            return hint
        }
        lhs = lhs.u.ptr
    }

    // We've already error'd if this is the case, but for better LSP support,
    // we should try to look into the type here to get more information.
    if lhs.base == UnresolvedTemplate {
        lhs = lhs.u.unresolved_spec.base
    }

    let rhs_name = node.u.member.rhs_name
    if not rhs_name? return hint

    let member_sym = lhs.get_member(rhs_name)
    let res = hint

    if member_sym? and member_sym.type == Variable {
        res = member_sym.u.var.type
        if is_try and res.base != Pointer {
            .error(Error::new(node.u.member.lhs.span, f"Cannot use ?. with non-pointer member type {res.str()}"))
        }
    }

    if member_sym? and member_sym.type == Function {
        let func = member_sym.u.func
        if {
            is_try => .error(Error::new(node.u.member.lhs.span, f"Cannot call method with ?. on it: {func.sym.display}"))
            not is_being_called => .error(Error::new(node.u.member.lhs.span, f"Cannot access method without calling it"))
            func.is_static => .error(Error::new(node.u.member.lhs.span, f"Cannot call static method as instance method"))
            else => {
                res = func.type
            }
        }
    }

    node.u.member.is_pointer = is_pointer
    if member_sym? {
        .set_resolved_symbol(node, member_sym)
    } else {
        .error(Error::new(
            node.span, `Type {lhs.str()} has no member named '{rhs_name}'`
        ))
    }

    return res
}


// This is just here so we can use early exits in the actual check_expression
// function, and still always assign the type to the node's etype field
def TypeChecker::check_expression(&this, node: &AST, hint: &Type = null): &Type {
    if node.etype? return node.etype

    let typ = .check_expression_helper(node, hint)
    if typ? and node.type != ArrayLiteral then typ = typ.decay_array()
    node.etype = typ
    node.hint = if typ? then typ else hint
    return typ
}

def TypeChecker::check_index(&this, node: &AST, hint: &Type, is_being_assigned: bool): &Type {
    let lhs = .check_expression(node.u.binary.lhs)
    let rhs = .check_expression(node.u.binary.rhs)
    if not lhs? or not rhs? return null

    if not is_being_assigned {
        let res = .find_and_replace_overloaded_op(Index, node, node.u.binary.lhs, node.u.binary.rhs)
        if res? return res
    }

    rhs = rhs.unaliased()
    if not rhs.is_integer() {
        .error(Error::new(node.span, `Index must be an integer, got {rhs.str()}`))
        return null
    }
    lhs = lhs.unaliased()
    match lhs.base {
        BaseType::Array => return lhs.u.arr.elem_type
        BaseType::Pointer => return lhs.u.ptr
        else => {
            .error(Error::new(node.span, `Cannot index type {lhs.str()}`))
            return null
        }
    }
}

// FIXME: Merge this into `check_binary_op`, but we need to properly handle how we
//        overload IndexAssign operator; we have 3 operands for that instead of 2.
def TypeChecker::check_assignment(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    if not node.u.binary.lhs.is_lvalue() {
        .error(Error::new(node.u.binary.lhs.span, "Must be an l-value"))
    }
    if not lhs.can_assign(rhs) {
        .error(Error::new(
            node.u.binary.rhs.span, `Variable type does not match assignment type, Expected type '{lhs.str()}', got '{rhs.str()}'`
        ))
    }
    return lhs
}

enum ErrorPropBase {
    Result
    Option
}

def TypeChecker::create_match_for_error_unwrap(&this, node: &AST, expr: &AST, error_prop_base: ErrorPropBase): &AST {
    // FIXME: Just rewriting AST for match statement here - is there a better way?
    let op_span = node.u.unary.op_span

    let res_text = match error_prop_base {
        Result => {
            let err_type = expr.etype.template_instance.args.at(1)
            let panic_txt = match .is_formattable(err_type, expr) {
                Yes => f"Error unwrapping: \{err\} ({expr.span.end})"
                else => f"Error unwrapping ({expr.span.end})"
            }

            yield f"""
            match x \{
                Ok(val) => val,
                Error(err) => std::panic(`{panic_txt}`)
            \}
            """
        }
        Option => f"""
            match x \{
                Some(val) => val,
                None => std::panic(`Error unwrapping: None ({expr.span.end})`)
            \}
            """
    }

    let lexer = Lexer::make(res_text, op_span.start.filename)

    let tokens = lexer.lex()
    let parser = Parser::make(.o.program, .o.ns())
    parser.tokens = tokens
    parser.curr = 0

    let match_stmt = parser.parse_match()
    let visitor = Visitor(
        node_fn: |node: &AST| => node.span = op_span
    )
    visitor.visit_po(match_stmt)

    match_stmt.u.match_stmt.expr = expr
    return match_stmt
}

def TypeChecker::check_error_unwrap(&this, node: &AST): &Type {
    let expr = node.u.unary.expr
    let expr_typ = .check_expression(expr)

    if not expr_typ? return null

    // TODO: Come up with a generic way to allow multiple structs to support error unwrap
    let parent = expr_typ.template_instance?.parent
    let error_prop_base: ErrorPropBase = if {
        parent == .o.program.cached_symbols.std_result => Result
        parent == .o.program.cached_symbols.std_option => Option
        else => {
            .error(Error::new(node.span, f"Can only use !! on Result/Option types, got {expr_typ.str()}"))
            return null
        }
    }

    // For exhaustiveness check if we add other options
    let ok_hint = match error_prop_base {
        Result => expr_typ.template_instance.args.at(0)
        Option => expr_typ.template_instance.args.at(0)
    }

    let cur_func = .o.current_func()
    if not cur_func? {
        .error(Error::new(node.span, "Cannot use !! outside of a function"))
        return ok_hint
    }

    let match_stmt = .create_match_for_error_unwrap(node, expr, error_prop_base)
    let res = .check_expression(match_stmt, ok_hint)
    *node = *match_stmt

    return res
}

def TypeChecker::create_match_for_error_prop(&this, node: &AST, expr: &AST, error_prop_base: ErrorPropBase): &AST {
    // FIXME: Just rewriting AST for match statement here - is there a better way?
    let op_span = node.u.unary.op_span

    let res_text = match error_prop_base {
        Result => """
            match x {
                Ok(val) => val,
                Error(err) => { return Error(err) }
            }
            """
        Option => """
            match x {
                Some(val) => val,
                None => { return None }
            }
            """
    }
    let lexer = Lexer::make(res_text, op_span.start.filename)

    let tokens = lexer.lex()
    let parser = Parser::make(.o.program, .o.ns())
    parser.tokens = tokens
    parser.curr = 0

    let match_stmt = parser.parse_match()
    let visitor = Visitor(
        node_fn: |node: &AST| => node.span = op_span
    )
    visitor.visit_po(match_stmt)

    match_stmt.u.match_stmt.expr = expr
    return match_stmt
}

def TypeChecker::check_error_prop(&this, node: &AST): &Type {
    let expr = node.u.unary.expr
    let expr_typ = .check_expression(expr)

    if not expr_typ? return null
    let cur_func = .o.current_func()
    if not cur_func? {
        .error(Error::new(node.span, "Cannot use ! outside of a function"))
        return null
    }

    // TODO: Come up with a generic way to allow multiple structs to support error prop
    let parent = expr_typ.template_instance?.parent
    let error_prop_base: ErrorPropBase = if {
        parent == .o.program.cached_symbols.std_result => Result
        parent == .o.program.cached_symbols.std_option => Option
        else => {
            .error(Error::new(node.span, f"Can only use ! on Result/Option types, got {expr_typ.str()}"))
            return null
        }
    }

    // For exhaustiveness check if we add other options
    let ok_hint = match error_prop_base {
        Result => expr_typ.template_instance.args.at(0)
        Option => expr_typ.template_instance.args.at(0)
    }

    let ret_type = cur_func.return_type
    if ret_type?.template_instance?.parent != parent {
        .error(Error::new_hint(
            node.span, f"Cannot use ! here, expression is {expr_typ.str()} but function returns {ret_type.str()}",
            cur_func.parsed_return_type.span, f"Function returns {ret_type.str()}"
        ))
        return ok_hint
    }

    match error_prop_base {
        Result => {
            let expr_err_type = expr_typ.template_instance.args.at(1)
            let ret_err_type = ret_type.template_instance.args.at(1)
            if not expr_err_type.eq(ret_err_type) {
                .error(Error::new_hint(
                    node.span, f"Cannot propagate error type {expr_err_type.str()}, expected {ret_err_type.str()}",
                    cur_func.parsed_return_type.span, f"Function returns {ret_type.str()}"
                ))
                return ok_hint
            }
        }
        // Nothing to do here, all options can propagate None
        Option => {}
    }

    let match_stmt = .create_match_for_error_prop(node, expr, error_prop_base)
    let res = .check_expression(match_stmt, ok_hint)
    *node = *match_stmt

    return res
}

def TypeChecker::check_expression_helper(&this, node: &AST, hint: &Type): &Type {
    match node.type {
        ASTType::IntLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_integer() then return hint
            return .get_base_type(BaseType::U32, node.span)
        }
        ASTType::FloatLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_float() then return hint
            return .get_base_type(BaseType::F32, node.span)
        }
        ASTType::StringLiteral => {
            return .get_type_by_name("str", node.span)
        }
        ASTType::Null => {
            if hint? {
                match hint.base {
                    Pointer | FunctionPtr | Closure => return hint
                    else => {}
                }
            }

            return .get_type_by_name("untyped_ptr", node.span)
        }
        ASTType::Cast => {
            let typ = .check_expression(node.u.cast.lhs)
            if not typ? return null
            let target = .resolve_type(node.u.cast.to)
            if not target? return null
            node.u.cast.to = target
            // FIXME: Disallow invalid casts
            return target
        }
        ASTType::FormatStringLiteral => {
            return .check_format_string(node)
        }
        ASTType::CharLiteral => {
            return .get_base_type(BaseType::Char, node.span)
        }
        ASTType::BoolLiteral => {
            return .get_base_type(BaseType::Bool, node.span)
        }
        ASTType::UnaryOp => match node.u.unary.op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                let lhs = .check_expression(node.u.unary.expr)
                if not lhs? return null
                if not lhs.is_integer() and lhs.base != Pointer {
                    .error(Error::new(node.span, `Cannot increment or decrement non-integer type: {lhs.str()}`))
                    return null
                }
                if not node.u.unary.expr.is_lvalue() {
                    .error(Error::new(node.span, `Can't perform {node.u.unary.op} on a non-lvalue`))
                }
                return lhs
            }
            Negate => {
                if not (hint? and hint.is_numeric()) {
                    hint = .get_base_type(BaseType::I32, node.span)
                }
                let typ = .check_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_numeric() {
                    .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                    return null
                }
                return typ
            }
            BitwiseNot => {
                let typ = .check_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_integer() {
                    .error(Error::new(node.span, `Cannot do bitwise-not on non-integer type: {typ.str()}`))
                    return null
                }
                return typ
            }
            IsNotNull => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null
                typ = typ.unaliased()
                match typ.base {
                    Pointer | FunctionPtr | Closure => {}
                    else => {
                        .error(Error::new(node.span, `Can only use ? on pointer types, got {typ.str()}`))
                        return null
                    }
                }
                return .get_base_type(BaseType::Bool, node.span)
            }
            Not => {
                let typ = .check_expression(node.u.unary.expr, hint: .get_base_type(BaseType::Bool, node.span))
                if not typ? return null
                if typ.base != BaseType::Bool {
                    .error(Error::new(node.span, `Cannot negate non-boolean type: {typ.str()}`))
                    return null
                }
                return typ
            }
            Address => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null

                match typ.base {
                    BaseType::Char => return .get_type_by_name("str", node.span)
                    BaseType::Void => return .get_type_by_name("untyped_ptr", node.span)
                    else => {
                        let ptr = Type::new_resolved(BaseType::Pointer, node.span)
                        ptr.u.ptr = typ
                        return ptr
                    }
                }
            }
            Dereference => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null
                if typ.base != BaseType::Pointer {
                    .error(Error::new(node.span, `Cannot dereference non-pointer type: {typ.str()}`))
                    return null
                }
                return typ.u.ptr
            }
            ErrorProp => return .check_error_prop(node)
            ErrorUnwrap => return .check_error_unwrap(node)
            else => {
                .error(Error::new(node.span, `Unknown unary operator in check_expression: {node.u.unary.op}`))
                return null
            }
        }

        ASTType::Member => return .check_member(node, is_being_called: false, is_try: false, hint)
        ASTType::TryMember => return .check_member(node, is_being_called: false, is_try: true, hint)
        ASTType::SizeOf => {
            let typ = .resolve_type(node.u.size_of_type)
            if not typ? return null
            node.u.size_of_type = typ
            return .get_base_type(BaseType::U32, node.span)
        }
        ASTType::If => {
            .check_if(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Block => {
            .check_block(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Match => {
            .check_match(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Identifier | ASTType::NSLookup | ASTType::Specialization => {
            let item = .resolve_scoped_identifier(node, error: true, hint)
            if not item? return null

            item = item.remove_alias()
            match item.type {
                Function => return item.u.func.type
                Variable | Constant => return item.u.var.type
                ClosedVariable => return item.u.closed_var.orig.type
                EnumVariant => {
                    let variant = item.u.enum_var
                    if variant.num_fields() != 0 {
                        .error(Error::new(node.span, f"{item.display} needs {variant.num_fields()} fields to construct"))
                    }
                    return variant.parent.type
                }
                TypeDef => {
                    // This is just for a nicer error message
                    .error(Error::new(node.span, f"Cannot use type `{item.name}` as an expression"))
                    return null
                }
                Structure | Namespace | Enum => {
                    .error(Error::new(node.span, f"Cannot use {item.type} `{item.name}` as an expression"))
                    return null
                }
                else => {
                    .error(Error::new(node.span, f"Should not get {item.type} `{item.name}` as an expression"))
                    return null
                }
            }
        }
        ASTType::Call => return .check_call(node, hint)

        // Binary operators
        BinaryOp => {
            let lhs_node = node.u.binary.lhs
            let rhs_node = node.u.binary.rhs
            let op = node.u.binary.op
            match op {
                Plus |
                Minus |
                Multiply |
                Divide |
                LessThan |
                LessThanEquals |
                GreaterThan |
                GreaterThanEquals |
                NotEquals |
                PlusEquals |
                MinusEquals |
                MultiplyEquals |
                DivideEquals |
                And |
                Or |
                Modulus |
                BitwiseOr |
                BitwiseAnd |
                BitwiseXor |
                LeftShiftEquals |
                RightShiftEquals |
                LeftShift |
                RightShift => {
                    let lhs = .check_expression(lhs_node, hint: hint)
                    let rhs = .check_expression(rhs_node, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
                }
                // We want to special-case this for value-enums. Basically, we want
                // to allow matching against **only** the tag of the enum, and not unpacking
                // the values. The RHS here needs to be checked manually.
                Equals => {
                    let lhs = .check_expression(lhs_node, hint: hint)
                    if not lhs? or lhs.base != Enum or not lhs.u.enom.has_values {
                        // Fall back to the normal binary op check
                        let rhs = .check_expression(rhs_node, hint: lhs)
                        if not lhs? or not rhs? return .get_base_type(Bool, node.span)
                        return .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
                    }

                    // OK, so lhs is a value enum. RHS must be some sort of scoped identifier,
                    // since we only allow naming the fully scoped enum variant.
                    match rhs_node.type {
                        Identifier | NSLookup | Specialization => {}
                        Call => {
                            let call = rhs_node.u.call
                            let args_span = call.open_paren_span + call.close_paren_span
                            .error(Error::new(args_span, f"Can only compare against the variant name here, remove this"))
                            .check_expression(rhs_node, hint: lhs)
                            return .get_base_type(Bool, node.span)
                        }
                        else => {
                            .error(Error::new(rhs_node.span, f"Expected explicit enum variant, got: {rhs_node.type}"))
                            .check_expression(rhs_node, hint: lhs)
                            return .get_base_type(Bool, node.span)
                        }
                    }

                    let rhs_sym = .resolve_scoped_identifier(rhs_node, error: true, hint: lhs)
                    if not rhs_sym? return .get_base_type(Bool, node.span)

                    if {
                        rhs_sym.type != EnumVariant => {
                            .error(Error::new(rhs_node.span, f"Expected enum variant, got: {rhs_sym.type}"))
                            return .get_base_type(Bool, node.span)
                        }
                        not rhs_sym.u.enum_var?.parent?.type.eq(lhs) => {
                            .error(Error::new(rhs_node.span, f"Expected enum variant of type {lhs.str()}, got: {rhs_sym.u.enum_var.parent.type.str()}"))
                            return .get_base_type(Bool, node.span)
                        }
                    }

                    node.u.binary.op = EqualsValueEnumVariant
                    return .get_base_type(Bool, node.span)
                }
                In => {
                    // Swap the order of the operands for the potential overload
                    let lhs = .check_expression(node.u.binary.lhs)
                    let rhs = .check_expression(node.u.binary.rhs)
                    if not lhs? or not rhs? return .get_base_type(Bool, node.span)
                    .find_and_replace_overloaded_op(In, node, node.u.binary.rhs, node.u.binary.lhs)
                    return .get_base_type(Bool, node.span)
                }
                Index => return .check_index(node, hint, is_being_assigned: false)
                Assignment => {
                    let lhs = .check_expression(node.u.binary.lhs)
                    let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_assignment(node, lhs, rhs)
                }
                IndexAssign => {
                    // We need to handle this operator overload carefully - since if we naively check the LHS
                    // and RHS, we might end up replacing the LHS with the overloaded function for `[]`.
                    // eg:     `a[x] = y` => `a_get(a, x) = y`
                    // which is bad.
                    let index = node.u.binary.lhs
                    let arg1 = index.u.binary.lhs
                    let arg2 = index.u.binary.rhs
                    let arg3 = node.u.binary.rhs
                    if not .check_expression(arg1)? return null
                    if not .check_expression(arg2)? return null

                    // Infer the type for the assigned value (in case it's a pointer to an array)
                    let arg3_hint: &Type = null
                    let arg1_typ = arg1.etype.unaliased()
                    if arg1_typ.base == BaseType::Pointer {
                        arg3_hint = arg1_typ.u.ptr
                    }

                    if not .check_expression(arg3, hint: arg3_hint)? return null

                    let res = .find_and_replace_overloaded_op(IndexAssign, node, arg1, arg2, arg3)
                    if res? return res

                    let lhs = .check_index(index, hint: null, is_being_assigned: true)
                    let rhs = .check_expression(arg3, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_assignment(node, lhs, rhs)
                }
                else => std::panic(`Internal error: unhandled op in check_expression binary_op: {node.u.binary.op}`)
            }
        }
        MapLiteral => {
            if (not .o.program.did_cache_symbols or
                not .o.program.cached_symbols.std_map?) {
                // This shouldn't happen since we should be auto-importing it and setting
                // up the binding if we can find it.
                .error(Error::new(node.span, "Could not find std::compact_map, please import it."))
            }
            let std_map = .o.program.cached_symbols.std_map

            let key_hint_type: &Type = null
            let value_hint_type: &Type = null
            if hint? and hint.base == Pointer {
                let ptr = hint.u.ptr
                if (ptr? and
                    ptr.template_instance? and
                    ptr.template_instance.parent == std_map
                ) {
                    assert ptr.template_instance.args.size == 2
                    key_hint_type = ptr.template_instance.args[0]
                    value_hint_type = ptr.template_instance.args[1]
                }
            }

            let key_type: &Type = null
            let value_type: &Type = null

            let first_key_span = Span::default()
            let first_value_span = Span::default()

            let elements = node.u.map_literal.elements
            for elem in elements.iter() {
                let key = .check_expression(elem.key, hint: key_hint_type)
                let value = .check_expression(elem.value, hint: value_hint_type)


                if not key_type? {
                    key_type = key
                    value_type = value
                    // After the first element, we can use the type of the first element as the hint
                    key_hint_type = key_type
                    value_hint_type = value_type
                    first_key_span = elem.key.span
                    first_value_span = elem.value.span

                } else {
                    if key? and not key.eq(key_type) {
                        .error(Error::new_hint(
                            elem.key.span, `Expected type {key_type.str()}, but got {key.str()}`,
                            first_key_span, `First key was of type {key_type.str()}`
                        ))
                    }
                    if value? and not value.eq(value_type) {
                        .error(Error::new_hint(
                            elem.value.span, `Expected type {value_type.str()}, but got {value.str()}`,
                            first_value_span, `First value was of type {value_type.str()}`
                        ))
                    }
                }
            }
            if elements.size == 0 {
                key_type = key_hint_type
                value_type = value_hint_type
            }
            if not (key_type? and value_type?) {
                .error(Error::new(node.span, "Can't infer type of Map literal"))
                return null
            }

            // We can no longer do anything if std_vector was not resolved. Exit.
            if not std_map? return null

            let res = .resolve_templated_symbol(std_map, $[key_type, value_type], node.span)
            if not res? or res.type != Structure {
                .error(Error::new(node.span, "Internal error: Failed to resolve std::compact_map specialization"))
                return null
            }
            node.u.map_literal.map_struc = res.u.struc
            node.u.map_literal.map_type = res.u.struc.type

            let ptr_type = Type::new_resolved(Pointer, node.span)
            ptr_type.u.ptr = res.u.struc.type
            return ptr_type
        }
        VectorLiteral => {
            if (not .o.program.did_cache_symbols or
                not .o.program.cached_symbols.std_vector?) {
                // This shouldn't happen since we should be auto-importing it and setting
                // up the binding if we can find it.
                .error(Error::new(node.span, "Could not find std::vector, please import it."))
            }
            let std_vector = .o.program.cached_symbols.std_vector

            let hint_elem_type: &Type = null
            if hint? and hint.base == Pointer {
                let ptr = hint.u.ptr
                if (ptr? and
                    ptr.template_instance? and
                    ptr.template_instance.parent == std_vector
                ) {
                    assert ptr.template_instance.args.size == 1
                    hint_elem_type = ptr.template_instance.args[0]
                }
            }

            let elem_type: &Type = null
            let first_span = Span::default()

            let elements = node.u.vec_literal.elements
            for elem in elements.iter() {
                let typ = .check_expression(elem, hint: hint_elem_type)
                if not typ? continue

                if not elem_type? {
                    elem_type = typ
                    // After the first element, we can use the type of the first element as the hint
                    hint_elem_type = elem_type
                    first_span = elem.span

                } else if not elem_type.can_assign(typ) {
                    .error(Error::new_hint(
                        elem.span, `Expected type {elem_type.str()}, but got {typ.str()}`,
                        first_span, `First element was of type {elem_type.str()}`
                    ))
                    return null
                }
            }
            if elements.size == 0 {
                elem_type = hint_elem_type
            }
            if not elem_type? {
                .error(Error::new(node.span, "Can't infer type of Vector literal"))
                return null
            }

            // We can no longer do anything if std_vector was not resolved. Exit.
            if not std_vector? return null

            let vec_sym = std_vector
            let template_args = Vector<&Type>::new()
            template_args.push(elem_type)

            let res = .resolve_templated_symbol(vec_sym, template_args, node.span)
            if not res? or res.type != Structure {
                .error(Error::new(node.span, "Internal error: Failed to resolve std::vector specialization"))
                return null
            }
            node.u.vec_literal.vec_struc = res.u.struc
            node.u.vec_literal.vec_type = res.u.struc.type

            let ptr_type = Type::new_resolved(Pointer, node.span)
            ptr_type.u.ptr = res.u.struc.type
            return ptr_type
        }
        ArrayLiteral => {
            let hint_elem_type: &Type = null
            if hint? and hint.base == BaseType::Array {
                hint_elem_type = hint.u.arr.elem_type
            }

            let elem_type: &Type = null
            let first_span = Span::default()
            for elem in node.u.array_literal.elements.iter() {
                let typ = .check_expression(elem, hint_elem_type)
                if not typ? continue

                if not elem_type? {
                    elem_type = typ
                    // After the first element, we can use the type of the first element as the hint
                    hint_elem_type = elem_type
                    first_span = elem.span

                } else if not elem_type.can_assign(typ) {
                    .error(Error::new_hint(
                        elem.span, `Expected type {elem_type.str()}, but got {typ.str()}`,
                        first_span, `First element was of type {elem_type.str()}`
                    ))
                    return null
                }
            }
            if not elem_type? {
                .error(Error::new(node.span, "Array literal must have at least one element"))
                return null
            }
            let arr = Type::new_resolved(Array, node.span)
            arr.u.arr.elem_type = elem_type
            arr.u.arr.size_known = true
            arr.u.arr.size = node.u.array_literal.elements.size
            return arr
        }
        ASTType::CreateNew => {
            if not .o.program.did_cache_symbols {
                .error(Error::new(node.span, "Cannot use `@new` without using stdlib"))
            }

            let hint_type = if {
                hint? and hint.base == BaseType::Pointer => hint.u.ptr
                else => null
            }

            let child_typ = .check_expression(node.u.child, hint: hint_type)
            if not child_typ? return null

            if child_typ.base == Pointer {
                // FIXME: Should we allow this?
                .error(Error::new(node.span, "Cannot use `@new` on a pointer type"))
            }

            let typ = Type::new_resolved(Pointer, node.span)
            typ.u.ptr = child_typ
            return typ
        }
        ASTType::CreateClosure => {
            let clos = node.u.closure
            clos.scope = .o.ns().scope

            clos.closure_scope = .o.scope()
            clos.closed_vars = Map<str, &Symbol>::new()

            let hint_matches = if {
                not hint? => false
                hint.base != Closure => false
                hint.u.func.params.size != clos.params.size => false
                else => true
            }

            if hint_matches {
                let hfunc = hint.u.func
                for let i = 0; i < clos.params.size; i += 1 {
                    let param = clos.params[i]
                    let hint_type = hfunc.params[i].type
                    let param_type = if {
                        param.type? => param.type
                        else => hint_type
                    }
                    param.type = param_type
                }

                let hint_ret_type = hfunc.return_type
                let clos_ret_type = if {
                    clos.return_type? => clos.return_type
                    else => hint_ret_type
                }
                clos.return_type = clos_ret_type
            } else {
                for param in clos.params.iter() {
                    if not param.type? {
                        .error(Error::new(param.sym.span, "Cannot infer type, specify it explicitly"))
                    }
                }
            }
            if not clos.return_type? {
                clos.return_type = .get_base_type(BaseType::Void, node.span)
            }

            .check_function_declaration(clos)
            .check_function(clos)
            return clos.type
        }
        Error => {
            return hint
        }
        Is => {
            .error(Error::new(node.span, "Can only use `is` inside an if statement condition. Use `==` for standalone enum comparison"))
            return .get_base_type(BaseType::Bool, node.span)
        }
        else => {
            .error(Error::new(node.span, f"Invalid expression in TypeChecker::check_expression: {node.type}"))
            return null
        }
    }
}

// When passing an enum to `print` or to a format string, we will automatically call
// the `.dbg()` method we generate on them.
def TypeChecker::call_dbg_on_enum_value(&this, node_ptr: &&AST): &Type {
    let node: &AST = *node_ptr

    if not node.etype? return null
    match node.etype.base {
        Enum => {}
        else => return node.etype
    }

    let member = AST::new(ASTType::Member, node.span)
    member.u.member.lhs = node
    member.u.member.rhs_name = "dbg"
    member.u.member.rhs_span = node.span

    let call = AST::new(ASTType::Call, node.span)
    call.u.call.callee = member
    call.u.call.args = Vector<&Argument>::new()

    *node_ptr = call

    return .check_expression(call)
}

def TypeChecker::check_match_case_enum(
    &this,
    lhs_node: &AST,
    enom_type: &Type,
    conds: $[&MatchCond],
    mapping: &Map<str, &MatchCond>,
    current_args: &Map<str, &Type>  // This is just a cache to avoid excessive allocations
) {
    assert enom_type.base == Enum
    let enom = enom_type.u.enom

    current_args.clear()
    for let i = 0; i < conds.size; i++ {
        let cond = conds[i]
        let name: str

        let expr = cond.expr
        expr.hint = enom_type
        match expr.type {
            Identifier | NSLookup | Specialization => {}
            else => {
                .error(Error::new(expr.span, f"Expected value enum variant, got {expr.type}"))
                continue
            }
        }

        let resolved_sym = .resolve_scoped_identifier(expr, error: true, hint: enom_type)
        if not resolved_sym? continue
        if resolved_sym.type != EnumVariant {
            .error(Error::new(
                expr.span, f"Expected value enum variant, got {resolved_sym.type} ({resolved_sym.display})",
            ))
            continue
        }
        let variant = resolved_sym.u.enum_var

        if variant.parent != enom {
            .error(Error::new_hint(
                expr.span, "Condition does not match expression type",
                lhs_node.span, `Match expression is of type '{enom.type.str()}'`
            ))
        }
        expr.etype = enom_type

        let args = cond.args

        // Populate the current_args map with the fields of the first variant
        if i == 0 {
            if args? {
                for let j = 0; j < args.size; j += 1 {
                    let arg = args[j]


                    // TODO: Allow binding name to be different from variable name in scope
                    // TODO: Maybe use a map inside enum to save the linear lookups in get_*_field

                    let sp_field = variant.get_specific_field(arg.var.sym.name)
                    let sh_field = enom.get_shared_field(arg.var.sym.name)
                    let field = if {
                        sp_field? => sp_field
                        sh_field? => {
                            arg.is_shared = true
                            yield sh_field
                        }
                        else => {
                            .error(Error::new(
                                arg.var.sym.span, f"Field `{arg.var.sym.name}` does not exist in enum variant {variant.sym.display}"
                            ))
                            yield null
                        }
                    }
                    if field? {
                        arg.var.type = field.type
                        current_args[arg.var.sym.name] = field.type
                    }
                }
            }

        // For the rest, check that the fields match the first variant
        } else {

            let found_args = 0
            for let j = 0; args? and j < args.size; j += 1 {
                let arg = args[j]

                // TODO: Maybe use a map inside enum to save the linear lookups in get_*_field
                let sp_field = variant.get_specific_field(arg.var.sym.name)
                let sh_field = enom.get_shared_field(arg.var.sym.name)
                let field = if {
                    sp_field? => sp_field
                    sh_field? => {
                        arg.is_shared = true
                        yield sh_field
                    }
                    else => {
                        .error(Error::new(
                            arg.var.sym.span, "Field does not exist in enum variant"
                        ))
                        yield null
                    }
                }


                if field? {
                    arg.var.type = field.type
                }

                let item = current_args.get_item(arg.var.sym.name)
                if not item? {
                    .error(Error::new(
                        arg.var.sym.span, "All conditions in this branch must have the same fields"
                    ))
                    continue
                }

                found_args += 1
                if field? and not item.value.eq(field.type) {
                    .error(Error::new(
                        arg.var.sym.span, f"Field type does not match previous branch: {item.value.str()}"
                    ))
                    continue
                }
            }
            if found_args != current_args.size {
                .error(Error::new(
                    expr.span, "All conditions in this branch must have the same fields"
                ))
            }
        }

        name = expr.resolved_symbol.name
        let prev = mapping.get(name, null)
        if prev? {
            .error(Error::new_hint(
                expr.span, "Duplicate condition name in match",
                prev.expr.span, "This condition was previously used here"
            ))
        }
        mapping.insert(name, cond)
    }
}

def TypeChecker::check_match_for_enum(&this, enom: &Enum, node: &AST, is_expr: bool, hint: &Type = null) {
    let mapping = Map<str, &MatchCond>::new()
    defer mapping.free()

    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)


    let current_args = Map<str, &Type>::new()
    for _case in cases.iter() {
        let conds = _case.conds

        .check_match_case_enum(
            lhs_node: node.u.match_stmt.expr,
            enom_type: enom.type,
            conds,
            mapping,
            current_args
        )

        if _case.body? {
            .o.push_scope(Scope::new(.o.scope()))
            for arg in current_args.iter() {
                let var = Variable::new(arg.value)
                var.sym = Symbol::from_local_variable(arg.key, var, arg.value.span)
                .o.insert_into_scope_checked(var.sym)
            }

            .check_expression_statement(node,  _case.body, is_expr, hint)
            .o.pop_scope()
        }
    }

    let defolt = node.u.match_stmt.defolt
    if mapping.size != enom.variants.size {
        let buf = Buffer::make()
        buf += "Remaining fields: "
        let first = true
        for variant in enom.variants.iter() {
            if not mapping.contains(variant.sym.name) {
                if not first then buf += " | "
                buf += variant.sym.name
                first = false
            }
        }
        if not defolt? {
            .error(Error::new_note(
                node.u.match_stmt.expr.span, f"Match does not cover all cases (Only {mapping.size} of {enom.variants.size})",
                buf.str()
            ))
        } else {
            .check_expression_statement(node, defolt, is_expr, hint)
        }
    } else {
        if defolt? {
            .error(Error::new(node.u.match_stmt.defolt_span, "`else` case is not needed for this match"))
        }
    }

    if is_expr and not node.etype? {
        .error(Error::new(node.u.match_stmt.match_span, "Expression-match must yield a value"))
    }
}

//! Special case for handling a case where we match against a boolean
def TypeChecker::check_match_for_bool(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let match_stmt = &node.u.match_stmt
    if match_stmt.cases.size != 2 or match_stmt.defolt? {
        .error(Error::new(match_stmt.match_span, "Match for bool must have exactly `true` and `false` cases"))
    }

    let seen_true = false
    let seen_false = false
    node.returns = true  // NOTE: `check_expression_statement` will modify this

    for _case in match_stmt.cases.iter() {
        for cond in _case.conds.iter() {
            let expr = cond.expr
            .check_expression(expr)
            if expr.type != ASTType::BoolLiteral {
                .error(Error::new(expr.span, "Expected either `true` or `false`"))
            } else {
                if expr.u.bool_literal {
                    seen_true = true
                } else {
                    seen_false = true
                }
            }
        }
        if _case.body? {
            .check_expression_statement(node,  _case.body, is_expr, hint)

        } else {
            .error(Error::new(node.span, "Case must have a body"))
        }
    }

    if not seen_true then .error(Error::new(match_stmt.match_span, "Missing `true` case"))
    if not seen_false then .error(Error::new(match_stmt.match_span, "Missing `false` case"))

    if is_expr and not node.etype? {
        .error(Error::new(match_stmt.match_span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_match_case_and_find_overload(&this, expr: &AST, cond: &MatchCond): &Function {
    let lhs = expr.etype
    let rhs = cond.expr.etype

    if lhs.eq(rhs) {
        if lhs.is_numeric_or_char() return null
        if lhs.base == Bool return null
        // Fallback to custom overloads...
    }

    let overload: OperatorOverload
    overload.op = Equals
    overload.type1 = lhs
    overload.type2 = rhs
    let func = .o.program.operator_overloads.get(overload, defolt: null)
    if not func? {
        .error(Error::new_hint(
            cond.expr.span, f"Cannot match {lhs.str()} with this case: {rhs.str()}",
            expr.span, f"Match expression is of type {lhs.str()}"
        ))
        return null
    }

    let ret = func.return_type.unaliased()
    if ret.base != Bool {
        .error(Error::new_hint(
            cond.expr.span, f"Overload {func.sym.display} must return a boolean",
            func.sym.span, f"Defined here, return type is {ret.str()}"
        ))
        return null
    }

    cond.cmp_fn = func
    return func
}


def TypeChecker::check_match(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let match_stmt = &node.u.match_stmt
    let expr = match_stmt.expr
    let expr_type = .check_expression(expr)
    if not expr_type? {
        .error(Error::new(match_stmt.match_span, "Match statement must have a valid expression"))
        return
    }

    let match_scope = Scope::new(.o.scope())
    match_scope.is_for_match = true
    .o.push_scope(match_scope)
    defer .o.pop_scope()

    match expr_type.base {
        Enum => {
            .check_match_for_enum(expr_type.u.enom, node, is_expr, hint)
            return
        }
        Bool => {
            .check_match_for_bool(node, is_expr, hint)
            return
        }
        else => {}
    }

    let cases = match_stmt.cases
    node.returns = (cases.size > 0)

    for _case in cases.iter() {
        for cond in _case.conds.iter() {
            let cond_expr = cond.expr
            let cond_type = .check_expression(cond_expr, hint: expr_type)
            if not cond_type? then continue

            let cmp_fn = .check_match_case_and_find_overload(expr, cond)
            if cmp_fn? {
                match_stmt.is_custom_match = true

            } else {
                let is_constant = cond_expr.resolved_symbol? and cond_expr.resolved_symbol.type == Constant

                if cond_expr.type != ASTType::IntLiteral and
                    cond_expr.type != ASTType::CharLiteral and not is_constant {
                    .error(Error::new(cond_expr.span, "Match condition must use only literals"))
                }
            }
        }

        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt

    if not defolt? {
        .error(Error::new(node.u.match_stmt.match_span, "`else` case is missing"))
    } else {
        .check_expression_statement(node, defolt, is_expr, hint)
    }

    if is_expr and not node.etype? and not node.returns {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_is_expr_in_if_condition(&this, cond: &AST) {
    assert cond.type == Is, `Expected 'Is' node, got '{cond.type}'`

    let is_expr = &cond.u.is_expr
    let lhs = .check_expression(is_expr.lhs)

    let mapping = Map<str, &MatchCond>::new()
    defer mapping.free()

    let current_args = Map<str, &Type>::new()
    defer current_args.free()

    .check_match_case_enum(
        lhs_node: is_expr.lhs,
        enom_type: lhs,
        conds: is_expr.conds,
        mapping,
        current_args
    )

    for arg in current_args.iter() {
        let var = Variable::new(arg.value)
        var.sym = Symbol::from_local_variable(arg.key, var, arg.value.span)
        .o.insert_into_scope_checked(var.sym)
    }
}

def TypeChecker::check_if(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    // NOTE: `check_expression_statement` will modify this
    node.returns = true

    let branches = node.u.if_stmt.branches
    let num_is_expr = 0
    let bad_span = Span::default()

    for branch in branches.iter() {
        match branch.cond.type {
            Is => {
                let scope = Scope::new(.scope())
                scope.is_for_match = true  // This will be codegen'd as a match
                .o.push_scope(scope)

                // NOTE: The return type of this is always bool
                .check_is_expr_in_if_condition(branch.cond)
                .check_expression_statement(node, branch.body, is_expr, hint)
                .o.pop_scope()
                num_is_expr++
            }
            else => {
                let cond_type = .check_expression(branch.cond, hint: .get_base_type(BaseType::Bool, node.span))
                if cond_type? and cond_type.base != BaseType::Bool {
                    .error(Error::new_note(
                        branch.cond.span, "Condition must be a boolean",
                        `Got type '{cond_type.str()}'`
                    ))
                }
                .check_expression_statement(node, branch.body, is_expr, hint)
            }
        }
    }

    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_expression_statement(node, else_stmt, is_expr, hint)

    } else if is_expr {
        .error(Error::new(
            node.u.if_stmt.if_span,
            "If expressions must have an else branch"
        ))

    } else {
        node.returns = false
    }
}

def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool, hint: &Type) {
    match body.type {
        // If this is an expression-statement, a non-block should also be an expression
        ASTType::Match => .check_match(body, is_expr, hint)
        ASTType::If => .check_if(body, is_expr, hint)

        ASTType::Block => .check_block(body, is_expr, hint)
        else => {
            if is_expr {
                .check_expression(body, hint)
            } else {
                .check_statement(body)
            }
        }
    }

    node.returns = node.returns and body.returns

    if not is_expr return

    // For now, we'll allow expression statements to early-return from the function.
    // Maybe this should be disallowed?

    let ret = body.etype
    if body.returns {
        // Do nothing
    } else if not ret? {
        let start_span = Span(body.span.start, body.span.start)
        .error(Error::new(start_span, `Must yield a value in this branch, body type is {body.type}`))
    } else if not node.etype? {
        node.etype = ret
    } else if not  ret.can_assign(node.etype) {
        let yield_stmt = if node.type == Block then node.u.block.final_stmt else body
        if not yield_stmt? yield_stmt = body
        .error(Error::new_note(
            yield_stmt.display_span(), "Yield type of branch doesn't match previous branches",
            `Expected type '{node.etype.str()}', got '{ret.str()}'`
        ))
    }
}


def TypeChecker::check_while(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1
    scope.parent_loop = node

    .o.push_scope(scope)
    let cond = node.u.loop.cond
    let body = node.u.loop.body

    let cond_type = .check_expression(cond, hint: .get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(body)
    .o.pop_scope()
}

def TypeChecker::check_for(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1
    scope.parent_loop = node
    .o.push_scope(scope)

    let init = node.u.loop.init
    let cond = node.u.loop.cond
    let step = node.u.loop.step
    let body = node.u.loop.body

    if init? then .check_statement(init)

    if cond? {
        let cond_type = .check_expression(cond, hint: .get_base_type(BaseType::Bool, node.span))
        if cond_type? and cond_type.base != BaseType::Bool {
            .error(Error::new_note(
                cond.span, "Condition must be a boolean",
                `Got type '{cond_type.str()}'`
            ))
        }
    }

    if step? then .check_expression(step)
    if body? then .check_statement(body)

    .o.pop_scope()
}

def TypeChecker::check_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return => {
            let cur_func = .scope().cur_func
            if not cur_func? {
                .error(Error::new(node.span, "Cannot return from outside a function"))
                return
            }

            let expected = cur_func.return_type

            let res: &Type = null
            let child = node.u.ret.expr
            let ret_span = node.u.ret.return_span
            if child? then res = .check_expression(child, hint: expected)

            if child? and child.returns {
                // No need to check anything

            } else if expected.base == BaseType::Void {
                // We allow using arrow returns in void functions, they just don't return anything.
                if node.u.child? {
                    .error(Error::new(ret_span, "Cannot return a value from a void function"))
                }
            } else if child? {
                if res? and not expected.can_assign(res) {
                    .error(Error::new(ret_span, `Return type {res.str()} does not match function return type {expected.str()}`))
                }
            } else {
                .error(Error::new(ret_span, "Expected a return value for non-void function"))
            }
            node.returns = true
        }
        ASTType::Assert => {
            let expr = node.u.assertion.expr
            let expr_typ = .check_expression(expr, hint: .get_base_type(BaseType::Bool, node.span))
            if expr_typ? and expr_typ.base != BaseType::Bool {
                .error(Error::new(node.span, `Can only assert boolean types, got {expr_typ.str()}`))
            }

            if node.u.assertion.msg? {
                let msg_typ = .check_expression(node.u.assertion.msg)
                if msg_typ? and msg_typ != .get_type_by_name("str", node.span) {
                    .error(Error::new(node.span, `Can only assert strings, got {msg_typ.str()}`))
                }
            }

            if expr.type == ASTType::BoolLiteral and expr.u.bool_literal == false {
                node.returns = true
            }
        }
        ASTType::Defer => .check_statement(node.u.child)
        ASTType::Yield => {
            if not .scope().can_yield {
                .error(Error::new(node.span, "Cannot yield here"))
            }
            node.etype = .check_expression(node.u.child)
        }
        ASTType::Import => {
            .handle_import_statement(node)
        }
        // TODO: Now that we have support for labelled break statements in C codegen,
        //       add support for `break N;` to break out of N loops.
        ASTType::Break | ASTType::Continue => {
            if .scope().loop_count == 0 {
                .error(Error::new(node.span, `{node.type} statement outside of loop`))
            }
            // FIXME: Handling the `break` from inside a match here is a little hacky.
            //        We need to do this purely because we codegen to C, and in there
            //        the `break` applies to the switch.
            //        A better place for this logic is probably in codegen since that
            //        should be the only place concerned with C-isms.
            let target_loop: &AST = null
            let needs_goto_break = false
            for let scope = .o.scope(); scope?; scope = scope.parent {
                if scope.parent_loop? {
                    target_loop = scope.parent_loop
                    break
                }
                if scope.is_for_match and node.type == Break {
                    needs_goto_break = true
                }
            }
            if not target_loop? {
                .error(Error::new(node.span, "Internal error: Could not find loop for break/continue"))
            } else {
                node.u.target_loop = target_loop
                target_loop.u.loop.needs_goto_break = needs_goto_break
            }
        }
        ASTType::If => .check_if(node, is_expr: false)
        ASTType::While => .check_while(node)
        ASTType::For => .check_for(node)
        ASTType::Block => .check_block(node, is_expr: false)
        ASTType::Match => .check_match(node, is_expr: false)
        ASTType::VarDeclaration => {
            let var = node.u.var_decl
            let res = .scope().lookup_local(var.sym.name)
            if res? {
                .error(Error::new(node.span, `Variable {var.sym.name} already exists in this scope`))
                return
            }

            let sym = var.sym
            .scope().insert(var.sym.name, sym)

            let is_inferred = (var.type == null)
            if is_inferred {
                var.type = Type::new_unresolved("<inferred>", node.span)

            } else {
                var.type = .resolve_type(var.type)
                if not var.type? return
            }

            let init = node.u.var_decl.default_value
            if init? {
                let res = .check_expression(init, hint: var.type)
                if not res? return

                if is_inferred {
                    var.type = res
                } else if not var.type.can_assign(res) {
                    .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {res.str()}`))
                }
            } else if is_inferred {
                .error(Error::new(node.span, `Variable {var.sym.name} has no type and no initializer`))
            }
        }
        else => {
            .check_expression(node)
        }
    }
}

def TypeChecker::check_function(&this, func: &Function) {
    .resolve_doc_links(func.sym)

    let is_templated = false
    if func.kind == Method {
        let parent_sym = func.parent_type.sym
        if parent_sym.is_templated() then is_templated = true
    }
    if func.sym.is_templated() is_templated = true
    if func.checked then return
    func.checked = true

    let new_scope = Scope::new(func.scope)
    let params = func.params

    // NOTE: If we have Foo<T> and we instantiate Foo<Bar>, we don't want to add to `Bar` for all the
    //       `T`s we see in the struct members, and in all attached methods. This is completely unhelpful
    //       since this is not an explicit usage of `Bar` in the source, and is not what the user intended
    //       to find when they search for references to `Bar`.
    let was_in_template_instance = .in_template_instance
    .in_template_instance = .in_template_instance or func.is_template_instance()
    defer .in_template_instance = was_in_template_instance

    // NOTE: If this is a (not-yet-specialized) template function, we're going to get a
    //       whole bunch of errors from type-checking. We don't want to report those errors
    //       to the user, because they're not really errors in the user's code, we're just
    //       doing this to make the IDE support be more useful.
    // NOTE: We're going to count the number of errors before and after type-checking the
    //       function, and if there are more errors after, we're going to remove them.
    let error_count_before = .o.program.errors.size

    for param in params.iter() {
        if not param.type? then continue  // Error should be reported already
        let default_expr = param.default_value
        if default_expr? {
            // NOTE: This `.check_expression()` call uses the scope _outside_ of the function.
            //       We don't check the new scope here on purpose: the default value needs to be
            //       valid outside the scope of this function, which is where it will be evaluated.
            let default_type = .check_expression(default_expr, hint: param.type)

            if default_type? and not param.type.can_assign(default_type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }

        new_scope.items.insert(param.sym.name, param.sym)
    }
    new_scope.cur_func = func

    if func.sym? and func.sym.is_extern then return

    .o.push_scope(new_scope)
    let ret_type = func.return_type
    if func.is_arrow and ret_type? and ret_type.base != BaseType::Void {
        let stmt_type = .check_expression(func.body, hint: ret_type)
        if not stmt_type? {
            .error(Error::new(func.body.span, "Arrow function must yield a value"))
        } else if not stmt_type.eq(ret_type) {
            .error(Error::new_hint(
                func.body.span, `Expected return type {ret_type.str()}, but got {stmt_type.str()}`,
                ret_type.span, `Arrow function has return type {ret_type.str()}`
            ))
        } else {
            func.body.returns = true
        }

    } else {
        .check_statement(func.body)
    }

    if not func.body.returns and func.return_type.base != BaseType::Void and not func.sym.full_name.eq("main") {
        .error(Error::new(func.sym.span, "Function does not always return"))
    }
    .o.pop_scope()

    // Remove the errors that were generated by type-checking the template function
    if is_templated {
        if .o.program.errors.size > error_count_before {
            .o.program.errors.size = error_count_before
        }
    }
}

def TypeChecker::handle_imports(&this, ns: &Namespace, is_global: bool = false) {
    .o.push_namespace(ns)
    .o.push_scope(ns.scope)

    for child in ns.namespaces.iter_values() {
        .handle_imports(child)
    }

    for import_ in ns.imports.iter() {
        .handle_import_statement(import_)
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::check_globals(&this, node: &AST, is_const: bool) {
    let var = node.u.var_decl
    .resolve_doc_links(var.sym)

    let init = node.u.var_decl.default_value
    if is_const {
        if init? {
            .check_const_expression(init)
        } else if not node.u.var_decl.sym.is_extern {
            .error(Error::new(node.span, "Constant must have an initializer"))
        }

    } else if init? {
        let init_type = .check_expression(init, hint: var.type)
        if not init_type? or not var.type? return

        if not var.type.can_assign(init_type) {
            .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but got {init_type.str()}`))
        }
    }
    .set_resolved_symbol(node, var.sym)
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)
    .resolve_doc_links(ns.sym)

    for func in ns.functions.iter() {
        .check_function(func)
    }

    for node in ns.constants.iter() {
        .check_globals(node, is_const: true)
    }

    for node in ns.variables.iter() {
        .check_globals(node, is_const: false)
    }

    for enom in ns.enums.iter() {
        // Rest of the enum is already resolved
        .resolve_doc_links(enom.sym)
        for variant in enom.variants.iter() {
            .resolve_doc_links(variant.sym)
        }
    }

    for child in ns.namespaces.iter_values() {
        .check_namespace(child)
    }
    .o.pop_namespace()
    .o.pop_scope()
}

// FIXME: This should really live somewhere else...
def TypeChecker::resolve_doc_links(&this, sym: &Symbol) {
    if not (sym? and sym.comment?) return

    let buffer = Buffer::make()
    let prev = 0
    let doc = sym.comment
    let doc_len = doc.len()
    for let i = 0; i < doc_len - 1; i++ {
        if doc[i] == '\\' {
            i++
        } else if doc[i] == doc[i+1] == '{' {
            buffer <<= doc.substring(prev, i-prev)
            prev = i + 2
            i++

        } else if doc[i] == doc[i+1] == '}' {
            let part = doc.substring(prev, i-prev)

            // This means we're not generating docs, and don't need to
            // replace the part with a unique ID. So we'll just add it
            // to the buffer without the { and } and continue
            if not .o.program.check_doc_links {
                buffer += '`'
                buffer <<= part
                buffer += '`'
                prev = i + 2
                i++
                continue
            }

            // Parse a scoped-identifier
            let lexer = Lexer::make(part, sym.span.start.filename)
            let span = Span(sym.comment_loc, sym.comment_loc)
            let tokens = lexer.lex()

            if lexer.errors.size > 0 {
                .error(Error::new(span, `Invalid link: '{part}' in this doc`))
                return
            }

            let parser = Parser::make(.o.program, .o.ns())
            parser.tokens = tokens
            parser.curr = 0

            let ident = parser.parse_scoped_identifier()
            if not ident? {
                .error(Error::new(span, `Invalid link: '{part}' in this doc`))
                return
            }

            let sym = .resolve_scoped_identifier(ident, error: false)
            if not sym? {
                .error(Error::new(span, `Couldn't find symbol '{part}' in this doc link`))
                return
            }

            let linked_part = match sym.type {
                Structure => {
                    let typ = sym.u.struc.type
                    // FIXME: Handle the case where the symbol is templated, for instance `Vec2<f32>`
                    if typ.template_instance? {
                        .error(Error::new_note(
                            span, `Cannot link directly to specialized type '{part}'`,
                            "Try doing `{{A}}<{{B}}>` instead of `{{A<B>}}`"
                        ))
                        return
                    }
                    yield `{sym.u.struc.type:x}`
                }
                Function => `{sym.u.func:x}`
                Enum => `{sym.u.enom:x}`
                EnumVariant => `{sym.u.enum_var:x}`
                TypeDef => `{sym.u.type_def:x}`
                Variable => `{sym.u.var:x}`
                Constant => `{sym.u.var:x}`
                Namespace => `{sym.u.ns:x}`
                else => {
                    .error(Error::new(span, `Cannot link to symbol of type {sym.type}`))
                    return
                }
            }

            buffer += "{{"
            buffer <<= linked_part
            buffer += "}}"
            mem::free(part)

            prev = i + 2
            i++
        }
    }
    buffer <<= doc.substring(prev, doc_len-prev)
    sym.comment = buffer.str()
}

def TypeChecker::check_const_expression(&this, node: &AST, hint: &Type = null): &Type {
    let typ = match node.type {
        Identifier | NSLookup => {
            let sym = .resolve_scoped_identifier(node, error: true, hint)
            if not sym? return null
            if sym.type != SymbolType::Constant {
                .error(Error::new_hint(
                    node.span, "Cannot use a non-constant value in a constant expression",
                    sym.span, "Value was defined here"
                ))
                return hint
            }
            yield sym.u.var.type
        }
        // FIXME: What about inferring integer types based on hint?
        IntLiteral  => .get_base_type(BaseType::I32, node.span)
        FloatLiteral => .get_base_type(BaseType::F32, node.span)
        BoolLiteral => .get_base_type(BaseType::Bool, node.span)
        CharLiteral => .get_base_type(BaseType::Char, node.span)
        StringLiteral => .get_type_by_name("str", node.span)
        BinaryOp => {
            let lhs = .check_const_expression(node.u.binary.lhs)
            let rhs = .check_const_expression(node.u.binary.rhs)
            if not lhs? or not rhs? return null

            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                .error(Error::new(node.span, "Cannot do pointer arithmetic in constant expressions"))
            }
            yield .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
        }
        UnaryOp => match node.u.unary.op {
            BitwiseNot | Negate => {
                if not hint? or not hint.is_numeric() {
                    hint = .get_base_type(BaseType::I32, node.span)
                }
                let typ = .check_const_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_numeric() {
                    .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                    return null
                }
                yield typ
            }
            else => {
                .error(Error::new(node.span, f"Unsupported operator in constant expression: {node.u.unary.op}"))
                return null
            }
        }
        else => {
            .error(Error::new(node.span, "Unsupported operator in constant expression"))
            return null
        }
    }
    node.etype = typ
    return typ
}

def TypeChecker::handle_import_path_base(
    &this,
    node: &AST, imp: &Import,
    parts: &Vector<&ImportPart>,
    base: &Symbol,
    search_in_ns_scope: bool,  // Only important for the first part of the import path
    alias: str = null
) {
    for let i = 0; i < parts.size; i += 1 {
        let part = parts.at(i)

        match part.type {
            Wildcard => {
                .o.import_all_from_symbol(base, imp.export)
                return
            }
            Multiple => {
                let paths = part.u.multiple.paths
                for let j = 0; j < paths.size; j += 1 {
                    let path = paths.at(j)
                    .handle_import_path_base(node, imp, path, base, search_in_ns_scope, alias)
                }
                return
            }
            Single => {} // continue below
        }

        let name = part.u.single.name
        if not name? return

        if name.eq("this") then {
            if i + 1 != parts.size {
                .error(Error::new(part.span, "`this` can only be used as the last part of an import path"))
                return
            }
            if part.u.single.alias? then alias = part.u.single.alias
            break
        }

        let err_span = part.u.single.alias_span
        let new_base = match search_in_ns_scope {
            true => {
                if base.type != Namespace {
                    .error(Error::new(part.span, "Cannot scope-import from a non-namespace"))
                    return
                }
                let res = base.u.ns.scope.lookup_recursive(name)
                search_in_ns_scope = false
                yield res
            }
            false => .o.find_in_symbol(base, name)
        }

        if not new_base? {
            .error(Error::new(part.span, `Invalid import, {base.name}::{name} does not exist`))
            return
        }

        base = new_base
        alias = part.u.single.alias
        if not alias? then alias = name

        part.resolved_symbol = base
        base.add_reference(Normal, part.u.single.name_span)
    }

    .o.insert_into_scope_checked(base, name: alias)
    if imp.export {
        .o.ns().exported_symbols.insert(alias, base)
    }
}

//* Insert all the imported items into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST) {
    let path = node.u.import_path

    let search_in_ns_scope = false
    let base_ns = match path.type {
        GlobalNamespace => .o.program.global,
        ProjectNamespace => .o.ns().get_project_root(node.span, .o.program)
        ParentNamespace => {
            let cur = .o.ns()
            for let i = 0; i < path.parent_count; i += 1 {
                if not cur.parent? {
                    // This should never happen, because the parser is responsible for handling this
                    .error(Error::new(node.span, "Cannot import from parent of root namespace")).panic()
                    return
                }
                cur = cur.parent
            }
            yield cur
        }
        CurrentScope => {
            search_in_ns_scope = true
            yield .o.ns()
        }
    }

    if not base_ns? {
        .error(Error::new(node.span, "Couldn't resolve the search base for the import"))
        return
    }

    node.u.import_path.root_sym = base_ns.sym
    .handle_import_path_base(node, &path, path.parts, base_ns.sym, search_in_ns_scope, alias:null)
}

def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {
    if func.kind == Method {
        let parent_span = func.parent_type.span
        let parent_type = .resolve_type(func.parent_type, allow_incomplete: true)
        if not parent_type? {
            .o.error(Error::new(parent_span, "Could not find this type"))
            return
        }

        if not parent_type.can_have_methods() {
            .o.error(Error::new(parent_span, "This type cannot have methods"))
            return
        }

        match parent_type.base {
            Structure => {
                let struc = parent_type.u.struc
                let name = struc.get_field(func.sym.name)
                if name? {
                    .o.error(Error::new_hint(
                        func.sym.span, f"Field with name `{func.sym.name}` already exists",
                        name.sym.span, "Previous definition here"
                    ))
                }
            }
            Enum => {
                let enom = parent_type.u.enom
                let var = enom.get_variant(func.sym.name)
                if var? {
                    .o.error(Error::new_hint(
                        func.sym.span, f"Enum variant with name `{func.sym.name}` already exists",
                        var.sym.span, "Previous definition here"
                    ))
                }
                let field = enom.get_shared_field(func.sym.name)
                if field? {
                    .o.error(Error::new_hint(
                        func.sym.span, f"Field with name `{func.sym.name}` already exists",
                        field.sym.span, "Previous definition here"
                    ))
                }
            }
            // Builtin type
            else => {}
        }

        let res = parent_type.methods.get(func.sym.name, null)
        if res? {
            .o.error(Error::new_hint(
                func.sym.span, "Method with this name already exists",
                res.sym.span, "Previous definition here"
            ))
            return
        }

        // Now that the parent type is valid, we need to update the symbol table with the updated
        // display and output names for the function
        func.sym.update_parent(parent_type.sym)

        parent_type.methods.insert(func.sym.name, func)
        func.parent_type = parent_type

    } else {
        let item = func.sym
        .o.insert_into_scope_checked(item)
    }

    func.scope = .scope()
}

// We can't really fully resolve the types for the template struct itself, but we can
// try to evaluate some of the explicit types so we have some more information.
def TypeChecker::loosely_resolve_templated_struct(&this, struc: &Structure) {
    for field in struc.fields.iter() {
        // Don't error here, we'll do that later when we specialize the struct
        let res = .resolve_type(field.type, allow_incomplete: true, error: false, resolve_templates: false)
        field.type = res
    }
}

// We can't really fully resolve the types for the template struct itself, but we can
// try to evaluate some of the explicit types so we have some more information.
def TypeChecker::loosely_resolve_templated_enum(&this, enom: &Enum) {
    for field in enom.shared_fields.iter() {
        // Don't error here, we'll do that later when we specialize the struct
        let res = .resolve_type(field.type, allow_incomplete: true, error: false, resolve_templates: false)
        field.type = res
    }
    for variant in enom.variants.iter() {
        for field in variant.specific_fields.iter() {
            let res = .resolve_type(field.type, allow_incomplete: true, error: false, resolve_templates: false)
            field.type = res
        }
    }
}


def TypeChecker::resolve_struct(&this, struc: &Structure) {

    if struc.parsed_parent? {
        let type = .resolve_type(struc.parsed_parent)
        if {
            not type? => {} // Already shown error
            type.base != Structure => .o.error(Error::new(struc.parsed_parent.span, "Parent type must be a struct"))
            else => {
                struc.parent = type.u.struc
            }
        }
    }

    let fields = struc.fields
    .resolve_doc_links(struc.sym)

    // We cannot resolve templated structs.
    if struc.sym.is_templated() {
        .loosely_resolve_templated_struct(struc)
        return
    }

    for field in fields.iter() {
        let res = .resolve_type(field.type)
        .resolve_doc_links(field.sym)
        if not res? {
            .o.error(Error::new(field.sym.span, "Couldn't resolve type"))
        } else {
            field.type = res
        }
        if field.default_value? {
            .check_expression(field.default_value, hint: field.type)
        }
    }
}

def TypeChecker::resolve_enum(&this, enom: &Enum) {
    // We cannot resolve templated structs.
    if enom.sym.is_templated() {
        .loosely_resolve_templated_enum(enom)
        return
    }

    let seen_fields = Map<str, Span>::new()
    defer seen_fields.free()

    for field in enom.shared_fields.iter() {
        let res = .resolve_type(field.type)
        if res? {
            field.type = res
        }
        let item = seen_fields.get_item(field.sym.name)
        if item? {
            .error(Error::new_hint(
                field.sym.span, f"Field with name `{field.sym.name}` already exists",
                item.value, "Previous definition here"
            ))
        }
        seen_fields[field.sym.name] = field.sym.span
        if field.default_value? {
            .check_expression(field.default_value, hint: field.type)
        }
    }
    for variant in enom.variants.iter() {
        for field in variant.specific_fields.iter() {
            let res = .resolve_type(field.type)
            if res? {
                field.type = res
            }
        }
    }
}

//! Check if this is a valid overload: do the number of params and types match expected? If yes,
//! add it to the list.
def TypeChecker::check_operator_overload_function(&this, func: &Function, op: Operator) {
    let num_params_needed = op.num_overload_params()
    if num_params_needed != func.params.size {
        .error(Error::new(func.sym.span, `Operator overload for {op} must have {num_params_needed} parameters`))
        return
    }

    if op.needs_lhs_pointer_for_overload() {
        let lhs = func.params.at(0)
        let lhs_type = lhs.type.unaliased()
        if lhs_type.base != BaseType::Pointer {
            .error(Error::new(lhs.sym.span, f"First parameter of {op} operator must be a pointer-type"))
            return
        }
    }

    // Operator specific checks
    match op {
        // Equals and NotEquals should return a boolean
        Equals | NotEquals | IsNotNull => if func.return_type.base != BaseType::Bool {
            .error(Error::new(func.sym.span, "`==` operator must return a boolean"))
            return
        },
        else => {}
    }

    let overload: OperatorOverload
    overload.op = op
    if num_params_needed > 0 then overload.type1 = func.params.at(0).type
    if num_params_needed > 1 then overload.type2 = func.params.at(1).type
    if num_params_needed > 2 then overload.type3 = func.params.at(2).type

    let it = .o.program.operator_overloads.get_item(overload)
    if it? {
        if it.value != func {
            .error(Error::new_hint(
                func.sym.span, `Operator overload for {op} already exists ({func.sym.display})`,
                it.value.sym.span, `Previous definition here ({it.value.sym.display})`
            ))
        }
        return
    }

    .o.program.operator_overloads.insert(overload, func)
}

def TypeChecker::check_function_declaration(&this, func: &Function) {
    let allow_incomplete = false
    let error = true
    let resolve_templates = true

    if func.kind == Method {
        let parent_sym = func.parent_type.sym
        if parent_sym.is_templated() {
            allow_incomplete = true
            error = false
            resolve_templates = false
        }
    }
    let func_span = match func.kind {
        Closure => func.span
        else => func.sym.span
    }
    if func.sym? and func.sym.is_templated() {
        allow_incomplete = true
        error = false
        resolve_templates = false
    }

    func.return_type = .resolve_type(func.return_type, allow_incomplete, error, resolve_templates)
    if not func.return_type? {
        func.return_type = .get_base_type(BaseType::Void, func_span)
    }

    for param in func.params.iter() {
        param.type = .resolve_type(param.type, allow_incomplete, error, resolve_templates)
    }

    if func.operator_overloads? {
        for op in func.operator_overloads.iter() {
            .check_operator_overload_function(func, op)
        }
    }

    // NOTE: This is NOT needed for regular compilation. We do this just to get better hover
    //       information in the IDE, especially for the parent struct.
    if func.name_ast? and func.name_ast.type == NSLookup {
        .resolve_scoped_identifier(func.name_ast.u.lookup.lhs, error: false, hint: null, resolve_templates: false)
    }

    // A function keeps track of a type that represents an equivalent function pointer type
    // This is used for type checking function calls
    if func.kind == Closure {
        func.type = .get_closure_type(func.params, func.return_type, func.type)

    } else {
        let typ = Type::new_resolved(FunctionPtr, func_span)
        typ.u.func = FunctionType(func, func.params, func.return_type, func.is_variadic)
        func.type = typ
    }
}

def TypeChecker::try_resolve_typedefs_in_namespace(&this, ns: &Namespace, pre_import: bool) {
    for it in ns.typedefs.iter() {
        if it.value.is_resolved() continue

        let sym = .o.scope().lookup_recursive(it.key)
        assert sym?, "Should have added the symbol into scope already"

        // FIXME: Why is there a `typedef` and `alias` at symbol/type level? Only one
        // should really be sufficient.
        assert sym.type == TypeDef

        // We only want to error out if we can't resolve this typedef _after_ importing
        let res = .resolve_type(
            it.value,
            allow_incomplete: false,
            error: not pre_import
        )
        if not res? continue
        sym.u.type_def.u.ptr = res
        sym.u.type_def = res
        it.value = res
    }
}

def TypeChecker::check_post_import(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)

    for func in ns.functions.iter() {
        .check_function_declaration(func)
    }

    for struc in ns.structs.iter() {
        .resolve_struct(struc)
    }

    for enom in ns.enums.iter() {
        .resolve_enum(enom)
    }

    for node in ns.constants.iter() {
        .pre_check_globals(node, is_const: true)
    }

    for node in ns.variables.iter() {
        .pre_check_globals(node, is_const: false)
    }

    // We try to resolve post-imports so typedefs can use imported types
    .try_resolve_typedefs_in_namespace(ns, pre_import: false)

    for child in ns.namespaces.iter_values() {
        .check_post_import(child)
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::pre_check_globals(&this, node: &AST, is_const: bool) {
    let var = node.u.var_decl
    if not var.type? {
        let c = if is_const "Constant" else "Global variable"
        .error(Error::new(node.span, f"{c} must have a type"))
        return
    }
    let type = .resolve_type(var.type)
    if not type? then return
    var.type = type
}

def TypeChecker::check_pre_import(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)

    for func in ns.functions.iter() {
        .pre_check_function(ns, func)
    }

    // FIXME: This shouldn't need to be done, only post-imports. there's some issue
    //        with how typedefs are added to namespaces/scopes that needs to be fixed.
    //        Removing this line causes `tests/import_typedef.oc` to fail.
    .try_resolve_typedefs_in_namespace(ns, pre_import: true)

    for child in ns.namespaces.iter_values() {
        .check_pre_import(child)
    }

    .o.pop_scope()
}

def TypeChecker::run(program: &Program) {
    let pass = TypeChecker(
        o: GenericPass::new(program),
        unchecked_functions: Vector<&Function>::new(),
        in_template_instance: false
    )
    pass.check_pre_import(program.global)
    pass.handle_imports(program.global, is_global: true)
    pass.check_post_import(program.global)

    pass.check_namespace(program.global)

    pass.o.push_namespace(program.global)
    while pass.unchecked_functions.size > 0 {
        let func = pass.unchecked_functions.pop()
        pass.check_function(func)
    }
    pass.o.pop_namespace()
}
