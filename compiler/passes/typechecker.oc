//* Resolve and check types in the AST
//*
//* This pass actually goes through the AST and checks the types of all the nodes.
//* Any remaining unresolved types should be resolved after this

import std::buffer::{ Buffer }
import std::map::{ Map }
import std::span::{ Span }
import std::vector::{ Vector }

import @ast::nodes::{ AST, ASTType, Structure, Function, Variable }
import @ast::operators::{ Operator, OperatorOverload }
import @ast::nodes::{ ImportPart, Import, Enum, Argument, MatchCase }
import @ast::program::{ Program, Namespace }
import @ast::scopes::{ Scope, Symbol, SymbolType, TemplateInstance }
import @errors::{ Error }
import @lexer::{ Lexer }
import @parser::{ Parser }
import @passes::generic_pass::{ GenericPass }
import @types::{ Type, BaseType, FunctionType, UnresolvedTemplate, ArrayType }

struct TypeChecker {
    o: &GenericPass
    unchecked_functions: &Vector<&Function>
}

// Some convenience accessors from the GenericPass
def TypeChecker::error(&this, err: &Error): &Error => .o.error(err)
def TypeChecker::scope(&this): &Scope => .o.scope()

def TypeChecker::get_base_type(&this, base: BaseType, span: Span): &Type => .o.program.get_base_type(base, span)
def TypeChecker::get_type_by_name(&this, name: str, span: Span): &Type => .o.program.get_type_by_name(name, span)

def TypeChecker::resolve_type(
    &this,
    old: &Type,
    allow_incomplete: bool = false, // Allow checking types like `Foo<i32, T>` without T being resolved
    error: bool = true,             // Whether to error if the type cannot be resolved
    resolve_templates: bool = true  // Don't try to resolve the templates, just resolve the base and params
): &Type {

    // Shorter names for parameters to make recursive calls easier to read
    let p_a = allow_incomplete
    let p_e = error
    let p_r = resolve_templates

    let resolved = old
    match old.base {
        Pointer => {
            let ptr = .resolve_type(old.u.ptr, p_a, p_e, p_r)
            if not ptr? return null
            match ptr.base {
                Char => resolved = .o.program.get_type_by_name("str", old.span)
                Void => resolved = .o.program.get_type_by_name("untyped_ptr", old.span)
                else => {
                    resolved = Type::shallow_copy(old)
                    resolved.u.ptr = ptr
                }
            }
        }
        Alias => {
            if not old.u.ptr? {
                println(f"Got unresolved type: {old:p}")
                .error(Error::new_note(
                    old.span, "This type does not point to anything",
                    "Cannot use a typedef for a type when defining any of it's members.\nUse fully qualified type for all field / method definitions."
                ))
                return null
            }
            return .resolve_type(old.u.ptr, p_a, p_e, p_r)
        }
        Function => {
            let checked_params = Vector<&Variable>::new()

            let func = old.u.func
            for var : func.params.iter() {
                // Note: it's okay to overwrite here since `var` has `parsed_type` already
                var.type = .resolve_type(var.type, p_a, p_e, p_r)
                if not var.type? return null
                checked_params.push(var)
            }

            let return_type = .resolve_type(func.return_type, p_a, p_e, p_r)
            if not return_type? return null

            resolved = Type::shallow_copy(old)
            resolved.u.func = FunctionType(func.orig, checked_params, return_type, func.is_variadic)
        }
        Unresolved => {
            let node = old.u.unresolved
            let res = .resolve_scoped_identifier(node, p_e, hint: null, p_r)

            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = res.u.type_def
                    SymbolType::Structure => {
                        let struc = res.u.struc
                        if res.is_templated() and not allow_incomplete {
                            if error {
                                .error(Error::new(old.span, `Cannot use templated struct {struc.sym.name} as a type`))
                                return null
                            }
                            return resolved
                        }
                        resolved = res.u.struc.type
                        if node.type == Specialization and res.is_templated() {
                            assert not resolve_templates, "Should have been errored in resolve_scoped_identifier"
                            let type = Type::new_resolved(UnresolvedTemplate, node.span)
                            type.u.unresolved_spec = UnresolvedTemplate(resolved, node.u.spec.template_args)
                            resolved = type
                        }
                    }
                    SymbolType::Function => {
                        let func = res.u.func
                        if res.is_templated() and not allow_incomplete {
                            if error {
                                .error(Error::new(old.span, `Cannot use templated function {func.sym.name} as a type`))
                                return null
                            }
                            return resolved
                        }
                        resolved = res.u.func.type
                        if node.type == Specialization and res.is_templated() {
                            assert not resolve_templates, "Should have been errored in resolve_scoped_identifier"
                            let type = Type::new_resolved(UnresolvedTemplate, node.span)
                            type.u.unresolved_spec = UnresolvedTemplate(resolved, node.u.spec.template_args)
                            resolved = type
                        }
                    }
                    SymbolType::Enum => resolved = res.u.enum_.type
                    else => {
                        if error {
                            .error(Error::new(res.span, `Cannot use {res.display} as a type`))
                            resolved = null
                        }
                    }
                }
            } else {
                if error {
                    .error(Error::new(old.u.unresolved.span, "Could not find type with this name"))
                    resolved = null
                }
            }
        }
        Array => {
            let arr = old.u.arr
            let elem_type = .resolve_type(arr.elem_type, p_a, p_e, p_r)
            if not elem_type? return null

            let res = .check_expression(arr.size_expr)
            if not res? return null

            resolved = Type::shallow_copy(old)
            resolved.u.arr.elem_type = elem_type

            .try_infer_array_size(&resolved.u.arr)
        }
        Structure | Char | Bool | Void | I8 | I16 |
        I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 |
        Enum => {}

        else => {
            if error {
                .error(Error::new(old.span, `Unhandled type in resolve {old.base.str()}`))
                resolved = null
            }
        }
    }
    return resolved
}

def TypeChecker::try_infer_array_size(&this, arr_typ: &ArrayType) {
    let size_expr = arr_typ.size_expr

    if size_expr.type == ASTType::IntLiteral {
        if size_expr.u.num_literal.suffix? {
            .error(Error::new(size_expr.span, "Array size literal cannot have a suffix"))
        }
        arr_typ.size_known = true
        arr_typ.size = size_expr.u.num_literal.text.to_u32()
    }

    // FIXME: We also want to be able to check based on constant expressions, however
    // we don't have a way to actually evaluate constant expressions yet since we just
    // pass that onto the C compiler.
}

def TypeChecker::resolve_templated_struct_methods(&this, old: &Structure, cur: &Structure) {
    let old_type = old.type
    let cur_type = cur.type

    let old_methods = old_type.methods
    let cur_methods = cur_type.methods

    let parent_ns = old.sym.ns

    for iter : old_methods.iter() {
        let name = iter.key
        let method = iter.value

        let new_method = .o.program.get_function_deep_copy(method, parent_ns)
        new_method.parent_type = cur_type
        cur_methods.insert(name, new_method)

        new_method.sym.update_parent(cur_type.sym)
        parent_ns.functions.push(new_method)

        if not method.is_static {
            let this_param = new_method.params.at(0)
            if this_param.type.base == Pointer {
                this_param.type.u.ptr = cur_type
            } else {
                this_param.type = cur_type
            }
        }

        new_method.scope = .scope()
        .check_function_declaration(new_method)

        // NOTE: We don't want to check these functions right now, since we could still be in the process
        // of setting up the namespaces / imports / etc. We'll check them later at the end of the program.
        .unchecked_functions.push(new_method)
    }
}

def TypeChecker::resolve_templated_struct(&this, struc: &Structure, instance: &TemplateInstance) {
    let sym = instance.resolved
    let resolved_struc = .o.program.get_struct_deep_copy(struc, struc.sym.ns)
    resolved_struc.sym.template = null
    resolved_struc.sym = sym
    sym.u.struc = resolved_struc
    // Copy over formatting information
    resolved_struc.format_spec = struc.format_spec
    resolved_struc.format_args = struc.format_args

    let typ = Type::new_resolved(Structure, sym.span)
    typ.u.struc = resolved_struc
    resolved_struc.type = typ
    typ.sym = sym
    typ.template_instance = instance

    .resolve_struct(resolved_struc)
    .resolve_templated_struct_methods(struc, resolved_struc)
}

def TypeChecker::resolve_templated_function(&this, func: &Function, instance: &TemplateInstance) {
    let sym = instance.resolved
    let resolved_func = .o.program.get_function_deep_copy(func, func.sym.ns)
    resolved_func.sym.template = null
    resolved_func.sym = sym
    if func.parent_type? {
        sym.update_parent(func.parent_type.sym)
    }
    sym.u.func = resolved_func
    resolved_func.scope = .scope()

    .check_function_declaration(resolved_func)
    .unchecked_functions.push(resolved_func)
}


def TypeChecker::find_template_instance(&this, template_instances: &Vector<&TemplateInstance>, args: &Vector<&Type>): &Symbol {
    for instance : template_instances.iter() {
        if instance.matches(args) return instance.resolved
    }
    return null
}

def TypeChecker::resolve_templated_symbol(&this, sym: &Symbol, node: &AST): &Symbol {
    // If we've already resolved this template, just return the symbol
    {
        let found = .find_template_instance(sym.template.instances, node.u.spec.template_args)
        if found? return found
    }

    let parent_ns = sym.ns
    let template_args = node.u.spec.template_args
    let template_params = sym.template.params

    if template_params.size != template_args.size {
        .error(Error::new(node.span, `Invalid number of template arguments for {sym.name}`))
        return null
    }

    // Want to also build a new display name for the specialization
    let new_display_name = Buffer::make()
    new_display_name += sym.name
    new_display_name += "<"

    // This is the scope that we'll use to resolve the template parameters
    let scope = Scope::new(sym.ns.scope)
    .o.push_scope(scope)

    // Add the template arguments to the scope with corresponding names
    for let i = 0; i < template_params.size; i += 1 {
        let param = template_params.at(i)
        let arg = template_args.at(i)

        if i > 0 then new_display_name += ", "
        new_display_name += arg.str()

        let cur_sym = Symbol::new(
            TypeDef,
            ns: null,
            param.sym.name, // name
            param.sym.name, // display
            param.sym.name, // out_name
            param.sym.span,
        )
        cur_sym.u.type_def = arg
        .o.insert_into_scope_checked(cur_sym)
    }

    new_display_name += ">"

    // NOTE: We need to do `new_with_parent` to properly set the namespaced names of the symbol
    let new_out_name = `{sym.name}__{sym.template.instances.size}`
    let new_sym = Symbol::new_with_parent(sym.type, parent_ns, parent_ns.sym, new_out_name, sym.span)
    new_sym.display = new_display_name.str()

    let instance = TemplateInstance::new(template_args, parent: sym, resolved: new_sym)
    sym.template.instances.push(instance)

    match sym.type {
        Structure => .resolve_templated_struct(sym.u.struc, instance)
        Function => .resolve_templated_function(sym.u.func, instance)
        else => {
            .error(Error::new(node.span, `Cannot specialize non-templated symbol {sym.name}`))
            return null
        }
    }
    .o.pop_scope()

    return new_sym
}


def TypeChecker::resolve_scoped_identifier(&this, node: &AST, error: bool = true, hint: &Type = null, resolve_templates: bool = true): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            let lhs_span = node.u.lookup.lhs.span
            let lhs = .resolve_scoped_identifier(node.u.lookup.lhs, error, hint: null, resolve_templates)
            if not lhs? return null

            let name = node.u.lookup.rhs_name
            if not name? return null

            let res = .o.lookup_in_symbol(lhs, name, node.span, error)
            node.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = null as &Symbol

            // If we know that the type of this identifier is supposed to be a particular enum,
            // then we can look up the field in that enum implicitly.
            if hint? and hint.base == Enum {
                let enum_ = hint.u.enum_
                let field = enum_.get_field(name) as &Variable
                if field? {
                    res = field.sym
                }
            }

            if not res? {
                res = .scope().lookup_recursive(name)
            }

            node.resolved_symbol = res
            if error and not res? {
                .error(Error::new(node.span, "Couldn't find this identifier"))
            }
            return res
        }
        ASTType::Specialization => {
            let base = .resolve_scoped_identifier(node.u.spec.base, error, hint, resolve_templates)
            if not base? return null

            base = base.remove_alias()
            if not base.is_templated() {
                .error(Error::new(node.span, `Cannot specialize non-templated symbol {base.name}`))
                return null
            }

            let args = node.u.spec.parsed_template_args
            let resolved_args = Vector<&Type>::new(capacity: args.size)
            let failed = false
            for let i = 0; i < args.size; i += 1 {
                let resolved_arg = .resolve_type(args.at(i), allow_incomplete: true, error, resolve_templates)
                if not resolved_arg? {
                    failed = true
                    continue
                }
                resolved_args.push(resolved_arg)
            }
            if failed return null
            node.u.spec.template_args = resolved_args

            if not resolve_templates {
                node.resolved_symbol = base
                return base
            }

            return .resolve_templated_symbol(base, node)
        }
        else => {
            if error {
                .error(Error::new(node.span, `Don't know how to resolve node type {node.type}`))
            }
            return null
        }
    }
}

def TypeChecker::check_block(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let block = &node.u.block

    let scope = Scope::new(.scope())
    scope.can_yield = scope.can_yield or is_expr
    block.scope = scope

    .o.push_scope(block.scope)
    let stmts = block.statements
    let yield_span = Span::default()
    for stmt : stmts.iter() {
        .check_statement(stmt)
        if stmt.returns then node.returns = true

        if stmt.type != Yield then continue
        if node.etype? {
            .error(Error::new_hint(
                stmt.span, "Cannot yield multiple times in a block",
                yield_span, "Previously yielded here"
            ))
        }
        node.etype = stmt.etype
        yield_span = stmt.span
    }
    .o.pop_scope()
}

def TypeChecker::check_method_call(&this, method: &Function, node: &AST) {
    let callee = node.u.call.callee
    if callee.type != ASTType::Member and callee.type != ASTType::NSLookup {
        .error(Error::new(callee.span, "Method call is not to a member, internal compiler error"))
        return
    }

    if callee.type != ASTType::Member return
    if method.params.size == 0 {
        // This should ideally never happen.
        .error(Error::new(callee.span, "Instance method should have `this` argument, internal error"))
        return
    }
    let method_param = (method.params.at(0)).type
    if not method_param? return

    let member = callee.u.member
    let first_arg = member.lhs

    if member.is_pointer and method_param.base != Pointer {
        first_arg = AST::new_unop(Dereference, first_arg.span, first_arg)
    } else if not member.is_pointer and method_param.base == Pointer {
        first_arg = AST::new_unop(Address, first_arg.span, first_arg)
    }
    node.u.call.args.push_front(Argument::new(first_arg))
}

def TypeChecker::check_internal_print(&this, node: &AST): &Type {
    let args = node.u.call.args
    if args.size < 1 {
        .o.error(Error::new(
            node.span, "Function requires at least one argument"
        ))
    }
    let first = args.at(0)
    let first_type = .check_expression(first.expr)
    if first_type? and not first_type.is_str() {
        .o.error(Error::new(
            first.expr.span, `First argument must be a string literal, got {first_type.str()}`
        ))
    }

    for arg : args.iter() {
        .check_expression(arg.expr)
        .call_dbg_on_enum_value(&arg.expr)
    }

    return .get_base_type(Void, node.span)
}

def TypeChecker::check_constructor(&this, node: &AST): &Type {
    node.u.call.is_constructor = true

    let callee = node.u.call.callee
    let type_sym = callee.resolved_symbol.remove_alias()

    assert type_sym.type == Structure, `Got non-struct type in check_constructor: {type_sym.type}`
    let struc = type_sym.u.struc

    let params = struc.fields

    .check_call_args(node, params)

    return struc.type
}

def TypeChecker::check_call_args(&this, node: &AST, params: &Vector<&Variable>, is_variadic: bool = false) {
    let args = node.u.call.args

    if params.size < args.size and not is_variadic {
        .error(Error::new(node.span, `Too many arguments, expected {params.size} but got {args.size}`))
    }

    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i)
        // Normal case
        if i < args.size {
            let arg = args.at(i)

            if arg.label? and not arg.label.eq(param.sym.name) {
                .error(Error::new(arg.label_span, `Argument label '{arg.label}' does not match parameter name '{param.sym.name}'`))
            }

            let arg_type = .check_expression(arg.expr, hint: param.type)
            if not arg_type? or not param.type? then continue
            if not arg_type.eq(param.type) {
                .error(Error::new(arg.expr.span, `Argument {param.sym.name} has type {arg_type.str()} but expected {param.type.str()}`))
            }

        // Default argument case
        } else if param.default_value? {

            // FIXME: We should not be evaluating the default argument here during every call,
            // we should be evaluating it at the time of checking the function declaration and using
            // a cached value here
            let new_arg = Argument::new(param.default_value)
            // Plus the default argument to the list of arguments
            args.push(new_arg)

        } else {
            .error(Error::new(node.span, `Missing required argument {param.sym.name}`))
            return
        }
    }

    if is_variadic {
        if args.size < params.size {
            assert .o.program.errors.size > 1, "Should have errored already"
            return
        }

        for let i = params.size; i < args.size; i += 1 {
            let arg = args.at(i)
            let arg_type = .check_expression(arg.expr)
            if not arg_type? then continue
        }
    }
}

def TypeChecker::check_call(&this, node: &AST): &Type {
    let callee = node.u.call.callee
    let args = node.u.call.args

    // FIXME: this is a fucking abonimation
    if callee.type == ASTType::Identifier {
        callee.u.ident.is_function = false
        let name = callee.u.ident.name

        if name.eq("print") or name.eq("println") {
            return .check_internal_print(node)
        }
    }

    let res = match callee.type {
        Member => .check_member(callee, is_being_called: true)
        Identifier | NSLookup | Specialization => {
            let sym = .resolve_scoped_identifier(callee, error: true)
            if not sym? return null

            sym = sym.remove_alias()
            callee.resolved_symbol = sym

            yield match sym.type {
                Structure | TypeDef => {
                    return .check_constructor(node)
                }
                else => .check_expression(callee)
            }
        }
        else => .check_expression(callee)
    }
    if not res? return null

    if res.base == BaseType::Pointer and res.u.ptr.base == BaseType::Function {
        res = res.u.ptr

    } else if res.base != BaseType::Function {
        .error(Error::new(callee.span, `Cannot call a non-function type: {res.str()}`))
        return null
    }

    let func = res.u.func
    if func.orig? and func.orig.exits then node.returns = true
    let params = func.params

    if func.orig? and func.orig.is_method and not func.orig.is_static {
        .check_method_call(func.orig, node)
    }

    .check_call_args(node, params, func.is_variadic)

    let is_variadic_format = func.orig? and func.orig.is_variadic_format
    if is_variadic_format and args.size >= params.size {
        let args = node.u.call.args

        let param = params.back()
        let arg = args.at(params.size - 1).expr

        if not param.type.is_str() {
            .error(Error::new(
                func.orig.sym.span, "Variadic-format function must have last positional argument of type 'str'"
            ))
        }
        match arg.type {
            StringLiteral | FormatStringLiteral => {}
            else => {
                .error(Error::new(
                    arg.span, "Expected a string literal for variadic-format function"
                ))
            }
        }
    }

    if func.orig? {
        node.u.call.is_function_pointer = false
        node.u.call.func = func.orig
    }

    return func.return_type
}

def TypeChecker::check_pointer_arith(&this, node: &AST, _lhs: &Type, _rhs: &Type): &Type {
    let op = node.u.binary.op
    if op == Operator::Plus or op == Operator::Minus {
        if _lhs.base == BaseType::Pointer and _rhs.is_integer() {
            return _lhs
        }
        if _lhs.is_integer() and _rhs.base == BaseType::Pointer {
            return _rhs
        }
        if _lhs.eq(_rhs) and _lhs.base == BaseType::Pointer {
            if op == Operator::Minus {
                return .get_base_type(BaseType::I64, node.span)
            }
        }
    }
    .error(Error::new(node.span, "Invalid pointer arithmetic"))
    return null
}

def TypeChecker::find_and_replace_overloaded_binary_op(&this, node: &AST, arg1: &AST, arg2: &AST, arg3: &AST = null): &Type {
    let op = node.u.binary.op
    if op.needs_lhs_pointer_for_overload() {
        // Auto-address for a value if it's not a pointer
        if arg1.is_lvalue() and arg1.etype.base != Pointer {
            arg1 = AST::new_unop(Address, arg1.span, arg1)
            if not .check_expression(arg1)? return null
        }
    }

    let overload: OperatorOverload
    overload.op = op
    if arg1? overload.type1 = arg1.etype
    if arg2? overload.type2 = arg2.etype
    if arg3? overload.type3 = arg3.etype
    let func = .o.program.operator_overloads.get(overload, defolt: null)
    if not func? return null

    // NOTE: This is a little hacky; it's not actually an identifier
    //        but we know the correct symbol so we're resolving it manually.
    let callee = AST::new(Identifier, node.u.binary.op_span)
    callee.u.ident.name = func.sym.name
    callee.resolved_symbol = func.sym

    let args = Vector<&Argument>::new()
    if arg1? args.push(Argument::new(arg1))
    if arg2? args.push(Argument::new(arg2))
    if arg3? args.push(Argument::new(arg3))

    node.type = Call
    node.u.call.callee = callee
    node.u.call.args = args
    return func.return_type
}

def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    let res = .find_and_replace_overloaded_binary_op(node, node.u.binary.lhs, node.u.binary.rhs)
    if res? return res

    let op = node.u.binary.op
    match op {
        Plus | Minus | Multiply | Divide => {
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                return .check_pointer_arith(node, lhs, rhs)

            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null

            } else if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else {
                return lhs
            }
        }
        PlusEquals | MinusEquals | DivideEquals | MultiplyEquals => {
            let lhs_node = node.u.binary.lhs
            if not lhs_node.is_lvalue() {
                .error(Error::new(node.span, "Left hand side of assignment must be assignable"))
                return null
            }
            if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            return lhs
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            if not lhs.is_numeric_or_char() or not rhs.is_numeric_or_char() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        Equals | NotEquals => {
            if not lhs.eq(rhs) {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if lhs.base == BaseType::Structure {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        And | Or => {
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        BitwiseXor => {
            if not lhs.eq(rhs) {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if lhs.base != BaseType::Bool and not lhs.is_integer() {
                .error(Error::new(node.span, "Operator requires integer types"))
            }
            return lhs
        }
        Modulus | BitwiseOr | BitwiseAnd | LeftShift | RightShift | LeftShiftEquals | RightShiftEquals => {
            if not lhs.is_integer() or not rhs.is_integer() {
                .error(Error::new(node.span,
                    f"Operator `{op}` does not support `{lhs.str()}` and `{rhs.str()}`"
                ))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }

            let lhs_node = node.u.binary.lhs
            match op {
                LeftShiftEquals | RightShiftEquals => if not lhs_node.is_lvalue() {
                    .error(Error::new(lhs_node.span, f"Must be an l-value"))
                    return null
                },
                else => {}
            }

            return lhs
        }
        else => std::panic(`Internal error: unhandled op in check_binary_op: {node.type}`)
    }
}

def TypeChecker::check_format_string(&this, node: &AST): &Type {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs

    if parts.size != exprs.size + 1 {
        .error(Error::new(node.span, "Number of format string parts does not match number of expressions"))
    }

    for let i = 0; i < exprs.size; i += 1 {
        let expr = exprs.at(i)
        let typ = .check_expression(expr)
        if not typ? continue

        typ = .call_dbg_on_enum_value(&expr)
        exprs.data[i] = expr

        if not typ? continue
        typ = typ.unaliased()

        match typ.base {
            Bool | Char | I8 | I16 | I32 | I64 | U8 | U16 |
            U32 | U64 | F32 | F64 | Pointer => {}
            else => {
                let can_format = false
                if typ.base == Structure {
                    let struc = typ.u.struc
                    if struc? and struc.format_spec? {
                        can_format = true
                    }
                }

                if can_format {
                    // These checks are to try to avoid side-effects when formatting our custom types. Eg:
                    //      println(`{get_sv()}`)
                    // would end up calling get_sv() twice when we generate:
                    //      printf("%.*s", get_sv().len, get_sv().data).
                    // These are just some heuristics to try to avoid that, but it's not perfect.
                    match expr.type {
                        Identifier | Member | NSLookup => continue
                        else => {
                            .error(Error::new_note(
                                expr.span, `Can only format {typ.sym.display} in simple expressions`,
                                "Try moving the expression into a variable and formatting that instead"
                            ))
                        }
                    }

                } else {
                    .error(Error::new(
                        expr.span, `Type '{typ.str()}' cannot be formatted automatically`
                    ))
                }
            }
        }
    }

    return .get_type_by_name("str", node.span)
}

def TypeChecker::check_member(&this, node: &AST, is_being_called: bool): &Type {
    let lhs = .check_expression(node.u.member.lhs)
    if not lhs? return null

    // How would this work for strings?
    let is_pointer = false
    if lhs.base == BaseType::Pointer {
        is_pointer = true

        if not lhs.u.ptr? {
            .error(Error::new(lhs.span, "Got unresolved type"))
            return null
        }
        lhs = lhs.u.ptr
    }

    let rhs_name = node.u.member.rhs_name
    if not rhs_name? return null

    if lhs.base == BaseType::Structure {
        let struc = lhs.u.struc
        let field = struc.get_field(rhs_name)
        if field? {
            node.u.member.is_pointer = is_pointer
            node.resolved_symbol = field.sym
            return field.type
        }
    }

    if lhs.can_have_methods() {
        let method = lhs.methods.get(rhs_name, null)
        if method? {
            if not is_being_called {
                .error(Error::new(node.span, "Cannot access method without calling it"))
                return null
            }
            if method.is_static {
                .error(Error::new(node.span, "Cannot call static method as instance method"))
                return null
            }
            node.u.member.is_pointer = is_pointer
            node.resolved_symbol = method.sym
            return method.type
        }
    }

    .error(Error::new(
        node.span, `Type {lhs.str()} has no member named '{rhs_name}'`
    ))
    return null
}


// This is just here so we can use early exits in the actual check_expression
// function, and still always assign the type to the node's etype field
def TypeChecker::check_expression(&this, node: &AST, hint: &Type = null): &Type {
    if node.etype? return node.etype

    let typ = .check_expression_helper(node, hint)
    if typ? and node.type != ArrayLiteral then typ = typ.decay_array()
    node.etype = typ
    return typ
}

def TypeChecker::check_index(&this, node: &AST, hint: &Type, is_being_assigned: bool): &Type {
    let lhs = .check_expression(node.u.binary.lhs)
    let rhs = .check_expression(node.u.binary.rhs)
    if not lhs? or not rhs? return null

    if not is_being_assigned {
        let res = .find_and_replace_overloaded_binary_op(node, node.u.binary.lhs, node.u.binary.rhs)
        if res? return res
    }

    if not rhs.is_integer() {
        .error(Error::new(node.span, `Index must be an integer, got {rhs.str()}`))
        return null
    }
    lhs = lhs.unaliased()
    match lhs.base {
        BaseType::Array => return lhs.u.arr.elem_type
        BaseType::Pointer => return lhs.u.ptr
        else => {
            .error(Error::new(node.span, `Cannot index type {lhs.str()}`))
            return null
        }
    }
}

// FIXME: Merge this into `check_binary_op`, but we need to properly handle how we
//        overload IndexAssign operator; we have 3 operands for that instead of 2.
def TypeChecker::check_assignment(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    if not node.u.binary.lhs.is_lvalue() {
        .error(Error::new(node.u.binary.lhs.span, "Must be an l-value"))
    }
    if not lhs.eq(rhs) {
        .error(Error::new(
            node.u.binary.rhs.span, `Variable type does not match assignment type, Expected type '{lhs.str()}', got '{rhs.str()}'`
        ))
    }
    return lhs
}

def TypeChecker::check_expression_helper(&this, node: &AST, hint: &Type): &Type {
    match node.type {
        ASTType::IntLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_integer() then return hint
            return .get_base_type(BaseType::U32, node.span)
        }
        ASTType::FloatLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_float() then return hint
            return .get_base_type(BaseType::F32, node.span)
        }
        ASTType::StringLiteral => {
            return .get_type_by_name("str", node.span)
        }
        ASTType::Null => {
            if hint? {
                if hint.base == BaseType::Pointer return hint
                if hint.base == BaseType::Function return hint
            }

            return .get_type_by_name("untyped_ptr", node.span)
        }
        ASTType::Cast => {
            let typ = .check_expression(node.u.cast.lhs)
            if not typ? return null
            let target = .resolve_type(node.u.cast.to)
            if not target? return null
            node.u.cast.to = target
            // FIXME: Disallow invalid casts
            return target
        }
        ASTType::FormatStringLiteral => {
            return .check_format_string(node)
        }
        ASTType::CharLiteral => {
            return .get_base_type(BaseType::Char, node.span)
        }
        ASTType::BoolLiteral => {
            return .get_base_type(BaseType::Bool, node.span)
        }
        ASTType::UnaryOp => match node.u.unary.op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                let lhs = .check_expression(node.u.unary.expr)
                if not lhs? return null
                if not lhs.is_integer() {
                    .error(Error::new(node.span, `Cannot increment or decrement non-integer type: {lhs.str()}`))
                    return null
                }
                if not node.u.unary.expr.is_lvalue() {
                    .error(Error::new(node.span, `Can't perform {node.u.unary.op} on a non-lvalue`))
                }
                return lhs
            }
            Negate => {
                if not (hint? and hint.is_numeric()) {
                    hint = .get_base_type(BaseType::I32, node.span)
                }
                let typ = .check_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_numeric() {
                    .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                    return null
                }
                return typ
            }
            BitwiseNot => {
                let typ = .check_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_integer() {
                    .error(Error::new(node.span, `Cannot do bitwise-not on non-integer type: {typ.str()}`))
                    return null
                }
                return typ
            }
            IsNotNull => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null
                typ = typ.unaliased()
                if typ.base != BaseType::Pointer {
                    .error(Error::new(node.span, `Can only use ? on pointer types, got {typ.str()}`))
                }
                return .get_base_type(BaseType::Bool, node.span)
            }
            Not => {
                let typ = .check_expression(node.u.unary.expr, hint: .get_base_type(BaseType::Bool, node.span))
                if not typ? return null
                if typ.base != BaseType::Bool {
                    .error(Error::new(node.span, `Cannot negate non-boolean type: {typ.str()}`))
                    return null
                }
                return typ
            }
            Address => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null

                match typ.base {
                    BaseType::Char => return .get_type_by_name("str", node.span)
                    BaseType::Void => return .get_type_by_name("untyped_ptr", node.span)
                    else => {
                        let ptr = Type::new_resolved(BaseType::Pointer, node.span)
                        ptr.u.ptr = typ
                        return ptr
                    }
                }
            }
            Dereference => {
                let typ = .check_expression(node.u.unary.expr)
                if not typ? return null
                if typ.base != BaseType::Pointer {
                    .error(Error::new(node.span, `Cannot dereference non-pointer type: {typ.str()}`))
                    return null
                }
                return typ.u.ptr
            }
            else => {
                .error(Error::new(node.span, `Unknown unary operator in check_expression: {node.u.unary.op}`))
                return null
            }
        }

        ASTType::Member => return .check_member(node, is_being_called: false)
        ASTType::SizeOf => {
            let typ = .resolve_type(node.u.size_of_type)
            if not typ? return null
            node.u.size_of_type = typ
            return .get_base_type(BaseType::U32, node.span)
        }
        ASTType::If => {
            .check_if(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Block => {
            .check_block(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Match => {
            .check_match(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Identifier | ASTType::NSLookup | ASTType::Specialization => {
            let item = .resolve_scoped_identifier(node, error: true, hint)
            if not item? return null

            item = item.remove_alias()
            match item.type {
                Function => return item.u.func.type
                Variable | Constant | EnumVariant => return item.u.var.type
                TypeDef => {
                    // This is just for a nicer error message
                    .error(Error::new(node.span, f"Cannot use type `{item.name}` as an expression"))
                    return null
                }
                Structure | Enum | Namespace => {
                    .error(Error::new(node.span, f"Cannot use {item.type} `{item.name}` as an expression"))
                    return null
                }
            }
        }
        ASTType::Call => return .check_call(node)

        // Binary operators
        BinaryOp => {
            let lhs_node = node.u.binary.lhs
            let rhs_node = node.u.binary.rhs
            let op = node.u.binary.op
            match op {
                Plus |
                Minus |
                Multiply |
                Divide |
                LessThan |
                LessThanEquals |
                GreaterThan |
                GreaterThanEquals |
                Equals |
                NotEquals |
                PlusEquals |
                MinusEquals |
                MultiplyEquals |
                DivideEquals |
                And |
                Or |
                Modulus |
                BitwiseOr |
                BitwiseAnd |
                BitwiseXor |
                LeftShiftEquals |
                RightShiftEquals |
                LeftShift |
                RightShift => {
                    let lhs = .check_expression(lhs_node)
                    let rhs = .check_expression(rhs_node, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
                }
                Index => return .check_index(node, hint, is_being_assigned: false)
                Assignment => {
                    let lhs = .check_expression(node.u.binary.lhs)
                    let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_assignment(node, lhs, rhs)
                }
                IndexAssign => {
                    // We need to handle this operator overload carefully - since if we naively check the LHS
                    // and RHS, we might end up replacing the LHS with the overloaded function for `[]`.
                    // eg:     `a[x] = y` => `a_get(a, x) = y`
                    // which is bad.
                    let index = node.u.binary.lhs
                    let arg1 = index.u.binary.lhs
                    let arg2 = index.u.binary.rhs
                    let arg3 = node.u.binary.rhs
                    if not .check_expression(arg1)? return null
                    if not .check_expression(arg2)? return null

                    // Infer the type for the assigned value (in case it's a pointer to an array)
                    let arg3_hint: &Type = null
                    let arg1_typ = arg1.etype.unaliased()
                    if arg1_typ.base == BaseType::Pointer {
                        arg3_hint = arg1_typ.u.ptr
                    }

                    if not .check_expression(arg3, hint: arg3_hint)? return null

                    let res = .find_and_replace_overloaded_binary_op(node, arg1, arg2, arg3)
                    if res? return res

                    let lhs = .check_index(index, hint: null, is_being_assigned: true)
                    let rhs = .check_expression(arg3, hint: lhs)
                    if not lhs? or not rhs? return null
                    return .check_assignment(node, lhs, rhs)
                }
                else => std::panic(`Internal error: unhandled op in check_expression binary_op: {node.type}`)
            }
        }

        ArrayLiteral => {
            let hint_elem_type = null as &Type
            if hint? and hint.base == BaseType::Array {
                hint_elem_type = hint.u.arr.elem_type
            }

            let elem_type = null as &Type
            let first_span = Span::default()
            for elem : node.u.array_literal.elements.iter() {
                let typ = .check_expression(elem, hint_elem_type)
                if not typ? continue

                if not elem_type? {
                    elem_type = typ
                    // After the first element, we can use the type of the first element as the hint
                    hint_elem_type = elem_type
                    first_span = elem.span

                } else if not elem_type.eq(typ) {
                    .error(Error::new_hint(
                        elem.span, `Expected type {elem_type.str()}, but got {typ.str()}`,
                        first_span, `First element was of type {elem_type.str()}`
                    ))
                    return null
                }
            }
            if not elem_type? {
                .error(Error::new(node.span, "Array literal must have at least one element"))
                return null
            }
            let arr = Type::new_resolved(Array, node.span)
            arr.u.arr.elem_type = elem_type
            arr.u.arr.size_known = true
            arr.u.arr.size = node.u.array_literal.elements.size
            return arr
        }

        else => {
            .error(Error::new(node.span, "Invalid expression in TypeChecker::check_expression"))
            return .o.error_type
        }
    }
}

// When passing an enum to `print` or to a format string, we will automatically call
// the `.dbg()` method we generate on them.
def TypeChecker::call_dbg_on_enum_value(&this, node_ptr: &&AST): &Type {
    let node: &AST = *node_ptr

    if not node.etype? return null
    if node.etype.base != BaseType::Enum return node.etype

    let member = AST::new(ASTType::Member, node.span)
    member.u.member.lhs = node
    member.u.member.rhs_name = "dbg"
    member.u.member.rhs_span = node.span

    let call = AST::new(ASTType::Call, node.span)
    call.u.call.callee = member
    call.u.call.args = Vector<&Argument>::new()

    *node_ptr = call

    return .check_expression(call)
}


def TypeChecker::check_match_for_enum(&this, enum_: &Enum, node: &AST, is_expr: bool, hint: &Type = null) {
    let mapping = Map<str, &MatchCase>::new()
    defer mapping.free()

    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for _case : cases.iter() {
        let cond = _case.cond
        let name: str

        let cond_type = .check_expression(cond, hint: enum_.type)
        if not cond_type? then continue
        if not cond_type.eq(enum_.type) {
            .error(Error::new_hint(
                cond.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{enum_.type.str()}'`
            ))
        }
        if cond_type.base != BaseType::Enum {
            .error(Error::new(cond.span, "Expected an enum value"))
            continue
        }

        name = cond.resolved_symbol.name
        let prev = mapping.get(name, null)
        if prev? {
            .error(Error::new_hint(
                cond.span, "Duplicate condition name in match",
                prev.cond.span, "This condition was previously used here"
            ))
        }
        mapping.insert(name, _case)
        if _case.body? {
            .check_expression_statement(node,  _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt
    if mapping.size != enum_.fields.size {
        if not defolt? {
            .error(Error::new_note(
                node.span, "Match does not cover all cases",
                `Only {mapping.size} of {enum_.fields.size} cases are covered`
            ))
        } else {
            .check_expression_statement(node, defolt, is_expr, hint)
        }
    } else {
        if defolt? {
            .error(Error::new(node.u.match_stmt.defolt_span, "`else` case is not needed for this match"))
        }
    }

    if is_expr and not node.etype? {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_match(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let expr = node.u.match_stmt.expr
    let expr_type = .check_expression(expr)
    if not expr_type? {
        .error(Error::new(node.span, "Match statement must have a valid expression"))
        return
    }

    if expr_type.base == BaseType::Enum {
        let enum_ = expr_type.u.enum_
        .check_match_for_enum(enum_, node, is_expr, hint)
        return
    }

    if not expr_type.is_integer() and
        not expr_type.is_str() and
        expr_type.base != BaseType::Char {
        .error(Error::new_note(
            expr.span, "This type cannot be matched on",
            `Expression type is '{expr_type.str()}'`
        ))
    }

    // Here we have either i32 or char
    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for _case : cases.iter() {
        let cond_type = .check_expression(_case.cond, hint: expr_type)
        if not cond_type? then continue
        if not cond_type.eq(expr_type) {
            .error(Error::new_hint(
                cond_type.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{cond_type.str()}'`
            ))
        }

        let is_constant = _case.cond.resolved_symbol? and _case.cond.resolved_symbol.type == Constant

        if _case.cond.type != ASTType::IntLiteral and
            _case.cond.type != ASTType::CharLiteral and
            _case.cond.type != ASTType::StringLiteral and
            not is_constant {
            .error(Error::new(_case.cond.span, "Match condition must use only literals"))
        }
        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt

    if not defolt? {
        .error(Error::new(node.span, "`else` case is missing"))
    } else {
        .check_expression_statement(node, defolt, is_expr, hint)
    }

    if is_expr and not node.etype? and not node.returns {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_if(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let cond_type = .check_expression(node.u.if_stmt.cond, hint: .get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    let body = node.u.if_stmt.body

    // `check_expression_statement` will modify this
    node.returns = true
    .check_expression_statement(node, body, is_expr, hint)

    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_expression_statement(node, else_stmt, is_expr, hint)

    } else if is_expr {
        .error(Error::new(node.span, "If expressions must have an else branch"))

    } else {
        node.returns = false
    }
}

def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool, hint: &Type) {
    match body.type {
        // If this is an expression-statement, a non-block should also be an expression
        ASTType::Match => .check_match(body, is_expr, hint)
        ASTType::If => .check_if(body, is_expr, hint)

        ASTType::Block => .check_block(body, is_expr, hint)
        else => {
            if is_expr {
                .check_expression(body, hint)
            } else {
                .check_statement(body)
            }
        }
    }

    node.returns = node.returns and body.returns

    if not is_expr return

    // For now, we'll allow expression statements to early-return from the function.
    // Maybe this should be disallowed?
    let ret = body.etype
    if body.returns {
        // Do nothing
    } else if not ret? {
        .error(Error::new(body.span, `Must yield a value in this branch, body type is {body.type}`))
    } else if not node.etype? {
        node.etype = ret
    } else if not node.etype.eq(ret) {
        .error(Error::new_note(
            body.span, "Yield type of branch doesn't match previous branches",
            `Expected type '{node.etype.str()}', got '{ret.str()}'`
        ))
    }
}


def TypeChecker::check_while(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1

    .o.push_scope(scope)
    let cond = node.u.loop.cond
    let body = node.u.loop.body

    let cond_type = .check_expression(cond, hint: .get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(body)
    .o.pop_scope()
}

def TypeChecker::check_for(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1
    .o.push_scope(scope)

    let init = node.u.loop.init
    let cond = node.u.loop.cond
    let step = node.u.loop.step
    let body = node.u.loop.body

    if init? then .check_statement(init)

    if cond? {
        let cond_type = .check_expression(cond, hint: .get_base_type(BaseType::Bool, node.span))
        if cond_type? and cond_type.base != BaseType::Bool {
            .error(Error::new_note(
                cond.span, "Condition must be a boolean",
                `Got type '{cond_type.str()}'`
            ))
        }
    }

    if step? then .check_expression(step)
    if body? then .check_statement(body)

    .o.pop_scope()
}

def TypeChecker::check_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return | ASTType::ArrowReturn => {
            let cur_func = .scope().cur_func
            if not cur_func? {
                .error(Error::new(node.span, "Cannot return from outside a function"))
                return
            }

            let expected = cur_func.return_type

            let res: &Type = null
            if node.u.child? then res = .check_expression(node.u.child, hint: expected)

            if expected.base == BaseType::Void {
                // We allow using arrow returns in void functions, they just don't return anything.
                if node.u.child? and node.type != ASTType::ArrowReturn {
                    .error(Error::new(node.span, "Cannot return a value from a void function"))
                }
            } else if node.u.child? {
                if res? and not res.eq(expected) {
                    .error(Error::new(node.span, `Return type {res.str()} does not match function return type {expected.str()}`))
                }
            } else {
                .error(Error::new(node.span, "Expected a return value for non-void function"))
            }
            node.returns = true
        }
        ASTType::Assert => {
            let expr = node.u.assertion.expr
            let expr_typ = .check_expression(expr, hint: .get_base_type(BaseType::Bool, node.span))
            if expr_typ? and expr_typ.base != BaseType::Bool {
                .error(Error::new(node.span, `Can only assert boolean types, got {expr_typ.str()}`))
            }

            if node.u.assertion.msg? {
                let msg_typ = .check_expression(node.u.assertion.msg)
                if msg_typ? and msg_typ != .get_type_by_name("str", node.span) {
                    .error(Error::new(node.span, `Can only assert strings, got {msg_typ.str()}`))
                }
            }

            if expr.type == ASTType::BoolLiteral and expr.u.bool_literal == false {
                node.returns = true
            }
        }
        ASTType::Defer => .check_statement(node.u.child)
        ASTType::Yield => {
            if not .scope().can_yield {
                .error(Error::new(node.span, "Cannot yield here"))
            }
            node.etype = .check_expression(node.u.child)
        }
        ASTType::Import => {
            .handle_import_statement(node)
        }
        ASTType::Break | ASTType::Continue => {
            if .scope().loop_count == 0 {
                .error(Error::new(node.span, `{node.type} statement outside of loop`))
            }
        }
        ASTType::If => .check_if(node, is_expr: false)
        ASTType::While => .check_while(node)
        ASTType::For => .check_for(node)
        ASTType::Block => .check_block(node, is_expr: false)
        ASTType::Match => .check_match(node, is_expr: false)
        ASTType::VarDeclaration => {
            let var = node.u.var_decl.var
            let res = .scope().lookup_local(var.sym.name)
            if res? {
                .error(Error::new(node.span, `Variable {var.sym.name} already exists in this scope`))
                return
            }

            let sym = var.sym
            .scope().insert(var.sym.name, sym)

            let is_inferred = (var.type == null)
            if is_inferred {
                var.type = Type::new_unresolved("<inferred>", node.span)

            } else {
                var.type = .resolve_type(var.type)
                if not var.type? return
            }

            let init = node.u.var_decl.init
            if init? {
                let res = .check_expression(init, hint: var.type)
                if not res? return

                if is_inferred {
                    var.type = res
                } else if not res.eq(var.type) {
                    .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {res.str()}`))
                }
            } else if is_inferred {
                .error(Error::new(node.span, `Variable {var.sym.name} has no type and no initializer`))
            }
        }
        else => {
            .check_expression(node)
        }
    }
}

def TypeChecker::check_function(&this, func: &Function) {
    .resolve_doc_links(func.sym)

    let is_templated = false
    if func.is_method and func.parent_type.base == Structure {
        let struc = func.parent_type.u.struc
        if struc.sym.is_templated() then is_templated = true
    }
    if func.sym.is_templated() is_templated = true
    if func.checked then return
    func.checked = true

    let new_scope = Scope::new(func.scope)
    let params = func.params

    // NOTE: If this is a (not-yet-specialized) template function, we're going to get a
    //       whole bunch of errors from type-checking. We don't want to report those errors
    //       to the user, because they're not really errors in the user's code, we're just
    //       doing this to make the IDE support be more useful.
    // NOTE: We're going to count the number of errors before and after type-checking the
    //       function, and if there are more errors after, we're going to remove them.
    let error_count_before = .o.program.errors.size

    .o.push_scope(func.scope)
    for param : params.iter() {
        if not param.type? then continue  // Error should be reported already
        let default_expr = param.default_value
        if default_expr? {
            // NOTE: This `.check_expression()` call uses the scope _outside_ of the function.
            //       We don't check the new scope here on purpose: the default value needs to be
            //       valid outside the scope of this function, which is where it will be evaluated.
            let default_type = .check_expression(default_expr, hint: param.type)

            if default_type? and not default_type.eq(param.type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }

        new_scope.items.insert(param.sym.name, param.sym)
    }
    .o.pop_scope()

    new_scope.cur_func = func

    if func.sym.is_extern then return

    .o.push_scope(new_scope)
    .check_statement(func.body)
    if not func.body.returns and func.return_type.base != BaseType::Void and not func.sym.full_name.eq("main") {
        .error(Error::new(func.sym.span, "Function does not always return"))
    }
    .o.pop_scope()

    // Remove the errors that were generated by type-checking the template function
    if is_templated {
        if .o.program.errors.size > error_count_before {
            .o.program.errors.size = error_count_before
        }
    }
}

def TypeChecker::handle_imports(&this, ns: &Namespace, is_global: bool = false) {
    .o.push_namespace(ns)
    .o.push_scope(ns.scope)

    for child : ns.namespaces.iter_values() {
        .handle_imports(child)
    }

    for import_ : ns.imports.iter() {
        .handle_import_statement(import_)
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::check_globals(&this, node: &AST, is_const: bool) {
    let var = node.u.var_decl.var
    .resolve_doc_links(var.sym)

    let init = node.u.var_decl.init
    if is_const {
        if init? {
            .check_const_expression(init)
        } else if not node.u.var_decl.var.sym.is_extern {
            .error(Error::new(node.span, "Constant must have an initializer"))
        }

    } else if init? {
        let init_type = .check_expression(init, hint: var.type)
        if not init_type? or not var.type? return

        if not init_type.eq(var.type) {
            .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {init_type.str()}`))
        }
    }

}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)
    .resolve_doc_links(ns.sym)

    for func : ns.functions.iter() {
        .check_function(func)
    }

    for node : ns.constants.iter() {
        .check_globals(node, is_const: true)
    }

    for node : ns.variables.iter() {
        .check_globals(node, is_const: false)
    }

    for enum_ : ns.enums.iter() {
        // Rest of the enum is already resolved
        .resolve_doc_links(enum_.sym)
        for field : enum_.fields.iter() {
            .resolve_doc_links(field.sym)
        }
    }

    for child : ns.namespaces.iter_values() {
        .check_namespace(child)
    }
    .o.pop_namespace()
    .o.pop_scope()
}

// FIXME: This should really live somewhere else...
def TypeChecker::resolve_doc_links(&this, sym: &Symbol) {
    if not (sym.comment? and .o.program.check_doc_links) return

    let buffer = Buffer::make()
    let prev = 0
    let doc = sym.comment
    let doc_len = doc.len()
    for let i = 0; i < doc_len - 1; i++ {
        if doc[i] == '\\' {
            i++

        } if doc[i] == doc[i+1] == '{' {
            buffer <<= doc.substring(prev, i-prev)
            prev = i + 2
            i++

        } else if doc[i] == doc[i+1] == '}' {
            let part = doc.substring(prev, i-prev)

            // Parse a scoped-identifier
            let lexer = Lexer::make(part, sym.span.start.filename)
            let span = Span(sym.comment_loc, sym.comment_loc)
            let tokens = lexer.lex()

            if lexer.errors.size > 0 {
                .error(Error::new(span, `Invalid link: '{part}' in this doc`))
                return
            }

            let parser = Parser::make(.o.program, .o.ns())
            parser.tokens = tokens
            parser.curr = 0

            let ident = parser.parse_scoped_identifier()
            if not ident? {
                .error(Error::new(span, `Invalid link: '{part}' in this doc`))
                return
            }

            let sym = .resolve_scoped_identifier(ident, error: false)
            if not sym? {
                .error(Error::new(span, `Couldn't find symbol '{part}' in this doc link`))
                return
            }

            let linked_part = match sym.type {
                Structure => {
                    let typ = sym.u.struc.type
                    // FIXME: Handle the case where the symbol is templated, for instance `Vec2<f32>`
                    if typ.template_instance? {
                        .error(Error::new_note(
                            span, `Cannot link directly to specialezed type '{part}'`,
                            "Try doing `{{A}}<{{B}}>` instead of `{{A<B>}}`"
                        ))
                        return
                    }
                    yield `{sym.u.struc.type:x}`
                }
                Function => `{sym.u.func:x}`
                Enum => `{sym.u.enum_.type:x}`
                TypeDef => `{sym.u.type_def:x}`
                Variable | EnumVariant => `{sym.u.var:x}`
                Constant => `{sym.u.var:x}`
                Namespace => `{sym.u.ns:x}`
            }

            buffer += "{{"
            buffer <<= linked_part
            buffer += "}}"
            std::free(part)

            prev = i + 2
            i++
        }
    }
    buffer <<= doc.substring(prev, doc_len)
    sym.comment = buffer.str()
}

def TypeChecker::check_const_expression(&this, node: &AST, hint: &Type = null): &Type {
    let typ = match node.type {
        Identifier | NSLookup => {
            let sym = .resolve_scoped_identifier(node, error: true, hint)
            if not sym? return null
            if sym.type != SymbolType::Constant {
                .error(Error::new_hint(
                    node.span, "Cannot use a non-constant value in a constant expression",
                    sym.span, "Value was defined here"
                ))
                return null
            }
            yield sym.u.var.type
        }
        IntLiteral  => .get_base_type(BaseType::I32, node.span)
        FloatLiteral => .get_base_type(BaseType::F32, node.span)
        BoolLiteral => .get_base_type(BaseType::Bool, node.span)
        CharLiteral => .get_base_type(BaseType::Char, node.span)
        StringLiteral => .get_type_by_name("str", node.span)
        BinaryOp => {
            let lhs = .check_const_expression(node.u.binary.lhs)
            let rhs = .check_const_expression(node.u.binary.rhs)
            if not lhs? or not rhs? return null

            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                .error(Error::new(node.span, "Cannot do pointer arithmetic in constant expressions"))
            }
            yield .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
        }
        UnaryOp => match node.u.unary.op {
            BitwiseNot | Negate => {
                if not hint? or not hint.is_numeric() {
                    hint = .get_base_type(BaseType::I32, node.span)
                }
                let typ = .check_const_expression(node.u.unary.expr, hint)
                if not typ? return null
                if not typ.is_numeric() {
                    .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                    return null
                }
                yield typ
            }
            else => {
                .error(Error::new(node.span, f"Unsupported operator in constant expression: {node.u.unary.op}"))
                return null
            }
        }
        else => {
            .error(Error::new(node.span, "Unsupported operator in constant expression"))
            return null
        }
    }
    node.etype = typ
    return typ
}

def TypeChecker::handle_import_path_base(&this, imp: &Import, parts: &Vector<&ImportPart>, base: &Symbol, alias: str, start_idx: i32) {
    for let i = start_idx as u32; i < parts.size; i += 1 {
        let part = parts.at(i)

        match part.type {
            Wildcard => {
                .o.import_all_from_symbol(base, imp.export)
                return
            }
            Multiple => {
                let paths = part.u.paths
                for let j = 0; j < paths.size; j += 1 {
                    let path = paths.at(j)
                    .handle_import_path_base(imp, path, base, alias, 0)
                }
                return
            }
            Single => {} // continue below
        }

        let name = part.u.single.name
        if name.eq("this") then {
            if i + 1 != parts.size {
                .error(Error::new(part.span, "`this` can only be used as the last part of an import path"))
                return
            }
            if part.u.single.alias? then alias = part.u.single.alias
            break
        }

        let new_base = .o.lookup_in_symbol(base, name, part.u.single.alias_span, error: false)
        if not new_base? {
            .error(Error::new(part.span, `Invalid import, namespace {name} does not exist`))
            return
        }

        base = new_base
        alias = part.u.single.alias
        if not alias? then alias = name
        part.resolved_symbol = base
    }

    .o.insert_into_scope_checked(base, name: alias)
    if imp.export {
        .o.ns().exported_symbols.insert(alias, base)
    }
}

//* Insert all the imported items into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST) {
    let path = node.u.import_path

    // NOTE: This is a little weird, but the first part of the import can either be a symbol in
    //       some namespace (global / parent), or it can be in the current scope. To handle these
    //       cases, we just manually import the first part from these different locations, and then
    //       loop over the rest of the parts.
    let part = path.parts.at(0)
    if part.type != Single {
        .error(Error::new(part.span, "Invalid import, first part must be a single identifier"))
        return
    }

    let name = part.u.single.name
    let alias = part.u.single.alias
    if not alias? then alias = name

    let base = match path.type {
        GlobalNamespace => {
            yield .o.program.global.find_importable_symbol(name)
        }
        ProjectNamespace => {
            let project_root = .o.ns().get_project_root(node.span, .o.program)
            if not project_root? return
            yield project_root.find_importable_symbol(name)
        }
        ParentNamespace => {
            let cur = .o.ns()
            for let i = 0; i < path.parent_count; i += 1 {
                if not cur.parent? {
                    // This should never happen, because the parser is responsible for handling this
                    .error(Error::new(node.span, "Cannot import from parent of root namespace")).panic()
                    return
                }
                cur = cur.parent
            }
            yield cur.find_importable_symbol(name)
        }

        // This is the special case: a `Symbol` can't hold a scope, so we can't just
        // wrap all 3 cases into a symbol and avoid the manual lookup.
        CurrentScope => {
            yield .o.scope().lookup_recursive(name)
        }
    }

    if not base? {
        .error(Error::new(part.span, `Couldn't import {name}`))
        return
    }

    part.resolved_symbol = base
    .handle_import_path_base(&path, path.parts, base, alias, start_idx: 1)
}

def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {
    if func.is_method {
        let parent_span = func.parent_type.span
        let parent_type = .resolve_type(func.parent_type, allow_incomplete: true)
        if not parent_type? {
            .o.error(Error::new(parent_span, "Could not find this type"))
            return
        }

        if not parent_type.can_have_methods() {
            .o.error(Error::new(parent_span, "This type cannot have methods"))
            return
        }

        match parent_type.base {
            Structure => {
                let struc = parent_type.u.struc
                let name = struc.get_field(func.sym.name)
                if name? {
                    .o.error(Error::new_hint(
                        func.sym.span, "Field with this name already exists",
                        name.sym.span, "Previous definition here"
                    ))
                }
            }
            Enum => {
                let enum_ = parent_type.u.enum_
                let name = enum_.get_field(func.sym.name)
                if name? {
                    .o.error(Error::new_hint(
                        func.sym.span, "Enum value with this name already exists",
                        name.sym.span, "Previous definition here"
                    ))
                }
            }
            // Builtin type
            else => {}
        }

        let res = parent_type.methods.get(func.sym.name, null)
        if res? {
            .o.error(Error::new_hint(
                func.sym.span, "Method with this name already exists",
                res.sym.span, "Previous definition here"
            ))
            return
        }

        // Now that the parent type is valid, we need to update the symbol table with the updated
        // display and output names for the function
        func.sym.update_parent(parent_type.sym)

        parent_type.methods.insert(func.sym.name, func)
        func.parent_type = parent_type

    } else {
        let item = func.sym
        .o.insert_into_scope_checked(item)
    }

    func.scope = .scope()
}

// We can't really fully resolve the types for the template struct itself, but we can
// try to evaluate some of the explicit types so we have some more information.
def TypeChecker::loosely_resolve_templated_struct(&this, struc: &Structure) {
    for field : struc.fields.iter() {
        // Don't error here, we'll do that later when we specialize the struct
        let res = .resolve_type(field.type, allow_incomplete: true, error: false, resolve_templates: false)
        field.type = res
    }
}

def TypeChecker::resolve_struct(&this, struc: &Structure) {
    let fields = struc.fields
    .resolve_doc_links(struc.sym)

    // We cannot resolve templated structs.
    if struc.sym.is_templated() {
        .loosely_resolve_templated_struct(struc)
        return
    }

    for field : fields.iter() {
        let res = .resolve_type(field.type)
        .resolve_doc_links(field.sym)
        if not res? {
            .o.error(Error::new(field.sym.span, "Couldn't resolve type"))
        } else {
            field.type = res
        }
    }
}

def TypeChecker::check_function_declaration(&this, func: &Function) {
    let allow_incomplete = false
    let error = true
    let resolve_templates = true

    if func.is_method and func.parent_type.base == Structure {
        let struc = func.parent_type.u.struc
        if struc.sym.is_templated() {
            allow_incomplete = true
            error = false
            resolve_templates = false
        }
    }
    if func.sym.is_templated() {
        allow_incomplete = true
        error = false
        resolve_templates = false
    }

    func.return_type = .resolve_type(func.return_type, allow_incomplete, error, resolve_templates)
    if not func.return_type? {
        func.return_type = .get_base_type(BaseType::Void, func.sym.span)
    }

    for param : func.params.iter() {
        param.type = .resolve_type(param.type, allow_incomplete, error, resolve_templates)
    }

    if func.operator_overloads? {
        for op : func.operator_overloads.iter() {
            let num_params_needed = op.num_overload_params()
            if num_params_needed != func.params.size {
                .error(Error::new(func.sym.span, `Operator overload for {op} must have {num_params_needed} parameters`))
                continue
            }

            let overload: OperatorOverload
            overload.op = op
            if num_params_needed > 0 then overload.type1 = func.params.at(0).type
            if num_params_needed > 1 then overload.type2 = func.params.at(1).type
            if num_params_needed > 2 then overload.type3 = func.params.at(2).type

            if op.needs_lhs_pointer_for_overload() {
                let type1 = overload.type1.unaliased()
                if type1.base != Pointer {
                    .error(Error::new(func.sym.span, f"First parameter of {op} operator must be a pointer-type"))
                    continue
                }
            }

            let it = .o.program.operator_overloads.get_item(overload)
            if it? {
                if it.value != func {
                    .error(Error::new_hint(
                        func.sym.span, `Operator overload for {op} already exists ({func.sym.display})`,
                        it.value.sym.span, `Previous definition here ({it.value.sym.display})`
                    ))
                }
                continue
            }

            .o.program.operator_overloads.insert(overload, func)
        }
    }


    // A function keeps track of a type that represents an equivalent function pointer type
    // This is used for type checking function calls
    let typ = Type::new_resolved(Function, func.sym.span)
    typ.u.func = FunctionType(func, func.params, func.return_type, func.is_variadic)
    func.type = typ
}

def TypeChecker::try_resolve_typedefs_in_namespace(&this, ns: &Namespace, pre_import: bool) {
    for it : ns.typedefs.iter() {
        if it.value.is_resolved() continue

        let sym = .o.scope().lookup_recursive(it.key)
        assert sym?, "Should have added the symbol into scope already"

        // FIXME: Why is there a `typedef` and `alias` at symbol/type level? Only one
        // should really be sufficient.
        assert sym.type == TypeDef

        // We only want to error out if we can't resolve this typedef _after_ importing
        let res = .resolve_type(
            it.value,
            allow_incomplete: false,
            error: not pre_import
        )
        if not res? continue
        sym.u.type_def.u.ptr = res
        sym.u.type_def = res
        it.value = res
    }
}

def TypeChecker::check_post_import(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)

    for func : ns.functions.iter() {
        .check_function_declaration(func)
    }

    for struc : ns.structs.iter() {
        .resolve_struct(struc)
    }

    for node : ns.constants.iter() {
        .pre_check_globals(node, is_const: true)
    }

    for node : ns.variables.iter() {
        .pre_check_globals(node, is_const: false)
    }

    // We try to resolve post-imports so typedefs can use imported types
    .try_resolve_typedefs_in_namespace(ns, pre_import: false)

    for child : ns.namespaces.iter_values() {
        .check_post_import(child)
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::pre_check_globals(&this, node: &AST, is_const: bool) {
    let var = node.u.var_decl.var
    if not var.type? {
        let c = if is_const "Constant" else "Global variable"
        .error(Error::new(node.span, f"{c} must have a type"))
        return
    }
    let type = .resolve_type(var.type)
    if not type? then return
    var.type = type
}

def TypeChecker::check_pre_import(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)

    for func : ns.functions.iter() {
        .pre_check_function(ns, func)
    }

    // FIXME: This shouldn't need to be done, only post-imports. there's some issue
    //        with how typedefs are added to namespaces/scopes that needs to be fixed.
    //        Removing this line causes `tests/import_typedef.oc` to fail.
    .try_resolve_typedefs_in_namespace(ns, pre_import: true)

    for child : ns.namespaces.iter_values() {
        .check_pre_import(child)
    }

    .o.pop_scope()
}

def TypeChecker::run(program: &Program) {
    let pass = TypeChecker(
        o: GenericPass::new(program),
        unchecked_functions: Vector<&Function>::new()
    )
    pass.check_pre_import(program.global)
    pass.handle_imports(program.global, is_global: true)
    pass.check_post_import(program.global)

    pass.check_namespace(program.global)

    while pass.unchecked_functions.size > 0 {
        let func = pass.unchecked_functions.pop() as &Function
        pass.check_function(func)
    }
}
