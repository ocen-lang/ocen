import std::vector::OldVector
import std::span::Span
import std::buffer::Buffer
import std::map::Map
import @ast::scopes::{ Scope, Symbol, SymbolType }
import @ast::program::{ Program, Namespace }
import @errors::Error
import @passes::generic_pass::GenericPass
import @types::{ Type, BaseType, FunctionType }
import @ast::nodes::*

// This pass actually goes through the AST and checks the types of all the nodes.
// Any remaining unresolved types should be resolved after this

struct TypeChecker {
    o: &GenericPass
}

// Some convenience accessors from the GenericPass
def TypeChecker::error(&this, err: &Error): &Error => .o.error(err)
def TypeChecker::scope(&this): &Scope => .o.scope()

def TypeChecker::resolve_type(&this, old: &Type, allow_incomplete: bool = false): &Type {
    let resolved = old
    match old.base {
        Pointer | Alias => {
            let ptr = .resolve_type(old.u.ptr)
            if not ptr? return null
            resolved.u.ptr = ptr
        }
        Function => {
            let func = old.u.func
            for let i = 0; i < func.params.size; i += 1 {
                let var = func.params.at(i) as &Variable
                var.type = .resolve_type(var.type)
                if not var.type? return null
            }
            func.return_type = .resolve_type(func.return_type)
            if not func.return_type? return null
        }
        Unresolved => {
            let res = .resolve_scoped_identifier(old.u.unresolved, error: false)
            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = res.u.type_def
                    SymbolType::Structure => {
                        let struc = res.u.struc
                        if struc.is_templated and not allow_incomplete {
                            .error(Error::new(old.span, `Cannot use templated struct {struc.sym.name} as a type`))
                            return null
                        }
                        resolved = res.u.struc.type
                    }
                    SymbolType::Enum => resolved = res.u.enum_.type
                    else => {
                        .error(Error::new(res.span, `Cannot use {res.display} as a type`))
                        resolved = null
                    }
                }
            } else {
                .error(Error::new(old.u.unresolved.span, "Could not find type with this name"))
                resolved = null
            }
        }
        Array => {
            let arr = old.u.arr
            arr.elem_type = .resolve_type(arr.elem_type)
            if not arr.elem_type? return null
            let res = .check_expression(arr.size_expr)
            if not res? return null
        }
        Structure | Char | Bool | Void | I8 | I16 |
        I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 |
        Enum => {}

        else => {
            .error(Error::new(old.span, `Unhandled type in resolve {old.base.str()}`))
            resolved = null
        }
    }
    return resolved
}

def TypeChecker::resolve_templated_struct_methods(&this, old: &Structure, cur: &Structure) {
    let old_type = old.type
    let cur_type = cur.type

    let old_methods = old_type.methods
    let cur_methods = cur_type.methods

    for let iter = old_methods.iter(); iter.cur?; iter.next() {
        let name = iter.key()
        let method = iter.value() as &Function

        let new_method = .o.program.get_function_deep_copy(method, .o.ns())
        new_method.parent_type = cur_type
        cur_methods.insert(name, new_method)

        new_method.sym.update_parent(cur_type.sym)
        .o.ns().functions.push(new_method)

        if not method.is_static {
            let this_param = new_method.params.at(0) as &Variable
            if this_param.type.base == Pointer {
                this_param.type.u.ptr = cur_type
            } else {
                this_param.type = cur_type
            }
        }

        .check_function_declaration(new_method)
        .check_function(.scope(), new_method)
    }
}

def TypeChecker::resolve_templated_struct(&this, struc: &Structure, node: &AST): &Symbol {
    // If we've already resolved this template, just return the symbol
    {
        let found = struc.find_template_instance(node.u.spec.template_args)
        if found? return found
    }

    // OK, so we need to make a new instance of this template (aka a specialization)
    let resolved_struc = Structure::new()

    // This is the scope that we'll use to resolve the template parameters
    let scope = Scope::new(.scope())
    .o.push_scope(scope)

    // Some sanity checks
    let template_params = struc.template_params
    let template_args = node.u.spec.template_args
    if template_params.size != template_args.size {
        .error(Error::new(node.span, `Invalid number of template arguments for {struc.sym.name}`))
        return null
    }

    // Want to also build a new display name for the specialization
    let new_display_name = Buffer::make()
    new_display_name.puts(struc.sym.name)
    new_display_name.puts("<")

    // Add the template arguments to the scope with corresponding names
    for let i = 0; i < template_params.size; i += 1 {
        let param = template_params.at(i) as &Variable
        let arg = template_args.at(i) as &Type

        if i > 0 then new_display_name.puts(", ")
        new_display_name.puts(arg.str())

        let sym = Symbol::new(
            TypeDef,
            param.sym.name, // name
            param.sym.name, // display
            param.sym.name, // out_name
            param.sym.span,
        )
        sym.u.type_def = arg
        .o.insert_into_scope_checked(sym)
    }

    new_display_name.puts(">")

    // Update the display/output name of the specialization
    // FIXME: Maybe a better name-mangling scheme? This is not very debuggable.
    let new_out_name = `{struc.sym.out_name}__{struc.template_instances.size}`
    let sym = Symbol::new_with_parent(Structure, .o.ns().sym, new_out_name, struc.sym.span)
    sym.display = new_display_name.str()

    sym.u.struc = resolved_struc
    resolved_struc.sym = sym

    // Note: We _need_ to deep-copy the fields here, otherwise we'll end up with a bunch of
    // pointers to the same types across different specializations, which is not what we want.
    for let i = 0; i < struc.fields.size; i += 1 {
        let field = struc.fields.at(i) as &Variable

        let new_type = .o.program.get_type_deep_copy(field.type, .o.ns())
        let new_field = Variable::new(new_type)
        new_field.sym = Symbol::from_local_variable(field.sym.name, new_field, field.sym.span)

        resolved_struc.fields.push(new_field)
    }

    let instance = TemplateInstance::new(template_args, sym)
    struc.template_instances.push(instance)

    let typ = Type::new_resolved(Structure, sym.span)
    typ.u.struc = resolved_struc
    resolved_struc.type = typ
    typ.sym = sym

    // Resolve the types of the fields
    .resolve_struct(resolved_struc)

    // Instantiate all the methods for this specialization
    .resolve_templated_struct_methods(struc, resolved_struc)

    .o.pop_scope()
    return sym
}

def TypeChecker::resolve_scoped_identifier(&this, node: &AST, error: bool = true, hint: &Type = null): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            let lhs_span = node.u.lookup.lhs.span
            let lhs = .resolve_scoped_identifier(node.u.lookup.lhs)
            if not lhs? return null

            let name = node.u.lookup.rhs_name
            let res = .o.lookup_in_symbol(lhs, name, error)
            node.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = null as &Symbol

            // If we know that the type of this identifier is supposed to be a particular enum,
            // then we can look up the field in that enum implicitly.
            if hint? and hint.base == Enum {
                let enum_ = hint.u.enum_
                let field = enum_.get_field(name) as &Variable
                if field? {
                    res = field.sym
                }
            }

            if not res? {
                res = .scope().lookup_recursive(name)
            }

            node.resolved_symbol = res
            if error and not res? {
                .error(Error::new(node.span, "Couldn't find this identifier"))
            }
            return res
        }
        ASTType::Specialization => {
            let base = .resolve_scoped_identifier(node.u.spec.base)
            if not base? return null

            let args = node.u.spec.template_args
            let failed = false
            for let i = 0; i < args.size; i += 1 {
                let resolved_arg = .resolve_type(args.at(i))
                if not resolved_arg? {
                    failed = true
                    continue
                }
                args.data[i] = resolved_arg
            }
            if failed return null

            match base.type {
                Structure => {
                    let struc = base.u.struc
                    if not struc.is_templated {
                        .error(Error::new(node.span, "Can only specialize a templated structure"))
                        return null
                    }

                    let res = .resolve_templated_struct(struc, node)
                    node.resolved_symbol = res
                    return res
                }
                else => {
                    .error(Error::new(node.span, "Can only specialize a templated structure"))
                    return null
                }
            }
        }
        else => {
            .error(Error::new(node.span, `Don't know how to resolve node type {node.type}`))
            return null
        }
    }
}

def TypeChecker::check_block(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let block = &node.u.block

    let scope = Scope::new(.scope())
    scope.can_yield = scope.can_yield or is_expr
    block.scope = scope

    .o.push_scope(block.scope)
    let stmts = block.statements
    let yield_span = Span::default()
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt)
        if stmt.returns then node.returns = true

        if stmt.type != Yield then continue
        if node.etype? {
            .error(Error::new_hint(
                stmt.span, "Cannot yield multiple times in a block",
                yield_span, "Previously yielded here"
            ))
        }
        node.etype = stmt.etype
        yield_span = stmt.span
    }
    .o.pop_scope()
}

def TypeChecker::check_method_call(&this, method: &Function, node: &AST) {
    let callee = node.u.call.callee
    if callee.type != ASTType::Member and callee.type != ASTType::NSLookup {
        .error(Error::new(callee.span, "Method call is not to a member, internal compiler error"))
        return
    }

    // Due to the way we handle typechecking, we might run this function twice
    // on the same node. This is fine, but we need to make sure we don't double
    // add the method argument twice implicitly.
    if node.u.call.added_method_arg return
    node.u.call.added_method_arg = true

    if callee.type != ASTType::Member return
    if method.params.size == 0 {
        // This should ideally never happen.
        .error(Error::new(callee.span, "Instance method should have `this` argument, internal error"))
        return
    }
    let method_param = (method.params.at(0) as &Variable).type
    if not method_param? return

    let member = callee.u.member
    let first_arg = member.lhs

    if member.is_pointer and method_param.base != Pointer {
        first_arg = AST::new_unop(ASTType::Dereference, first_arg.span, first_arg)
    } else if not member.is_pointer and method_param.base == Pointer {
        first_arg = AST::new_unop(ASTType::Address, first_arg.span, first_arg)
    }
    node.u.call.args.push_front(Argument::new(null, Span::default(), first_arg))
}

def TypeChecker::check_internal_print(&this, node: &AST): &Type {
    let args = node.u.call.args
    if args.size < 1 {
        .o.error(Error::new(
            node.span, "Function requires at least one argument"
        ))
    }
    let first = args.at(0) as &Argument
    let first_type = .check_expression(first.expr)
    if first_type? and not first_type.is_str() {
        .o.error(Error::new(
            first.expr.span, `First argument must be a string literal, got {first_type.str()}`
        ))
    }

    for let i = 1; i < args.size; i += 1 {
        let arg = args.at(i) as &Argument
        .check_expression(arg.expr)
        .call_dbg_on_enum_value(&arg.expr)
    }

    return .o.get_base_type(Void, node.span)
}

def TypeChecker::check_constructor(&this, node: &AST): &Type {
    node.u.call.is_constructor = true

    let callee = node.u.call.callee
    let struc = callee.resolved_symbol.u.struc

    let params = struc.fields

    .check_call_args(node, params)

    return struc.type
}

def TypeChecker::check_call_args(&this, node: &AST, params: &OldVector) {
    let args = node.u.call.args
    if params.size < args.size {
        .error(Error::new(node.span, `Too many arguments, expected {params.size} but got {args.size}`))
    }

    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable
        // Normal case
        if i < args.size {
            let arg = args.at(i) as &Argument

            if arg.label? and not arg.label.eq(param.sym.name) {
                .error(Error::new(arg.label_span, `Argument label '{arg.label}' does not match parameter name '{param.sym.name}'`))
            }

            let arg_type = .check_expression(arg.expr, hint: param.type)
            if not arg_type? or not param.type? then continue
            if not arg_type.eq(param.type) {
                .error(Error::new(arg.expr.span, `Argument {param.sym.name} has type {arg_type.str()} but expected {param.type.str()}`))
            }

        // Default argument case
        } else if param.default_value? {

            // FIXME: We should not be evaluating the default argument here during every call,
            // we should be evaluating it at the time of checking the function declaration and using
            // a cached value here
            let new_arg = Argument::new(label: null, label_span: Span::default(), expr: param.default_value)
            // Plus the default argument to the list of arguments
            args.push(new_arg)

        } else {
            .error(Error::new(node.span, `Missing required argument {param.sym.name}`))
        }
    }
}

def TypeChecker::check_call(&this, node: &AST): &Type {
    let callee = node.u.call.callee
    let args = node.u.call.args

    // FIXME: this is a fucking abonimation
    if callee.type == ASTType::Identifier {
        callee.u.ident.is_function = false
        let name = callee.u.ident.name

        if name.eq("print") or name.eq("println") {
            return .check_internal_print(node)
        }
    }

    let res = match callee.type {
        Member => .check_member(callee, is_being_called: true)
        Identifier | NSLookup => {
            let sym = .resolve_scoped_identifier(callee, error: true)
            if not sym? return null
            callee.resolved_symbol = sym

            yield match sym.type {
                Structure => {
                    return .check_constructor(node)
                }
                else => .check_expression(callee)
            }
        }
        else => .check_expression(callee)
    }
    if not res? return null

    if res.base != BaseType::Function {
        .error(Error::new(callee.span, `Cannot call a non-function type: {res.str()}`))
        return null
    }

    let func = res.u.func
    if func.orig? and func.orig.exits then node.returns = true
    let params = func.params

    if func.orig? and func.orig.is_method and not func.orig.is_static {
        .check_method_call(func.orig, node)
    }

    .check_call_args(node, params)

    if func.orig? {
        node.u.call.is_function_pointer = false
        node.u.call.func = func.orig
    }

    return func.return_type

}

def TypeChecker::check_pointer_arith(&this, node: &AST, _lhs: &Type, _rhs: &Type): &Type {
    if node.type == ASTType::Plus or node.type == ASTType::Minus {
        if _lhs.base == BaseType::Pointer and _rhs.is_integer() {
            return _lhs
        }
        if _lhs.is_integer() and _rhs.base == BaseType::Pointer {
            return _rhs
        }
        if _lhs.eq(_rhs) and _lhs.base == BaseType::Pointer {
            if node.type == ASTType::Minus {
                return .o.get_base_type(BaseType::I64, node.span)
            }
        }
    }
    .error(Error::new(node.span, "Invalid pointer arithmetic"))
    return null
}

def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    match node.type {
        Plus | Minus | Multiply | Divide => {
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                return .check_pointer_arith(node, lhs, rhs)
            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else {
                return lhs
            }
        }
        PlusEquals | MinusEquals | DivideEquals | MultiplyEquals => {
            if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            let lhs_node = node.u.binary.lhs
            if not lhs_node.is_lvalue() {
                .error(Error::new(node.span, "Left hand side of assignment must be assignable"))
                return null
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            }
            return lhs
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            if not lhs.is_numeric_or_char() or not rhs.is_numeric_or_char() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric or char types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        Equals | NotEquals => {
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if lhs.base == BaseType::Structure {
                .error(Error::new(node.span, "Cannot compare structs directly"))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        And | Or => {
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                .error(Error::new_note(
                    node.span, "Operands must be boolean",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        Modulus | BitwiseOr | BitwiseAnd | BitwiseXor | LeftShift | RightShift => {
            if not lhs.is_integer() or not rhs.is_integer() {
                .error(Error::new_note(
                    node.span, "Operator requires integer types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return lhs
        }
        else => std::panic(`Internal error: unhandled op in check_binary_op: {node.type}`)
    }
}

def TypeChecker::check_format_string(&this, node: &AST): &Type {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs

    if parts.size != exprs.size + 1 {
        .error(Error::new(node.span, "Number of format string parts does not match number of expressions"))
    }

    for let i = 0; i < exprs.size; i += 1 {
        let expr = exprs.at(i) as &AST
        let typ = .check_expression(expr)
        if not typ? continue

        typ = .call_dbg_on_enum_value(&expr)
        exprs.data[i] = expr

        if not typ? continue

        match typ.unaliased().base {
            Bool | Char | I8 | I16 | I32 | I64 | U8 | U16 |
            U32 | U64 | F32 | F64 | Pointer => {}
            else => .error(Error::new(
                expr.span, `Only strings / builtin types can be formatted, got type '{typ.str()}'`
            ))
        }
    }

    return .o.get_type_by_name("str", node.span)
}

def TypeChecker::check_member(&this, node: &AST, is_being_called: bool): &Type {
    let lhs = .check_expression(node.u.member.lhs)
    if not lhs? return null

    // How would this work for strings?
    let is_pointer = false
    if lhs.base == BaseType::Pointer {
        is_pointer = true

        if not lhs.u.ptr? {
            .error(Error::new(lhs.span, "Got unresolved type"))
            return null
        }

        lhs = lhs.u.ptr
    }

    if lhs.base == BaseType::Structure {
        let struc = lhs.u.struc
        let field = struc.get_field(node.u.member.rhs_name)
        if field? {
            node.u.member.is_pointer = is_pointer
            return field.type
        }
    }

    if lhs.can_have_methods() {
        let method = lhs.methods.get(node.u.member.rhs_name) as &Function
        if method? {
            if not is_being_called {
                .error(Error::new(node.span, "Cannot access method without calling it"))
                return null
            }
            if method.is_static {
                .error(Error::new(node.span, "Cannot call static method as instance method"))
                return null
            }
            node.u.member.is_pointer = is_pointer
            node.resolved_symbol = method.sym
            return method.type
        }
    }

    .error(Error::new(node.span, `Type {lhs.str()} has no member named '{node.u.member.rhs_name}'`))
    return null
}


// This is just here so we can use early exits in the actual check_expression
// function, and still always assign the type to the node's etype field
def TypeChecker::check_expression(&this, node: &AST, hint: &Type = null): &Type {
    let typ = .check_expression_helper(node, hint)
    if typ? then typ = typ.decay_array()
    node.etype = typ
    return typ
}

def TypeChecker::check_expression_helper(&this, node: &AST, hint: &Type): &Type {
    match node.type {
        ASTType::IntLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_integer() then return hint
            return .o.get_base_type(BaseType::U32, node.span)
        }
        ASTType::FloatLiteral => {
            if node.u.num_literal.suffix? {
                return .resolve_type(node.u.num_literal.suffix)
            }
            if hint? and hint.is_float() then return hint
            return .o.get_base_type(BaseType::F32, node.span)
        }
        ASTType::StringLiteral => {
            return .o.get_type_by_name("str", node.span)
        }
        ASTType::Null => return .o.get_type_by_name("untyped_ptr", node.span)
        ASTType::Cast => {
            let typ = .check_expression(node.u.cast.lhs)
            if not typ? return null
            let target = .resolve_type(node.u.cast.to)
            if not target? return null
            // FIXME: Disallow invalid casts
            return target
        }
        ASTType::FormatStringLiteral => {
            return .check_format_string(node)
        }
        ASTType::CharLiteral => {
            return .o.get_base_type(BaseType::Char, node.span)
        }
        ASTType::BoolLiteral => {
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        ASTType::Negate => {
            if not hint? {
                hint = .o.get_base_type(BaseType::I32, node.span)
            }
            let typ = .check_expression(node.u.unary, hint)
            if not typ? return null
            if not typ.is_numeric() {
                .error(Error::new(node.span, `Cannot negate non-numeric type: {typ.str()}`))
                return null
            }
            return typ
        }
        ASTType::BitwiseNot => {
            let typ = .check_expression(node.u.unary, hint)
            if not typ? return null
            if not typ.is_integer() {
                .error(Error::new(node.span, `Cannot do bitwise-not on non-integer type: {typ.str()}`))
                return null
            }
            return typ
        }
        ASTType::IsNotNull => {
            let typ = .check_expression(node.u.unary)
            if not typ? return null
            typ = typ.unaliased()
            if typ.base != BaseType::Pointer {
                .error(Error::new(node.span, `Can only use ? on pointer types, got {typ.str()}`))
            }
            return .o.get_base_type(BaseType::Bool, node.span)
        }
        ASTType::Not => {
            let typ = .check_expression(node.u.unary, hint: .o.get_base_type(BaseType::Bool, node.span))
            if not typ? return null
            if typ.base != BaseType::Bool {
                .error(Error::new(node.span, `Cannot negate non-boolean type: {typ.str()}`))
                return null
            }
            return typ
        }
        ASTType::Address => {
            let typ = .check_expression(node.u.unary)
            if not typ? return null

            match typ.base {
                BaseType::Char => return .o.get_type_by_name("str", node.span)
                BaseType::Void => return .o.get_type_by_name("untyped_ptr", node.span)
                else => {
                    let ptr = Type::new_resolved(BaseType::Pointer, node.span)
                    ptr.u.ptr = typ
                    return ptr
                }
            }
        }
        ASTType::Dereference => {
            let typ = .check_expression(node.u.unary)
            if not typ? return null
            if typ.base != BaseType::Pointer {
                .error(Error::new(node.span, `Cannot dereference non-pointer type: {typ.str()}`))
                return null
            }
            return typ.u.ptr
        }
        ASTType::Member => return .check_member(node, is_being_called: false)
        ASTType::SizeOf => {
            let typ = .resolve_type(node.u.size_of_type)
            if not typ? return null
            node.u.size_of_type = typ
            return .o.get_base_type(BaseType::U32, node.span)
        }
        ASTType::If => {
            .check_if(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Block => {
            .check_block(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Match => {
            .check_match(node, is_expr: true, hint)
            return node.etype
        }
        ASTType::Index => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs? or not rhs? return null
            if not rhs.is_integer() {
                .error(Error::new(node.span, `Index must be an integer, got {rhs.str()}`))
                return null
            }
            lhs = lhs.unaliased()
            match lhs.base {
                BaseType::Array => return lhs.u.arr.elem_type
                BaseType::Pointer => return lhs.u.ptr
                else => {
                    .error(Error::new(node.span, `Cannot index type {lhs.str()}`))
                    return null
                }
            }
        }
        ASTType::Identifier | ASTType::NSLookup => {
            let item = .resolve_scoped_identifier(node, error: true, hint)
            if not item? return null

            match item.type {
                Function => return item.u.func.type
                Variable | Constant => return item.u.var.type
                Structure => {
                    .error(Error::new(node.span, "Cannot use a struct name as an expression"))
                    return null
                }
                Enum => {
                    .error(Error::new(node.span, "Cannot use an enum name as an expression"))
                    return null
                }
                Namespace => {
                    .error(Error::new(node.span, "Cannot use a namespace as an expression"))
                    return null
                }
                TypeDef => {
                    // Fixme: How will this work with struct constructors?
                    .error(Error::new(node.span, "Cannot use a type name as an expression"))
                    return null
                }
            }
        }
        ASTType::Call => return .check_call(node)

        // Binary operators
        Plus |
        Minus |
        Multiply |
        Divide |
        LessThan |
        LessThanEquals |
        GreaterThan |
        GreaterThanEquals |
        Equals |
        NotEquals |
        PlusEquals |
        MinusEquals |
        MultiplyEquals |
        DivideEquals |
        And |
        Or |
        Modulus |
        BitwiseOr |
        BitwiseAnd |
        BitwiseXor |
        LeftShift |
        RightShift => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
            if not lhs? or not rhs? return null
            return .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
        }

        Assignment => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs, hint: lhs)
            if not lhs? or not rhs? return null

            if not node.u.binary.lhs.is_lvalue() {
                .error(Error::new(node.u.binary.lhs.span, "Must be an l-value"))
            }
            if not lhs.eq(rhs) {
                .error(Error::new(
                    node.span, `Variable type does not match assignment type, Expected type '{lhs.str()}', got '{rhs.str()}'`
                ))
            }
            return lhs
        }

        else => {
            .error(Error::new(node.span, "Invalid expression in TypeChecker::check_expression"))
            return .o.error_type
        }
    }
}

// When passing an enum to `print` or to a format string, we will automatically call
// the `.dbg()` method we generate on them.
def TypeChecker::call_dbg_on_enum_value(&this, node_ptr: &&AST): &Type {
    let node: &AST = *node_ptr

    if not node.etype? return null
    if node.etype.base != BaseType::Enum return node.etype

    let member = AST::new(ASTType::Member, node.span)
    member.u.member.lhs = node
    member.u.member.rhs_name = "dbg"
    member.u.member.rhs_span = node.span

    let call = AST::new(ASTType::Call, node.span)
    call.u.call.callee = member
    call.u.call.args = OldVector::new()

    *node_ptr = call

    return .check_expression(call)
}


def TypeChecker::check_match_for_enum(&this, enum_: &Enum, node: &AST, is_expr: bool, hint: &Type = null) {
    let mapping = Map::new()
    defer mapping.free()

    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond = _case.cond
        let name: str

        let cond_type = .check_expression(cond, hint: enum_.type)
        if not cond_type? then continue
        if not cond_type.eq(enum_.type) {
            .error(Error::new_hint(
                cond.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{enum_.type.str()}'`
            ))
        }
        if cond_type.base != BaseType::Enum {
            .error(Error::new(cond.span, "Expected an enum value"))
            continue
        }

        name = cond.resolved_symbol.name
        let prev = mapping.get(name) as &MatchCase
        if prev? {
            .error(Error::new_hint(
                cond.span, "Duplicate condition name in match",
                prev.cond.span, "This condition was previously used here"
            ))
        }
        mapping.insert(name, _case)
        if _case.body? {
            .check_expression_statement(node,  _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt
    if mapping.num_items != enum_.fields.size {
        if not defolt? {
            .error(Error::new_note(
                node.span, "Match does not cover all cases",
                `Only {mapping.num_items} of {enum_.fields.size} cases are covered`
            ))
        } else {
            .check_expression_statement(node, defolt, is_expr, hint)
        }
    } else {
        if defolt? {
            .error(Error::new(node.u.match_stmt.defolt_span, "`else` case is not needed for this match"))
        }
    }

    if is_expr and not node.etype? {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_match(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let expr = node.u.match_stmt.expr
    let expr_type = .check_expression(expr)
    if not expr_type? {
        .error(Error::new(node.span, "Match statement must have a valid expression"))
        return
    }

    if expr_type.base == BaseType::Enum {
        let enum_ = expr_type.u.enum_
        .check_match_for_enum(enum_, node, is_expr, hint)
        return
    }

    if not expr_type.is_integer() and
        not expr_type.is_str() and
        expr_type.base != BaseType::Char {
        .error(Error::new_note(
            expr.span, "This type cannot be matched on",
            `Expression type is '{expr_type.str()}'`
        ))
    }

    // Here we have either i32 or char
    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond_type = .check_expression(_case.cond, hint: expr_type)
        if not cond_type? then continue
        if not cond_type.eq(expr_type) {
            .error(Error::new_hint(
                cond_type.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{cond_type.str()}'`
            ))
        }
        if _case.cond.type != ASTType::IntLiteral and
            _case.cond.type != ASTType::CharLiteral and
            _case.cond.type != ASTType::StringLiteral {
            .error(Error::new(_case.cond.span, "Match condition must use only literals"))
        }
        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr, hint)
        }
    }

    let defolt = node.u.match_stmt.defolt

    if not defolt? {
        .error(Error::new(node.span, "`else` case is missing"))
    } else {
        .check_expression_statement(node, defolt, is_expr, hint)
    }

    if is_expr and not node.etype? and not node.returns {
        .error(Error::new(node.span, "Expression-match must yield a value"))
    }
}

def TypeChecker::check_if(&this, node: &AST, is_expr: bool, hint: &Type = null) {
    let cond_type = .check_expression(node.u.if_stmt.cond, hint: .o.get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    let body = node.u.if_stmt.body

    // `check_expression_statement` will modify this
    node.returns = true
    .check_expression_statement(node, body, is_expr, hint)

    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_expression_statement(node, else_stmt, is_expr, hint)

    } else if is_expr {
        .error(Error::new(node.span, "If expressions must have an else branch"))

    } else {
        node.returns = false
    }
}

def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool, hint: &Type) {
    match body.type {
        // If this is an expression-statement, a non-block should also be an expression
        ASTType::Match => .check_match(body, is_expr, hint)
        ASTType::If => .check_if(body, is_expr, hint)

        ASTType::Block => .check_block(body, is_expr, hint)
        else => {
            if is_expr {
                .check_expression(body, hint)
            } else {
                .check_statement(body)
            }
        }
    }

    node.returns = node.returns and body.returns

    if not is_expr return

    // For now, we'll allow expression statements to early-return from the function.
    // Maybe this should be disallowed?
    let ret = body.etype
    if body.returns {
        // Do nothing
    } else if not ret? {
        .error(Error::new(body.span, `Must yield a value in this branch, body type is {body.type}`))
    } else if not node.etype? {
        node.etype = ret
    } else if not node.etype.eq(ret) {
        .error(Error::new_note(
            body.span, "Yield type of branch doesn't match previous branches",
            `Expected type '{node.etype.str()}', got '{ret.str()}'`
        ))
    }
}


def TypeChecker::check_while(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1

    .o.push_scope(scope)
    let cond = node.u.loop.cond
    let body = node.u.loop.body

    let cond_type = .check_expression(cond, hint: .o.get_base_type(BaseType::Bool, node.span))
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(body)
    .o.pop_scope()
}

def TypeChecker::check_for(&this, node: &AST) {
    let scope = Scope::new(.scope())
    scope.loop_count += 1
    .o.push_scope(scope)

    let init = node.u.loop.init
    let cond = node.u.loop.cond
    let step = node.u.loop.step
    let body = node.u.loop.body

    if init? then .check_statement(init)

    if cond? {
        let cond_type = .check_expression(cond, hint: .o.get_base_type(BaseType::Bool, node.span))
        if cond_type? and cond_type.base != BaseType::Bool {
            .error(Error::new_note(
                cond.span, "Condition must be a boolean",
                `Got type '{cond_type.str()}'`
            ))
        }
    }

    if step? then .check_expression(step)
    .check_statement(body)


    .o.pop_scope()
}

def TypeChecker::check_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            let cur_func = .scope().cur_func
            if not cur_func? {
                .error(Error::new(node.span, "Cannot return from outside a function"))
                return
            }

            let expected = cur_func.return_type
            if expected.base == BaseType::Void {
                if node.u.unary? {
                    .error(Error::new(node.span, "Cannot return a value from a void function"))
                }
            } else if node.u.unary? {
                let res = .check_expression(node.u.unary, hint: expected)
                if res? and not res.eq(expected) {
                    .error(Error::new(node.span, `Return type {res.str()} does not match function return type {expected.str()}`))
                }
            } else {
                .error(Error::new(node.span, "Expected a return value for non-void function"))
            }
            node.returns = true
        }
        ASTType::Assert => {
            let expr_typ = .check_expression(node.u.assertion.expr, hint: .o.get_base_type(BaseType::Bool, node.span))
            if expr_typ? and expr_typ.base != BaseType::Bool {
                .error(Error::new(node.span, `Can only assert boolean types, got {expr_typ.str()}`))
            }

            if node.u.assertion.msg? {
                let msg_typ = .check_expression(node.u.assertion.msg)
                if msg_typ? and msg_typ != .o.get_type_by_name("str", node.span) {
                    .error(Error::new(node.span, `Can only assert strings, got {msg_typ.str()}`))
                }
            }
        }
        ASTType::Defer => .check_statement(node.u.unary)
        ASTType::Yield => {
            if not .scope().can_yield {
                .error(Error::new(node.span, "Cannot yield here"))
            }
            node.etype = .check_expression(node.u.unary)
        }
        ASTType::Import => {
            .handle_import_statement(node)
        }
        ASTType::Break | ASTType::Continue => {
            if .scope().loop_count == 0 {
                .error(Error::new(node.span, `{node.type} statement outside of loop`))
            }
        }
        ASTType::If => .check_if(node, is_expr: false)
        ASTType::While => .check_while(node)
        ASTType::For => .check_for(node)
        ASTType::Block => .check_block(node, is_expr: false)
        ASTType::Match => .check_match(node, is_expr: false)
        ASTType::VarDeclaration => {
            let var = node.u.var_decl.var
            let res = .scope().lookup_local(var.sym.name)
            if res? {
                .error(Error::new(node.span, `Variable {var.sym.name} already exists in this scope`))
                return
            }

            let sym = var.sym
            .scope().insert(var.sym.name, sym)

            if var.type? {
                var.type = .resolve_type(var.type)
                if not var.type? return
            }

            let init = node.u.var_decl.init
            if init? {
                let res = .check_expression(init, hint: var.type)
                if res? and var.type? and not res.eq(var.type) {
                    .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {res.str()}`))
                } else if not var.type? {
                    var.type = res
                }
            } else if not var.type? {
                .error(Error::new(node.span, `Variable {var.sym.name} has no type and no initializer`))
            }
        }
        else => {
            .check_expression(node)
        }
    }
}

def TypeChecker::check_function(&this, scope: &Scope, func: &Function) {
    if func.is_method and func.parent_type.base == Structure {
        let struc = func.parent_type.u.struc
        if struc.is_templated then return
    }
    if func.checked then return
    func.checked = true

    let new_scope = Scope::new(scope)
    let params = func.params

    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable

        let default_expr = param.default_value
        if default_expr? {
            // NOTE: This `.check_expression()` call uses the scope _outside_ of the function.
            //       We don't check the new scope here on purpose: the default value needs to be
            //       valid outside the scope of this function, which is where it will be evaluated.
            let default_type = .check_expression(default_expr, hint: param.type)

            if default_type? and not default_type.eq(param.type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }

        new_scope.items.insert(param.sym.name, param.sym)
    }

    new_scope.cur_func = func

    if func.sym.is_extern then return

    .o.push_scope(new_scope)
    .check_statement(func.body)
    if not func.body.returns and func.return_type.base != BaseType::Void and not func.sym.name.eq("main") {
        .error(Error::new(func.sym.span, "Function does not always return"))
    }
    .o.pop_scope()
}

def TypeChecker::handle_namespace_imports(&this, ns: &Namespace) {
    .o.push_namespace(ns)
    .o.push_scope(ns.scope)

    let imports = ns.imports
    for let i = 0; i < imports.size; i += 1 {
        let import_ = imports.at(i) as &AST
        .handle_import_statement(import_)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .handle_namespace_imports(iter.value())
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::check_global_variable(&this, node: &AST) {
    let init = node.u.var_decl.init
    if not init? return

    let var = node.u.var_decl.var
    let init_type = .check_expression(init, hint: var.type)
    if not init_type? or not var.type? return

    if not init_type.eq(var.type) {
        .error(Error::new(init.span, `Variable {var.sym.name} has type {var.type.str()} but initializer has type {init_type.str()}`))
    }
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)

    for let i = 0; i < ns.functions.size; i += 1 {
        let func = ns.functions.at(i) as &Function
        .check_function(ns.scope, func)
    }

    for let i = 0; i < ns.constants.size; i += 1 {
        let node = ns.constants.at(i) as &AST
        let init = node.u.var_decl.init
        if init? {
            .check_const_expression(init)
        } else if not node.u.var_decl.var.sym.is_extern {
            .error(Error::new(node.span, "Constant must have an initializer"))
        }
    }

    for let i = 0; i < ns.variables.size; i += 1 {
        let node = ns.variables.at(i) as &AST
        .check_global_variable(node)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .check_namespace(iter.value())
    }
    .o.pop_namespace()
    .o.pop_scope()
}

def TypeChecker::check_const_expression(&this, node: &AST, hint: &Type = null): &Type {
    let typ = match node.type {
        Identifier | NSLookup => {
            let sym = .resolve_scoped_identifier(node, error: true, hint)
            if not sym? return null
            if sym.type != SymbolType::Constant {
                .error(Error::new_hint(
                    node.span, "Cannot use a non-constant value in a constant expression",
                    sym.span, "Value was defined here"
                ))
                return null
            }
            yield sym.u.var.type
        }
        IntLiteral  => .o.get_base_type(BaseType::I32, node.span)
        FloatLiteral => .o.get_base_type(BaseType::F32, node.span)
        BoolLiteral => .o.get_base_type(BaseType::Bool, node.span)
        CharLiteral => .o.get_base_type(BaseType::Char, node.span)
        StringLiteral => .o.get_type_by_name("str", node.span)
        Plus |
        Minus |
        Multiply |
        Divide |
        LessThan |
        LessThanEquals |
        GreaterThan |
        GreaterThanEquals |
        Equals |
        NotEquals |
        And |
        Or |
        Modulus |
        BitwiseNot |
        BitwiseOr |
        BitwiseAnd |
        BitwiseXor |
        LeftShift |
        RightShift => {
            let lhs = .check_const_expression(node.u.binary.lhs)
            let rhs = .check_const_expression(node.u.binary.rhs)
            if not lhs? or not rhs? return null

            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                .error(Error::new(node.span, "Cannot do pointer arithmetic in constant expressions"))
            }
            yield .check_binary_op(node, lhs.unaliased(), rhs.unaliased())
        }
        else => {
            .error(Error::new(node.span, "Unsupported operator in constant expression"))
            return null
        }
    }
    node.etype = typ
    return typ
}

def TypeChecker::handle_import_path_base(&this, parts: &OldVector, base: &Symbol, alias: str, start_idx: i32) {
    for let i = start_idx as u32; i < parts.size; i += 1 {
        let part = parts.at(i) as &ImportPart

        match part.type {
            Wildcard => {
                .o.import_all_from_symbol(base)
                return
            }
            Multiple => {
                let paths = part.u.paths
                for let j = 0; j < paths.size; j += 1 {
                    let path = paths.at(j) as &OldVector
                    .handle_import_path_base(path, base, null, 0)
                }
                return
            }
            Single => {} // continue below
        }

        let name = part.u.single.name
        alias = part.u.single.alias
        let new_base = .o.lookup_in_symbol(base, name, error: false)

        if not new_base? {
            .error(Error::new(part.span, `Invalid import, namespace {name} does not exist`))
            return
        }
        base = new_base
    }

    // println(`imported symbol {base.display} with type {base.type} into namespace {.o.ns().sym.display}`)
    .scope().insert(alias, base)
}

// Insert all the imported items defined in the Import AST statement into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST) {
    let path = node.u.import_path

    // NOTE: This is a little weird, but the first part of the import can either be a symbol in
    //       some namespace (global / parent), or it can be in the current scope. To handle these
    //       cases, we just manually import the first part from these different locations, and then
    //       loop over the rest of the parts.
    let part = path.parts.at(0) as &ImportPart
    if part.type != Single {
        .error(Error::new(part.span, "Invalid import, first part must be a single identifier"))
        return
    }

    let name = part.u.single.name
    let alias = part.u.single.alias

    let base = match path.type {
        FromRootNamespace => {
            yield .o.program.global.find_importable_symbol(name)
        }
        FromParentNamespace => {
            let cur = .o.ns()
            for let i = 0; i < path.parent_count; i += 1 {
                if not cur.parent? {
                    // This should never happen, because the parser is responsible for handling this
                    .error(Error::new(node.span, "Cannot import from parent of root namespace")).panic()
                    return
                }
                cur = cur.parent
            }
            yield cur.find_importable_symbol(name)
        }

        // This is the special case: a `Symbol` can't hold a scope, so we can't just
        // wrap all 3 cases into a symbol and avoid the manual lookup.
        FromCurrentScope => {
            yield .o.scope().lookup_recursive(name)
        }
    }

    if not base? {
        .error(Error::new(part.span, `Couldn't import {name}`))
        return
    }

    .handle_import_path_base(path.parts, base, alias, start_idx: 1)
}

def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {
    if func.is_method {
        let parent_span = func.parent_type.span
        let parent_type = .resolve_type(func.parent_type, allow_incomplete: true)
        if not parent_type? {
            .o.error(Error::new(parent_span, "Could not find this type"))
            return
        }

        if not parent_type.can_have_methods() {
            .o.error(Error::new(parent_span, "This type cannot have methods"))
            return
        }

        match parent_type.base {
            Structure => {
                let struc = parent_type.u.struc
                let name = struc.get_field(func.sym.name)
                if name? {
                    .o.error(Error::new_hint(
                        func.sym.span, "Field with this name already exists",
                        name.sym.span, "Previous definition here"
                    ))
                }
            }
            Enum => {
                let enum_ = parent_type.u.enum_
                let name = enum_.get_field(func.sym.name)
                if name? {
                    .o.error(Error::new_hint(
                        func.sym.span, "Enum value with this name already exists",
                        name.sym.span, "Previous definition here"
                    ))
                }
            }
            // Builtin type
            else => {}
        }

        let res = parent_type.methods.get(func.sym.name) as &Function
        if res? {
            .o.error(Error::new_hint(
                func.sym.span, "Method with this name already exists",
                res.sym.span, "Previous definition here"
            ))
            return
        }

        // Now that the parent type is valid, we need to update the symbol table with the updated
        // display and output names for the function
        func.sym.update_parent(parent_type.sym)

        parent_type.methods.insert(func.sym.name, func)
        func.parent_type = parent_type

    } else {
        let item = func.sym
        .o.insert_into_scope_checked(item)
    }
}

def TypeChecker::resolve_struct(&this, struc: &Structure) {
    let fields = struc.fields

    // We cannot resolve templated structs.
    if struc.is_templated return

    for let i = 0; i < fields.size; i += 1 {
        let field = fields.at(i) as &Variable
        let res = .resolve_type(field.type)
        if not res? {
            .o.error(Error::new(field.sym.span, "Couldn't resolve type"))
        } else {
            field.type = res
        }
    }
}

def TypeChecker::check_function_declaration(&this, func: &Function) {
    if func.is_method and func.parent_type.base == Structure {
        let struc = func.parent_type.u.struc
        if struc.is_templated then return
    }

    func.return_type = .resolve_type(func.return_type)
    if not func.return_type? {
        func.return_type = .o.get_base_type(BaseType::Void, func.sym.span)
    }

    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable
        param.type = .resolve_type(param.type)
    }

    // A function keeps track of a type that represents an equivalent function pointer type
    // This is used for type checking function calls
    let typ = Type::new_resolved(Function, func.sym.span)
    typ.u.func = FunctionType::from_func(func)
    func.type = typ
}

def TypeChecker::check_function_declarations(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)
    .o.push_namespace(ns)

    for let i = 0; i < ns.functions.size; i += 1 {
        let func = ns.functions.at(i) as &Function
        .check_function_declaration(func)
    }

    for let i = 0; i < ns.structs.size; i += 1 {
        let struc = ns.structs.at(i) as &Structure
        .resolve_struct(struc)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .check_function_declarations(iter.value())
    }

    .o.pop_scope()
    .o.pop_namespace()
}

def TypeChecker::pre_check_globals(&this, node: &AST, is_const: bool) {
    let var = node.u.var_decl.var
    if not var.type? {
        let c = if is_const "Constant" else "Global variable"
        .error(Error::new(node.span, f"{c} must have a type"))
        return
    }
    var.type = .resolve_type(var.type)
    if not var.type? then return
    .o.insert_into_scope_checked(var.sym)
}

def TypeChecker::pre_check_constants(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)

    for let i = 0; i < ns.constants.size; i += 1 {
        let node = ns.constants.at(i) as &AST
        .pre_check_globals(node, is_const: true)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .pre_check_constants(iter.value())
    }

    .o.pop_scope()
}

def TypeChecker::pre_check_namespace(&this, ns: &Namespace) {
    .o.push_scope(ns.scope)

    for let i = 0; i < ns.functions.size; i += 1 {
        let func = ns.functions.at(i) as &Function
        .pre_check_function(ns, func)
    }

    for let i = 0; i < ns.variables.size; i += 1 {
        let node = ns.variables.at(i) as &AST
        .pre_check_globals(node, is_const: false)
    }

    for let iter = ns.namespaces.iter(); iter.cur?; iter.next() {
        .pre_check_namespace(iter.value())
    }

    .o.pop_scope()
}


def TypeChecker::run(program: &Program) {
    let pass = TypeChecker(
        o: GenericPass::new(program),
    )
    pass.pre_check_constants(program.global)
    pass.pre_check_namespace(program.global)
    pass.handle_namespace_imports(program.global)
    pass.check_function_declarations(program.global)
    pass.check_namespace(program.global)
}
