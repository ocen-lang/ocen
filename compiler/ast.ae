use "lib/vector.ae"
use "lib/map.ae"
use "compiler/types.ae"
use "compiler/tokens.ae"
use "compiler/errors.ae"
use "compiler/scopes.ae"

enum ASTType {
    Block
    BoolLiteral
    Break
    Call
    Continue
    Error
    Identifier
    If
    Import
    IntLiteral
    Member
    NSLookup
    Return
    StringLiteral
    SizeOf
    VarDeclaration
    While
    For
    CharLiteral
    FloatLiteral
    FormatStringLiteral
    IsNotNull //  ptr? operator
    Cast
    Null
    MethodCall

    // Unary operators
    Address
    Dereference
    Negate
    Not

    // Binary operators
    And
    Assignment
    BitwiseAnd
    BitwiseNot
    BitwiseOr
    BitwiseXor
    Divide
    DivideEquals
    Equals
    GreaterThan
    GreaterThanEquals
    LeftShift
    LessThan
    LessThanEquals
    Minus
    MinusEquals
    Modulus
    Multiply
    MultiplyEquals
    NotEquals
    Or
    Plus
    PlusEquals
    RightShift
}

def ASTType::from_token(type: TokenType): ASTType => match type {
    Ampersand => ASTType::BitwiseAnd
    And => ASTType::And
    Caret => ASTType::BitwiseXor
    EqualEquals => ASTType::Equals
    Equals => ASTType::Assignment
    GreaterThan => ASTType::GreaterThan
    GreaterThanEquals => ASTType::GreaterThanEquals
    GreaterThanGreaterThan => ASTType::RightShift
    LessThan => ASTType::LessThan
    LessThanEquals => ASTType::LessThanEquals
    LessThanLessThan => ASTType::LeftShift
    Line => ASTType::BitwiseOr
    Minus => ASTType::Minus
    MinusEquals => ASTType::MinusEquals
    NotEquals => ASTType::NotEquals
    Or => ASTType::Or
    Percent => ASTType::Modulus
    Plus => ASTType::Plus
    PlusEquals => ASTType::PlusEquals
    Slash => ASTType::Divide
    SlashEquals => ASTType::DivideEquals
    Star => ASTType::Multiply
    StarEquals => ASTType::MultiplyEquals
    Tilde => ASTType::BitwiseNot
    else => panic(`Unhandled token type in ASTType::from_token: {type.str()}`)
}

struct Variable {
    name: string
    type: &Type
    span: Span

    prefix: string

    // Only for functions, FIXMNE: move to `Parameter` type?
    default_value: &AST
}

def Variable::new(name: string, type: &Type, span: Span): &Variable {
    let var = calloc(1, sizeof(Variable)) as &Variable
    var.name = name
    var.type = type
    var.span = span
    var.prefix = ""
    return var
}

struct VarDeclaration {
    var: &Variable
    init: &AST
}

struct Structure {
    name: string
    fields: &Vector     // Vector<&Variable>

    type: &Type
    span: Span
    prefix: string
}

def Structure::new(name: string, span: Span): &Structure {
    let struc = calloc(1, sizeof(Structure)) as &Structure
    struc.fields = Vector::new()
    struc.span = span
    struc.name = name
    return struc
}

def Structure::get_field(&this, name: string): &Variable {
    for let i = 0; i < .fields.size; i += 1 {
        let field = .fields.at(i) as &Variable
        if field.name.eq(name) {
            return field
        }
    }
    return null
}

struct Function {
    name: string
    params: &Vector     // Vector<&Variable>
    return_type: &Type
    body: &AST
    exits: bool

    type: &Type
    span: Span
    prefix: string

    is_method: bool
    is_static: bool
    parent_type: &Type
}

def Function::new(span: Span): &Function {
    let func = calloc(1, sizeof(Function)) as &Function
    func.params = Vector::new()
    func.span = span
    return func
}

struct Program {
    global: &Namespace
    errors: &Vector       // Vector<&Error>
}

def Program::new(): &Program {
    let prog = calloc(1, sizeof(Program)) as &Program
    prog.global = Namespace::new(null, "", "")
    prog.errors = Vector::new()
    return prog
}

struct Block {
    statements: &Vector     // Vector<&AST>
    scope: &Scope
}

struct Identifier {
    name: string
    var: &Variable
    is_function: bool
    func: &Function
}

struct Argument {
    expr: &AST
    label: string // Identifier
    label_span: Span
}

def Argument::new(label: string, label_span: Span, expr: &AST): &Argument {
    let arg = calloc(1, sizeof(Argument)) as &Argument
    arg.expr = expr
    arg.label = label
    arg.label_span = label_span
    return arg
}

struct FuncCall {
    callee: &AST
    args: &Vector    // Vector<&Argument>
    func: &Function
    is_function_pointer: bool
    added_method_arg: bool
}

struct ImportPart {
    name: string
    span: Span
}

def ImportPart::new(name: string, span: Span): &ImportPart {
    let part = calloc(1, sizeof(ImportPart)) as &ImportPart
    part.name = name
    part.span = span
    return part
}

struct ImportPath {
    parts: &Vector    // &Vector<ImportPart>

    // For relative imports, we might have something like `import ..foo`, in which
    // case we need to know how namspace levels to go up.
    is_relative: bool
    parent_count: i32
}

struct NumLiteral {
    text: string
    suffix: &Type
}

struct Binary {
    lhs: &AST
    rhs: &AST
}

struct NSLookup {
    lhs: &AST
    rhs_name: string
    rhs_span: Span
}

struct Member {
    lhs: &AST
    rhs_name: string
    rhs_span: Span
    is_pointer: bool
}

struct IfStatement {
    cond: &AST
    body: &AST
    els: &AST
}

struct Loop {
    init: &AST
    cond: &AST
    step: &AST
    body: &AST
}

struct Cast {
    lhs: &AST
    to: &Type
}

struct FormatString {
    parts: &Vector    // Vector<string>
    specs: &Vector    // Vector<string>
    exprs: &Vector    // Vector<&AST>
}

union ASTUnion {
    binary: Binary
    block: Block
    bool_literal: bool
    call: FuncCall
    cast: Cast
    ident: Identifier
    if_stmt: IfStatement
    import_path: ImportPath
    lookup: NSLookup
    loop: Loop
    member: Member
    num_literal: NumLiteral
    string_literal: string
    char_literal: string
    unary: &AST
    var_decl: VarDeclaration
    fmt_str: FormatString
    size_of_type: &Type
}

struct AST {
    type: ASTType
    span: Span
    u: ASTUnion
    etype: &Type
    returns: bool
    resolved_symbol: &Symbol
}

def AST::new(type: ASTType, span: Span): &AST {
    let ast = calloc(1, sizeof(AST)) as &AST
    ast.type = type
    ast.span = span
    return ast
}

def AST::new_unop(type: ASTType, span: Span, expr: &AST): &AST {
    let ast = AST::new(type, span)
    ast.u.unary = expr
    return ast
}

def AST::new_binop(type: ASTType, lhs: &AST, rhs: &AST): &AST {
    let span = lhs.span.join(rhs.span)
    let ast = AST::new(type, span)
    ast.u.binary.lhs = lhs
    ast.u.binary.rhs = rhs
    return ast
}

def AST::is_lvalue(&this): bool => match .type {
    // FIXME: What about `a::b::c?`
    Identifier => not .u.ident.is_function
    Member => true
    Dereference => true
    else => false
}
