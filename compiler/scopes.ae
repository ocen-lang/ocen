use "compiler/ast.ae"
use "compiler/types.ae"

enum SymbolType {
    Function
    Structure
    Enum
    TypeDef
    Namespace
    Variable
}

struct SymbolUnion {
    func: &Function
    struc: &Structure
    enum_: &Enum
    ns: &Namespace
    type_def: &Type
    var: &Variable
}

struct Symbol {
    name: string        // Name in the scope it was defined in
    display: string     // Fully qualified display name, including namespaces
    out_name: string    // Name used in the output C code
    span: Span          // Span of the declaration

    type: SymbolType
    u: SymbolUnion
}

def Symbol::new(type: SymbolType, name: string, display: string, out_name: string, span: Span): &Symbol {
    let item = calloc(1, sizeof(Symbol)) as &Symbol
    item.name = name
    item.display = display
    item.out_name = out_name
    item.span = span
    item.type = type
    return item
}

def Symbol::join_display(a: string, b: string): string => if a.len() == 0 then b else `{a}::{b}`
def Symbol::join_out_name(a: string, b: string): string => if a.len() == 0 then b else `{a}_{b}`

def Symbol::new_with_parent(type: SymbolType, parent: &Symbol, name: string, span: Span): &Symbol {
    let display = Symbol::join_display(parent.display, name)
    let out_name = Symbol::join_out_name(parent.out_name, name)
    return Symbol::new(type, name, display, out_name, span)
}

def Symbol::from_local_variable(name: string, var: &Variable, span: Span): &Symbol {
    let item = Symbol::new(
        SymbolType::Variable,
        name: name,
        display: name,
        out_name: name,
        span: span,
    )
    item.u.var = var
    return item
}

def Symbol::lookup_symbol(&this, name: string): &Symbol => match .type {
    SymbolType::Namespace => {
        let ns = .u.ns
        let res = ns.find_importable_symbol(name)
        return res
    }
    SymbolType::Structure => {
        let struc = .u.struc
        let method = struc.type.methods.get(name) as &Function
        if not method? return null
        return method.sym
    }
    SymbolType::TypeDef => {
        let type_def = .u.type_def
        let method = type_def.methods.get(name) as &Function
        if not method? return null
        return method.sym
    }
    SymbolType::Enum => {
        let enum_ = .u.enum_
        let field = enum_.get_field(name) as &Variable
        if not field? return null
        return field.sym
    }
    else => null
}

struct Scope {
    items: &Map // &Map<string, &Symbol>
    parent: &Scope
}

def Scope::new(parent: &Scope): &Scope {
    let scope = calloc(1, sizeof(Scope)) as &Scope
    scope.items = Map::new()
    scope.parent = parent
    return scope
}

def Scope::lookup_recursive(&this, name: string): &Symbol {
    let item = .items.get(name) as &Symbol
    if item? return item
    if .parent? then return .parent.lookup_recursive(name)
    return null
}

def Scope::lookup_local(&this, name: string): &Symbol {
    return .items.get(name) as &Symbol
}

def Scope::insert(&this, name: string, symbol: &Symbol) {
    .items.insert(name, symbol)
}

struct Namespace {
    parent: &Namespace

    functions: &Vector    // Vector<&Function>
    structs: &Vector      // Vector<&Structure>
    enums: &Vector        // Vector<&Enum>
    imports: &Vector      // Vector<&AST>
    namespaces: &Map      // Map<string, &Namespace>

    sym: &Symbol
    scope: &Scope
    path: string

    // Does this namespace correspond to an actual file with source code? Or is it just an
    // intermediate namespace for a directory?
    is_a_file: bool

    // This is used for any namespaces that need to be added to the scope by default. For instance,
    // the standard library, or user-defined namespaces with the `namespace` keyword.
    always_add_to_scope: bool

    // FIXME: This is hacky, but we want to include everything in `std/prelude.ae` in the
    //        `std` namespace, as opposed to the `std::prelude` namespace. This is done by
    //        treating `std/prelude.ae` as "top-level", which means all it's contents are put
    //        in the same namespace as the containing folder. All other files that are imported
    //        from the same folder will go into a new namespace as per usual.
    is_top_level: bool
}

def Namespace::new(parent: &Namespace, path: string): &Namespace {
    let ns = calloc(1, sizeof(Namespace)) as &Namespace
    ns.parent = parent
    let parent_scope = if parent? then parent.scope else null
    ns.scope = Scope::new(parent_scope)
    ns.functions = Vector::new()
    ns.structs = Vector::new()
    ns.enums = Vector::new()
    ns.namespaces = Map::new()
    ns.imports = Vector::new()
    ns.path = path
    // ns.prefix = prefix
    ns.is_a_file = false
    // ns.span = Span::default()

    if parent? then {
        println(`Created namespace: {ns.path} with parent {ns.parent.path}`)
    } else {
        println(`Created namespace: {ns.path} with no parent`)
    }
    return ns
}

def Namespace::find_importable_symbol(&this, name: string): &Symbol {
    let item = .namespaces.get(name) as &Namespace
    if item? then return item.sym

    for let i = 0; i < .functions.size; i += 1 {
        let func = .functions.at(i) as &Function
        if func.sym.name.eq(name) {
            return func.sym
        }
    }

    for let i = 0; i < .structs.size; i += 1 {
        let struc = .structs.at(i) as &Structure
        if struc.sym.name.eq(name) {
            return struc.sym
        }
    }

    for let i = 0; i < .enums.size; i += 1 {
        let enum_ = .enums.at(i) as &Enum
        if enum_.sym.name.eq(name) {
            return enum_.sym
        }
    }
    return null
}