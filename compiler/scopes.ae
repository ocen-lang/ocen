use "compiler/ast.ae"
use "compiler/types.ae"

enum SymbolType {
    Function
    Structure
    TypeDef
    Namespace
    Variable
}

struct SymbolUnion {
    func: &Function
    struc: &Structure
    ns: &Namespace
    type_def: &Type
    var: &Variable
}

struct Symbol {
    name: string
    type: SymbolType
    u: SymbolUnion
}

def Symbol::new(name: string, type: SymbolType): &Symbol {
    let item = calloc(1, sizeof(Symbol)) as &Symbol
    item.name = name
    item.type = type
    return item
}

def Symbol::span(&this): Span => match .type {
    SymbolType::Function => .u.func.span
    SymbolType::Structure => .u.struc.span
    SymbolType::TypeDef => .u.type_def.span
    SymbolType::Variable => .u.var.span
    else => Span::default()
}

def Symbol::from_function(name: string, func: &Function): &Symbol {
    let item = Symbol::new(name, SymbolType::Function)
    item.u.func = func
    return item
}

def Symbol::from_namespace(name: string, ns: &Namespace): &Symbol {
    let item = Symbol::new(name, SymbolType::Namespace)
    item.u.ns = ns
    return item
}

def Symbol::from_type(name: string, type: &Type): &Symbol {
    let item = Symbol::new(name, SymbolType::TypeDef)
    item.u.type_def = type
    return item
}

def Symbol::from_variable(var: &Variable): &Symbol {
    let item = Symbol::new(var.name, SymbolType::Variable)
    item.u.var = var
    return item
}

def Symbol::from_structure(struc: &Structure): &Symbol {
    let item = Symbol::new(struc.name, SymbolType::Structure)
    item.u.struc = struc
    return item
}

struct Scope {
    items: &Map // &Map<string, &Symbol>
    parent: &Scope
}

def Scope::new(parent: &Scope): &Scope {
    let scope = calloc(1, sizeof(Scope)) as &Scope
    scope.items = Map::new()
    scope.parent = parent
    return scope
}

def Scope::lookup_recursive(&this, name: string): &Symbol {
    let item = .items.get(name) as &Symbol
    if item? return item
    if .parent? then return .parent.lookup_recursive(name)
    return null
}

def Scope::lookup_local(&this, name: string): &Symbol {
    return .items.get(name) as &Symbol
}

def Scope::insert(&this, name: string, symbol: &Symbol) {
    .items.insert(name, symbol)
}

struct Namespace {
    parent: &Namespace

    functions: &Vector    // Vector<&Function>
    structs: &Vector      // Vector<&Structure>
    imports: &Vector      // Vector<&AST>
    namespaces: &Map      // Map<string, &Namespace>
    span: Span

    scope: &Scope
    path: string
    prefix: string

    // The distinction between a namespace and a module is that a module corresponds
    // to a specific file, whereas a namespace is a logical grouping of symbols.
    is_module: bool

    // A user-defined namespace is one that is defined in the source code with the
    // `namespace` keyword. A non-user-defined namespace is based on the file structure
    is_user_defined: bool
}

def Namespace::new(parent: &Namespace, path: string, prefix: string): &Namespace {
    let ns = calloc(1, sizeof(Namespace)) as &Namespace
    ns.parent = parent
    let parent_scope = if parent? then parent.scope else null
    ns.scope = Scope::new(parent_scope)
    ns.functions = Vector::new()
    ns.structs = Vector::new()
    ns.namespaces = Map::new()
    ns.imports = Vector::new()
    ns.path = path
    ns.prefix = prefix
    ns.is_module = false
    ns.span = Span::default()

    if parent? then {
        println(`Created namespace: {ns.path} with parent {ns.parent.path}`)
    } else {
        println(`Created namespace: {ns.path} with no parent`)
    }
    return ns
}

def Namespace::find_importable_symbol(&this, name: string): &Symbol {
    let item = .namespaces.get(name) as &Namespace
    if item? then {
        return Symbol::from_namespace(name, item)
    }

    for let i = 0; i < .functions.size; i += 1 {
        let func = .functions.at(i) as &Function
        if func.name.eq(name) {
            return Symbol::from_function(name, func)
        }
    }

    for let i = 0; i < .structs.size; i += 1 {
        let struc = .structs.at(i) as &Structure
        if struc.name.eq(name) {
            return Symbol::from_type(name, struc.type)
        }
    }
    return null
}