use "lib/buffer.ae"
use "compiler/ast.ae"
use "compiler/utils.ae"

struct CodeGenerator {
    program: &Program
    out: Buffer
    indent: i32
}

def CodeGenerator::make(program: &Program): CodeGenerator {
    return CodeGenerator(
        program,
        out: Buffer::make(),
        indent: 0
    )
}

def CodeGenerator::error(&this, err: &Error) {
    .program.errors.push(err)
}

def CodeGenerator::gen_indent(&this) {
    for let i = 0; i < .indent; i += 1 {
        .out.puts("  ")
    }
}


def string::replace(&this, other: string) {
    let s: string = *this
    free(s)
    *this = other
}

def CodeGenerator::get_op(&this, type: ASTType): string => match type {
    And => "&&",
    BitwiseAnd => "&",
    BitwiseOr => "|",
    BitwiseXor => "^",
    Divide => "/",
    Equals => "==",
    GreaterThan => ">",
    GreaterThanEquals => ">=",
    LeftShift => "<<",
    LessThan => "<",
    LessThanEquals => "<=",
    Minus => "-",
    Modulus => "%",
    Multiply => "*",
    NotEquals => "!=",
    Or => "||",
    Plus => "+",
    PlusEquals => "+=",
    MinusEquals => "-=",
    MultiplyEquals => "*=",
    DivideEquals => "/=",
    RightShift => ">>",
    else => panic(`Unknown op type in get_op: {type}`)
}

def CodeGenerator::gen_internal_print(&this, node: &AST) {
    let callee = node.u.call.callee
    let newline_after = callee.u.ident.name.eq("println")

    .out.puts("printf(")

    // FIXME: these checks should move to typechecker
    let args = node.u.call.args
    if args.size < 1 {
        .error(Error::new(
            node.span, "Function requires at least one argument"
        ))
    }
    let first = args.at(0) as &Argument
    if args.size == 1 and first.expr.type == ASTType::FormatStringLiteral {
        .gen_format_string_variadic(first.expr, newline_after)
        .out.puts(")")
        return
    }

    if first.expr.type != StringLiteral {
        .error(Error::new(
            first.expr.span, "First argument must be a string literal"
        ))
    }

    for let i = 0; i < args.size; i += 1 {
        if i > 0 then .out.puts(", ")
        let arg = args.at(i) as &Argument
        .gen_expression(arg.expr)
        if i == 0 and newline_after then .out.puts("\"\\n\"")
    }
    .out.puts(")")
}

// The point of this is to escape / unescape the correct characters
def CodeGenerator::gen_format_string_part(&this, part: string) {
    let len = part.len()
    for let i = 0; i < len; i += 1 {
        if part[i] == '\\' {
            // This should be safe
            i += 1
            match part[i] {
                // We want to unescape these
                '`' | '{' | '}' => {}
                // Anything else should remain escaped
                else => .out.putc('\\')
            }
        } else if part[i] == '"' {
            // If we have double quotes in a string we should escape it
            .out.putc('\\')
        } else if part[i] == '%' {
            // Percent signs are special in printf, we need to do "%%"
            .out.putc('%')
        }
        .out.putc(part[i])
    }
}

def CodeGenerator::gen_format_string_variadic(&this, node: &AST, newline_after: bool) {
    let parts = node.u.fmt_str.parts
    let exprs = node.u.fmt_str.exprs
    let specs = node.u.fmt_str.specs

    .out.putc('"')
    for let i = 0; i < exprs.size; i += 1 {
        let part = parts.at(i) as string
        .gen_format_string_part(part)

        let spec = specs.at(i) as string
        if spec? {
            .out.puts("%")
            .out.puts(spec)
            continue
        }

        let expr = exprs.at(i) as &AST
        let expr_type = expr.etype
        match expr_type.base {
            I8 | I16 | I32 => .out.puts("%d")
            U8 | U16 | U32 => .out.puts("%u")
            I64 => .out.puts("%lld")
            U64 => .out.puts("%llu")
            Bool => .out.puts("%s")
            F32 | F64 => .out.puts("%f")
            Char => .out.puts("%c")
            Pointer => match expr_type.u.ptr.base {
                Char => .out.puts("%s")
                else => .out.puts("%p")
            }
            else => {
                .error(Error::new(
                    expr.span, "Invalid type for format string"
                ))
                .out.puts("%s")
            }
        }
    }
    // Put the last part:
    let part = parts.back() as string
    .gen_format_string_part(part)
    if newline_after then .out.puts("\\n")
    .out.putc('"')

    for let i = 0; i < exprs.size; i += 1 {
        .out.puts(", ")
        let expr = exprs.at(i) as &AST
        .gen_expression(expr)
    }
}


def CodeGenerator::gen_format_string(&this, node: &AST) {
    .out.puts("format_string(")
    .gen_format_string_variadic(node, newline_after: false)
    .out.puts(")")
}

def CodeGenerator::gen_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => {
            let num_lit = &node.u.num_literal
            .out.puts(num_lit.text)
        }
        FormatStringLiteral => .gen_format_string(node)
        FloatLiteral => {
            let num_lit = &node.u.num_literal
            .out.puts(num_lit.text)
        }
        StringLiteral => {
            let str_lit = node.u.string_literal
            .out.puts("\"")
            .out.puts(str_lit)
            .out.puts("\"")
        }
        CharLiteral => {
            let char_lit = node.u.char_literal
            .out.puts("'")
            .out.puts(char_lit)
            .out.puts("'")
        }
        Member => {
            if node.resolved_symbol? {
                // Method call
                let sym = node.resolved_symbol
                match sym.type {
                    Function => .out.putsf(.get_method_name(sym.u.func))
                    else => panic(`Unhandled symbol type: {sym.type}`)
                }
                return
            }

            let lhs = node.u.member.lhs
            .gen_expression(lhs)
            if node.u.member.is_pointer {
                .out.puts("->")
            } else {
                .out.puts(".")
            }
            .out.puts(node.u.member.rhs_name)
        }
        Identifier | NSLookup => {
            let sym = node.resolved_symbol
            if not sym? {
                .error(Error::new(node.span, "Symbol not found in CodeGenerator::gen_expression"))
                return
            }
            match sym.type {
                Function => .out.putsf(.get_function_name(sym.u.func))
                Variable => .out.putsf(.get_variable_name(sym.u.var))
                else => panic(`Unhandled symbol type: {sym.type}`)
            }
        }
        Call => {
            let callee = node.u.call.callee

            // FIXME: Re-do abomination of hacky-IO with some sort of variadics?
            // FIXME: Escape string characters
            // FIXME: Plus newline to println
            // FIXME: Expand out format strings inline
            if callee.type == Identifier and (callee.u.ident.name.eq("print") or callee.u.ident.name.eq("println")) {
                .gen_internal_print(node)
                return
            }

            .gen_expression(callee)

            .out.puts("(")
            let args = node.u.call.args
            for let i = 0; i < args.size; i += 1 {
                if i != 0 then .out.puts(", ")
                let arg = args.at(i) as &Argument
                // FIXME: check arg.label
                .gen_expression(arg.expr)
            }
            .out.puts(")")
        }
        BoolLiteral => {
            let bool_lit = node.u.bool_literal
            .out.puts(if bool_lit then "true" else "false")
        }
        Address => {
            let expr = node.u.unary
            .out.puts("&")
            .gen_expression(expr)
        }
        Dereference => {
            let expr = node.u.unary
            .out.puts("*")
            .gen_expression(expr)
        }
        Negate => {
            let expr = node.u.unary
            .out.puts("-")
            .gen_expression(expr)
        }
        Not => {
            let expr = node.u.unary
            .out.puts("!")
            .gen_expression(expr)
        }
        IsNotNull => {
            let expr = node.u.unary
            .out.puts("((bool)")
            .gen_expression(expr)
            .out.puts(")")
        }
        Cast => {
            let expr = node.u.unary
            let type = node.etype
            .out.puts("((")
            .out.puts(.get_type_name_string(type, name: "", is_func_def: false))
            .out.puts(")")
            .gen_expression(expr)
            .out.puts(")")
        }
        Null => .out.puts("NULL")

        And |
        BitwiseAnd |
        BitwiseOr |
        BitwiseXor |
        Divide |
        Equals |
        GreaterThan |
        GreaterThanEquals |
        LeftShift |
        LessThan |
        LessThanEquals |
        Minus |
        Modulus |
        Multiply |
        NotEquals |
        Or |
        Plus |
        PlusEquals |
        MinusEquals |
        MultiplyEquals |
        DivideEquals |
        RightShift => {
            let lhs = node.u.binary.lhs
            let rhs = node.u.binary.rhs
            .out.puts("(")
            .gen_expression(lhs)
            .out.puts(" ")
            .out.puts(.get_op(node.type))
            .out.puts(" ")
            .gen_expression(rhs)
            .out.puts(")")
        }

        Assignment => {
            let lhs = node.u.binary.lhs
            let rhs = node.u.binary.rhs
            .gen_expression(lhs)
            .out.puts(" = ")
            .gen_expression(rhs)
        }

        else => .error(Error::new(node.span, `Unhandled expression type in CodeGenerator: {node.type}`))
    }
}

def CodeGenerator::gen_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return => {
            .gen_indent()
            .out.puts("return ")
            if node.u.unary? {
                .gen_expression(node.u.unary)
            }
            .out.puts(";\n")
        }
        ASTType::Break => {
            .gen_indent()
            .out.puts("break;\n")
        }
        ASTType::VarDeclaration => {
            let var = node.u.var_decl.var
            let type = var.type
            let name = var.name
            .gen_indent()
            .out.puts(.get_type_name_string(type, name, is_func_def: false))

            let init = node.u.var_decl.init
            if init? {
                .out.puts(" = ")
                .gen_expression(init)
            }
            .out.puts(";\n")
        }
        ASTType::Block => {
            .gen_indent()
            .gen_block(node)
            .out.puts("\n")
        }
        ASTType::If => {
            let cond = node.u.if_stmt.cond
            let body = node.u.if_stmt.body
            let else_body = node.u.if_stmt.els
            .gen_indent()
            .out.puts("if (")
            .gen_expression(cond)
            .out.puts(") ")
            .gen_block(body)

            if else_body? {
                .out.puts(" else ")
                .gen_block(else_body)
                .out.puts("\n")
            } else {
                .out.puts("\n")
            }
        }
        ASTType::While => {
            let cond = node.u.loop.cond
            let body = node.u.loop.body
            .gen_indent()
            .out.puts("while (")
            .gen_expression(cond)
            .out.puts(") ")
            .gen_block(body)
            .out.puts("\n")
        }
        ASTType::For => {
            let init = node.u.loop.init
            let cond = node.u.loop.cond
            let step = node.u.loop.step
            let body = node.u.loop.body
            .gen_indent()
            .out.puts("for (")
            if init? then .gen_expression(init)
            .out.puts("; ")
            if cond? then .gen_expression(cond)
            .out.puts("; ")
            if step? then .gen_expression(step)
            .out.puts(") ")
            .gen_block(body)
            .out.puts("\n")
        }
        else => {
            .gen_indent()
            .gen_expression(node)
            .out.puts(";\n")
        }
    }
}

def CodeGenerator::gen_block(&this, node: &AST) {
    .out.puts("{\n")

    let statements = node.u.block.statements
    .indent += 1
    for let i = 0; i < statements.size; i += 1 {
        let statement = statements.at(i) as &AST
        .gen_statement(statement)
    }
    .indent -= 1
    .gen_indent()
    .out.puts("}")
}

def CodeGenerator::get_type_name_string(&this, type: &Type, name: string, is_func_def: bool): string {
    // This is a bit weird because of how C expects type names to be written.
    // There's possibly a better way to do this, but I'll leave that for another day.
    let final = name.copy()

    if not type? { panic("Internal error: null type in codegen") }

    for let cur = type; cur?; cur = cur.u.ptr {
        match cur.base {
            // These should all be terminal types
            Void | Bool | Char |
            I8   | I16  | I32  | I64 |
            U8   | U16  | U32  | U64 |
            F32  | F64 => final.replace(`{cur.base.str()} {final}`)

            Function => {
                let acc = Buffer::make()
                let params = cur.u.func.params

                if params.size == 0 then acc.puts("void")

                for let i = 0; i < params.size; i += 1 {
                    if i != 0 then acc.puts(", ")
                    let var = params.at(i) as &Variable
                    let arg_str = .get_type_name_string(var.type, var.name, is_func_def: false)
                    acc.putsf(arg_str)
                }
                if is_func_def and cur == type {
                    // This allows us to also create function declarations
                    final.replace(`{final}({acc.str()})`)
                } else {
                    final.replace(`(*{final})({acc.str()})`)
                }
                free(acc.data)
                final.replace(.get_type_name_string(
                    cur.u.func.return_type,
                    name: final,
                    is_func_def: false
                ))
            }

            Structure => {
                let struc_name = .get_struct_name(cur.u.struc)
                final.replace(`{struc_name} {final}`)
            }

            Unresolved => {
                .error(Error::new(type.span, "Unresolved type found"))
            }
            Error => {
                .error(Error::new(type.span, "Error found in type"))
            }
            Pointer => {
                let needs_parens = (cur.u.ptr? and
                    // FIXME: Also if it's an array below
                    (cur.u.ptr.base == BaseType::Function))
                if needs_parens {
                    final.replace(`(*{final})`)
                } else {
                    final.replace(`*{final}`)
                }
            }
            else => {
                .error(Error::new(type.span, `Unhandled type found: {type.str()}`))
            }
        }
    }
    final.strip_trailing_whitespace()
    return final
}

def CodeGenerator::gen_type_and_name(&this, type: &Type, name: string) {
    .out.putsf(.get_type_name_string(type, name, is_func_def: false))
}

def CodeGenerator::gen_type(&this, type: &Type) {
    .gen_type_and_name(type, name: "")
}

def CodeGenerator::get_function_name(&this, func: &Function): string {
    return `{func.prefix}{func.name}`
}

def CodeGenerator::get_method_name(&this, func: &Function): string {
    let struc = func.parent_type.u.struc
    return `{func.prefix}{func.name}`
}

def CodeGenerator::get_variable_name(&this, var: &Variable): string {
    return `{var.prefix}{var.name}`
}

def CodeGenerator::get_struct_name(&this, struc: &Structure): string {
    return `{struc.prefix}{struc.name}`
}


def CodeGenerator::gen_function(&this, func: &Function) {
    .gen_function_decl(func)
    .out.puts(" ")
    .gen_block(func.body)
    .out.puts("\n\n")
}

def CodeGenerator::gen_function_decl(&this, func: &Function) {
    let func_name = .get_function_name(func)
    let s = .get_type_name_string(func.type, func_name, true)
    .out.putsf(s)
}

def CodeGenerator::gen_functions(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .gen_function(func)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_functions(child)
    }
}

def CodeGenerator::gen_function_decls(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .gen_function_decl(func)
        .out.puts(";\n")
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_function_decls(child)
    }
}

def CodeGenerator::gen_struct_typedefs(&this, ns: &Namespace) {
    let structs = ns.structs;
    for let i = 0; i < structs.size; i += 1 {
        let struc = structs.at(i) as &Structure
        let struc_name = .get_struct_name(struc)
        .out.putsf(`typedef struct {struc_name} {struc_name};\n`)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_struct_typedefs(child)
    }
}

def CodeGenerator::gen_structs(&this, ns: &Namespace) {
    let structs = ns.structs;
    for let i = 0; i < structs.size; i += 1 {
        let struc = structs.at(i) as &Structure
        let struc_name = .get_struct_name(struc)
        .out.putsf(`struct {struc_name} \{\n`)
        let fields = struc.fields
        for let j = 0; j < fields.size; j += 1 {
            let field = fields.at(j) as &Variable
            .out.puts("    ")
            .gen_type_and_name(field.type, .get_variable_name(field))
            .out.puts(";\n")
        }
        .out.puts("};\n\n")
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_structs(child)
    }
}

def CodeGenerator::generate(&this): string {
    // FIXME: Put all of this in a prelude file
    .out.puts("#include <stdio.h>\n")
    .out.puts("#include <stdlib.h>\n")
    .out.puts("#include <stdint.h>\n")
    .out.puts("#include <stdbool.h>\n")
    .out.puts("#include <stdarg.h>\n")
    .out.puts("\n")

    .out.puts("typedef int32_t i32;\n")
    .out.puts("typedef int64_t i64;\n")
    .out.puts("typedef uint32_t u32;\n")
    .out.puts("typedef uint64_t u64;\n")
    .out.puts("typedef float f32;\n")
    .out.puts("typedef double f64;\n")
    .out.puts("\n")

    .out.puts("char* format_string(const char* format, ...) {\n")
    .out.puts("  va_list args;\n")
    .out.puts("  va_start(args, format);\n")
    .out.puts("  int size = vsnprintf(NULL, 0, format, args);\n")
    .out.puts("  va_end(args);\n")
    .out.puts("  va_start(args, format);\n")
    .out.puts("  char* s = calloc(1, size + 1);\n")
    .out.puts("  vsprintf(s, format, args);\n")
    .out.puts("  s[size] = '\\0';\n")
    .out.puts("  va_end(args);\n")
    .out.puts("  return s;\n")
    .out.puts("}\n")
    .out.puts("\n")

    // TODO: gen structs / other stuff...
    .out.puts("/* Struct typedefs */\n")
    .gen_struct_typedefs(.program.global)

    .out.puts("/* Structs */\n")
    .gen_structs(.program.global)

    .out.puts("/* function declarations */\n")
    .gen_function_decls(.program.global)

    .out.puts("/* function implementations */\n")
    .gen_functions(.program.global)

    return .out.str()
}
