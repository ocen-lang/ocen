import std::vec::{ Vec3f }
import std::math::{ radians }

// lol
[formatting
    "(\n  %f   %f   %f   %f\n  %f   %f   %f   %f\n  %f   %f   %f   %f\n  %f   %f   %f   %f\n)"
    "$.d[0][0], $.d[0][1], $.d[0][2], $.d[0][3], $.d[1][0], $.d[1][1], $.d[1][2], $.d[1][3], $.d[2][0], $.d[2][1], $.d[2][2], $.d[2][3], $.d[3][0], $.d[3][1], $.d[3][2], $.d[3][3]"
]
struct Matrix4f {
    d: [[f32; 4]; 4]
}

def Matrix4f::transpose(this): Matrix4f {
    let m: Matrix4f
    for let i = 0; i < 4; i += 1 {
        for let j = 0; j < 4; j += 1 {
            m.d[i][j] = .d[j][i]
        }
    }
    return m
}

def Matrix4f::make(
    d00: f32, d01: f32, d02: f32, d03: f32,
    d10: f32, d11: f32, d12: f32, d13: f32,
    d20: f32, d21: f32, d22: f32, d23: f32,
    d30: f32, d31: f32, d32: f32, d33: f32
): Matrix4f {
    let m: Matrix4f
    m.d[0][0] = d00; m.d[0][1] = d01; m.d[0][2] = d02; m.d[0][3] = d03
    m.d[1][0] = d10; m.d[1][1] = d11; m.d[1][2] = d12; m.d[1][3] = d13
    m.d[2][0] = d20; m.d[2][1] = d21; m.d[2][2] = d22; m.d[2][3] = d23
    m.d[3][0] = d30; m.d[3][1] = d31; m.d[3][2] = d32; m.d[3][3] = d33
    return m
}

def Matrix4f::identity(): Matrix4f => Matrix4f::make(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
)

[operator "*"]
def Matrix4f::mul(this, other: Matrix4f): Matrix4f {
    let m: Matrix4f
    for let i = 0; i < 4; i += 1 {
        for let j = 0; j < 4; j += 1 {
            m.d[i][j] = 0.0
            for let k = 0; k < 4; k += 1 {
                m.d[i][j] += .d[i][k] * other.d[k][j]
            }
        }
    }
    return m
}

[operator "*"]
def Matrix4f::mulv(this, v: Vec3f): Vec3f {
    let x = v.x * .d[0][0] + v.y * .d[0][1] + v.z * .d[0][2] + .d[0][3]
    let y = v.x * .d[1][0] + v.y * .d[1][1] + v.z * .d[1][2] + .d[1][3]
    let z = v.x * .d[2][0] + v.y * .d[2][1] + v.z * .d[2][2] + .d[2][3]
    return Vec3f(x, y, z)
}

[operator "%"]
def Matrix4f::mulv_no_translation(this, v: Vec3f): Vec3f {
    let x = v.x * .d[0][0] + v.y * .d[0][1] + v.z * .d[0][2]
    let y = v.x * .d[1][0] + v.y * .d[1][1] + v.z * .d[1][2]
    let z = v.x * .d[2][0] + v.y * .d[2][1] + v.z * .d[2][2]
    return Vec3f(x, y, z)
}

[operator "*"]
def Matrix4f::scale(this, t: f32): Matrix4f {
    let m: Matrix4f
    for let i = 0; i < 4; i += 1 {
        for let j = 0; j < 4; j += 1 {
            m.d[i][j] = .d[i][j] * t
        }
    }
    return m
}

def Matrix4f::determinant(this): f32 {
    let a = .d[0][0] * (.d[1][1] * (.d[2][2] * .d[3][3] - .d[2][3] * .d[3][2]) - .d[1][2] * (.d[2][1] * .d[3][3] - .d[2][3] * .d[3][1]) + .d[1][3] * (.d[2][1] * .d[3][2] - .d[2][2] * .d[3][1]))
    let b = .d[0][1] * (.d[1][0] * (.d[2][2] * .d[3][3] - .d[2][3] * .d[3][2]) - .d[1][2] * (.d[2][0] * .d[3][3] - .d[2][3] * .d[3][0]) + .d[1][3] * (.d[2][0] * .d[3][2] - .d[2][2] * .d[3][0]))
    let c = .d[0][2] * (.d[1][0] * (.d[2][1] * .d[3][3] - .d[2][3] * .d[3][1]) - .d[1][1] * (.d[2][0] * .d[3][3] - .d[2][3] * .d[3][0]) + .d[1][3] * (.d[2][0] * .d[3][1] - .d[2][1] * .d[3][0]))
    let d = .d[0][3] * (.d[1][0] * (.d[2][1] * .d[3][2] - .d[2][2] * .d[3][1]) - .d[1][1] * (.d[2][0] * .d[3][2] - .d[2][2] * .d[3][0]) + .d[1][2] * (.d[2][0] * .d[3][1] - .d[2][1] * .d[3][0]))
    return a - b + c - d
}

// Source: https://stackoverflow.com/questions/1148309
def Matrix4f::invert(&this): Matrix4f {
  let inv: Matrix4f

  inv.d[0][0] =  .d[1][1] * .d[2][2] * .d[3][3] - .d[1][1] * .d[2][3] * .d[3][2] - .d[2][1] * .d[1][2] * .d[3][3] + .d[2][1] * .d[1][3] * .d[3][2] + .d[3][1] * .d[1][2] * .d[2][3] - .d[3][1] * .d[1][3] * .d[2][2]
  inv.d[1][0] = -.d[1][0] * .d[2][2] * .d[3][3] + .d[1][0] * .d[2][3] * .d[3][2] + .d[2][0] * .d[1][2] * .d[3][3] - .d[2][0] * .d[1][3] * .d[3][2] - .d[3][0] * .d[1][2] * .d[2][3] + .d[3][0] * .d[1][3] * .d[2][2]
  inv.d[2][0] =  .d[1][0] * .d[2][1] * .d[3][3] - .d[1][0] * .d[2][3] * .d[3][1] - .d[2][0] * .d[1][1] * .d[3][3] + .d[2][0] * .d[1][3] * .d[3][1] + .d[3][0] * .d[1][1] * .d[2][3] - .d[3][0] * .d[1][3] * .d[2][1]
  inv.d[3][0] = -.d[1][0] * .d[2][1] * .d[3][2] + .d[1][0] * .d[2][2] * .d[3][1] + .d[2][0] * .d[1][1] * .d[3][2] - .d[2][0] * .d[1][2] * .d[3][1] - .d[3][0] * .d[1][1] * .d[2][2] + .d[3][0] * .d[1][2] * .d[2][1]
  inv.d[0][1] = -.d[0][1] * .d[2][2] * .d[3][3] + .d[0][1] * .d[2][3] * .d[3][2] + .d[2][1] * .d[0][2] * .d[3][3] - .d[2][1] * .d[0][3] * .d[3][2] - .d[3][1] * .d[0][2] * .d[2][3] + .d[3][1] * .d[0][3] * .d[2][2]
  inv.d[1][1] =  .d[0][0] * .d[2][2] * .d[3][3] - .d[0][0] * .d[2][3] * .d[3][2] - .d[2][0] * .d[0][2] * .d[3][3] + .d[2][0] * .d[0][3] * .d[3][2] + .d[3][0] * .d[0][2] * .d[2][3] - .d[3][0] * .d[0][3] * .d[2][2]
  inv.d[2][1] = -.d[0][0] * .d[2][1] * .d[3][3] + .d[0][0] * .d[2][3] * .d[3][1] + .d[2][0] * .d[0][1] * .d[3][3] - .d[2][0] * .d[0][3] * .d[3][1] - .d[3][0] * .d[0][1] * .d[2][3] + .d[3][0] * .d[0][3] * .d[2][1]
  inv.d[3][1] =  .d[0][0] * .d[2][1] * .d[3][2] - .d[0][0] * .d[2][2] * .d[3][1] - .d[2][0] * .d[0][1] * .d[3][2] + .d[2][0] * .d[0][2] * .d[3][1] + .d[3][0] * .d[0][1] * .d[2][2] - .d[3][0] * .d[0][2] * .d[2][1]
  inv.d[0][2] =  .d[0][1] * .d[1][2] * .d[3][3] - .d[0][1] * .d[1][3] * .d[3][2] - .d[1][1] * .d[0][2] * .d[3][3] + .d[1][1] * .d[0][3] * .d[3][2] + .d[3][1] * .d[0][2] * .d[1][3] - .d[3][1] * .d[0][3] * .d[1][2]
  inv.d[1][2] = -.d[0][0] * .d[1][2] * .d[3][3] + .d[0][0] * .d[1][3] * .d[3][2] + .d[1][0] * .d[0][2] * .d[3][3] - .d[1][0] * .d[0][3] * .d[3][2] - .d[3][0] * .d[0][2] * .d[1][3] + .d[3][0] * .d[0][3] * .d[1][2]
  inv.d[2][2] =  .d[0][0] * .d[1][1] * .d[3][3] - .d[0][0] * .d[1][3] * .d[3][1] - .d[1][0] * .d[0][1] * .d[3][3] + .d[1][0] * .d[0][3] * .d[3][1] + .d[3][0] * .d[0][1] * .d[1][3] - .d[3][0] * .d[0][3] * .d[1][1]
  inv.d[3][2] = -.d[0][0] * .d[1][1] * .d[3][2] + .d[0][0] * .d[1][2] * .d[3][1] + .d[1][0] * .d[0][1] * .d[3][2] - .d[1][0] * .d[0][2] * .d[3][1] - .d[3][0] * .d[0][1] * .d[1][2] + .d[3][0] * .d[0][2] * .d[1][1]
  inv.d[0][3] = -.d[0][1] * .d[1][2] * .d[2][3] + .d[0][1] * .d[1][3] * .d[2][2] + .d[1][1] * .d[0][2] * .d[2][3] - .d[1][1] * .d[0][3] * .d[2][2] - .d[2][1] * .d[0][2] * .d[1][3] + .d[2][1] * .d[0][3] * .d[1][2]
  inv.d[1][3] =  .d[0][0] * .d[1][2] * .d[2][3] - .d[0][0] * .d[1][3] * .d[2][2] - .d[1][0] * .d[0][2] * .d[2][3] + .d[1][0] * .d[0][3] * .d[2][2] + .d[2][0] * .d[0][2] * .d[1][3] - .d[2][0] * .d[0][3] * .d[1][2]
  inv.d[2][3] = -.d[0][0] * .d[1][1] * .d[2][3] + .d[0][0] * .d[1][3] * .d[2][1] + .d[1][0] * .d[0][1] * .d[2][3] - .d[1][0] * .d[0][3] * .d[2][1] - .d[2][0] * .d[0][1] * .d[1][3] + .d[2][0] * .d[0][3] * .d[1][1]
  inv.d[3][3] =  .d[0][0] * .d[1][1] * .d[2][2] - .d[0][0] * .d[1][2] * .d[2][1] - .d[1][0] * .d[0][1] * .d[2][2] + .d[1][0] * .d[0][2] * .d[2][1] + .d[2][0] * .d[0][1] * .d[1][2] - .d[2][0] * .d[0][2] * .d[1][1]

  let det = .d[0][0] * inv.d[0][0] + .d[0][1] * inv.d[1][0] + .d[0][2] * inv.d[2][0] + .d[0][3] * inv.d[3][0]
  if det.abs() <= 0.0 return Matrix4f::identity()

  return inv * (1.0 / det)
}

def Matrix4f::for_translate(v: Vec3f): Matrix4f => Matrix4f::make(
    1.0, 0.0, 0.0, v.x,
    0.0, 1.0, 0.0, v.y,
    0.0, 0.0, 1.0, v.z,
    0.0, 0.0, 0.0, 1.0,
)

def Matrix4f::for_scale(v: Vec3f): Matrix4f => Matrix4f::make(
    v.x, 0.0, 0.0, 0.0,
    0.0, v.y, 0.0, 0.0,
    0.0, 0.0, v.z, 0.0,
    0.0, 0.0, 0.0, 1.0,
)

def Matrix4f::for_rotate_x(a: f32): Matrix4f => Matrix4f::make(
    1.0,     0.0,      0.0, 0.0,
    0.0, a.cos(), -a.sin(), 0.0,
    0.0, a.sin(),  a.cos(), 0.0,
    0.0,     0.0,      0.0, 1.0,
)

def Matrix4f::for_rotate_y(a: f32): Matrix4f => Matrix4f::make(
     a.cos(), 0.0, a.sin(), 0.0,
         0.0, 1.0,     0.0, 0.0,
    -a.sin(), 0.0, a.cos(), 0.0,
         0.0, 0.0,     0.0, 1.0,

)

def Matrix4f::for_rotate_z(a: f32): Matrix4f => Matrix4f::make(
    a.cos(), -a.sin(), 0.0, 0.0,
    a.sin(),  a.cos(), 0.0, 0.0,
        0.0,      0.0, 1.0, 0.0,
        0.0,      0.0, 0.0, 1.0,
)

def Matrix4f::for_rotate_axis(axis: Vec3f, angle: f32): Matrix4f {
    let u = axis.normalized()
    let cos_a = angle.cos()
    let sin_a = angle.sin()
    let one_minus_cos = 1.0 - cos_a

    return Matrix4f::make(
        cos_a + u.x * u.x * one_minus_cos,
        u.x * u.y * one_minus_cos - u.z * sin_a,
        u.x * u.z * one_minus_cos + u.y * sin_a,
        0.0,

        u.y * u.x * one_minus_cos + u.z * sin_a,
        cos_a + u.y * u.y * one_minus_cos,
        u.y * u.z * one_minus_cos - u.x * sin_a,
        0.0,

        u.z * u.x * one_minus_cos - u.y * sin_a,
        u.z * u.y * one_minus_cos + u.x * sin_a,
        cos_a + u.z * u.z * one_minus_cos,
        0.0,

        0.0, 0.0, 0.0, 1.0
    )
}


def Matrix4f::rotation_matrix_for(vec: Vec3f): Matrix4f {
    let theta = vec.y.atan2(vec.x)
    let phi = vec.z.acos()
    return Matrix4f::for_rotate_z(theta) * Matrix4f::for_rotate_y(phi)
}

