//! Simple wrapper around the pthread library

@compiler c_include "unistd.h"
@compiler c_include "pthread.h"
@compiler c_flag "-pthread"
import std::libc::{errno,strerror,exit,EXIT_FAILURE}

namespace impl {
  struct pthread_t extern
  struct pthread_attr_t extern
    
  def pthread_create(thread: &pthread_t, attr: &pthread_attr_t, start_routine: fn(untyped_ptr): untyped_ptr, arg: untyped_ptr): i32 extern
  def pthread_join(thread: pthread_t, retval: &untyped_ptr): i32 extern
  def pthread_attr_init(attr:&pthread_attr_t):i32 extern
  def pthread_attr_destroy(attr:&pthread_attr_t): i32 extern
  def pthread_attr_setstacksize(attr:&pthread_attr_t,stack_size:u64): i32 extern
  def pthread_attr_getstacksize(attr:&pthread_attr_t,getss:&i32):i32 extern
  def pthread_detach(attr:pthread_t):i32 extern
  def pthread_attr_setdetachstate(attr:&pthread_attr_t,detachstate:DetachState):i32 extern
  def pthread_attr_getdetachstate(attr:&pthread_attr_t,detachstate:&DetachState):i32 extern
  def pthread_attr_setschedpolicy(attr:&pthread_attr_t,policy:SchedPolicy):i32 extern
  def pthread_attr_getschedpolicy(attr:&pthread_attr_t,policy:&SchedPolicy):i32 extern
  def pthread_exit(retval:untyped_ptr) extern
}

namespace Muteximpl{ 
  struct pthread_mutex_t extern
  struct pthread_mutexattr_t extern
 
  def pthread_mutex_init(mutex:&pthread_mutex_t,attr:&pthread_mutexattr_t):i32 extern
  def pthread_mutexattr_init(attr: &pthread_mutexattr_t): i32 extern
  def pthread_mutexattr_settype(attr:&pthread_mutexattr_t,tty:MutexMode):i32 extern
  def pthread_mutex_destroy(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_lock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_trylock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_tryunlock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_unlock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutexattr_destroy(mutex:&pthread_mutexattr_t):i32 extern
}

// Soon i'll be implementing the conditional variable in this sync package 
namespace Condimpl{
  
}

[extern "int"]
enum MutexMode{
  Normal    = extern("PTHREAD_MUTEX_NORMAL") 
  Recursive = extern("PTHREAD_MUTEX_RECURSIVE")
  Errcheck  = extern("PTHREAD_MUTEX_ERRORCHECK") 
}

[extern "int"]
enum SchedPolicy{
  Normal     = extern("SCHED_OTHER")
  Fifo       = extern("SCHED_FIFO")
  RoundRobin = extern("SCHED_RR")
}

[extern "int"]
enum DetachState{
  Joinable   = extern("PTHREAD_CREATE_JOINABLE")
  Detached   = extern("PTHREAD_CREATE_DETACHED")
}

def check_and_fail(a:i32,msg: str = "Failed"){
  if a != 0 {
    println(`ERROR: {msg}`)
    exit(EXIT_FAILURE);
  }
}

def check_and_fail_with_errno(a:i32,msg:str = "Failed"){
  if a != 0 {
    println(`Error {msg}: {strerror(a)}`);
    exit(EXIT_FAILURE);
  }
}


struct Thread {
  tid:    impl::pthread_t 
  tattr:  impl::pthread_attr_t 
  cb:     fn(untyped_ptr): untyped_ptr
  args:   untyped_ptr
  policy: SchedPolicy
  dstate: DetachState
}

// Soon i will make this mutex like rust mutex which also contains the data in which needs to be locked
struct Mutex{
  tx:   Muteximpl::pthread_mutex_t
  attr: Muteximpl::pthread_mutexattr_t
  mode: MutexMode
}

def Thread::make(callback: fn(untyped_ptr): untyped_ptr, arg: untyped_ptr = null): Thread {
    let thread: Thread
    thread.policy = Normal
    thread.dstate = Joinable
    thread.cb     = callback
    thread.args   = arg
    return thread
}


// soon it will be deprecated if if language feature improves and we have varaiadic and template variadic 
def Thread::set_attr(&this,stack_size:u64,dstate:DetachState,policy:SchedPolicy){

  if .dstate == Joinable and .policy == Normal{
    check_and_fail_with_errno(impl::pthread_attr_init(&.tattr))
  }
  .dstate = dstate
  .policy = policy
  
  check_and_fail_with_errno(impl::pthread_attr_setstacksize(&.tattr,stack_size))
  check_and_fail_with_errno(impl::pthread_attr_setschedpolicy(&.tattr,.policy))
  check_and_fail_with_errno(impl::pthread_attr_setdetachstate(&.tattr,.dstate)) 
}

def Thread::set_stack(&this,stack_size:u64){
  if .dstate == Joinable and .policy == Normal{
    check_and_fail_with_errno(impl::pthread_attr_init(&.tattr))
  }
  
  check_and_fail_with_errno(impl::pthread_attr_setstacksize(&.tattr,stack_size))
}

def Thread::set_detach_state(&this,dstate:DetachState = Detached){
  if .dstate == Joinable and .policy == Normal{
    check_and_fail_with_errno(impl::pthread_attr_init(&.tattr))
  }
  .dstate = dstate
  
  check_and_fail_with_errno(impl::pthread_attr_setdetachstate(&.tattr,.dstate)) 
}

def Thread::set_sched_policy(&this,policy:SchedPolicy){
   if .dstate == Joinable and .policy == Normal{
    check_and_fail_with_errno(impl::pthread_attr_init(&.tattr))
  }
  .policy = policy

  check_and_fail_with_errno(impl::pthread_attr_setschedpolicy(&.tattr,.policy))
}

def Thread::start(&this){
  check_and_fail_with_errno(impl::pthread_create(&.tid, &.tattr, .cb, .args))
  //check_and_fail_with_errno(impl::pthread_detach(.tid)) 
}

def Thread::start_and_join(&this){
  .start()
  .join()
}

def Thread::join(&this,b:&untyped_ptr=null) {
  check_and_fail_with_errno(impl::pthread_join(.tid, b))
}

def Thread::exit(&this,retval:untyped_ptr){
  impl::pthread_exit(retval)
}

def Thread::destroy_attr(&this){
  check_and_fail_with_errno(impl::pthread_attr_destroy(&.tattr))
}

def Mutex::make(attrmode:MutexMode = Normal): Mutex{
  let mutex: Mutex
  let val:i32 
  mutex.mode = attrmode

  if attrmode != Normal{
    check_and_fail(Muteximpl::pthread_mutexattr_init(&mutex.attr),"Cannot initialize attribute")
    check_and_fail_with_errno(Muteximpl::pthread_mutexattr_settype(&mutex.attr,mutex.mode)) 
    val = Muteximpl::pthread_mutex_init(&mutex.tx,&mutex.attr);
  }else{
    val = Muteximpl::pthread_mutex_init(&mutex.tx,null)
  }
  
  // handling the error from here only and giving the errno output as str
  if val != 0{
    println(`{strerror(errno)}`);
    exit(EXIT_FAILURE);
  }
  return mutex
}

def Mutex::get_attr_type(&this): MutexMode => .mode

def Mutex::lock(&this){
  let val = Muteximpl::pthread_mutex_lock(&.tx)
  
  // handling error from here only and giving errno output as str
  if val != 0{
    println(`{strerror(errno)}`)
    exit(EXIT_FAILURE)
  }
}

def Mutex::try_lock(&this): i32{
  return Muteximpl::pthread_mutex_trylock(&.tx)
}

def Mutex::try_unlock(&this):i32 {
  return Muteximpl::pthread_mutex_unlock(&.tx)
}

def Mutex::unlock(&this){
  let val = Muteximpl::pthread_mutex_unlock(&.tx)
  
  if val != 0{
    println(`{strerror(errno)}`)
    exit(EXIT_FAILURE)
  }
}

def Mutex::destroy(&this){
  check_and_fail_with_errno(Muteximpl::pthread_mutex_destroy(&.tx))
}

[extern] def sleep(seconds: u32)
