import std::map::{ Map, Node }
import std::libc::{ calloc, free }

struct Set<T> {
    map: &Map<T, bool>
}

def Set::new(): &Set<T> {
    let set = calloc(1, sizeof(Set<T>)) as &Set<T>
    set.map = Map<T, bool>::new()
    return set
}

def Set::add(&this, key: T) {
    .map.insert(key, true)
}

def Set::remove(&this, key: T) {
    .map.remove(key)
}

def Set::size(&this): u32 {
    return .map.num_items
}

def Set::extend(&this, other: &Set<T>) {
    .map.extend(other.map)
}

def Set::subtract(&this, other: &Set<T>) {
    for let iter = other.iter(); iter.cur?; iter.next() {
        .remove(iter.value())
    }
}

def Set::iter(&this): Iterator<T> => Iterator<T>::make(this)
def Set::contains(&this, key: T): bool => .map.contains(key)
def Set::is_empty(&this): bool =>.size() == 0

def Set::free(&this) {
    .map.free()
    free(this)
}



struct Iterator<T> {
    idx: i32
    cur: &Node<T, bool>
    map: &Map<T, bool>
}

def Iterator::value(&this): T => .cur.key

def Iterator::make(set: &Set<T>): Iterator<T> {
    let it = Iterator<T>(idx: -1, cur: null, set.map)
    it.next()
    return it
}

def Iterator::next(&this) {
    while .idx < .map.num_buckets as i32 {
        while .cur? {
            .cur = .cur.next
            if .cur? return
        }
        .idx += 1
        .cur = if .idx < .map.num_buckets as i32 {
            yield .map.buckets[.idx]
        } else {
            yield null
        }
        if .cur? return
    }
}

// TODO: implement intersection as in-place operation