import std::thread::{Thread}
import std::libc::{errno,strerror,exit}

const EXIT_FAILURE:i32 extern

def check_and_fail(a:i32,msg: str = "Failed"){
  if(a != 0){
    println("MESSAGE: %s",msg)
    exit(EXIT_FAILURE);
  }
}

def check_and_fail_with_errno(a:i32,msg:str = "Failed"){
  if(a != 0){
    println("Message %s - %s",msg,strerror(errno));
    exit(EXIT_FAILURE);
  }
}

namespace Muteximpl{ 
  struct pthread_mutex_t extern
  struct pthread_mutexattr_t extern
  
  const PTHREAD_MUTEX_NORMAL:i32 extern
  const PTHREAD_MUTEX_RECURSIVE:i32 extern
  const PTHREAD_MUTEX_ERRORCHECK:i32 extern
  
  def pthread_mutex_init(mutex:&pthread_mutex_t,attr:&pthread_mutexattr_t):i32 extern
  def pthread_mutexattr_init(attr: &pthread_mutexattr_t): i32 extern
  def pthread_mutexattr_settype(attr:&pthread_mutexattr_t,tty:i32):i32 extern
  def pthread_mutex_destroy(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_lock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_trylock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_tryunlock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutex_unlock(mutex:&pthread_mutex_t):i32 extern
  def pthread_mutexattr_destroy(mutex:&pthread_mutexattr_t):i32 extern
}


// Soon i'll be implementing the conditional variable in this sync package 
namespace Condimpl{
  
}

enum Mutex_mode{
  NORMAL   
  RECURSIVE
  ERRCHECK 
}

def Mutex_mode::to_thread_api(this): i32{
  match this{
    NORMAL =>    return Muteximpl::PTHREAD_MUTEX_NORMAL
    RECURSIVE => return Muteximpl::PTHREAD_MUTEX_RECURSIVE
    ERRCHECK =>  return Muteximpl::PTHREAD_MUTEX_ERRORCHECK
  }
}

struct Mutex{
  tx:   Muteximpl::pthread_mutex_t
  attr: Muteximpl::pthread_mutexattr_t
  mode: Mutex_mode
}

def Mutex::init(attrmode:Mutex_mode = NORMAL): Mutex{
  let mutex: Mutex
  let val:i32 
  mutex.mode = attrmode

  if attrmode != NORMAL{
    check_and_fail(Muteximpl::pthread_mutexattr_init(&mutex.attr),"Cannot initialize attribute")
    check_and_fail_with_errno(Muteximpl::pthread_mutexattr_settype(&mutex.attr,mutex.mode.to_thread_api())) 
    val = Muteximpl::pthread_mutex_init(&mutex.tx,&mutex.attr);
  }else{
    val = Muteximpl::pthread_mutex_init(&mutex.tx,null)
  }
  
  // handling the error from here only and giving the errno output as str
  if val != 0{
    println("%s",strerror(errno));
    exit(EXIT_FAILURE);
  }
  return mutex
}

def Mutex::get_attr_type(&this): Mutex_mode{
  return this.mode
}

def Mutex::lock(&this){
  let val = Muteximpl::pthread_mutex_lock(&this.tx)
  
  // handling error from here only and giving errno output as str
  if val != 0{
    println("%s",strerror(errno))
    exit(EXIT_FAILURE)
  }
}

def Mutex::trylock(&this): i32{
  return Muteximpl::pthread_mutex_trylock(&this.tx)
}

def Mutex::tryunlock(&this):i32 {
  return Muteximpl::pthread_mutex_unlock(&this.tx)
}

def Mutex::unlock(&this){
  let val = Muteximpl::pthread_mutex_unlock(&this.tx)
  
  if val != 0{
    println("%s",strerror(errno))
    exit(EXIT_FAILURE)
  }
}

def Mutex::destroy(&this){
  Muteximpl::pthread_mutex_destroy(&this.tx);
}

let m:Mutex

def start_routine(a:untyped_ptr): untyped_ptr{
  m.lock()
  m.lock()
  for let i =0;i < 3;i+=1{
    print("Hello world bro meow meow\n");
  }
  m.unlock()
  m.unlock()
  return null;
}

