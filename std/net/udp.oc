//! UDP socket implementation for connectionless, datagram-based communication
//!
//! This module provides UDP socket functionality through the `UdpSocket` type,
//! supporting both client and server patterns for fast, unreliable message delivery.
//!
//! Socket Operations:
//!   Server Pattern:
//!     1. UdpSocket::bind(host, port) - Bind to specific address for receiving
//!     2. socket.recv_from(&buffer) - Receive datagram from any client
//!     3. socket.send_to(&buffer, "client_addr:port") - Send response back
//!
//!   Client Pattern:
//!     1. UdpSocket::bind("0.0.0.0", 0) - Bind to any available port
//!     2. socket.send_to(&buffer, "server_addr:port") - Send to server
//!     3. socket.recv_from(&buffer) - Receive response (if expected)
//!
//! Address Format:
//!   String format: "host:port" (e.g., "192.168.1.1:8080", "localhost:9001")
//!   Automatically parsed by send_to() using SV string utilities
//!
//! Socket Options:
//!   - SO_REUSEADDR enabled by default for quick server restarts
//!   - Binds to INADDR_ANY (0.0.0.0) to accept from any interface

import std::socket::{this, Socket, SocketStatus, SocketMode, RecvFromResult}
import std::socket::{close, sendto, recvfrom, setsockopt}
import std::buffer::Buffer
import std::result::Result
import std::sv::SV


//* A UDP socket.
struct UdpSocket {
    sock: Socket
}

//* Creates a UdpSocket from the given address.
def UdpSocket::bind(host: str, port: i32): Result<&UdpSocket, SocketStatus> {
    let fd = socket::socket(socket::AF_INET, socket::SOCK_DGRAM, socket::IPPROTO_UDP)
    if fd < 0 {
        return Error(SocketStatus::CreateError)
    }

    // Allow quick restarts
    let reuse: i32 = 1
    let res = setsockopt(fd, socket::SOL_SOCKET, socket::SO_REUSEADDR, &reuse as &i32, sizeof(i32) as i32)

    if res < 0 {
        println(f"Failed to set socket options")
        return Error(SocketStatus::ConnectError)
    }

    let server_addr: socket::SockAddrIn
    server_addr.sin_family = socket::AF_INET
    server_addr.sin_port = socket::htons(port)
    server_addr.sin_addr.s_addr = socket::INADDR_ANY as i32

    if socket::bind(fd, &server_addr as &socket::SockAddr, sizeof(socket::SockAddrIn) as i32) < 0 {
        let e = socket::errno
        socket::close(fd)
        return Error(SocketStatus::ConnectError)
    }

    let udp_socket = @new UdpSocket(Socket(fd))
    return Ok(udp_socket)
}

//* Receives a single datagram message on the socket. Returns the number of bytes read and the origin address.
def UdpSocket::recv_from(&this, buf: &Buffer, max_size: u32 = 65535): Result<&RecvFromResult, SocketStatus> {
    return .sock.recvfrom(buf, max_size)
}

//* Sends data on the socket to the given address. Returns the number of bytes written.
def UdpSocket::send_to(&this, buf: &Buffer, target: str): Result<i64, SocketStatus> {
    let sv = SV::from_str(target)
    let host = sv.chop_by_delim(':').copy_data_to_cstr()
    defer host.free()
    let port = sv.chop_i32()

    let bytes_written = .sock.sendto(buf, host, port)
    if bytes_written < 0 {
        return Error(SocketStatus::ConnectError)
    }
    return Ok(bytes_written)
}

//* Closes the UDP socket.
def UdpSocket::close(&this) {
    close(.sock.fd)
}
