//! TCP socket implementation for reliable, connection-oriented communication
//!
//! This module provides TCP client and server functionality through two main types:
//! - `TcpListener`: Binds to an address and accepts incoming connections
//! - `TcpStream`: Represents an established TCP connection for bidirectional data transfer
//!
//! Connection Lifecycle:
//!   Server Side:
//!     1. TcpListener::bind(host, port) - Creates listening socket
//!     2. listener.accept() - Blocks until client connects, returns TcpStream
//!     3. stream.read()/write() - Exchange data with client
//!     4. stream.close() - Terminate connection
//!
//!   Client Side:
//!     1. TcpStream::connect(host, port) - Establishes connection to server
//!     2. stream.read()/write() - Exchange data with server
//!     3. stream.close() - Terminate connection
//!
//! Error Handling:
//!   All operations return Result<T, SocketStatus> for proper error propagation:
//!   - SocketStatus::Ok: Operation succeeded
//!   - SocketStatus::CreateError: Socket creation failed
//!   - SocketStatus::ConnectError: Connection/bind/listen failed


import std::socket::{this, Socket, SocketStatus, SocketMode, SockAddr, SockAddrIn }
import std::buffer::Buffer
import std::result::Result
import std::fcntl::{ fcntl, F_GETFL }


//* Represents a TCP socket that is listening for incoming connections.
struct TcpListener {
    sock: Socket
}

//* Represents a TCP stream between a local and a remote socket.
struct TcpStream {
    sock: Socket
}

//* Creates a new TcpListener which will be bound to the specified address.
def TcpListener::bind(host: str, port: i32): Result<&TcpListener, SocketStatus> {

    let sock_fd = socket::socket(socket::AF_INET, socket::SOCK_STREAM, socket::IPPROTO_TCP)
    if sock_fd < 0 {
        println(f"Socket creation failed with errno: {socket::errno}")
        return Error(SocketStatus::CreateError)
    }

    let server_addr: SockAddrIn
    server_addr.sin_family = socket::AF_INET
    server_addr.sin_port = socket::htons(port)
    server_addr.sin_addr.s_addr = socket::INADDR_ANY as i32

    let bind_result = socket::bind(sock_fd, &server_addr as &SockAddr, sizeof(SockAddrIn) as i32)
    if bind_result < 0 {
        return Error(SocketStatus::ConnectError)
    }

    let listen_result = socket::listen(sock_fd, 128)
    if listen_result < 0 {
        return Error(SocketStatus::ConnectError)
    }

    let sock = Socket(sock_fd)
    let listener = @new TcpListener(sock)
    return Ok(listener)
}

//* Accepts a new connection on this listener.
def TcpListener::accept(&this): Result<&TcpStream, SocketStatus> {
    
    // Check if the socket is still valid
    let flags = fcntl(.sock.fd, F_GETFL, 0)

    if flags < 0 {
        return Error(SocketStatus::ConnectError)
    }
    
    let client_addr: SockAddrIn
    let addr_len: i32 = sizeof(SockAddrIn) as i32
    
    let client_fd = socket::accept(.sock.fd, &client_addr as &SockAddr, &addr_len)

    if client_fd < 0 {
        return Error(SocketStatus::ConnectError)
    }

    let stream_sock = Socket(client_fd)
    let stream = @new TcpStream(stream_sock)
    return Ok(stream)
}

//* Opens a TCP connection to a remote host.
def TcpStream::connect(host: str, port: i32): Result<&TcpStream, SocketStatus> {
    let sock: Socket
    let status = Socket::try_connect(host, port, SocketMode::TCP, &sock)
    if status != SocketStatus::Ok {
        return Error(status)
    }
    let stream = @new TcpStream(sock)
    return Ok(stream)
}

//* Reads data from the stream. Returns the number of bytes read.
def TcpStream::read(&this, buf: &Buffer): u32 {
    return .sock.read(buf, buf.capacity)
}

//* Writes data to the stream. Returns the number of bytes written.
def TcpStream::write(&this, buf: &Buffer): u32 {
    return .sock.write(buf)
}

//* Closes the connection.
def TcpStream::close(&this) {
    socket::close(.sock.fd)
}

//* Closes the listener.
def TcpListener::close(&this) {
    socket::close(.sock.fd)
}