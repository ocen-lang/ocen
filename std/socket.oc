//! Bindings to the C socket library

import std::buffer::Buffer
import std::libc::{ exit, strerror }
import std::fcntl
import std::time::{ TimeVal }
import std::result::Result

struct Socket {
    fd: i32
}

enum SocketMode {
    UDP
    TCP
}

enum SocketStatus {
    Ok
    CreateError
    HostError
    InetPtonError
    ConnectError
}

struct RecvFromResult {
    bytes_read: i64
    source_addr: str
}

def RecvFromResult::free(&this) {
    .source_addr.free()
    std::mem::free(this)
}

def Socket::try_connect(host: str, port: i32, mode: SocketMode, out_sock: &Socket, timeout_secs: i32 = -1): SocketStatus {
    let sock: Socket

	// Creating socket
	sock.fd = match mode {
        UDP => socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP),
        TCP => socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    }
	if (sock.fd < 0) {
        return CreateError
	}

	// Adding server address info. to struct
	let server_address: SockAddrIn
	server_address.sin_family = AF_INET;
	server_address.sin_port = htons(port);

    let hostm = gethostbyname(host)
    if not hostm? or not hostm.h_addr_list? {
        return HostError
    }
    let addr_ptr = hostm.h_addr_list[0] as &i32
    if not addr_ptr? {
        return HostError
    }
    server_address.sin_addr.s_addr = *addr_ptr

	// Assigning IP address to struct
	if (inet_pton(AF_INET, host, &server_address.sin_addr) < 0) {
        return InetPtonError
  	}

    let should_timeout = (timeout_secs > 0)
    let set: fcntl::FdSet

    if should_timeout {
        // Setting the socket to non-blocking
        set.zero()
        set.set(sock.fd)
        fcntl::fcntl(sock.fd, fcntl::F_SETFL, fcntl::O_NONBLOCK)
    }

    // Connecting to the socket
  	if (connect(sock.fd, (&server_address) as &SockAddr, sizeof(SockAddrIn)) < 0) {
        if should_timeout and errno != fcntl::EINPROGRESS {
            return ConnectError
        }
    }

    if should_timeout {
        let timeout: TimeVal
        timeout.tv_sec = timeout_secs as i64;
        timeout.tv_usec = 0;

        let ret = fcntl::select(sock.fd + 1, null, &set, null, &timeout);
        if (ret <= 0) {
            return ConnectError
        }

        // After connecting
        let flags = fcntl::fcntl(sock.fd, fcntl::F_GETFL, 0);
        fcntl::fcntl(sock.fd, fcntl::F_SETFL, flags & ~fcntl::O_NONBLOCK);
    }

    *out_sock = sock
    return Ok
}

def Socket::connect(host: str, port: i32, mode: SocketMode, timeout_secs: i32 = -1): Socket {
    let sock: Socket
    let res = Socket::try_connect(host, port, mode, &sock, timeout_secs)
    match res {
        Ok => {}
        CreateError => std::panic(f"Error creating socket: {strerror(errno)}")
        HostError => std::panic(f"Error getting host by name: {strerror(errno)}: ({host})")
        InetPtonError => std::panic(f"Error converting host to IP address: {strerror(errno)}: ({host})")
        ConnectError => std::panic(f"Error connecting to host: {strerror(errno)}")
    }
    return sock
}

def Socket::read(&this, buf: &Buffer, max_size: u32): u32 {
    buf.resize_if_necessary(max_size)
    buf.size = read(this.fd, buf.data, max_size)
    return buf.size
}

def Socket::read_exactly(&this, buf: &Buffer, size: u32): u32 {
    buf.resize_if_necessary(size)
    buf.size = 0
    while size > 0 {
        let n = read(this.fd, buf.data + buf.size, size)
        if n < 0 {
            println(`Error reading from socket: {strerror(errno)}`)
            return -1
        }
        buf.size += n
        size -= n
    }
    return buf.size
}

def Socket::recvfrom(&this, buf: &Buffer, max_size: u32): Result<&RecvFromResult, SocketStatus> {
    buf.resize_if_necessary(max_size)
    
    let client_addr: SockAddrIn
    let addr_len: u32 = sizeof(SockAddrIn) as u32
    
    let bytes_read = recvfrom(.fd, buf.data, max_size, 0, &client_addr as &SockAddr, &addr_len)
    if bytes_read < 0 {
        println(f"recvfrom failed with errno: {errno}")
        return Error(ConnectError)
    }

    buf.size = bytes_read as u32

    let addr_buf = Buffer::make()
    defer addr_buf.free()
    inet_ntop(AF_INET, &client_addr.sin_addr, addr_buf.data as str, INET_ADDRSTRLEN)
    
    let port = ntohs(client_addr.sin_port)
    let final_addr = f"{addr_buf.str()}:{port}"
    
    let result = @new RecvFromResult(bytes_read, final_addr)
    return Ok(result)
}

def Socket::sendto(&this, buf: &Buffer, host: str, port: i32): i64 {
    let dest_addr: SockAddrIn
    dest_addr.sin_family = AF_INET
    dest_addr.sin_port = htons(port)
    
    let hostm = gethostbyname(host)
    if not hostm? or not hostm.h_addr_list? {
        return -1
    }
    let addr_ptr = hostm.h_addr_list[0] as &i32
    if not addr_ptr? {
        return -1
    }
    dest_addr.sin_addr.s_addr = *addr_ptr

    return sendto(.fd, buf.data, buf.size, 0, &dest_addr as &SockAddr, sizeof(SockAddrIn))
}

def Socket::write(&this, buf: &Buffer): u32 => write(this.fd, buf.data, buf.size)


/// Internal stuff

@compiler c_include "sys/socket.h"
@compiler c_include "netinet/in.h"
@compiler c_include "arpa/inet.h"
@compiler c_include "unistd.h"
@compiler c_include "errno.h"
@compiler c_include "sys/types.h"
@compiler c_include "time.h"
@compiler c_include "sys/time.h"
@compiler c_include "netdb.h"

[extern "struct sockaddr"] struct SockAddr

[extern "struct hostent"]
struct HostEnt {
    h_name: str
    h_aliases: &&str
    h_addrtype: i32
    h_length: i32
    h_addr_list: &&u8
}

[extern "struct in_addr"]
struct SinAddr {
    s_addr: i32
}

[extern "struct sockaddr_in"]
struct SockAddrIn {
    sin_family: i32
    sin_port: i32
    sin_addr: SinAddr
}

[extern] def htonl(val: i32): i32
[extern] def htons(val: i32): i32
[extern] def ntohl(val: i32): i32
[extern] def ntohs(val: i32): i32

[extern] let errno: i32
[extern] let AF_INET: i32
[extern] let SOCK_STREAM: i32
[extern] let INADDR_ANY: i32
[extern] let IPPROTO_UDP: i32
[extern] let IPPROTO_TCP: i32
[extern] let SOCK_DGRAM: i32
[extern] let INET_ADDRSTRLEN: i32
[extern] let SOL_SOCKET: i32
[extern] let SO_REUSEADDR: i32

[extern] def socket(domain: i32, type: i32, protocol: i32): i32
[extern] def setsockopt(sockfd: i32, level: i32, optname: i32, optval: untyped_ptr, optlen: i32): i32
[extern] def bind(sockfd: i32, addr: &SockAddr, addrlen: i32): i32
[extern] def listen(sockfd: i32, backlog: i32): i32
[extern] def accept(sockfd: i32, addr: &SockAddr, addrlen: &i32): i32
[extern] def inet_pton(af: i32, src: str, dst: untyped_ptr): i32
[extern] def inet_ntop(af: i32, src: untyped_ptr, dst: str, size: i32): str
[extern] def connect(sockfd: i32, addr: &SockAddr, addrlen: u32): i32
[extern] def gethostbyname(name: str): &HostEnt

[extern] def recvfrom(sockfd: i32, buf: untyped_ptr, len: u32, flags: i32, src_addr: &SockAddr, addrlen: &u32): i64
[extern] def sendto(sockfd: i32, buf: untyped_ptr, len: u32, flags: i32, dest_addr: &SockAddr, addrlen: u32): i64
[extern] def read(fd: i32, buf: untyped_ptr, count: u32): u32
[extern] def write(fd: i32, buf: untyped_ptr, count: u32): u32
[extern] def close(fd: i32): i32
