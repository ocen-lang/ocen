//* Image struct / IO utilities (PPM)

import std::libc::{ calloc, free }
import std::buffer::Buffer

//* A type that holds an Image in 24-bit RGB format

struct Color {
    r: u8
    g: u8
    b: u8
}

struct Image {
    width: u32
    height: u32
    data: &Color
}

def Image::new(width: u32, height: u32): &Image {
    let img = calloc(1, sizeof(Image)) as &Image
    *img = Image(width, height, calloc(width * height, sizeof(Color)))
    return img
}

def Image::free(&this) {
    free(.data)
    free(this)
}

def Image::get(&this, x: u32, y: u32): Color => .data[y * .width + x]
def Image::set(&this, x: u32, y: u32, col: Color) { .data[y * .width + x] = col }

def Image::save(&this, filename: str) {
    import .ppm
    import .qoi

    let buffer = Buffer::make()
    if filename.ends_with(".ppm") {
        ppm::encode(this, &buffer)
    } else if filename.ends_with(".qoi") {
        qoi::encode(this, &buffer)
    } else {
        assert false, `Unknown file format for image: ${filename}`
    }

    let file = std::File::open(filename, "wb")
    file.write(buffer.data, buffer.size)
    file.close()
    buffer.free()
}

def Image::load(filename: str): &Image {
    import .ppm
    import .qoi

    let data = Buffer::from_file(filename)

    let image = null as &Image
    if filename.ends_with(".ppm") {
        image = ppm::decode(&data)
    } else if filename.ends_with(".qoi") {
        image = qoi::decode(&data)
    } else {
        assert false, `Unknown file format for image: ${filename}`
    }

    assert image?, `Failed to load image: ${filename}`
    data.free()
    return image
}

def interp(t: f32, a: f32, b: f32): f32 {
    return a * (1.0 - t) + b * t
}

def bilinear_interp(t0: f32, t1: f32, a: f32, b: f32, c: f32, d: f32):f32 {
    return interp(t1, interp(t0, a, b), interp(t0, c, d))
}

def Image::get_interpolated(&this, xf: f32, yf: f32): Color {
    assert 0.0 <= xf < (.width as f32), `X coordinate out of bounds: {xf}`
    assert 0.0 <= yf < (.height as f32), `Y coordinate out of bounds: {yf}`

    let x_fl = xf as u32
    let y_fl = yf as u32

    let x_cl = if xf != (x_fl as f32) then x_fl + 1 else x_fl
    let y_cl = if yf != (y_fl as f32) then y_fl + 1 else y_fl

    let a = .get(x_fl, y_fl)
    let b = .get(x_cl, y_fl)
    let c = .get(x_fl, y_cl)
    let d = .get(x_cl, y_cl)

    let x_ratio = xf - (x_fl as f32)
    let y_ratio = yf - (y_fl as f32)

    let col = Color(
        bilinear_interp(x_ratio, y_ratio, a.r as f32, b.r as f32, c.r as f32, d.r as f32) as u8,
        bilinear_interp(x_ratio, y_ratio, a.g as f32, b.g as f32, c.g as f32, d.g as f32) as u8,
        bilinear_interp(x_ratio, y_ratio, a.b as f32, b.b as f32, c.b as f32, d.b as f32) as u8,
    )
    return col
}

def Image::resize(&this, new_width: u32, new_height: u32): &Image {
    let resized = Image::new(new_width, new_height)
    let x_ratio = .width as f32 / new_width as f32
    let y_ratio = .height as f32 / new_height as f32
    for let ny = 0; ny < new_height; ++ny {
        for let nx = 0; nx < new_width; ++nx {
            let x = (nx as f32 * x_ratio)
            let y = (ny as f32 * y_ratio)
            resized.set(nx, ny, .get_interpolated(x, y))
        }
    }
    return resized
}

enum RotationDirection {
    Clockwise
    CounterClockwise
}

def Image::rotate(&this, dir: RotationDirection = RotationDirection::Clockwise): &Image {
    let rotated = Image::new(.height, .width)
    for let y = 0; y < .height; ++y {
        for let x = 0; x < .width; ++x {
            let col = if dir == RotationDirection::CounterClockwise {
                yield .get(.width - x - 1, y)
            } else {
                yield .get(x, .height - y - 1)
            }
            rotated.set(y, x, col)
        }
    }
    return rotated
}

def Image::draw_line_f(&this, x1: f32, y1: f32, x2: f32, y2: f32, color: Color) {
    // line algorithm
    let dx = x2 - x1
    let dy = y2 - y1

    let xt: f32
    let yt: f32

    if dx.abs() >= dy.abs() {
        if x2 < x1 {
            xt = x1; x1 = x2; x2 = xt
            yt = y1; y1 = y2; y2 = yt
        }

        let y = y1
        let inc = (y2 - y1) / (x2 - x1)

        for let x = x1; x <= x2; x += 1.0 {
            if 0 <= x as u32 < .width and 0 <= y as u32 < .height {
                .set(x as u32, y as u32, color)
            }

            y += inc
        }

    } else {
        if y2 < y1 {
            xt = x1; x1 = x2; x2 = xt
            yt = y1; y1 = y2; y2 = yt
        }

        let x = x1
        let inc = (x2 - x1) / (y2 - y1)

        for let y = y1; y <= y2; y += 1.0 {
            if 0 <= x as u32 < .width and 0 <= y as u32 < .height {
                .set(x as u32, y as u32, color)
            }

            x += inc
        }
    }
}

def Image::draw_line(&this, x1: i32, y1: i32, x2: i32, y2: i32, color: Color) {
    .draw_line_f(x1 as f32, y1 as f32, x2 as f32, y2 as f32, color)
}

def Image::draw_circle_f(&this, x: f32, y: f32, radius: f32, color: Color, segments: u32 = 100) {
    let dt = 6.2831852 / segments as f32
    for let i = 0; i < segments; i += 1 {
        let x0 = x + radius * (i as f32 * dt).cos()
        let y0 = y + radius * (i as f32 * dt).sin()
        let x1 = x + radius * ((i + 1) as f32 * dt).cos()
        let y1 = y + radius * ((i + 1) as f32 * dt).sin()
        .draw_line_f(x0, y0, x1, y1, color)
    }
}

def Image::draw_circle(&this, x: i32, y: i32, radius: i32, color: Color, segments: u32 = 100) {
    .draw_circle_f(x as f32, y as f32, radius as f32, color, segments)
}


def Image::clear(&this) {
    std::libc::memset(.data, 0, .width * .height * sizeof(Color))
}

def Image::copy(&this): &Image {
    let copy = Image::new(.width, .height)
    std::libc::memcpy(copy.data, .data, .width * .height * sizeof(Color))
    return copy
}