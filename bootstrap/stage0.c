#include "stdarg.h"
#include "string.h"
#include "ctype.h"
#include "dirent.h"
#include "unistd.h"
#include "sys/stat.h"
#include "sys/types.h"
#include "errno.h"
#include "libgen.h"
#include "dirent.h"
#include "setjmp.h"
#include "signal.h"
#include "sys/types.h"
#include "sys/wait.h"
#include "unistd.h"
#include "time.h"

/* Embed: /Users/mustafa/ocen-lang/ocen/std/./prelude.h */
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>
#include <stdlib.h>

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef float f32;
typedef double f64;

const char* __asan_default_options() { return "detect_leaks=0"; }

//// Backtraces

volatile static const char *__oc_bt[] = {0};
volatile u64 __oc_bt_idx = 0;

#define _WITH_BT(s, ...)      \
  __oc_bt[__oc_bt_idx++] = s; \
  __VA_ARGS__;                \
  (void)__oc_bt_idx--;

void dump_backtrace() {
  if (__oc_bt_idx == 0) {
    return;
  }
  fprintf(stderr, "--------------------------------------------------------------------------------\n");
  fprintf(stderr, "Backtrace:\n");
  for (u64 i = 0; i < __oc_bt_idx; i++) {
    fprintf(stderr, "  => %s\n", __oc_bt[i]);
  }

  fprintf(stderr, "--------------------------------------------------------------------------------\n");
}

/// End backtraces

#ifdef __APPLE__
  #define oc_trap __builtin_debugtrap
#else
  #define oc_trap __builtin_trap
#endif

void ae_assert_fail(char *dbg_msg, char *msg) {
  dump_backtrace();
  fprintf(stderr, "--------------------------------------------------------------------------------\n");
  fprintf(stderr, "%s\n", dbg_msg);
  if (msg) {
    fprintf(stderr, "  Message: %s\n", msg);
  }
  fprintf(stderr, "--------------------------------------------------------------------------------\n");
  fflush(stdout);
  oc_trap();
}


/* Constants */
#define compiler_passes_code_generator_cls_ctx_name ("_C")
#define compiler_passes_code_generator_cls_fn_field_name ("fn")
#define std_compact_map_INDEX_FREE (-1)
#define std_compact_map_INDEX_DELETED (-2)
/* Typedefs */
typedef struct std_sv_SV std_sv_SV;
typedef struct compiler_docgen_DocGenerator compiler_docgen_DocGenerator;
typedef struct compiler_passes_register_types_RegisterTypes compiler_passes_register_types_RegisterTypes;
typedef struct compiler_passes_register_types_Finder compiler_passes_register_types_Finder;
typedef struct _ClosureTy_2 _ClosureTy_2;
typedef struct _ClosureTy_3 _ClosureTy_3;
typedef struct compiler_passes_visitor_Visitor compiler_passes_visitor_Visitor;
typedef struct compiler_passes_mark_dead_code_MarkDeadCode compiler_passes_mark_dead_code_MarkDeadCode;
typedef struct compiler_passes_generic_pass_GenericPass compiler_passes_generic_pass_GenericPass;
typedef struct compiler_passes_typechecker_TypeChecker compiler_passes_typechecker_TypeChecker;
typedef enum compiler_passes_typechecker_Formattable compiler_passes_typechecker_Formattable;
typedef enum compiler_passes_typechecker_ErrorPropBase compiler_passes_typechecker_ErrorPropBase;
typedef struct std_buffer_Buffer std_buffer_Buffer;
typedef struct compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator;
typedef struct compiler_passes_reorder_symbols_ReorderSymbols compiler_passes_reorder_symbols_ReorderSymbols;
typedef struct std_span_Location std_span_Location;
typedef struct std_span_Span std_span_Span;
typedef struct compiler_parser_Parser compiler_parser_Parser;
typedef struct compiler_parser_LibraryInfo compiler_parser_LibraryInfo;
typedef struct compiler_ast_program_Namespace compiler_ast_program_Namespace;
typedef struct compiler_ast_program_CachedSymbols compiler_ast_program_CachedSymbols;
typedef struct compiler_ast_program_Program compiler_ast_program_Program;
typedef struct compiler_ast_program_NSIterator compiler_ast_program_NSIterator;
typedef struct compiler_ast_scopes_TemplateInstance compiler_ast_scopes_TemplateInstance;
typedef struct compiler_ast_scopes_Template compiler_ast_scopes_Template;
typedef enum compiler_ast_scopes_ReferenceType compiler_ast_scopes_ReferenceType;
typedef struct compiler_ast_scopes_Reference compiler_ast_scopes_Reference;
typedef struct compiler_ast_scopes_EnumField compiler_ast_scopes_EnumField;
typedef struct compiler_ast_scopes_ClosedVariable compiler_ast_scopes_ClosedVariable;
typedef union compiler_ast_scopes_SymbolUnion compiler_ast_scopes_SymbolUnion;
typedef enum compiler_ast_scopes_SymbolType compiler_ast_scopes_SymbolType;
typedef struct compiler_ast_scopes_Symbol compiler_ast_scopes_Symbol;
typedef struct compiler_ast_scopes_Scope compiler_ast_scopes_Scope;
typedef enum compiler_ast_operators_Operator compiler_ast_operators_Operator;
typedef struct compiler_ast_operators_OperatorOverload compiler_ast_operators_OperatorOverload;
typedef struct compiler_ast_nodes_Assertion compiler_ast_nodes_Assertion;
typedef struct compiler_ast_nodes_Binary compiler_ast_nodes_Binary;
typedef struct compiler_ast_nodes_Block compiler_ast_nodes_Block;
typedef enum compiler_ast_nodes_CallType compiler_ast_nodes_CallType;
typedef struct compiler_ast_nodes_FuncCall compiler_ast_nodes_FuncCall;
typedef struct compiler_ast_nodes_Cast compiler_ast_nodes_Cast;
typedef struct compiler_ast_nodes_Identifier compiler_ast_nodes_Identifier;
typedef struct compiler_ast_nodes_IfStatement compiler_ast_nodes_IfStatement;
typedef enum compiler_ast_nodes_ImportType compiler_ast_nodes_ImportType;
typedef struct compiler_ast_nodes_Import compiler_ast_nodes_Import;
typedef struct compiler_ast_nodes_NSLookup compiler_ast_nodes_NSLookup;
typedef struct compiler_ast_nodes_Loop compiler_ast_nodes_Loop;
typedef struct compiler_ast_nodes_Member compiler_ast_nodes_Member;
typedef struct compiler_ast_nodes_NumLiteral compiler_ast_nodes_NumLiteral;
typedef struct compiler_ast_nodes_Unary compiler_ast_nodes_Unary;
typedef struct compiler_ast_nodes_FormatString compiler_ast_nodes_FormatString;
typedef struct compiler_ast_nodes_Match compiler_ast_nodes_Match;
typedef struct compiler_ast_nodes_IsExpression compiler_ast_nodes_IsExpression;
typedef struct compiler_ast_nodes_Specialization compiler_ast_nodes_Specialization;
typedef struct compiler_ast_nodes_ArrayLiteral compiler_ast_nodes_ArrayLiteral;
typedef struct compiler_ast_nodes_VectorLiteral compiler_ast_nodes_VectorLiteral;
typedef struct compiler_ast_nodes_MapLiteral compiler_ast_nodes_MapLiteral;
typedef struct compiler_ast_nodes_Return compiler_ast_nodes_Return;
typedef union compiler_ast_nodes_ASTUnion compiler_ast_nodes_ASTUnion;
typedef enum compiler_ast_nodes_ASTType compiler_ast_nodes_ASTType;
typedef struct compiler_ast_nodes_AST compiler_ast_nodes_AST;
typedef struct compiler_ast_nodes_Variable compiler_ast_nodes_Variable;
typedef struct compiler_ast_nodes_Structure compiler_ast_nodes_Structure;
typedef struct compiler_ast_nodes_Enum compiler_ast_nodes_Enum;
typedef struct compiler_ast_nodes_EnumVariant compiler_ast_nodes_EnumVariant;
typedef enum compiler_ast_nodes_FunctionKind compiler_ast_nodes_FunctionKind;
typedef struct compiler_ast_nodes_Function compiler_ast_nodes_Function;
typedef struct compiler_ast_nodes_Argument compiler_ast_nodes_Argument;
typedef struct compiler_ast_nodes_ImportPartSingle compiler_ast_nodes_ImportPartSingle;
typedef struct compiler_ast_nodes_ImportPartMultiple compiler_ast_nodes_ImportPartMultiple;
typedef union compiler_ast_nodes_ImportPartUnion compiler_ast_nodes_ImportPartUnion;
typedef enum compiler_ast_nodes_ImportPartType compiler_ast_nodes_ImportPartType;
typedef struct compiler_ast_nodes_ImportPart compiler_ast_nodes_ImportPart;
typedef struct compiler_ast_nodes_IfBranch compiler_ast_nodes_IfBranch;
typedef struct compiler_ast_nodes_MatchCondArg compiler_ast_nodes_MatchCondArg;
typedef struct compiler_ast_nodes_MatchCond compiler_ast_nodes_MatchCond;
typedef struct compiler_ast_nodes_MatchCase compiler_ast_nodes_MatchCase;
typedef struct compiler_ast_nodes_MapLiteralPair compiler_ast_nodes_MapLiteralPair;
typedef struct compiler_lexer_Lexer compiler_lexer_Lexer;
typedef enum compiler_attributes_AttributeType compiler_attributes_AttributeType;
typedef struct compiler_attributes_Attribute compiler_attributes_Attribute;
typedef struct compiler_lsp_server_Loc compiler_lsp_server_Loc;
typedef struct compiler_lsp_server_TextDocument compiler_lsp_server_TextDocument;
typedef struct compiler_lsp_server_LSPServer compiler_lsp_server_LSPServer;
typedef enum compiler_lsp_cli_CommandType compiler_lsp_cli_CommandType;
typedef struct compiler_lsp_cli_finder_Finder compiler_lsp_cli_finder_Finder;
typedef enum compiler_tokens_TokenType compiler_tokens_TokenType;
typedef struct compiler_tokens_Token compiler_tokens_Token;
typedef struct compiler_types_FunctionType compiler_types_FunctionType;
typedef struct compiler_types_ArrayType compiler_types_ArrayType;
typedef struct compiler_types_UnresolvedTemplate compiler_types_UnresolvedTemplate;
typedef struct compiler_types_MapShorthandType compiler_types_MapShorthandType;
typedef struct compiler_types_TypeUnion compiler_types_TypeUnion;
typedef enum compiler_types_BaseType compiler_types_BaseType;
typedef struct compiler_types_Type compiler_types_Type;
typedef enum compiler_errors_ErrorType compiler_errors_ErrorType;
typedef struct compiler_errors_Error compiler_errors_Error;
typedef enum compiler_errors_MessageType compiler_errors_MessageType;
typedef struct std_CharIterator std_CharIterator;
typedef struct std_sv_SVLineIterator std_sv_SVLineIterator;
typedef struct std_sv_SVSplitIterator std_sv_SVSplitIterator;
typedef struct std_gc_impl_Header std_gc_impl_Header;
typedef struct std_compact_map_Item__0 std_compact_map_Item__0;
typedef struct std_compact_map_Item__1 std_compact_map_Item__1;
typedef struct std_compact_map_Item__2 std_compact_map_Item__2;
typedef struct std_compact_map_Map__0 std_compact_map_Map__0;
typedef struct std_compact_map_Map__1 std_compact_map_Map__1;
typedef struct std_compact_map_Map__2 std_compact_map_Map__2;
typedef struct std_vector_Iterator__29 std_vector_Iterator__29;
typedef struct std_compact_map_Iterator__1 std_compact_map_Iterator__1;
typedef enum std_logging_LogLevel std_logging_LogLevel;
typedef struct std_set_Set__0 std_set_Set__0;
typedef struct std_set_Set__1 std_set_Set__1;
typedef struct std_set_Set__2 std_set_Set__2;
typedef struct std_set_Set__3 std_set_Set__3;
typedef struct std_map_Iterator__13 std_map_Iterator__13;
typedef struct std_set_Iterator__3 std_set_Iterator__3;
typedef union std_value_ValueUnion std_value_ValueUnion;
typedef enum std_value_ValueType std_value_ValueType;
typedef struct std_value_Value std_value_Value;
typedef struct std_process_Output std_process_Output;
typedef enum std_fs_EntryType std_fs_EntryType;
typedef struct std_fs_DirectoryEntry std_fs_DirectoryEntry;
typedef struct std_fs_DirectoryIterator std_fs_DirectoryIterator;
typedef struct std_map_Item__0 std_map_Item__0;
typedef struct std_map_Item__1 std_map_Item__1;
typedef struct std_map_Item__2 std_map_Item__2;
typedef struct std_map_Item__3 std_map_Item__3;
typedef struct std_map_Item__4 std_map_Item__4;
typedef struct std_map_Item__5 std_map_Item__5;
typedef struct std_map_Item__6 std_map_Item__6;
typedef struct std_map_Item__7 std_map_Item__7;
typedef struct std_map_Item__8 std_map_Item__8;
typedef struct std_map_Item__9 std_map_Item__9;
typedef struct std_map_Item__10 std_map_Item__10;
typedef struct std_map_Item__11 std_map_Item__11;
typedef struct std_map_Item__12 std_map_Item__12;
typedef struct std_map_Item__13 std_map_Item__13;
typedef struct std_map_Map__0 std_map_Map__0;
typedef struct std_map_Map__1 std_map_Map__1;
typedef struct std_map_Map__2 std_map_Map__2;
typedef struct std_map_Map__3 std_map_Map__3;
typedef struct std_map_Map__4 std_map_Map__4;
typedef struct std_map_Map__5 std_map_Map__5;
typedef struct std_map_Map__6 std_map_Map__6;
typedef struct std_map_Map__7 std_map_Map__7;
typedef struct std_map_Map__8 std_map_Map__8;
typedef struct std_map_Map__9 std_map_Map__9;
typedef struct std_map_Map__10 std_map_Map__10;
typedef struct std_map_Map__11 std_map_Map__11;
typedef struct std_map_Map__12 std_map_Map__12;
typedef struct std_map_Map__13 std_map_Map__13;
typedef struct std_map_Iterator__2 std_map_Iterator__2;
typedef struct std_map_Iterator__4 std_map_Iterator__4;
typedef struct std_map_Iterator__5 std_map_Iterator__5;
typedef struct std_map_Iterator__7 std_map_Iterator__7;
typedef struct std_map_Iterator__9 std_map_Iterator__9;
typedef struct std_map_ValueIterator__4 std_map_ValueIterator__4;
typedef struct std_map_ValueIterator__5 std_map_ValueIterator__5;
typedef struct std_map_ValueIterator__9 std_map_ValueIterator__9;
typedef struct std_vector_Vector__0 std_vector_Vector__0;
typedef struct std_vector_Vector__1 std_vector_Vector__1;
typedef struct std_vector_Vector__2 std_vector_Vector__2;
typedef struct std_vector_Vector__3 std_vector_Vector__3;
typedef struct std_vector_Vector__4 std_vector_Vector__4;
typedef struct std_vector_Vector__5 std_vector_Vector__5;
typedef struct std_vector_Vector__6 std_vector_Vector__6;
typedef struct std_vector_Vector__7 std_vector_Vector__7;
typedef struct std_vector_Vector__8 std_vector_Vector__8;
typedef struct std_vector_Vector__9 std_vector_Vector__9;
typedef struct std_vector_Vector__10 std_vector_Vector__10;
typedef struct std_vector_Vector__11 std_vector_Vector__11;
typedef struct std_vector_Vector__12 std_vector_Vector__12;
typedef struct std_vector_Vector__13 std_vector_Vector__13;
typedef struct std_vector_Vector__14 std_vector_Vector__14;
typedef struct std_vector_Vector__15 std_vector_Vector__15;
typedef struct std_vector_Vector__16 std_vector_Vector__16;
typedef struct std_vector_Vector__17 std_vector_Vector__17;
typedef struct std_vector_Vector__18 std_vector_Vector__18;
typedef struct std_vector_Vector__19 std_vector_Vector__19;
typedef struct std_vector_Vector__20 std_vector_Vector__20;
typedef struct std_vector_Vector__21 std_vector_Vector__21;
typedef struct std_vector_Vector__22 std_vector_Vector__22;
typedef struct std_vector_Vector__23 std_vector_Vector__23;
typedef struct std_vector_Vector__24 std_vector_Vector__24;
typedef struct std_vector_Vector__25 std_vector_Vector__25;
typedef struct std_vector_Vector__26 std_vector_Vector__26;
typedef struct std_vector_Vector__27 std_vector_Vector__27;
typedef struct std_vector_Vector__28 std_vector_Vector__28;
typedef struct std_vector_Vector__29 std_vector_Vector__29;
typedef struct std_vector_Vector__30 std_vector_Vector__30;
typedef struct std_vector_Vector__31 std_vector_Vector__31;
typedef struct std_vector_Iterator__0 std_vector_Iterator__0;
typedef struct std_vector_Iterator__1 std_vector_Iterator__1;
typedef struct std_vector_Iterator__4 std_vector_Iterator__4;
typedef struct std_vector_Iterator__5 std_vector_Iterator__5;
typedef struct std_vector_Iterator__6 std_vector_Iterator__6;
typedef struct std_vector_Iterator__7 std_vector_Iterator__7;
typedef struct std_vector_Iterator__8 std_vector_Iterator__8;
typedef struct std_vector_Iterator__9 std_vector_Iterator__9;
typedef struct std_vector_Iterator__10 std_vector_Iterator__10;
typedef struct std_vector_Iterator__12 std_vector_Iterator__12;
typedef struct std_vector_Iterator__13 std_vector_Iterator__13;
typedef struct std_vector_Iterator__14 std_vector_Iterator__14;
typedef struct std_vector_Iterator__15 std_vector_Iterator__15;
typedef struct std_vector_Iterator__16 std_vector_Iterator__16;
typedef struct std_vector_Iterator__18 std_vector_Iterator__18;
typedef struct std_vector_Iterator__19 std_vector_Iterator__19;
typedef struct std_vector_Iterator__20 std_vector_Iterator__20;
typedef struct std_vector_Iterator__21 std_vector_Iterator__21;
typedef struct std_vector_Iterator__22 std_vector_Iterator__22;
typedef struct std_vector_Iterator__23 std_vector_Iterator__23;
typedef struct std_vector_Iterator__24 std_vector_Iterator__24;
typedef struct std_vector_Iterator__25 std_vector_Iterator__25;
typedef struct std_vector_Iterator__27 std_vector_Iterator__27;
typedef struct std_vector_Iterator__28 std_vector_Iterator__28;
typedef struct std_json_Parser std_json_Parser;
typedef struct _ClosureTy_32 _ClosureTy_32;
typedef struct compiler_lsp_cli_handle_validate__Closure_0Ctx compiler_lsp_cli_handle_validate__Closure_0Ctx;
typedef struct compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx;
typedef struct compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx;
typedef struct compiler_passes_visitor__Closure_3Ctx compiler_passes_visitor__Closure_3Ctx;
typedef struct compiler_passes_visitor__Closure_4Ctx compiler_passes_visitor__Closure_4Ctx;
typedef struct compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx;
typedef struct compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx;

/* Structs */
struct std_sv_SV {
  char *data;
  u32 len;
};

struct compiler_docgen_DocGenerator {
  compiler_ast_program_Program *program;
  std_sv_SV ocen_root;
};

struct compiler_passes_register_types_RegisterTypes {
  compiler_passes_generic_pass_GenericPass *o;
};

struct compiler_passes_register_types_Finder {
  compiler_passes_generic_pass_GenericPass *o;
  compiler_ast_scopes_Symbol *sym;
  compiler_types_Type *type;
};

struct _ClosureTy_2 {
  void *_C;
  void (*fn)(void *__C, compiler_ast_nodes_AST *);
};
struct _ClosureTy_3 {
  void *_C;
  void (*fn)(void *__C, compiler_types_Type *);
};
struct compiler_passes_visitor_Visitor {
  _ClosureTy_2 node_fn;
  _ClosureTy_3 type_fn;
};

struct compiler_passes_mark_dead_code_MarkDeadCode {
  compiler_passes_generic_pass_GenericPass *o;
  std_set_Set__0 *done;
};

struct compiler_passes_generic_pass_GenericPass {
  std_vector_Vector__2 *scope_stack;
  std_vector_Vector__3 *namespace_stack;
  compiler_ast_program_Program *program;
  compiler_types_Type *error_type;
};

struct compiler_passes_typechecker_TypeChecker {
  compiler_passes_generic_pass_GenericPass *o;
  std_vector_Vector__8 *unchecked_functions;
  bool in_template_instance;
};

enum compiler_passes_typechecker_Formattable {
  compiler_passes_typechecker_Formattable_No,
  compiler_passes_typechecker_Formattable_NotHere,
  compiler_passes_typechecker_Formattable_Yes,
};

char *compiler_passes_typechecker_Formattable_dbg(compiler_passes_typechecker_Formattable this) {
  switch (this) {
    case compiler_passes_typechecker_Formattable_No: return "No";
    case compiler_passes_typechecker_Formattable_NotHere: return "NotHere";
    case compiler_passes_typechecker_Formattable_Yes: return "Yes";
    default: return "<unknown>";
  }
}

enum compiler_passes_typechecker_ErrorPropBase {
  compiler_passes_typechecker_ErrorPropBase_Result,
  compiler_passes_typechecker_ErrorPropBase_Option,
};

char *compiler_passes_typechecker_ErrorPropBase_dbg(compiler_passes_typechecker_ErrorPropBase this) {
  switch (this) {
    case compiler_passes_typechecker_ErrorPropBase_Result: return "Result";
    case compiler_passes_typechecker_ErrorPropBase_Option: return "Option";
    default: return "<unknown>";
  }
}

struct std_buffer_Buffer {
  u8 *data;
  u32 size;
  u32 capacity;
};

struct compiler_passes_code_generator_CodeGenerator {
  compiler_passes_generic_pass_GenericPass *o;
  std_buffer_Buffer out;
  std_vector_Vector__1 *yield_vars;
  u32 indent;
};

struct compiler_passes_reorder_symbols_ReorderSymbols {
  compiler_passes_generic_pass_GenericPass *o;
  std_vector_Vector__10 *all_syms;
  std_set_Set__1 *done;
};

struct std_span_Location {
  char *filename;
  u32 line;
  u32 col;
  u32 index;
};

struct std_span_Span {
  std_span_Location start;
  std_span_Location end;
};

struct compiler_parser_Parser {
  std_vector_Vector__11 *tokens;
  u32 curr;
  compiler_ast_nodes_Function *curr_func;
  compiler_ast_program_Program *program;
  compiler_ast_program_Namespace *ns;
  std_vector_Vector__12 *attrs;
  std_span_Span attrs_span;
  compiler_tokens_Token *attrs_start_tok;
  std_span_Span prev_expr_error_span;
};

struct compiler_parser_LibraryInfo {
  char *parent_dir;
  char *path;
};

struct compiler_ast_program_Namespace {
  compiler_ast_program_Namespace *parent;
  std_vector_Vector__8 *functions;
  std_vector_Vector__13 *structs;
  std_vector_Vector__14 *enums;
  std_vector_Vector__15 *constants;
  std_vector_Vector__15 *variables;
  std_vector_Vector__15 *imports;
  std_map_Map__2 *typedefs;
  std_map_Map__4 *namespaces;
  std_map_Map__5 *exported_symbols;
  compiler_ast_scopes_Symbol *sym;
  compiler_ast_scopes_Scope *scope;
  char *path;
  std_span_Span span;
  bool is_a_file;
  bool always_add_to_scope;
  bool is_dir_with_mod;
  compiler_ast_program_Namespace *internal_project_root;
  std_vector_Vector__15 *unhandled_imports;
};

struct compiler_ast_program_CachedSymbols {
  compiler_ast_scopes_Symbol *fmt_string_fn;
  compiler_ast_scopes_Symbol *mem_alloc_fn;
  compiler_ast_scopes_Symbol *mem_allocator;
  compiler_ast_scopes_Symbol *std_vector;
  compiler_ast_scopes_Symbol *std_map;
  compiler_ast_scopes_Symbol *std_result;
  compiler_ast_scopes_Symbol *std_option;
  compiler_ast_scopes_Symbol *std_run_test;
  compiler_ast_scopes_Symbol *std_print_test_stats;
};

struct compiler_ast_program_Program {
  compiler_ast_program_Namespace *global;
  std_vector_Vector__10 *ordered_symbols;
  std_vector_Vector__1 *c_includes;
  std_vector_Vector__1 *c_flags;
  std_map_Map__6 *operator_overloads;
  std_map_Map__7 *c_embeds;
  std_map_Map__7 *sources;
  std_vector_Vector__1 *library_paths;
  std_vector_Vector__16 *errors;
  u32 error_level;
  compiler_ast_program_CachedSymbols cached_symbols;
  bool did_cache_symbols;
  std_vector_Vector__17 *err_jmp_stack;
  std_vector_Vector__10 *explicit_alive_symbols;
  std_vector_Vector__0 *closure_types;
  std_vector_Vector__8 *closures;
  bool check_doc_links;
  bool gen_debug_info;
  bool backtrace;
  bool keep_all_code;
  bool include_stdlib;
  bool is_test_mode;
  u32 uid;
};

struct compiler_ast_program_NSIterator {
  std_vector_Vector__3 *stack;
  compiler_ast_program_Namespace *curr;
};

struct compiler_ast_scopes_TemplateInstance {
  std_vector_Vector__0 *args;
  compiler_ast_scopes_Symbol *parent;
  compiler_ast_scopes_Symbol *resolved;
};

struct compiler_ast_scopes_Template {
  std_vector_Vector__10 *params;
  std_vector_Vector__5 *instances;
};

enum compiler_ast_scopes_ReferenceType {
  compiler_ast_scopes_ReferenceType_Normal,
  compiler_ast_scopes_ReferenceType_OperatorOverload,
  compiler_ast_scopes_ReferenceType_DotShorthand,
};

char *compiler_ast_scopes_ReferenceType_dbg(compiler_ast_scopes_ReferenceType this) {
  switch (this) {
    case compiler_ast_scopes_ReferenceType_Normal: return "Normal";
    case compiler_ast_scopes_ReferenceType_OperatorOverload: return "OperatorOverload";
    case compiler_ast_scopes_ReferenceType_DotShorthand: return "DotShorthand";
    default: return "<unknown>";
  }
}

struct compiler_ast_scopes_Reference {
  compiler_ast_scopes_ReferenceType type;
  std_span_Span span;
};

struct compiler_ast_scopes_EnumField {
  compiler_ast_nodes_EnumVariant *variant;
  u32 idx;
};

struct compiler_ast_scopes_ClosedVariable {
  compiler_ast_nodes_Variable *orig;
  compiler_ast_nodes_Function *closure;
};

union compiler_ast_scopes_SymbolUnion {
  compiler_ast_nodes_Function *func;
  compiler_ast_nodes_Structure *struc;
  compiler_ast_program_Namespace *ns;
  compiler_types_Type *type_def;
  compiler_ast_nodes_Variable *var;
  compiler_ast_nodes_Enum *enom;
  compiler_ast_nodes_EnumVariant *enum_var;
  compiler_ast_scopes_EnumField enum_field;
  compiler_ast_nodes_Function *closure;
  compiler_ast_scopes_ClosedVariable closed_var;
};

enum compiler_ast_scopes_SymbolType {
  compiler_ast_scopes_SymbolType_Function,
  compiler_ast_scopes_SymbolType_Structure,
  compiler_ast_scopes_SymbolType_TypeDef,
  compiler_ast_scopes_SymbolType_Namespace,
  compiler_ast_scopes_SymbolType_Variable,
  compiler_ast_scopes_SymbolType_Constant,
  compiler_ast_scopes_SymbolType_ClosureType,
  compiler_ast_scopes_SymbolType_Closure,
  compiler_ast_scopes_SymbolType_ClosedVariable,
  compiler_ast_scopes_SymbolType_Enum,
  compiler_ast_scopes_SymbolType_EnumVariant,
  compiler_ast_scopes_SymbolType_EnumField,
};

char *compiler_ast_scopes_SymbolType_dbg(compiler_ast_scopes_SymbolType this) {
  switch (this) {
    case compiler_ast_scopes_SymbolType_Function: return "Function";
    case compiler_ast_scopes_SymbolType_Structure: return "Structure";
    case compiler_ast_scopes_SymbolType_TypeDef: return "TypeDef";
    case compiler_ast_scopes_SymbolType_Namespace: return "Namespace";
    case compiler_ast_scopes_SymbolType_Variable: return "Variable";
    case compiler_ast_scopes_SymbolType_Constant: return "Constant";
    case compiler_ast_scopes_SymbolType_ClosureType: return "ClosureType";
    case compiler_ast_scopes_SymbolType_Closure: return "Closure";
    case compiler_ast_scopes_SymbolType_ClosedVariable: return "ClosedVariable";
    case compiler_ast_scopes_SymbolType_Enum: return "Enum";
    case compiler_ast_scopes_SymbolType_EnumVariant: return "EnumVariant";
    case compiler_ast_scopes_SymbolType_EnumField: return "EnumField";
    default: return "<unknown>";
  }
}

struct compiler_ast_scopes_Symbol {
  char *name;
  char *display;
  char *full_name;
  std_span_Span span;
  compiler_ast_program_Namespace *ns;
  char *comment;
  std_span_Location comment_loc;
  std_vector_Vector__18 *references;
  compiler_ast_scopes_SymbolType type;
  compiler_ast_scopes_SymbolUnion u;
  bool is_extern;
  char *extern_name;
  compiler_ast_scopes_Template *template;
  bool is_dead;
};

struct compiler_ast_scopes_Scope {
  std_map_Map__5 *items;
  std_vector_Vector__15 *defers;
  bool can_yield;
  compiler_ast_nodes_Function *cur_func;
  u32 loop_count;
  compiler_ast_nodes_AST *parent_loop;
  bool is_for_match;
  compiler_ast_scopes_Scope *parent;
};

enum compiler_ast_operators_Operator {
  compiler_ast_operators_Operator_Address,
  compiler_ast_operators_Operator_Dereference,
  compiler_ast_operators_Operator_Negate,
  compiler_ast_operators_Operator_Not,
  compiler_ast_operators_Operator_BitwiseNot,
  compiler_ast_operators_Operator_IsNotNull,
  compiler_ast_operators_Operator_ErrorProp,
  compiler_ast_operators_Operator_ErrorUnwrap,
  compiler_ast_operators_Operator_PreIncrement,
  compiler_ast_operators_Operator_PreDecrement,
  compiler_ast_operators_Operator_PostIncrement,
  compiler_ast_operators_Operator_PostDecrement,
  compiler_ast_operators_Operator_And,
  compiler_ast_operators_Operator_Assignment,
  compiler_ast_operators_Operator_BitwiseAnd,
  compiler_ast_operators_Operator_BitwiseOr,
  compiler_ast_operators_Operator_BitwiseXor,
  compiler_ast_operators_Operator_Divide,
  compiler_ast_operators_Operator_DivideEquals,
  compiler_ast_operators_Operator_Equals,
  compiler_ast_operators_Operator_EqualsValueEnumVariant,
  compiler_ast_operators_Operator_GreaterThan,
  compiler_ast_operators_Operator_GreaterThanEquals,
  compiler_ast_operators_Operator_In,
  compiler_ast_operators_Operator_Index,
  compiler_ast_operators_Operator_LeftShift,
  compiler_ast_operators_Operator_LessThan,
  compiler_ast_operators_Operator_LessThanEquals,
  compiler_ast_operators_Operator_Minus,
  compiler_ast_operators_Operator_MinusEquals,
  compiler_ast_operators_Operator_Modulus,
  compiler_ast_operators_Operator_Multiply,
  compiler_ast_operators_Operator_MultiplyEquals,
  compiler_ast_operators_Operator_NotEquals,
  compiler_ast_operators_Operator_Or,
  compiler_ast_operators_Operator_Plus,
  compiler_ast_operators_Operator_PlusEquals,
  compiler_ast_operators_Operator_RightShift,
  compiler_ast_operators_Operator_LeftShiftEquals,
  compiler_ast_operators_Operator_RightShiftEquals,
  compiler_ast_operators_Operator_IndexAssign,
  compiler_ast_operators_Operator_Error,
};

char *compiler_ast_operators_Operator_dbg(compiler_ast_operators_Operator this) {
  switch (this) {
    case compiler_ast_operators_Operator_Address: return "Address";
    case compiler_ast_operators_Operator_Dereference: return "Dereference";
    case compiler_ast_operators_Operator_Negate: return "Negate";
    case compiler_ast_operators_Operator_Not: return "Not";
    case compiler_ast_operators_Operator_BitwiseNot: return "BitwiseNot";
    case compiler_ast_operators_Operator_IsNotNull: return "IsNotNull";
    case compiler_ast_operators_Operator_ErrorProp: return "ErrorProp";
    case compiler_ast_operators_Operator_ErrorUnwrap: return "ErrorUnwrap";
    case compiler_ast_operators_Operator_PreIncrement: return "PreIncrement";
    case compiler_ast_operators_Operator_PreDecrement: return "PreDecrement";
    case compiler_ast_operators_Operator_PostIncrement: return "PostIncrement";
    case compiler_ast_operators_Operator_PostDecrement: return "PostDecrement";
    case compiler_ast_operators_Operator_And: return "And";
    case compiler_ast_operators_Operator_Assignment: return "Assignment";
    case compiler_ast_operators_Operator_BitwiseAnd: return "BitwiseAnd";
    case compiler_ast_operators_Operator_BitwiseOr: return "BitwiseOr";
    case compiler_ast_operators_Operator_BitwiseXor: return "BitwiseXor";
    case compiler_ast_operators_Operator_Divide: return "Divide";
    case compiler_ast_operators_Operator_DivideEquals: return "DivideEquals";
    case compiler_ast_operators_Operator_Equals: return "Equals";
    case compiler_ast_operators_Operator_EqualsValueEnumVariant: return "EqualsValueEnumVariant";
    case compiler_ast_operators_Operator_GreaterThan: return "GreaterThan";
    case compiler_ast_operators_Operator_GreaterThanEquals: return "GreaterThanEquals";
    case compiler_ast_operators_Operator_In: return "In";
    case compiler_ast_operators_Operator_Index: return "Index";
    case compiler_ast_operators_Operator_LeftShift: return "LeftShift";
    case compiler_ast_operators_Operator_LessThan: return "LessThan";
    case compiler_ast_operators_Operator_LessThanEquals: return "LessThanEquals";
    case compiler_ast_operators_Operator_Minus: return "Minus";
    case compiler_ast_operators_Operator_MinusEquals: return "MinusEquals";
    case compiler_ast_operators_Operator_Modulus: return "Modulus";
    case compiler_ast_operators_Operator_Multiply: return "Multiply";
    case compiler_ast_operators_Operator_MultiplyEquals: return "MultiplyEquals";
    case compiler_ast_operators_Operator_NotEquals: return "NotEquals";
    case compiler_ast_operators_Operator_Or: return "Or";
    case compiler_ast_operators_Operator_Plus: return "Plus";
    case compiler_ast_operators_Operator_PlusEquals: return "PlusEquals";
    case compiler_ast_operators_Operator_RightShift: return "RightShift";
    case compiler_ast_operators_Operator_LeftShiftEquals: return "LeftShiftEquals";
    case compiler_ast_operators_Operator_RightShiftEquals: return "RightShiftEquals";
    case compiler_ast_operators_Operator_IndexAssign: return "IndexAssign";
    case compiler_ast_operators_Operator_Error: return "Error";
    default: return "<unknown>";
  }
}

struct compiler_ast_operators_OperatorOverload {
  compiler_ast_operators_Operator op;
  compiler_types_Type *type1;
  compiler_types_Type *type2;
  compiler_types_Type *type3;
};

struct compiler_ast_nodes_Assertion {
  compiler_ast_nodes_AST *expr;
  compiler_ast_nodes_AST *msg;
};

struct compiler_ast_nodes_Binary {
  compiler_ast_operators_Operator op;
  compiler_ast_nodes_AST *lhs;
  compiler_ast_nodes_AST *rhs;
  std_span_Span op_span;
};

struct compiler_ast_nodes_Block {
  std_vector_Vector__15 *statements;
  compiler_ast_scopes_Scope *scope;
  compiler_ast_nodes_AST *final_stmt;
};

enum compiler_ast_nodes_CallType {
  compiler_ast_nodes_CallType_Normal,
  compiler_ast_nodes_CallType_Closure,
  compiler_ast_nodes_CallType_StructConstructor,
  compiler_ast_nodes_CallType_EnumConstructor,
};

char *compiler_ast_nodes_CallType_dbg(compiler_ast_nodes_CallType this) {
  switch (this) {
    case compiler_ast_nodes_CallType_Normal: return "Normal";
    case compiler_ast_nodes_CallType_Closure: return "Closure";
    case compiler_ast_nodes_CallType_StructConstructor: return "StructConstructor";
    case compiler_ast_nodes_CallType_EnumConstructor: return "EnumConstructor";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_FuncCall {
  compiler_ast_nodes_AST *callee;
  std_vector_Vector__9 *args;
  compiler_ast_nodes_Function *func;
  std_span_Span open_paren_span;
  std_span_Span close_paren_span;
  compiler_ast_nodes_CallType call_type;
  bool is_function_pointer;
};

struct compiler_ast_nodes_Cast {
  compiler_ast_nodes_AST *lhs;
  compiler_types_Type *to;
  compiler_types_Type *parsed_to;
};

struct compiler_ast_nodes_Identifier {
  char *name;
  compiler_ast_nodes_Variable *var;
  bool is_function;
  compiler_ast_nodes_Function *func;
};

struct compiler_ast_nodes_IfStatement {
  std_vector_Vector__23 *branches;
  compiler_ast_nodes_AST *els;
  std_span_Span els_span;
  std_span_Span if_span;
};

enum compiler_ast_nodes_ImportType {
  compiler_ast_nodes_ImportType_GlobalNamespace,
  compiler_ast_nodes_ImportType_ProjectNamespace,
  compiler_ast_nodes_ImportType_ParentNamespace,
  compiler_ast_nodes_ImportType_CurrentScope,
};

char *compiler_ast_nodes_ImportType_dbg(compiler_ast_nodes_ImportType this) {
  switch (this) {
    case compiler_ast_nodes_ImportType_GlobalNamespace: return "GlobalNamespace";
    case compiler_ast_nodes_ImportType_ProjectNamespace: return "ProjectNamespace";
    case compiler_ast_nodes_ImportType_ParentNamespace: return "ParentNamespace";
    case compiler_ast_nodes_ImportType_CurrentScope: return "CurrentScope";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_Import {
  std_vector_Vector__7 *parts;
  compiler_ast_nodes_ImportType type;
  u32 parent_count;
  bool export;
  compiler_ast_scopes_Symbol *root_sym;
};

struct compiler_ast_nodes_NSLookup {
  compiler_ast_nodes_AST *lhs;
  char *rhs_name;
  std_span_Span rhs_span;
};

struct compiler_ast_nodes_Loop {
  compiler_ast_nodes_AST *init;
  compiler_ast_nodes_AST *cond;
  compiler_ast_nodes_AST *step;
  compiler_ast_nodes_AST *body;
  bool needs_goto_break;
  char *break_label;
};

struct compiler_ast_nodes_Member {
  compiler_ast_nodes_AST *lhs;
  char *rhs_name;
  std_span_Span rhs_span;
  bool dot_shorthand;
  bool is_pointer;
};

struct compiler_ast_nodes_NumLiteral {
  char *text;
  compiler_types_Type *suffix;
  f64 as_float;
  u64 as_int;
};

struct compiler_ast_nodes_Unary {
  compiler_ast_operators_Operator op;
  compiler_ast_nodes_AST *expr;
  std_span_Span op_span;
};

struct compiler_ast_nodes_FormatString {
  std_vector_Vector__1 *parts;
  std_vector_Vector__1 *specs;
  std_vector_Vector__15 *exprs;
};

struct compiler_ast_nodes_Match {
  compiler_ast_nodes_AST *expr;
  std_vector_Vector__24 *cases;
  compiler_ast_nodes_AST *defolt;
  bool is_custom_match;
  std_span_Span defolt_span;
  std_span_Span match_span;
};

struct compiler_ast_nodes_IsExpression {
  compiler_ast_nodes_AST *lhs;
  std_vector_Vector__6 *conds;
};

struct compiler_ast_nodes_Specialization {
  compiler_ast_nodes_AST *base;
  std_vector_Vector__0 *parsed_template_args;
  std_vector_Vector__0 *template_args;
};

struct compiler_ast_nodes_ArrayLiteral {
  std_vector_Vector__15 *elements;
};

struct compiler_ast_nodes_VectorLiteral {
  std_vector_Vector__15 *elements;
  compiler_types_Type *vec_type;
  compiler_ast_nodes_Structure *vec_struc;
  std_span_Span start_span;
};

struct compiler_ast_nodes_MapLiteral {
  std_vector_Vector__25 *elements;
  compiler_types_Type *map_type;
  compiler_ast_nodes_Structure *map_struc;
  std_span_Span start_span;
};

struct compiler_ast_nodes_Return {
  compiler_ast_nodes_AST *expr;
  std_span_Span return_span;
};

union compiler_ast_nodes_ASTUnion {
  compiler_ast_nodes_Assertion assertion;
  compiler_ast_nodes_Binary binary;
  compiler_ast_nodes_Block block;
  bool bool_literal;
  compiler_ast_nodes_FuncCall call;
  compiler_ast_nodes_Cast cast;
  compiler_ast_nodes_Identifier ident;
  compiler_ast_nodes_IfStatement if_stmt;
  compiler_ast_nodes_Import import_path;
  compiler_ast_nodes_NSLookup lookup;
  compiler_ast_nodes_Loop loop;
  compiler_ast_nodes_Member member;
  compiler_ast_nodes_NumLiteral num_literal;
  char *string_literal;
  char *char_literal;
  compiler_ast_nodes_Unary unary;
  std_span_Span operator_span;
  compiler_ast_nodes_Variable *var_decl;
  compiler_ast_nodes_FormatString fmt_str;
  compiler_types_Type *size_of_type;
  compiler_ast_nodes_Match match_stmt;
  compiler_ast_nodes_IsExpression is_expr;
  compiler_ast_nodes_AST *target_loop;
  compiler_ast_nodes_Specialization spec;
  compiler_ast_nodes_ArrayLiteral array_literal;
  compiler_ast_nodes_VectorLiteral vec_literal;
  compiler_ast_nodes_MapLiteral map_literal;
  compiler_ast_nodes_AST *child;
  compiler_ast_nodes_Return ret;
  compiler_ast_nodes_Function *closure;
};

enum compiler_ast_nodes_ASTType {
  compiler_ast_nodes_ASTType_Assert,
  compiler_ast_nodes_ASTType_Block,
  compiler_ast_nodes_ASTType_BoolLiteral,
  compiler_ast_nodes_ASTType_Break,
  compiler_ast_nodes_ASTType_Call,
  compiler_ast_nodes_ASTType_Continue,
  compiler_ast_nodes_ASTType_Error,
  compiler_ast_nodes_ASTType_Identifier,
  compiler_ast_nodes_ASTType_If,
  compiler_ast_nodes_ASTType_Is,
  compiler_ast_nodes_ASTType_Import,
  compiler_ast_nodes_ASTType_IntLiteral,
  compiler_ast_nodes_ASTType_Member,
  compiler_ast_nodes_ASTType_NSLookup,
  compiler_ast_nodes_ASTType_OverloadedOperator,
  compiler_ast_nodes_ASTType_Return,
  compiler_ast_nodes_ASTType_Yield,
  compiler_ast_nodes_ASTType_StringLiteral,
  compiler_ast_nodes_ASTType_SizeOf,
  compiler_ast_nodes_ASTType_VarDeclaration,
  compiler_ast_nodes_ASTType_While,
  compiler_ast_nodes_ASTType_For,
  compiler_ast_nodes_ASTType_CharLiteral,
  compiler_ast_nodes_ASTType_FloatLiteral,
  compiler_ast_nodes_ASTType_FormatStringLiteral,
  compiler_ast_nodes_ASTType_Cast,
  compiler_ast_nodes_ASTType_Null,
  compiler_ast_nodes_ASTType_Match,
  compiler_ast_nodes_ASTType_Defer,
  compiler_ast_nodes_ASTType_Specialization,
  compiler_ast_nodes_ASTType_CreateClosure,
  compiler_ast_nodes_ASTType_ArrayLiteral,
  compiler_ast_nodes_ASTType_TryMember,
  compiler_ast_nodes_ASTType_VectorLiteral,
  compiler_ast_nodes_ASTType_MapLiteral,
  compiler_ast_nodes_ASTType_CreateNew,
  compiler_ast_nodes_ASTType_UnaryOp,
  compiler_ast_nodes_ASTType_BinaryOp,
};

char *compiler_ast_nodes_ASTType_dbg(compiler_ast_nodes_ASTType this) {
  switch (this) {
    case compiler_ast_nodes_ASTType_Assert: return "Assert";
    case compiler_ast_nodes_ASTType_Block: return "Block";
    case compiler_ast_nodes_ASTType_BoolLiteral: return "BoolLiteral";
    case compiler_ast_nodes_ASTType_Break: return "Break";
    case compiler_ast_nodes_ASTType_Call: return "Call";
    case compiler_ast_nodes_ASTType_Continue: return "Continue";
    case compiler_ast_nodes_ASTType_Error: return "Error";
    case compiler_ast_nodes_ASTType_Identifier: return "Identifier";
    case compiler_ast_nodes_ASTType_If: return "If";
    case compiler_ast_nodes_ASTType_Is: return "Is";
    case compiler_ast_nodes_ASTType_Import: return "Import";
    case compiler_ast_nodes_ASTType_IntLiteral: return "IntLiteral";
    case compiler_ast_nodes_ASTType_Member: return "Member";
    case compiler_ast_nodes_ASTType_NSLookup: return "NSLookup";
    case compiler_ast_nodes_ASTType_OverloadedOperator: return "OverloadedOperator";
    case compiler_ast_nodes_ASTType_Return: return "Return";
    case compiler_ast_nodes_ASTType_Yield: return "Yield";
    case compiler_ast_nodes_ASTType_StringLiteral: return "StringLiteral";
    case compiler_ast_nodes_ASTType_SizeOf: return "SizeOf";
    case compiler_ast_nodes_ASTType_VarDeclaration: return "VarDeclaration";
    case compiler_ast_nodes_ASTType_While: return "While";
    case compiler_ast_nodes_ASTType_For: return "For";
    case compiler_ast_nodes_ASTType_CharLiteral: return "CharLiteral";
    case compiler_ast_nodes_ASTType_FloatLiteral: return "FloatLiteral";
    case compiler_ast_nodes_ASTType_FormatStringLiteral: return "FormatStringLiteral";
    case compiler_ast_nodes_ASTType_Cast: return "Cast";
    case compiler_ast_nodes_ASTType_Null: return "Null";
    case compiler_ast_nodes_ASTType_Match: return "Match";
    case compiler_ast_nodes_ASTType_Defer: return "Defer";
    case compiler_ast_nodes_ASTType_Specialization: return "Specialization";
    case compiler_ast_nodes_ASTType_CreateClosure: return "CreateClosure";
    case compiler_ast_nodes_ASTType_ArrayLiteral: return "ArrayLiteral";
    case compiler_ast_nodes_ASTType_TryMember: return "TryMember";
    case compiler_ast_nodes_ASTType_VectorLiteral: return "VectorLiteral";
    case compiler_ast_nodes_ASTType_MapLiteral: return "MapLiteral";
    case compiler_ast_nodes_ASTType_CreateNew: return "CreateNew";
    case compiler_ast_nodes_ASTType_UnaryOp: return "UnaryOp";
    case compiler_ast_nodes_ASTType_BinaryOp: return "BinaryOp";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_AST {
  compiler_ast_nodes_ASTType type;
  std_span_Span span;
  compiler_ast_nodes_ASTUnion u;
  compiler_types_Type *etype;
  compiler_types_Type *hint;
  compiler_ast_scopes_Symbol *resolved_symbol;
  bool returns;
};

struct compiler_ast_nodes_Variable {
  compiler_ast_scopes_Symbol *sym;
  compiler_types_Type *type;
  bool is_atomic;
  compiler_ast_nodes_AST *default_value;
  compiler_types_Type *parsed_type;
};

struct compiler_ast_nodes_Structure {
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__4 *fields;
  compiler_types_Type *type;
  bool is_union;
  std_span_Span span;
  char *format_spec;
  char *format_args;
};

struct compiler_ast_nodes_Enum {
  compiler_ast_scopes_Symbol *sym;
  std_span_Span span;
  std_vector_Vector__4 *shared_fields;
  std_vector_Vector__20 *variants;
  compiler_types_Type *type;
  bool has_values;
};

struct compiler_ast_nodes_EnumVariant {
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__4 *specific_fields;
  compiler_ast_nodes_Enum *parent;
  std_span_Span span;
};

enum compiler_ast_nodes_FunctionKind {
  compiler_ast_nodes_FunctionKind_Normal,
  compiler_ast_nodes_FunctionKind_Method,
  compiler_ast_nodes_FunctionKind_Closure,
};

char *compiler_ast_nodes_FunctionKind_dbg(compiler_ast_nodes_FunctionKind this) {
  switch (this) {
    case compiler_ast_nodes_FunctionKind_Normal: return "Normal";
    case compiler_ast_nodes_FunctionKind_Method: return "Method";
    case compiler_ast_nodes_FunctionKind_Closure: return "Closure";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_Function {
  compiler_ast_nodes_FunctionKind kind;
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__4 *params;
  compiler_types_Type *return_type;
  compiler_ast_nodes_AST *body;
  bool is_arrow;
  compiler_ast_scopes_Scope *scope;
  compiler_ast_scopes_Scope *closure_scope;
  std_map_Map__5 *closed_vars;
  std_span_Span span;
  compiler_types_Type *parsed_return_type;
  compiler_ast_nodes_AST *name_ast;
  compiler_types_Type *type;
  bool checked;
  bool is_variadic;
  bool is_variadic_format;
  bool is_test_function;
  std_vector_Vector__21 *operator_overloads;
  bool exits;
  bool is_static;
  compiler_types_Type *parent_type;
};

struct compiler_ast_nodes_Argument {
  compiler_ast_nodes_AST *expr;
  char *label;
  std_span_Span label_span;
};

struct compiler_ast_nodes_ImportPartSingle {
  char *name;
  std_span_Span name_span;
  char *alias;
  std_span_Span alias_span;
};

struct compiler_ast_nodes_ImportPartMultiple {
  std_span_Span open_curly_span;
  std_span_Span close_curly_span;
  std_vector_Vector__22 *paths;
};

union compiler_ast_nodes_ImportPartUnion {
  compiler_ast_nodes_ImportPartSingle single;
  compiler_ast_nodes_ImportPartMultiple multiple;
};

enum compiler_ast_nodes_ImportPartType {
  compiler_ast_nodes_ImportPartType_Single,
  compiler_ast_nodes_ImportPartType_Multiple,
  compiler_ast_nodes_ImportPartType_Wildcard,
};

char *compiler_ast_nodes_ImportPartType_dbg(compiler_ast_nodes_ImportPartType this) {
  switch (this) {
    case compiler_ast_nodes_ImportPartType_Single: return "Single";
    case compiler_ast_nodes_ImportPartType_Multiple: return "Multiple";
    case compiler_ast_nodes_ImportPartType_Wildcard: return "Wildcard";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_ImportPart {
  compiler_ast_nodes_ImportPartType type;
  compiler_ast_nodes_ImportPartUnion u;
  std_span_Span span;
  compiler_ast_scopes_Symbol *resolved_symbol;
};

struct compiler_ast_nodes_IfBranch {
  compiler_ast_nodes_AST *cond;
  compiler_ast_nodes_AST *body;
};

struct compiler_ast_nodes_MatchCondArg {
  compiler_ast_nodes_Variable *var;
  bool is_shared;
};

struct compiler_ast_nodes_MatchCond {
  compiler_ast_nodes_AST *expr;
  compiler_ast_nodes_Function *cmp_fn;
  std_vector_Vector__19 *args;
};

struct compiler_ast_nodes_MatchCase {
  std_vector_Vector__6 *conds;
  compiler_ast_nodes_AST *body;
};

struct compiler_ast_nodes_MapLiteralPair {
  compiler_ast_nodes_AST *key;
  compiler_ast_nodes_AST *value;
};

struct compiler_lexer_Lexer {
  char *source;
  u32 source_len;
  u32 i;
  std_span_Location loc;
  bool seen_newline;
  std_vector_Vector__11 *tokens;
  std_vector_Vector__16 *errors;
  bool in_comment;
  std_buffer_Buffer comment;
  std_span_Location comment_start;
};

enum compiler_attributes_AttributeType {
  compiler_attributes_AttributeType_Extern,
  compiler_attributes_AttributeType_Exits,
  compiler_attributes_AttributeType_VariadicFormat,
  compiler_attributes_AttributeType_Export,
  compiler_attributes_AttributeType_Formatting,
  compiler_attributes_AttributeType_Operator,
  compiler_attributes_AttributeType_Atomic,
  compiler_attributes_AttributeType_Alive,
  compiler_attributes_AttributeType_Test,
  compiler_attributes_AttributeType_Invalid,
};

char *compiler_attributes_AttributeType_dbg(compiler_attributes_AttributeType this) {
  switch (this) {
    case compiler_attributes_AttributeType_Extern: return "Extern";
    case compiler_attributes_AttributeType_Exits: return "Exits";
    case compiler_attributes_AttributeType_VariadicFormat: return "VariadicFormat";
    case compiler_attributes_AttributeType_Export: return "Export";
    case compiler_attributes_AttributeType_Formatting: return "Formatting";
    case compiler_attributes_AttributeType_Operator: return "Operator";
    case compiler_attributes_AttributeType_Atomic: return "Atomic";
    case compiler_attributes_AttributeType_Alive: return "Alive";
    case compiler_attributes_AttributeType_Test: return "Test";
    case compiler_attributes_AttributeType_Invalid: return "Invalid";
    default: return "<unknown>";
  }
}

struct compiler_attributes_Attribute {
  compiler_attributes_AttributeType type;
  std_vector_Vector__1 *args;
  std_span_Span span;
};

struct compiler_lsp_server_Loc {
  i32 row;
  i32 col;
  std_sv_SV uri;
  std_sv_SV path;
};

struct compiler_lsp_server_TextDocument {
  std_buffer_Buffer text;
};

struct compiler_lsp_server_LSPServer {
  std_compact_map_Map__0 *documents;
  f64 validate_throttle_ms;
  f64 last_validated;
  std_value_Value *to_validate_req;
};

char *compiler_lsp_server_DiagnosticSeverity_dbg(i64 this) {
  switch (this) {
    case 1: return "Error";
    case 2: return "Warning";
    case 3: return "Information";
    case 4: return "Hint";
    default: return "<unknown>";
  }
}

char *compiler_lsp_server_LSPSymbolKind_dbg(i32 this) {
  switch (this) {
    case 1: return "File";
    case 2: return "Module";
    case 3: return "Namespace";
    case 4: return "Package";
    case 5: return "Class";
    case 6: return "Method";
    case 7: return "Property";
    case 8: return "Field";
    case 9: return "Constructor";
    case 10: return "Enum";
    case 11: return "Interface";
    case 12: return "Function";
    case 13: return "Variable";
    case 14: return "Constant";
    case 15: return "String";
    case 16: return "Number";
    case 17: return "Boolean";
    case 18: return "Array";
    case 19: return "Object";
    case 20: return "Key";
    case 21: return "Null";
    case 22: return "EnumMember";
    case 23: return "Struct";
    case 24: return "Event";
    case 25: return "Operator";
    case 26: return "TypeParameter";
    default: return "<unknown>";
  }
}

enum compiler_lsp_cli_CommandType {
  compiler_lsp_cli_CommandType_Hover,
  compiler_lsp_cli_CommandType_GoToDefinition,
  compiler_lsp_cli_CommandType_GoToType,
  compiler_lsp_cli_CommandType_None,
  compiler_lsp_cli_CommandType_DocumentSymbols,
  compiler_lsp_cli_CommandType_Completions,
  compiler_lsp_cli_CommandType_References,
  compiler_lsp_cli_CommandType_Renames,
  compiler_lsp_cli_CommandType_SignatureHelp,
  compiler_lsp_cli_CommandType_Validate,
};

char *compiler_lsp_cli_CommandType_dbg(compiler_lsp_cli_CommandType this) {
  switch (this) {
    case compiler_lsp_cli_CommandType_Hover: return "Hover";
    case compiler_lsp_cli_CommandType_GoToDefinition: return "GoToDefinition";
    case compiler_lsp_cli_CommandType_GoToType: return "GoToType";
    case compiler_lsp_cli_CommandType_None: return "None";
    case compiler_lsp_cli_CommandType_DocumentSymbols: return "DocumentSymbols";
    case compiler_lsp_cli_CommandType_Completions: return "Completions";
    case compiler_lsp_cli_CommandType_References: return "References";
    case compiler_lsp_cli_CommandType_Renames: return "Renames";
    case compiler_lsp_cli_CommandType_SignatureHelp: return "SignatureHelp";
    case compiler_lsp_cli_CommandType_Validate: return "Validate";
    default: return "<unknown>";
  }
}

struct compiler_lsp_cli_finder_Finder {
  compiler_lsp_cli_CommandType cmd;
  std_span_Location loc;
  compiler_ast_scopes_Symbol *found_sym;
  compiler_ast_nodes_AST *found_node;
  compiler_ast_scopes_Scope *found_scope;
  compiler_ast_program_Namespace *found_import_ns;
  u32 active_param;
  compiler_ast_nodes_AST *call;
  std_vector_Vector__2 *scopes;
};

enum compiler_tokens_TokenType {
  compiler_tokens_TokenType_Ampersand,
  compiler_tokens_TokenType_AtSign,
  compiler_tokens_TokenType_Backtick,
  compiler_tokens_TokenType_Caret,
  compiler_tokens_TokenType_CharLiteral,
  compiler_tokens_TokenType_CloseCurly,
  compiler_tokens_TokenType_CloseParen,
  compiler_tokens_TokenType_CloseSquare,
  compiler_tokens_TokenType_Colon,
  compiler_tokens_TokenType_ColonColon,
  compiler_tokens_TokenType_Comma,
  compiler_tokens_TokenType_Dollar,
  compiler_tokens_TokenType_Dot,
  compiler_tokens_TokenType_Ellipsis,
  compiler_tokens_TokenType_EOF,
  compiler_tokens_TokenType_EqualEquals,
  compiler_tokens_TokenType_Equals,
  compiler_tokens_TokenType_Exclamation,
  compiler_tokens_TokenType_ExclamationExclamation,
  compiler_tokens_TokenType_FatArrow,
  compiler_tokens_TokenType_FloatLiteral,
  compiler_tokens_TokenType_FormatStringLiteral,
  compiler_tokens_TokenType_GreaterThan,
  compiler_tokens_TokenType_GreaterThanEquals,
  compiler_tokens_TokenType_Identifier,
  compiler_tokens_TokenType_IntLiteral,
  compiler_tokens_TokenType_LessThan,
  compiler_tokens_TokenType_LessThanEquals,
  compiler_tokens_TokenType_Line,
  compiler_tokens_TokenType_Minus,
  compiler_tokens_TokenType_MinusEquals,
  compiler_tokens_TokenType_MinusMinus,
  compiler_tokens_TokenType_NotEquals,
  compiler_tokens_TokenType_OpenCurly,
  compiler_tokens_TokenType_OpenParen,
  compiler_tokens_TokenType_OpenSquare,
  compiler_tokens_TokenType_Percent,
  compiler_tokens_TokenType_Plus,
  compiler_tokens_TokenType_PlusEquals,
  compiler_tokens_TokenType_PlusPlus,
  compiler_tokens_TokenType_Question,
  compiler_tokens_TokenType_QuestionDot,
  compiler_tokens_TokenType_Semicolon,
  compiler_tokens_TokenType_Slash,
  compiler_tokens_TokenType_SlashEquals,
  compiler_tokens_TokenType_Star,
  compiler_tokens_TokenType_StarEquals,
  compiler_tokens_TokenType_StringLiteral,
  compiler_tokens_TokenType_Tilde,
  compiler_tokens_TokenType_Newline,
  compiler_tokens_TokenType_BEGIN_KEYWORDS,
  compiler_tokens_TokenType_And,
  compiler_tokens_TokenType_As,
  compiler_tokens_TokenType_Assert,
  compiler_tokens_TokenType_Break,
  compiler_tokens_TokenType_Const,
  compiler_tokens_TokenType_Continue,
  compiler_tokens_TokenType_Def,
  compiler_tokens_TokenType_Defer,
  compiler_tokens_TokenType_Else,
  compiler_tokens_TokenType_Enum,
  compiler_tokens_TokenType_Extern,
  compiler_tokens_TokenType_False,
  compiler_tokens_TokenType_For,
  compiler_tokens_TokenType_Fn,
  compiler_tokens_TokenType_If,
  compiler_tokens_TokenType_Let,
  compiler_tokens_TokenType_Match,
  compiler_tokens_TokenType_Namespace,
  compiler_tokens_TokenType_Null,
  compiler_tokens_TokenType_Not,
  compiler_tokens_TokenType_Or,
  compiler_tokens_TokenType_Return,
  compiler_tokens_TokenType_SizeOf,
  compiler_tokens_TokenType_Struct,
  compiler_tokens_TokenType_True,
  compiler_tokens_TokenType_Then,
  compiler_tokens_TokenType_TypeDef,
  compiler_tokens_TokenType_Union,
  compiler_tokens_TokenType_Import,
  compiler_tokens_TokenType_Void,
  compiler_tokens_TokenType_Yield,
  compiler_tokens_TokenType_While,
};

char *compiler_tokens_TokenType_dbg(compiler_tokens_TokenType this) {
  switch (this) {
    case compiler_tokens_TokenType_Ampersand: return "Ampersand";
    case compiler_tokens_TokenType_AtSign: return "AtSign";
    case compiler_tokens_TokenType_Backtick: return "Backtick";
    case compiler_tokens_TokenType_Caret: return "Caret";
    case compiler_tokens_TokenType_CharLiteral: return "CharLiteral";
    case compiler_tokens_TokenType_CloseCurly: return "CloseCurly";
    case compiler_tokens_TokenType_CloseParen: return "CloseParen";
    case compiler_tokens_TokenType_CloseSquare: return "CloseSquare";
    case compiler_tokens_TokenType_Colon: return "Colon";
    case compiler_tokens_TokenType_ColonColon: return "ColonColon";
    case compiler_tokens_TokenType_Comma: return "Comma";
    case compiler_tokens_TokenType_Dollar: return "Dollar";
    case compiler_tokens_TokenType_Dot: return "Dot";
    case compiler_tokens_TokenType_Ellipsis: return "Ellipsis";
    case compiler_tokens_TokenType_EOF: return "EOF";
    case compiler_tokens_TokenType_EqualEquals: return "EqualEquals";
    case compiler_tokens_TokenType_Equals: return "Equals";
    case compiler_tokens_TokenType_Exclamation: return "Exclamation";
    case compiler_tokens_TokenType_ExclamationExclamation: return "ExclamationExclamation";
    case compiler_tokens_TokenType_FatArrow: return "FatArrow";
    case compiler_tokens_TokenType_FloatLiteral: return "FloatLiteral";
    case compiler_tokens_TokenType_FormatStringLiteral: return "FormatStringLiteral";
    case compiler_tokens_TokenType_GreaterThan: return "GreaterThan";
    case compiler_tokens_TokenType_GreaterThanEquals: return "GreaterThanEquals";
    case compiler_tokens_TokenType_Identifier: return "Identifier";
    case compiler_tokens_TokenType_IntLiteral: return "IntLiteral";
    case compiler_tokens_TokenType_LessThan: return "LessThan";
    case compiler_tokens_TokenType_LessThanEquals: return "LessThanEquals";
    case compiler_tokens_TokenType_Line: return "Line";
    case compiler_tokens_TokenType_Minus: return "Minus";
    case compiler_tokens_TokenType_MinusEquals: return "MinusEquals";
    case compiler_tokens_TokenType_MinusMinus: return "MinusMinus";
    case compiler_tokens_TokenType_NotEquals: return "NotEquals";
    case compiler_tokens_TokenType_OpenCurly: return "OpenCurly";
    case compiler_tokens_TokenType_OpenParen: return "OpenParen";
    case compiler_tokens_TokenType_OpenSquare: return "OpenSquare";
    case compiler_tokens_TokenType_Percent: return "Percent";
    case compiler_tokens_TokenType_Plus: return "Plus";
    case compiler_tokens_TokenType_PlusEquals: return "PlusEquals";
    case compiler_tokens_TokenType_PlusPlus: return "PlusPlus";
    case compiler_tokens_TokenType_Question: return "Question";
    case compiler_tokens_TokenType_QuestionDot: return "QuestionDot";
    case compiler_tokens_TokenType_Semicolon: return "Semicolon";
    case compiler_tokens_TokenType_Slash: return "Slash";
    case compiler_tokens_TokenType_SlashEquals: return "SlashEquals";
    case compiler_tokens_TokenType_Star: return "Star";
    case compiler_tokens_TokenType_StarEquals: return "StarEquals";
    case compiler_tokens_TokenType_StringLiteral: return "StringLiteral";
    case compiler_tokens_TokenType_Tilde: return "Tilde";
    case compiler_tokens_TokenType_Newline: return "Newline";
    case compiler_tokens_TokenType_BEGIN_KEYWORDS: return "BEGIN_KEYWORDS";
    case compiler_tokens_TokenType_And: return "And";
    case compiler_tokens_TokenType_As: return "As";
    case compiler_tokens_TokenType_Assert: return "Assert";
    case compiler_tokens_TokenType_Break: return "Break";
    case compiler_tokens_TokenType_Const: return "Const";
    case compiler_tokens_TokenType_Continue: return "Continue";
    case compiler_tokens_TokenType_Def: return "Def";
    case compiler_tokens_TokenType_Defer: return "Defer";
    case compiler_tokens_TokenType_Else: return "Else";
    case compiler_tokens_TokenType_Enum: return "Enum";
    case compiler_tokens_TokenType_Extern: return "Extern";
    case compiler_tokens_TokenType_False: return "False";
    case compiler_tokens_TokenType_For: return "For";
    case compiler_tokens_TokenType_Fn: return "Fn";
    case compiler_tokens_TokenType_If: return "If";
    case compiler_tokens_TokenType_Let: return "Let";
    case compiler_tokens_TokenType_Match: return "Match";
    case compiler_tokens_TokenType_Namespace: return "Namespace";
    case compiler_tokens_TokenType_Null: return "Null";
    case compiler_tokens_TokenType_Not: return "Not";
    case compiler_tokens_TokenType_Or: return "Or";
    case compiler_tokens_TokenType_Return: return "Return";
    case compiler_tokens_TokenType_SizeOf: return "SizeOf";
    case compiler_tokens_TokenType_Struct: return "Struct";
    case compiler_tokens_TokenType_True: return "True";
    case compiler_tokens_TokenType_Then: return "Then";
    case compiler_tokens_TokenType_TypeDef: return "TypeDef";
    case compiler_tokens_TokenType_Union: return "Union";
    case compiler_tokens_TokenType_Import: return "Import";
    case compiler_tokens_TokenType_Void: return "Void";
    case compiler_tokens_TokenType_Yield: return "Yield";
    case compiler_tokens_TokenType_While: return "While";
    default: return "<unknown>";
  }
}

struct compiler_tokens_Token {
  compiler_tokens_TokenType type;
  std_span_Span span;
  char *text;
  compiler_tokens_Token *suffix;
  bool seen_newline;
  char *comment;
  std_span_Location comment_loc;
};

struct compiler_types_FunctionType {
  compiler_ast_nodes_Function *orig;
  std_vector_Vector__4 *params;
  compiler_types_Type *return_type;
  bool is_variadic;
};

struct compiler_types_ArrayType {
  compiler_types_Type *elem_type;
  compiler_ast_nodes_AST *size_expr;
  bool size_known;
  u32 size;
};

struct compiler_types_UnresolvedTemplate {
  compiler_types_Type *base;
  std_vector_Vector__0 *args;
};

struct compiler_types_MapShorthandType {
  compiler_types_Type *key;
  compiler_types_Type *value;
};

struct compiler_types_TypeUnion {
  compiler_types_Type *ptr;
  compiler_ast_nodes_Structure *struc;
  compiler_ast_nodes_Enum *enom;
  compiler_ast_nodes_AST *unresolved;
  compiler_types_FunctionType func;
  compiler_types_ArrayType arr;
  compiler_types_UnresolvedTemplate unresolved_spec;
  compiler_types_MapShorthandType map_types;
};

enum compiler_types_BaseType {
  compiler_types_BaseType_Char,
  compiler_types_BaseType_Bool,
  compiler_types_BaseType_Void,
  compiler_types_BaseType_I8,
  compiler_types_BaseType_I16,
  compiler_types_BaseType_I32,
  compiler_types_BaseType_I64,
  compiler_types_BaseType_U8,
  compiler_types_BaseType_U16,
  compiler_types_BaseType_U32,
  compiler_types_BaseType_U64,
  compiler_types_BaseType_F32,
  compiler_types_BaseType_F64,
  compiler_types_BaseType_NUM_BASE_TYPES,
  compiler_types_BaseType_FunctionPtr,
  compiler_types_BaseType_Closure,
  compiler_types_BaseType_Pointer,
  compiler_types_BaseType_Structure,
  compiler_types_BaseType_Unresolved,
  compiler_types_BaseType_Array,
  compiler_types_BaseType_Alias,
  compiler_types_BaseType_UnresolvedTemplate,
  compiler_types_BaseType_Enum,
  compiler_types_BaseType_VectorShorthand,
  compiler_types_BaseType_MapShorthand,
  compiler_types_BaseType_Error,
};

char *compiler_types_BaseType_dbg(compiler_types_BaseType this) {
  switch (this) {
    case compiler_types_BaseType_Char: return "Char";
    case compiler_types_BaseType_Bool: return "Bool";
    case compiler_types_BaseType_Void: return "Void";
    case compiler_types_BaseType_I8: return "I8";
    case compiler_types_BaseType_I16: return "I16";
    case compiler_types_BaseType_I32: return "I32";
    case compiler_types_BaseType_I64: return "I64";
    case compiler_types_BaseType_U8: return "U8";
    case compiler_types_BaseType_U16: return "U16";
    case compiler_types_BaseType_U32: return "U32";
    case compiler_types_BaseType_U64: return "U64";
    case compiler_types_BaseType_F32: return "F32";
    case compiler_types_BaseType_F64: return "F64";
    case compiler_types_BaseType_NUM_BASE_TYPES: return "NUM_BASE_TYPES";
    case compiler_types_BaseType_FunctionPtr: return "FunctionPtr";
    case compiler_types_BaseType_Closure: return "Closure";
    case compiler_types_BaseType_Pointer: return "Pointer";
    case compiler_types_BaseType_Structure: return "Structure";
    case compiler_types_BaseType_Unresolved: return "Unresolved";
    case compiler_types_BaseType_Array: return "Array";
    case compiler_types_BaseType_Alias: return "Alias";
    case compiler_types_BaseType_UnresolvedTemplate: return "UnresolvedTemplate";
    case compiler_types_BaseType_Enum: return "Enum";
    case compiler_types_BaseType_VectorShorthand: return "VectorShorthand";
    case compiler_types_BaseType_MapShorthand: return "MapShorthand";
    case compiler_types_BaseType_Error: return "Error";
    default: return "<unknown>";
  }
}

struct compiler_types_Type {
  char *name;
  compiler_types_BaseType base;
  std_span_Span span;
  compiler_types_TypeUnion u;
  std_map_Map__9 *methods;
  compiler_ast_scopes_Symbol *sym;
  compiler_ast_scopes_TemplateInstance *template_instance;
};

enum compiler_errors_ErrorType {
  compiler_errors_ErrorType_Standard,
  compiler_errors_ErrorType_WithNote,
  compiler_errors_ErrorType_WithHint,
};

char *compiler_errors_ErrorType_dbg(compiler_errors_ErrorType this) {
  switch (this) {
    case compiler_errors_ErrorType_Standard: return "Standard";
    case compiler_errors_ErrorType_WithNote: return "WithNote";
    case compiler_errors_ErrorType_WithHint: return "WithHint";
    default: return "<unknown>";
  }
}

struct compiler_errors_Error {
  compiler_errors_ErrorType type;
  char *msg1;
  std_span_Span span1;
  char *msg2;
  std_span_Span span2;
};

enum compiler_errors_MessageType {
  compiler_errors_MessageType_Error,
  compiler_errors_MessageType_Warning,
  compiler_errors_MessageType_Note,
};

char *compiler_errors_MessageType_dbg(compiler_errors_MessageType this) {
  switch (this) {
    case compiler_errors_MessageType_Error: return "Error";
    case compiler_errors_MessageType_Warning: return "Warning";
    case compiler_errors_MessageType_Note: return "Note";
    default: return "<unknown>";
  }
}

struct std_CharIterator {
  char *data;
  u32 len;
  u32 pos;
};

struct std_sv_SVLineIterator {
  std_sv_SV sv;
};

struct std_sv_SVSplitIterator {
  std_sv_SV sv;
  std_sv_SV delim;
};

struct std_gc_impl_Header {
  u32 size;
  bool marked;
  bool global;
  std_gc_impl_Header *next;
  std_gc_impl_Header *prev;
};

struct std_compact_map_Item__0 {
  u32 hash;
  std_sv_SV key;
  compiler_lsp_server_TextDocument value;
};

struct std_compact_map_Item__1 {
  u32 hash;
  char *key;
  std_value_Value *value;
};

struct std_compact_map_Item__2 {
  u32 hash;
  char *key;
  std_span_Span value;
};

struct std_compact_map_Map__0 {
  std_vector_Vector__26 *items;
  i32 *indices;
  u32 capacity;
  u32 num_tombstones;
};

struct std_compact_map_Map__1 {
  std_vector_Vector__29 *items;
  i32 *indices;
  u32 capacity;
  u32 num_tombstones;
};

struct std_compact_map_Map__2 {
  std_vector_Vector__30 *items;
  i32 *indices;
  u32 capacity;
  u32 num_tombstones;
};

struct std_vector_Iterator__29 {
  std_vector_Vector__29 *vec;
  u32 index;
};

struct std_compact_map_Iterator__1 {
  std_vector_Iterator__29 iter;
};

enum std_logging_LogLevel {
  std_logging_LogLevel_Debug,
  std_logging_LogLevel_Info,
  std_logging_LogLevel_Warn,
  std_logging_LogLevel_Error,
};

char *std_logging_LogLevel_dbg(std_logging_LogLevel this) {
  switch (this) {
    case std_logging_LogLevel_Debug: return "Debug";
    case std_logging_LogLevel_Info: return "Info";
    case std_logging_LogLevel_Warn: return "Warn";
    case std_logging_LogLevel_Error: return "Error";
    default: return "<unknown>";
  }
}

struct std_set_Set__0 {
  std_map_Map__0 *map;
  u32 size;
};

struct std_set_Set__1 {
  std_map_Map__3 *map;
  u32 size;
};

struct std_set_Set__2 {
  std_map_Map__8 *map;
  u32 size;
};

struct std_set_Set__3 {
  std_map_Map__13 *map;
  u32 size;
};

struct std_map_Iterator__13 {
  i32 idx;
  std_map_Item__13 *node;
  std_map_Map__13 *map;
};

struct std_set_Iterator__3 {
  std_map_Iterator__13 map_iter;
};

union std_value_ValueUnion {
  bool as_bool;
  i64 as_int;
  f64 as_float;
  std_buffer_Buffer as_str;
  std_vector_Vector__28 *as_list;
  std_compact_map_Map__1 *as_dict;
};

enum std_value_ValueType {
  std_value_ValueType_Null,
  std_value_ValueType_Bool,
  std_value_ValueType_Integer,
  std_value_ValueType_Float,
  std_value_ValueType_String,
  std_value_ValueType_List,
  std_value_ValueType_Dictionary,
};

char *std_value_ValueType_dbg(std_value_ValueType this) {
  switch (this) {
    case std_value_ValueType_Null: return "Null";
    case std_value_ValueType_Bool: return "Bool";
    case std_value_ValueType_Integer: return "Integer";
    case std_value_ValueType_Float: return "Float";
    case std_value_ValueType_String: return "String";
    case std_value_ValueType_List: return "List";
    case std_value_ValueType_Dictionary: return "Dictionary";
    default: return "<unknown>";
  }
}

struct std_value_Value {
  std_value_ValueType type;
  std_value_ValueUnion u;
  std_span_Span span;
};

struct std_process_Output {
  bool error;
  i32 error_code;
  std_buffer_Buffer output;
};

enum std_fs_EntryType {
  std_fs_EntryType_File,
  std_fs_EntryType_Directory,
  std_fs_EntryType_SymbolicLink,
  std_fs_EntryType_Unknown,
};

char *std_fs_EntryType_dbg(std_fs_EntryType this) {
  switch (this) {
    case std_fs_EntryType_File: return "File";
    case std_fs_EntryType_Directory: return "Directory";
    case std_fs_EntryType_SymbolicLink: return "SymbolicLink";
    case std_fs_EntryType_Unknown: return "Unknown";
    default: return "<unknown>";
  }
}

struct std_fs_DirectoryEntry {
  std_fs_EntryType type;
  char *name;
};

struct std_fs_DirectoryIterator {
  DIR *dir;
  struct dirent *dp;
  bool skip_self_and_parent;
};

char *std_fs_SeekMode_dbg(i32 this) {
  switch (this) {
    case SEEK_SET: return "Set";
    case SEEK_CUR: return "Cur";
    case SEEK_END: return "End";
    default: return "<unknown>";
  }
}

struct std_map_Item__0 {
  u64 key;
  bool value;
  std_map_Item__0 *next;
};

struct std_map_Item__1 {
  char *key;
  compiler_ast_nodes_MatchCond *value;
  std_map_Item__1 *next;
};

struct std_map_Item__2 {
  char *key;
  compiler_types_Type *value;
  std_map_Item__2 *next;
};

struct std_map_Item__3 {
  void *key;
  bool value;
  std_map_Item__3 *next;
};

struct std_map_Item__4 {
  char *key;
  compiler_ast_program_Namespace *value;
  std_map_Item__4 *next;
};

struct std_map_Item__5 {
  char *key;
  compiler_ast_scopes_Symbol *value;
  std_map_Item__5 *next;
};

struct std_map_Item__6 {
  compiler_ast_operators_OperatorOverload key;
  compiler_ast_nodes_Function *value;
  std_map_Item__6 *next;
};

struct std_map_Item__7 {
  char *key;
  char *value;
  std_map_Item__7 *next;
};

struct std_map_Item__8 {
  char *key;
  bool value;
  std_map_Item__8 *next;
};

struct std_map_Item__9 {
  char *key;
  compiler_ast_nodes_Function *value;
  std_map_Item__9 *next;
};

struct std_map_Item__10 {
  char *key;
  compiler_ast_nodes_Argument *value;
  std_map_Item__10 *next;
};

struct std_map_Item__11 {
  char *key;
  compiler_ast_nodes_Variable *value;
  std_map_Item__11 *next;
};

struct std_map_Item__12 {
  char *key;
  std_span_Span value;
  std_map_Item__12 *next;
};

struct std_map_Item__13 {
  std_span_Span key;
  bool value;
  std_map_Item__13 *next;
};

struct std_map_Map__0 {
  std_map_Item__0 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__1 {
  std_map_Item__1 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__2 {
  std_map_Item__2 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__3 {
  std_map_Item__3 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__4 {
  std_map_Item__4 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__5 {
  std_map_Item__5 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__6 {
  std_map_Item__6 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__7 {
  std_map_Item__7 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__8 {
  std_map_Item__8 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__9 {
  std_map_Item__9 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__10 {
  std_map_Item__10 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__11 {
  std_map_Item__11 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__12 {
  std_map_Item__12 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__13 {
  std_map_Item__13 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Iterator__2 {
  i32 idx;
  std_map_Item__2 *node;
  std_map_Map__2 *map;
};

struct std_map_Iterator__4 {
  i32 idx;
  std_map_Item__4 *node;
  std_map_Map__4 *map;
};

struct std_map_Iterator__5 {
  i32 idx;
  std_map_Item__5 *node;
  std_map_Map__5 *map;
};

struct std_map_Iterator__7 {
  i32 idx;
  std_map_Item__7 *node;
  std_map_Map__7 *map;
};

struct std_map_Iterator__9 {
  i32 idx;
  std_map_Item__9 *node;
  std_map_Map__9 *map;
};

struct std_map_ValueIterator__4 {
  std_map_Iterator__4 map_iter;
};

struct std_map_ValueIterator__5 {
  std_map_Iterator__5 map_iter;
};

struct std_map_ValueIterator__9 {
  std_map_Iterator__9 map_iter;
};

char *std_signal_Signal_dbg(i32 this) {
  switch (this) {
    case SIGHUP: return "SIGHUP";
    case SIGINT: return "SIGINT";
    case SIGQUIT: return "SIGQUIT";
    case SIGILL: return "SIGILL";
    case SIGTRAP: return "SIGTRAP";
    case SIGABRT: return "SIGABRT";
    case SIGFPE: return "SIGFPE";
    case SIGKILL: return "SIGKILL";
    case SIGBUS: return "SIGBUS";
    case SIGSEGV: return "SIGSEGV";
    case SIGSYS: return "SIGSYS";
    case SIGPIPE: return "SIGPIPE";
    case SIGTERM: return "SIGTERM";
    case SIGSTOP: return "SIGSTOP";
    default: return "<unknown>";
  }
}

struct std_vector_Vector__0 {
  compiler_types_Type **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__1 {
  char **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__2 {
  compiler_ast_scopes_Scope **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__3 {
  compiler_ast_program_Namespace **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__4 {
  compiler_ast_nodes_Variable **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__5 {
  compiler_ast_scopes_TemplateInstance **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__6 {
  compiler_ast_nodes_MatchCond **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__7 {
  compiler_ast_nodes_ImportPart **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__8 {
  compiler_ast_nodes_Function **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__9 {
  compiler_ast_nodes_Argument **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__10 {
  compiler_ast_scopes_Symbol **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__11 {
  compiler_tokens_Token **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__12 {
  compiler_attributes_Attribute **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__13 {
  compiler_ast_nodes_Structure **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__14 {
  compiler_ast_nodes_Enum **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__15 {
  compiler_ast_nodes_AST **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__16 {
  compiler_errors_Error **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__17 {
  jmp_buf *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__18 {
  compiler_ast_scopes_Reference *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__19 {
  compiler_ast_nodes_MatchCondArg **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__20 {
  compiler_ast_nodes_EnumVariant **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__21 {
  compiler_ast_operators_Operator *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__22 {
  std_vector_Vector__7 **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__23 {
  compiler_ast_nodes_IfBranch *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__24 {
  compiler_ast_nodes_MatchCase *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__25 {
  compiler_ast_nodes_MapLiteralPair *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__26 {
  std_compact_map_Item__0 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__27 {
  std_span_Span *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__28 {
  std_value_Value **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__29 {
  std_compact_map_Item__1 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__30 {
  std_compact_map_Item__2 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__31 {
  u32 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Iterator__0 {
  std_vector_Vector__0 *vec;
  u32 index;
};

struct std_vector_Iterator__1 {
  std_vector_Vector__1 *vec;
  u32 index;
};

struct std_vector_Iterator__4 {
  std_vector_Vector__4 *vec;
  u32 index;
};

struct std_vector_Iterator__5 {
  std_vector_Vector__5 *vec;
  u32 index;
};

struct std_vector_Iterator__6 {
  std_vector_Vector__6 *vec;
  u32 index;
};

struct std_vector_Iterator__7 {
  std_vector_Vector__7 *vec;
  u32 index;
};

struct std_vector_Iterator__8 {
  std_vector_Vector__8 *vec;
  u32 index;
};

struct std_vector_Iterator__9 {
  std_vector_Vector__9 *vec;
  u32 index;
};

struct std_vector_Iterator__10 {
  std_vector_Vector__10 *vec;
  u32 index;
};

struct std_vector_Iterator__12 {
  std_vector_Vector__12 *vec;
  u32 index;
};

struct std_vector_Iterator__13 {
  std_vector_Vector__13 *vec;
  u32 index;
};

struct std_vector_Iterator__14 {
  std_vector_Vector__14 *vec;
  u32 index;
};

struct std_vector_Iterator__15 {
  std_vector_Vector__15 *vec;
  u32 index;
};

struct std_vector_Iterator__16 {
  std_vector_Vector__16 *vec;
  u32 index;
};

struct std_vector_Iterator__18 {
  std_vector_Vector__18 *vec;
  u32 index;
};

struct std_vector_Iterator__19 {
  std_vector_Vector__19 *vec;
  u32 index;
};

struct std_vector_Iterator__20 {
  std_vector_Vector__20 *vec;
  u32 index;
};

struct std_vector_Iterator__21 {
  std_vector_Vector__21 *vec;
  u32 index;
};

struct std_vector_Iterator__22 {
  std_vector_Vector__22 *vec;
  u32 index;
};

struct std_vector_Iterator__23 {
  std_vector_Vector__23 *vec;
  u32 index;
};

struct std_vector_Iterator__24 {
  std_vector_Vector__24 *vec;
  u32 index;
};

struct std_vector_Iterator__25 {
  std_vector_Vector__25 *vec;
  u32 index;
};

struct std_vector_Iterator__27 {
  std_vector_Vector__27 *vec;
  u32 index;
};

struct std_vector_Iterator__28 {
  std_vector_Vector__28 *vec;
  u32 index;
};

struct std_json_Parser {
  std_vector_Vector__11 *tokens;
  u32 curr;
};

struct _ClosureTy_32 {
  void *_C;
  void (*fn)(void *__C);
};
struct compiler_lsp_cli_handle_validate__Closure_0Ctx {
  char **path;
};
struct compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx {
  std_span_Span *op_span;
};
struct compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx {
  std_span_Span *op_span;
};
struct compiler_passes_visitor__Closure_3Ctx {
};
struct compiler_passes_visitor__Closure_4Ctx {
};
struct compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx {
  std_vector_Vector__1 **args;
  char **contents;
};
struct compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx {
  std_vector_Vector__1 **args;
};
/* function declarations */
std_value_Value *compiler_docgen_DocGenerator_gen_enum(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_docgen_DocGenerator_gen_location(compiler_docgen_DocGenerator *this, std_value_Value *obj, std_span_Span span);
char *compiler_docgen_DocGenerator_gen_templated_type(compiler_docgen_DocGenerator *this, compiler_types_Type *base, std_vector_Vector__0 *args);
char *compiler_docgen_DocGenerator_gen_typename_str(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_typename(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_methods(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_function(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Function *func);
std_value_Value *compiler_docgen_DocGenerator_gen_struct(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Structure *struc);
std_value_Value *compiler_docgen_DocGenerator_gen_ns(compiler_docgen_DocGenerator *this, compiler_ast_program_Namespace *ns);
std_value_Value *compiler_docgen_DocGenerator_gen_builtin(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_builtins(compiler_docgen_DocGenerator *this, compiler_ast_program_Program *program);
void compiler_docgen_generate_doc_json(compiler_ast_program_Program *program, char *json_path);
bool compiler_utils_directory_exists(char *path);
void compiler_passes_run_typecheck_passes(compiler_ast_program_Program *program);
char *compiler_passes_run_codegen_passes(compiler_ast_program_Program *program);
void compiler_passes_register_types_RegisterTypes_register_struct(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *struc);
void compiler_passes_register_types_RegisterTypes_register_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *enum_);
void compiler_passes_register_types_RegisterTypes_register_globals(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_AST *node);
void compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_register_types_RegisterTypes_register_namespace(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns);
void compiler_passes_register_types_RegisterTypes_register_base_type(compiler_passes_register_types_RegisterTypes *this, compiler_types_BaseType base);
void compiler_passes_register_types_RegisterTypes_register_alias(compiler_passes_register_types_RegisterTypes *this, char *name, compiler_types_Type *orig);
void compiler_passes_register_types_RegisterTypes_register_print_function(compiler_passes_register_types_RegisterTypes *this, char *name);
void compiler_passes_register_types_RegisterTypes_register_builtin_types(compiler_passes_register_types_RegisterTypes *this);
compiler_passes_register_types_Finder compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder this, char *name, bool error);
compiler_passes_register_types_Finder compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder this, char *name);
compiler_passes_register_types_Finder compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder this, char *name);
void compiler_passes_register_types_RegisterTypes_register_cached_types(compiler_passes_register_types_RegisterTypes *this);
void compiler_passes_register_types_RegisterTypes_create_namespace_scopes(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_program_Namespace *parent);
void compiler_passes_register_types_RegisterTypes_run(compiler_ast_program_Program *program);
void compiler_passes_visitor_Visitor_visit_var(compiler_passes_visitor_Visitor *this, compiler_ast_nodes_Variable *var);
void compiler_passes_visitor_Visitor_visit_po(compiler_passes_visitor_Visitor *this, compiler_ast_nodes_AST *node);
compiler_passes_mark_dead_code_MarkDeadCode *compiler_passes_mark_dead_code_MarkDeadCode_new(compiler_ast_program_Program *program);
void compiler_passes_mark_dead_code_MarkDeadCode_free(compiler_passes_mark_dead_code_MarkDeadCode *this);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Function *f);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_type(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_types_Type *typ);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Structure *s);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Enum *e);
void compiler_passes_mark_dead_code_MarkDeadCode_mark(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_AST *node);
compiler_ast_nodes_Function *compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_program_Program *program);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_mark_dead_code_MarkDeadCode_run(compiler_ast_program_Program *program);
compiler_passes_generic_pass_GenericPass *compiler_passes_generic_pass_GenericPass_new(compiler_ast_program_Program *program);
void compiler_passes_generic_pass_GenericPass_push_scope(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Scope *scope);
void compiler_passes_generic_pass_GenericPass_push_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns);
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_pop_scope(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_pop_namespace(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_scope(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_ns(compiler_passes_generic_pass_GenericPass *this);
compiler_errors_Error *compiler_passes_generic_pass_GenericPass_error(compiler_passes_generic_pass_GenericPass *this, compiler_errors_Error *err);
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(compiler_passes_generic_pass_GenericPass *this, bool export, compiler_ast_scopes_Symbol *item, char *name);
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *item, char *name);
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, bool allow_templated);
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, std_span_Span span, bool error);
void compiler_passes_generic_pass_GenericPass_import_all_from_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns, bool export);
void compiler_passes_generic_pass_GenericPass_import_all_from_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, bool export);
compiler_ast_nodes_Function *compiler_passes_generic_pass_GenericPass_current_func(compiler_passes_generic_pass_GenericPass *this);
compiler_errors_Error *compiler_passes_typechecker_TypeChecker_error(compiler_passes_typechecker_TypeChecker *this, compiler_errors_Error *err);
compiler_ast_scopes_Scope *compiler_passes_typechecker_TypeChecker_scope(compiler_passes_typechecker_TypeChecker *this);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_base_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_type_by_name(compiler_passes_typechecker_TypeChecker *this, char *name, std_span_Span span);
void compiler_passes_typechecker_TypeChecker_set_resolved_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_closure_type(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__4 *params, compiler_types_Type *return_type, compiler_types_Type *old);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_resolve_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old, bool allow_incomplete, bool error, bool resolve_templates);
void compiler_passes_typechecker_TypeChecker_try_infer_array_size(compiler_passes_typechecker_TypeChecker *this, compiler_types_ArrayType *arr_typ);
void compiler_passes_typechecker_TypeChecker_resolve_templated_methods(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old_type, compiler_types_Type *cur_type);
void compiler_passes_typechecker_TypeChecker_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc, compiler_ast_scopes_TemplateInstance *instance);
void compiler_passes_typechecker_TypeChecker_resolve_templated_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_scopes_TemplateInstance *instance);
void compiler_passes_typechecker_TypeChecker_resolve_templated_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_scopes_TemplateInstance *instance);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_find_template_instance(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__5 *template_instances, std_vector_Vector__0 *args);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym, std_vector_Vector__0 *template_args, std_span_Span span);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool error, compiler_types_Type *hint, bool resolve_templates);
void compiler_passes_typechecker_TypeChecker_check_block(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_method_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *method, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_union_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_enum_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_call_args_labelled(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params, u32 start);
void compiler_passes_typechecker_TypeChecker_check_call_args(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params, bool is_variadic);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_pointer_arith(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_operators_Operator op, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *arg1, compiler_ast_nodes_AST *arg2, compiler_ast_nodes_AST *arg3);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_binary_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_passes_typechecker_Formattable compiler_passes_typechecker_TypeChecker_is_formattable(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *typ, compiler_ast_nodes_AST *expr);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_format_string(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_member(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_being_called, bool is_try, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_index(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint, bool is_being_assigned);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_assignment(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_ast_nodes_AST *compiler_passes_typechecker_TypeChecker_create_match_for_error_unwrap(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *expr, compiler_passes_typechecker_ErrorPropBase error_prop_base);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_error_unwrap(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_ast_nodes_AST *compiler_passes_typechecker_TypeChecker_create_match_for_error_prop(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *expr, compiler_passes_typechecker_ErrorPropBase error_prop_base);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_error_prop(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression_helper(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST **node_ptr);
void compiler_passes_typechecker_TypeChecker_check_match_case_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *lhs_node, compiler_types_Type *enom_type, std_vector_Vector__6 *conds, std_map_Map__1 *mapping, std_map_Map__2 *current_args);
void compiler_passes_typechecker_TypeChecker_check_match_for_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_match_for_bool(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
compiler_ast_nodes_Function *compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *expr, compiler_ast_nodes_MatchCond *cond);
void compiler_passes_typechecker_TypeChecker_check_match(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_is_expr_in_if_condition(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *cond);
void compiler_passes_typechecker_TypeChecker_check_if(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_expression_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_while(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_for(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_handle_imports(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool is_global);
void compiler_passes_typechecker_TypeChecker_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const);
void compiler_passes_typechecker_TypeChecker_check_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_resolve_doc_links(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_const_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_handle_import_path_base(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Import *imp, std_vector_Vector__7 *parts, compiler_ast_scopes_Symbol *base, bool search_in_ns_scope, char *alias);
void compiler_passes_typechecker_TypeChecker_handle_import_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_pre_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_typechecker_TypeChecker_resolve_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_typechecker_TypeChecker_resolve_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_typechecker_TypeChecker_check_operator_overload_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_operators_Operator op);
void compiler_passes_typechecker_TypeChecker_check_function_declaration(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool pre_import);
void compiler_passes_typechecker_TypeChecker_check_post_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_pre_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const);
void compiler_passes_typechecker_TypeChecker_check_pre_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_run(compiler_ast_program_Program *program);
void compiler_passes_code_generator_CodeGenerator_gen_indent(compiler_passes_code_generator_CodeGenerator *this);
void str_replace(char **this, char *other);
compiler_errors_Error *compiler_passes_code_generator_CodeGenerator_error(compiler_passes_code_generator_CodeGenerator *this, compiler_errors_Error *err);
compiler_ast_scopes_Scope *compiler_passes_code_generator_CodeGenerator_scope(compiler_passes_code_generator_CodeGenerator *this);
void compiler_passes_code_generator_CodeGenerator_gen_debug_info(compiler_passes_code_generator_CodeGenerator *this, std_span_Span span, bool force);
char *compiler_passes_code_generator_CodeGenerator_get_op(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(compiler_passes_code_generator_CodeGenerator *this);
void compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(compiler_passes_code_generator_CodeGenerator *this);
bool compiler_passes_code_generator_CodeGenerator_gen_internal_print(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after, bool is_stderr);
void compiler_passes_code_generator_CodeGenerator_gen_format_string_part(compiler_passes_code_generator_CodeGenerator *this, char *part);
void compiler_passes_code_generator_CodeGenerator_gen_string_literal(compiler_passes_code_generator_CodeGenerator *this, char *literal);
void compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after);
void compiler_passes_code_generator_CodeGenerator_gen_format_string(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_vector_literal(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_map_literal(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_yield_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_gen_constant(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_constants(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_global_variables(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_control_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body);
void compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_EnumVariant *variant, std_vector_Vector__9 *args);
void compiler_passes_code_generator_CodeGenerator_gen_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_create_new(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_call_args(compiler_passes_code_generator_CodeGenerator *this, std_vector_Vector__9 *args, bool is_variadic_format);
void compiler_passes_code_generator_CodeGenerator_gen_closure_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_expr);
void compiler_passes_code_generator_CodeGenerator_gen_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_top_level, bool is_statement);
void compiler_passes_code_generator_CodeGenerator_gen_var_declaration(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match_case_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body);
void compiler_passes_code_generator_CodeGenerator_gen_custom_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
char *compiler_passes_code_generator_CodeGenerator_gen_match_enum_switch_line(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_gen_match_enum_cases_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, char *var_name, std_vector_Vector__6 *conds, compiler_ast_nodes_AST *body, u32 uid, u32 case_index);
void compiler_passes_code_generator_CodeGenerator_gen_match_enum(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match_bool(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, char *var_name, std_vector_Vector__6 *conds, compiler_ast_nodes_AST *body, char *bool_name);
void compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_branch(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_IfBranch *branch);
void compiler_passes_code_generator_CodeGenerator_gen_if(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_defers_upto(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Scope *end_scope);
char *compiler_passes_code_generator_CodeGenerator_get_break_label_for_loop(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_statement(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_block(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool with_braces);
char *compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def, char *param_prefix, std_vector_Vector__4 *params);
char *compiler_passes_code_generator_CodeGenerator_helper_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def);
char *compiler_passes_code_generator_CodeGenerator_get_type_name_string(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name, bool is_func_def);
void compiler_passes_code_generator_CodeGenerator_gen_type_and_name(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name);
void compiler_passes_code_generator_CodeGenerator_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type);
void compiler_passes_code_generator_CodeGenerator_gen_function_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_functions(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function_decls(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_func(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_sym_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_code_generator_CodeGenerator_gen_struct_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_enum_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_code_generator_CodeGenerator_gen_test_mode_main(compiler_passes_code_generator_CodeGenerator *this);
char *compiler_passes_code_generator_CodeGenerator_generate(compiler_passes_code_generator_CodeGenerator *this);
compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator_make(compiler_ast_program_Program *program);
char *compiler_passes_code_generator_CodeGenerator_run(compiler_ast_program_Program *program);
char *compiler_passes_code_generator_cls_ctx_type(compiler_ast_nodes_Function *func);
compiler_passes_reorder_symbols_ReorderSymbols *compiler_passes_reorder_symbols_ReorderSymbols_new(compiler_ast_program_Program *program);
void compiler_passes_reorder_symbols_ReorderSymbols_free(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_program_Namespace *ns);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_dfs(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_run(compiler_ast_program_Program *program);
compiler_parser_Parser compiler_parser_Parser_make(compiler_ast_program_Program *program, compiler_ast_program_Namespace *ns);
void compiler_parser_Parser_free(compiler_parser_Parser *this);
compiler_tokens_Token *compiler_parser_Parser_peek(compiler_parser_Parser *this, i32 off);
compiler_errors_Error *compiler_parser_Parser_error_msg(compiler_parser_Parser *this, char *msg);
compiler_errors_Error *compiler_parser_Parser_error(compiler_parser_Parser *this, compiler_errors_Error *err);
void compiler_parser_Parser_unhandled_type(compiler_parser_Parser *this, char *func);
compiler_tokens_Token *compiler_parser_Parser_token(compiler_parser_Parser *this);
bool compiler_parser_Parser_token_is(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_token_is_eof_or(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_token_is_identifier(compiler_parser_Parser *this, char *name);
bool compiler_parser_Parser_peek_token_is(compiler_parser_Parser *this, u32 off, compiler_tokens_TokenType type);
bool compiler_parser_Parser_consume_if(compiler_parser_Parser *this, compiler_tokens_TokenType type);
void compiler_parser_Parser_consume_newline_or(compiler_parser_Parser *this, compiler_tokens_TokenType type);
void compiler_parser_Parser_consume_tokens_until_newline(compiler_parser_Parser *this);
compiler_tokens_Token *compiler_parser_Parser_consume(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_is_end_of_statement(compiler_parser_Parser *this);
void compiler_parser_Parser_consume_end_of_statement(compiler_parser_Parser *this);
void compiler_parser_Parser_clear_attributes(compiler_parser_Parser *this);
bool compiler_parser_Parser_is_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op);
std_span_Span compiler_parser_Parser_consume_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op);
compiler_types_Type *compiler_parser_Parser_parse_type(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_identifier(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_scoped_identifier(compiler_parser_Parser *this, bool consume_template);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_format_string(compiler_parser_Parser *this);
std_vector_Vector__6 *compiler_parser_Parser_parse_match_case_conds(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_match(compiler_parser_Parser *this);
void compiler_parser_Parser_sync_toplevel(compiler_parser_Parser *this);
compiler_types_Type *compiler_parser_Parser_parse_literal_suffix_type(compiler_parser_Parser *this, compiler_tokens_Token *suffix);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_call(compiler_parser_Parser *this, compiler_ast_nodes_AST *callee);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_initializer(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_declaration(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_global_value(compiler_parser_Parser *this, bool is_const);
u64 compiler_parser_Parser_parse_num_literal_int(compiler_parser_Parser *this, char *text);
f64 compiler_parser_Parser_parse_num_literal_float(compiler_parser_Parser *this, char *text);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_atom(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_postfix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_prefix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_cast(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_term(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_additive(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_shift(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_xor(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_relational(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_is(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_not(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_expression(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_multi_if(compiler_parser_Parser *this, compiler_tokens_Token *start_tok);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_if(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for_each(compiler_parser_Parser *this, std_span_Span start_span);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_statement(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_block(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_template_params(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, std_span_Span *out_span);
void compiler_parser_Parser_add_doc_comment(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_tokens_Token *token);
void compiler_parser_Parser_parse_function_args(compiler_parser_Parser *this, compiler_ast_nodes_Function *func, compiler_tokens_TokenType end, bool need_types);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_function_body(compiler_parser_Parser *this, compiler_ast_nodes_Function *func);
compiler_ast_nodes_Function *compiler_parser_Parser_parse_closure(compiler_parser_Parser *this);
compiler_ast_nodes_Function *compiler_parser_Parser_parse_function(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_extern_into_symbol(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym);
void compiler_parser_Parser_get_extern_from_attr(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_attributes_Attribute *attr);
std_vector_Vector__7 *compiler_parser_Parser_parse_import_path(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_import(compiler_parser_Parser *this);
bool compiler_parser_Parser_parse_struct_field(compiler_parser_Parser *this, compiler_ast_nodes_Structure *struc);
compiler_ast_nodes_Structure *compiler_parser_Parser_parse_struct(compiler_parser_Parser *this);
compiler_ast_nodes_Enum *compiler_parser_Parser_parse_enum(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_attribute(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_attributes_if_any(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_namespace_until(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
void compiler_parser_Parser_parse_compiler_option(compiler_parser_Parser *this);
void compiler_parser_Parser_try_load_mod_for_namespace(compiler_parser_Parser *this, compiler_ast_program_Namespace *ns);
compiler_ast_program_Namespace *compiler_parser_Parser_load_single_import_part(compiler_parser_Parser *this, compiler_ast_program_Namespace *base, char *name, std_span_Span span);
bool compiler_parser_Parser_load_import_path_from_base(compiler_parser_Parser *this, std_vector_Vector__7 *parts, compiler_ast_program_Namespace *base);
compiler_parser_LibraryInfo compiler_parser_Parser_find_external_library(compiler_parser_Parser *this, char *name);
compiler_ast_program_Namespace *compiler_parser_Parser_import_from_stdlib(compiler_parser_Parser *this, char *name, std_span_Span span);
compiler_ast_program_Namespace *compiler_parser_Parser_import_external_lib(compiler_parser_Parser *this, char *name);
bool compiler_parser_Parser_load_import_path(compiler_parser_Parser *this, compiler_ast_nodes_AST *import_stmt);
void compiler_parser_Parser_load_file(compiler_parser_Parser *this, char *filename, char *contents);
void compiler_parser_Parser_couldnt_find_stdlib(compiler_parser_Parser *this);
compiler_ast_program_Namespace *compiler_parser_Parser_find_or_import_stdlib(compiler_parser_Parser *this);
void compiler_parser_Parser_include_prelude_only(compiler_parser_Parser *this);
void compiler_parser_Parser_create_namespaces_for_initial_file(compiler_parser_Parser *this, char *filename, bool single_file);
void compiler_parser_Parser_parse_toplevel(compiler_ast_program_Program *program, char *filename, char *file_contents, bool include_workspace_main);
compiler_ast_program_Namespace *compiler_ast_program_Namespace_new(compiler_ast_program_Namespace *parent, char *path);
compiler_ast_scopes_Symbol *compiler_ast_program_Namespace_find_importable_symbol(compiler_ast_program_Namespace *this, char *name);
compiler_ast_program_Namespace *compiler_ast_program_Namespace_get_project_root(compiler_ast_program_Namespace *this, std_span_Span span, compiler_ast_program_Program *program_for_errors);
compiler_ast_program_Program *compiler_ast_program_Program_new(void);
jmp_buf *compiler_ast_program_Program_add_error_context(compiler_ast_program_Program *this);
jmp_buf *compiler_ast_program_Program_get_error_context(compiler_ast_program_Program *this);
void compiler_ast_program_Program_pop_error_context(compiler_ast_program_Program *this);
void compiler_ast_program_Program_setup_library_paths(compiler_ast_program_Program *this);
void compiler_ast_program_Program_exit_with_errors_if_any(compiler_ast_program_Program *this);
char *compiler_ast_program_Program_get_source_text(compiler_ast_program_Program *this, std_span_Span span);
compiler_errors_Error *compiler_ast_program_Program_error(compiler_ast_program_Program *this, compiler_errors_Error *err);
compiler_types_Type *compiler_ast_program_Program_find_closure_type(compiler_ast_program_Program *this, std_vector_Vector__4 *params, compiler_types_Type *ret);
compiler_ast_nodes_Function *compiler_ast_program_get_deep_copy__0(compiler_ast_program_Program *program, compiler_ast_nodes_Function *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *(*parse_fn)(compiler_parser_Parser *));
compiler_ast_nodes_Structure *compiler_ast_program_get_deep_copy__1(compiler_ast_program_Program *program, compiler_ast_nodes_Structure *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *(*parse_fn)(compiler_parser_Parser *));
compiler_ast_nodes_Enum *compiler_ast_program_get_deep_copy__2(compiler_ast_program_Program *program, compiler_ast_nodes_Enum *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *(*parse_fn)(compiler_parser_Parser *));
compiler_types_Type *compiler_ast_program_Program_get_base_type(compiler_ast_program_Program *this, compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_ast_program_Program_get_type_by_name(compiler_ast_program_Program *this, char *name, std_span_Span span);
compiler_ast_program_NSIterator compiler_ast_program_Program_iter_namespaces(compiler_ast_program_Program *this);
bool compiler_ast_program_NSIterator_has_value(compiler_ast_program_NSIterator *this);
void compiler_ast_program_NSIterator_next(compiler_ast_program_NSIterator *this);
compiler_ast_program_Namespace *compiler_ast_program_NSIterator_cur(compiler_ast_program_NSIterator *this);
compiler_ast_scopes_TemplateInstance *compiler_ast_scopes_TemplateInstance_new(std_vector_Vector__0 *args, compiler_ast_scopes_Symbol *parent, compiler_ast_scopes_Symbol *resolved);
bool compiler_ast_scopes_TemplateInstance_matches(compiler_ast_scopes_TemplateInstance *this, std_vector_Vector__0 *other);
compiler_ast_scopes_Template *compiler_ast_scopes_Template_new(std_vector_Vector__10 *params);
char *compiler_ast_scopes_Symbol_out_name(compiler_ast_scopes_Symbol *this);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, char *name, char *display, char *full_name, std_span_Span span);
char *compiler_ast_scopes_Symbol_join_display(char *a, char *b);
char *compiler_ast_scopes_Symbol_join_full_name(char *a, char *b);
bool compiler_ast_scopes_Symbol_is_templated(compiler_ast_scopes_Symbol *this);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, compiler_ast_scopes_Symbol *parent, char *name, std_span_Span span);
void compiler_ast_scopes_Symbol_update_parent(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_Symbol *parent);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_from_local_variable(char *name, compiler_ast_nodes_Variable *var, std_span_Span span);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_remove_alias(compiler_ast_scopes_Symbol *this);
void compiler_ast_scopes_Symbol_add_reference(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_ReferenceType type, std_span_Span span);
compiler_ast_scopes_Scope *compiler_ast_scopes_Scope_new(compiler_ast_scopes_Scope *parent);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_recursive(compiler_ast_scopes_Scope *this, char *name);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_local(compiler_ast_scopes_Scope *this, char *name);
void compiler_ast_scopes_Scope_insert(compiler_ast_scopes_Scope *this, char *name, compiler_ast_scopes_Symbol *symbol);
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_operator_overload(char *s, std_vector_Vector__4 *params);
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_token(compiler_tokens_Token *tok);
u32 compiler_ast_operators_Operator_num_overload_params(compiler_ast_operators_Operator this);
bool compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(compiler_ast_operators_Operator this);
u32 compiler_ast_operators_OperatorOverload_hash(compiler_ast_operators_OperatorOverload this);
bool compiler_ast_operators_OperatorOverload_eq(compiler_ast_operators_OperatorOverload this, compiler_ast_operators_OperatorOverload other);
compiler_ast_nodes_Variable *compiler_ast_nodes_Variable_new(compiler_types_Type *type);
compiler_ast_nodes_Structure *compiler_ast_nodes_Structure_new(void);
compiler_ast_nodes_Variable *compiler_ast_nodes_Structure_get_field(compiler_ast_nodes_Structure *this, char *name);
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_Enum_get_variant(compiler_ast_nodes_Enum *this, char *name);
compiler_ast_nodes_Variable *compiler_ast_nodes_Enum_get_shared_field(compiler_ast_nodes_Enum *this, char *name);
compiler_ast_nodes_Enum *compiler_ast_nodes_Enum_new(std_span_Span span);
u32 compiler_ast_nodes_EnumVariant_num_fields(compiler_ast_nodes_EnumVariant *this);
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_field_by_idx(compiler_ast_nodes_EnumVariant *this, u32 idx);
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_specific_field(compiler_ast_nodes_EnumVariant *this, char *name);
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_EnumVariant_new(std_span_Span span);
compiler_ast_nodes_Function *compiler_ast_nodes_Function_new(void);
bool compiler_ast_nodes_Function_is_template_instance(compiler_ast_nodes_Function *this);
compiler_ast_nodes_Argument *compiler_ast_nodes_Argument_new(compiler_ast_nodes_AST *expr, compiler_tokens_Token *label_token);
compiler_ast_nodes_ImportPart *compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType type, std_span_Span span);
compiler_ast_nodes_MatchCond *compiler_ast_nodes_MatchCond_new(compiler_ast_nodes_AST *cond, std_vector_Vector__19 *args, compiler_ast_nodes_Function *cmp_fn);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType type, std_span_Span span);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator op, std_span_Span span, compiler_ast_nodes_AST *expr);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator op, compiler_ast_nodes_AST *lhs, compiler_ast_nodes_AST *rhs, std_span_Span op_span);
std_span_Span compiler_ast_nodes_AST_display_span(compiler_ast_nodes_AST *this);
compiler_ast_scopes_Symbol *compiler_ast_nodes_AST_symbol(compiler_ast_nodes_AST *this);
bool compiler_ast_nodes_AST_is_lvalue(compiler_ast_nodes_AST *this);
compiler_lexer_Lexer compiler_lexer_Lexer_make_sv(std_sv_SV source, char *filename, std_vector_Vector__16 *errors);
compiler_lexer_Lexer compiler_lexer_Lexer_make(char *source, char *filename, std_vector_Vector__16 *errors);
void compiler_lexer_Lexer_push(compiler_lexer_Lexer *this, compiler_tokens_Token *token);
void compiler_lexer_Lexer_push_type(compiler_lexer_Lexer *this, compiler_tokens_TokenType type, u32 len);
char compiler_lexer_Lexer_cur(compiler_lexer_Lexer *this);
bool compiler_lexer_is_valid_ident_char(char c);
bool compiler_lexer_is_valid_utf8_start(char c, u32 *out_sz);
void compiler_lexer_Lexer_inc(compiler_lexer_Lexer *this);
char compiler_lexer_Lexer_peek(compiler_lexer_Lexer *this, u32 offset);
void compiler_lexer_Lexer_lex_char_literal(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_string_literal(compiler_lexer_Lexer *this, bool has_seen_f);
void compiler_lexer_Lexer_lex_raw_string_literal(compiler_lexer_Lexer *this);
compiler_tokens_Token *compiler_lexer_Lexer_lex_int_literal_different_base(compiler_lexer_Lexer *this);
compiler_tokens_Token *compiler_lexer_Lexer_lex_numeric_literal_helper(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_numeric_literal(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_comment(compiler_lexer_Lexer *this);
std_vector_Vector__11 *compiler_lexer_Lexer_lex(compiler_lexer_Lexer *this);
compiler_attributes_AttributeType compiler_attributes_AttributeType_from_str(char *s);
compiler_attributes_Attribute *compiler_attributes_Attribute_new(compiler_attributes_AttributeType type, std_span_Span span);
bool compiler_attributes_Attribute_validate(compiler_attributes_Attribute *this, compiler_parser_Parser *parser_for_errors);
char *compiler_lsp_server_read_message(void);
void compiler_lsp_server_send_message(std_value_Value *content);
void compiler_lsp_server_send_response(std_value_Value *req, std_value_Value *result);
void compiler_lsp_server_lsp_log(char *msg);
compiler_lsp_server_Loc compiler_lsp_server_get_location(std_value_Value *req);
std_process_Output compiler_lsp_server_LSPServer_run_lsp_backend_raw(compiler_lsp_server_LSPServer *this, compiler_lsp_server_Loc loc, char *lsp_cmd, bool include_pos);
std_value_Value *compiler_lsp_server_LSPServer_run_lsp_backend(compiler_lsp_server_LSPServer *this, compiler_lsp_server_Loc loc, char *lsp_cmd, bool include_pos);
std_value_Value *compiler_lsp_server_get_range(std_value_Value *val);
std_value_Value *compiler_lsp_server_get_uri(std_value_Value *orig_uri, std_value_Value *val);
void compiler_lsp_server_unescape_buf(std_buffer_Buffer *buf);
void compiler_lsp_server_LSPServer_handle_initialize(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_validate_document(compiler_lsp_server_LSPServer *this);
void compiler_lsp_server_LSPServer_handle_hover(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_definition(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_type_definition(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_references(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_rename(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_signature_help(compiler_lsp_server_LSPServer *this, std_value_Value *req);
std_value_Value *compiler_lsp_server_LSPServer_symbol_def_obj(compiler_lsp_server_LSPServer *this, std_value_Value *obj);
void compiler_lsp_server_LSPServer_handle_on_document_symbols(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_did_open(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_did_change(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_did_close(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_completion(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_shutdown(compiler_lsp_server_LSPServer *this, std_value_Value *req);
void compiler_lsp_server_LSPServer_handle_initialized(compiler_lsp_server_LSPServer *this, std_value_Value *req);
bool compiler_lsp_server_LSPServer_handle_request(compiler_lsp_server_LSPServer *this);
void compiler_lsp_server_main_loop(void);
i32 compiler_lsp_server_main(i32 argc, char **argv);
void compiler_lsp_cli_typecheck_and_log_errors(compiler_ast_program_Program *program, char *path);
void compiler_lsp_cli_handle_validate(compiler_ast_program_Program *program, char *path);
void compiler_lsp_cli_handle_location_command(compiler_ast_program_Program *program, compiler_lsp_cli_CommandType type, std_span_Location loc);
void compiler_lsp_cli_handle_document_symbols(compiler_ast_program_Program *program, char *path);
char *compiler_lsp_cli_shift_args(i32 *argc, char ***argv);
void compiler_lsp_cli_lsp_usage(i32 code, bool full);
void compiler_lsp_cli_signal_handler(i32 sig);
i32 compiler_lsp_cli_main(i32 argc, char **argv, char *contents);
char *compiler_lsp_cli_utils_gen_func_param_string(u32 i, compiler_ast_nodes_Variable *param, bool is_non_static_method);
char *compiler_lsp_cli_utils_gen_template_params(std_vector_Vector__0 *args);
char *compiler_lsp_cli_utils_gen_type_string(compiler_types_Type *type, bool full);
char *compiler_lsp_cli_utils_try_gen_expr_string(compiler_ast_nodes_AST *expr);
char *compiler_lsp_cli_utils_gen_hover_string(compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_lsp_cli_utils_get_symbol_typedef(compiler_ast_scopes_Symbol *sym);
std_value_Value *compiler_lsp_cli_utils_gen_error_json(compiler_errors_Error *err);
std_value_Value *compiler_lsp_cli_utils_gen_span_json(std_span_Span span);
std_value_Value *compiler_lsp_cli_utils_gen_span_json_with_filename(std_span_Span span, std_span_Location search_loc);
std_value_Value *compiler_lsp_cli_utils_gen_hover_string_with_docs(compiler_ast_scopes_Symbol *sym);
void compiler_lsp_cli_utils_gen_type_methods_into(std_value_Value *obj, compiler_types_Type *type);
std_value_Value *compiler_lsp_cli_utils_gen_struct_json(compiler_ast_nodes_Structure *struc);
std_value_Value *compiler_lsp_cli_utils_gen_variable_json(compiler_ast_nodes_Variable *var);
std_value_Value *compiler_lsp_cli_utils_gen_function_json(compiler_ast_nodes_Function *func);
std_value_Value *compiler_lsp_cli_utils_gen_namespace_json(compiler_ast_program_Namespace *ns);
void compiler_lsp_cli_utils_insert_completion_item(std_value_Value *completions, compiler_ast_scopes_Symbol *sym, std_set_Set__2 *seen, char *name);
std_vector_Vector__27 *compiler_lsp_cli_utils_get_unique_reference_spans(compiler_ast_scopes_Symbol *sym, bool for_rename);
std_value_Value *compiler_lsp_cli_utils_gen_references_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc);
std_value_Value *compiler_lsp_cli_utils_gen_signature_help(compiler_ast_nodes_AST *node, u32 active_param);
std_value_Value *compiler_lsp_cli_utils_gen_renames_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc);
void compiler_lsp_cli_utils_gen_completions_from_scope(compiler_ast_scopes_Scope *scope, std_value_Value *completions, compiler_types_Type *hint_type, std_set_Set__2 *seen);
void compiler_lsp_cli_utils_gen_completion_items_from_ns(std_value_Value *completions, compiler_ast_program_Namespace *ns, std_set_Set__2 *seen);
void compiler_lsp_cli_utils_gen_completions_from_symbol(compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node, std_value_Value *completions, std_set_Set__2 *seen);
std_value_Value *compiler_lsp_cli_utils_gen_completions_json(compiler_lsp_cli_finder_Finder *finder);
std_value_Value *compiler_lsp_cli_utils_gen_inlay_hint(compiler_ast_nodes_Variable *var, char *path);
compiler_lsp_cli_finder_Finder compiler_lsp_cli_finder_Finder_make(compiler_lsp_cli_CommandType cmd, std_span_Location loc);
bool compiler_lsp_cli_finder_Finder_find_in_identifier(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_var(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_Variable *var, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_set_usage(compiler_lsp_cli_finder_Finder *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_literal(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_signature_help(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__9 *args, u32 param_idx);
bool compiler_lsp_cli_finder_Finder_find_in_call_args(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__9 *args);
bool compiler_lsp_cli_finder_Finder_find_in_expression(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_import_part(compiler_lsp_cli_finder_Finder *this, compiler_ast_scopes_Symbol *base, compiler_ast_nodes_ImportPart *part, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_statement(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_block(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_cli_finder_Finder_find_in_type(compiler_lsp_cli_finder_Finder *this, compiler_types_Type *type);
bool compiler_lsp_cli_finder_Finder_find_in_function(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_Function *func);
bool compiler_lsp_cli_finder_Finder_find_in_program(compiler_lsp_cli_finder_Finder *this, compiler_ast_program_Namespace *ns);
bool compiler_lsp_cli_finder_Finder_find(compiler_lsp_cli_finder_Finder *this, compiler_ast_program_Program *program);
compiler_tokens_Token *compiler_tokens_Token_new(compiler_tokens_TokenType type, std_span_Span span, char *text);
compiler_tokens_Token *compiler_tokens_Token_from_type(compiler_tokens_TokenType type, std_span_Span span);
compiler_tokens_Token *compiler_tokens_Token_from_ident(char *text, std_span_Span span);
bool compiler_tokens_Token_is_word(compiler_tokens_Token this);
bool compiler_tokens_Token_is_identifier(compiler_tokens_Token this, char *name);
compiler_tokens_TokenType compiler_tokens_TokenType_from_text(char *text);
char *compiler_tokens_TokenType_str(compiler_tokens_TokenType this);
void usage(i32 code, bool full);
void save_and_compile_code(compiler_ast_program_Program *program, char *code);
void run_executable(i32 argc, char **argv);
void parse_args(i32 *argc, char ***argv, compiler_ast_program_Program *program);
void signal_handler(i32 sig);
i32 main(i32 argc, char **argv);
char *compiler_types_BaseType_str(compiler_types_BaseType this);
bool compiler_types_BaseType_is_callable(compiler_types_BaseType this);
compiler_types_Type *compiler_types_Type_shallow_copy(compiler_types_Type *old);
compiler_types_Type *compiler_types_Type_new_resolved(compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_types_Type_new_unresolved(char *name, std_span_Span span);
compiler_types_Type *compiler_types_Type_new_unresolved_base(compiler_types_BaseType base, std_span_Span span);
bool compiler_types_Type_is_integer(compiler_types_Type *this);
bool compiler_types_Type_is_float(compiler_types_Type *this);
bool compiler_types_Type_is_numeric(compiler_types_Type *this);
bool compiler_types_Type_is_numeric_or_char(compiler_types_Type *this);
bool compiler_types_Type_can_have_methods(compiler_types_Type *this);
bool compiler_types_Type_is_resolved(compiler_types_Type *this);
bool compiler_types_Type_eq(compiler_types_Type *this, compiler_types_Type *other, bool strict);
bool compiler_types_Type_is_str(compiler_types_Type *this);
compiler_types_Type *compiler_types_Type_unaliased(compiler_types_Type *this);
compiler_types_Type *compiler_types_Type_decay_array(compiler_types_Type *this);
char *compiler_types_Type_str(compiler_types_Type *this);
char *compiler_errors_MessageType_to_color(compiler_errors_MessageType this);
char *compiler_errors_MessageType_str(compiler_errors_MessageType this);
void compiler_errors_display_line(void);
void compiler_errors_display_message(compiler_errors_MessageType type, std_span_Span span, char *msg);
void compiler_errors_display_message_span(compiler_errors_MessageType type, std_span_Span span, char *msg, bool line_after);
void compiler_errors_Error_display(compiler_errors_Error *this);
void compiler_errors_Error_panic(compiler_errors_Error *this) __attribute__((noreturn));
compiler_errors_Error *compiler_errors_Error_new(std_span_Span span, char *msg);
compiler_errors_Error *compiler_errors_Error_new_note(std_span_Span span, char *msg, char *note);
compiler_errors_Error *compiler_errors_Error_new_hint(std_span_Span span, char *msg, std_span_Span span2, char *hint);
void compiler_errors_display_error_messages(std_vector_Vector__16 *errors, u32 detail_level);
void std_panic(char *msg) __attribute__((noreturn));
u32 str_to_u32(char *this);
bool str_eq(char *this, char *other);
char *std_format(char *fmt, ...);
char *str_substring(char *this, u32 start, u32 len);
bool str_ends_with(char *this, char *suffix);
bool str_starts_with(char *this, char *prefix);
void str_strip_trailing_whitespace(char *this);
void str_replace_with(char **this, char *other);
void str_free(char **this);
std_CharIterator str_chars(char *this, u32 start);
bool std_CharIterator_has_value(std_CharIterator *this);
u32 std_CharIterator_next(std_CharIterator *this);
char std_CharIterator_cur(std_CharIterator *this);
bool char_is_digit(char this);
bool char_is_hex_digit(char this);
u8 char_get_hex_digit(char this);
bool char_is_alnum(char this);
bool char_is_print(char this);
u32 u32_min(u32 this, u32 other);
u32 u32_max(u32 this, u32 other);
char *std_shift_args(i32 *argc, char ***argv, char *where);
bool std_sv_SV_is_empty(std_sv_SV *this);
std_sv_SV std_sv_SV_from_str(char *s);
std_sv_SV std_sv_SV_get(std_sv_SV this, u32 n);
char std_sv_SV_at(std_sv_SV this, u32 n);
std_sv_SV std_sv_SV_chop_by_delim(std_sv_SV *this, char delim);
std_sv_SV std_sv_SV_chop_by_sv(std_sv_SV *this, std_sv_SV delim);
std_sv_SV std_sv_SV_chop_by_str(std_sv_SV *this, char *delim);
u64 std_sv_SV_chop_unsigned(std_sv_SV *this, char *fn_name);
u32 std_sv_SV_chop_u32(std_sv_SV *this);
std_sv_SV std_sv_SV_chop_line(std_sv_SV *this);
bool std_sv_SV_eq(std_sv_SV this, std_sv_SV other);
bool std_sv_SV_eq_str(std_sv_SV this, char *other);
u32 std_sv_SV_hash(std_sv_SV this);
void std_sv_SV_only_chop_left(std_sv_SV *this, u32 n);
bool std_sv_SV_starts_with_sv(std_sv_SV this, std_sv_SV other);
bool std_sv_SV_starts_with_str(std_sv_SV this, char *other);
std_sv_SV std_sv_SV_slice(std_sv_SV this, u32 off, u32 end);
std_sv_SVLineIterator std_sv_SV_lines(std_sv_SV this);
std_sv_SVSplitIterator std_sv_SV_split_str(std_sv_SV this, char *delim);
char *std_sv_SV_copy_data_to_cstr(std_sv_SV this);
bool std_sv_SVLineIterator_has_value(std_sv_SVLineIterator *this);
std_sv_SV std_sv_SVLineIterator_cur(std_sv_SVLineIterator *this);
void std_sv_SVLineIterator_next(std_sv_SVLineIterator *this);
bool std_sv_SVSplitIterator_has_value(std_sv_SVSplitIterator *this);
std_sv_SV std_sv_SVSplitIterator_cur(std_sv_SVSplitIterator *this);
void std_sv_SVSplitIterator_next(std_sv_SVSplitIterator *this);
void std_mem_set_allocator(void *allocator, void *(*alloc_fn)(void *, u32), void (*free_fn)(void *, void *), void *(*realloc_fn)(void *, void *, u32, u32));
compiler_passes_mark_dead_code_MarkDeadCode *std_mem_alloc__0(u32 count);
compiler_passes_generic_pass_GenericPass *std_mem_alloc__1(u32 count);
compiler_passes_reorder_symbols_ReorderSymbols *std_mem_alloc__2(u32 count);
compiler_ast_program_Namespace *std_mem_alloc__3(u32 count);
compiler_ast_program_Program *std_mem_alloc__4(u32 count);
compiler_ast_scopes_TemplateInstance *std_mem_alloc__5(u32 count);
compiler_ast_scopes_Template *std_mem_alloc__6(u32 count);
compiler_ast_scopes_Symbol *std_mem_alloc__7(u32 count);
compiler_ast_scopes_Scope *std_mem_alloc__8(u32 count);
compiler_ast_nodes_Variable *std_mem_alloc__9(u32 count);
compiler_ast_nodes_Structure *std_mem_alloc__10(u32 count);
compiler_ast_nodes_Enum *std_mem_alloc__11(u32 count);
compiler_ast_nodes_EnumVariant *std_mem_alloc__12(u32 count);
compiler_ast_nodes_Function *std_mem_alloc__13(u32 count);
compiler_ast_nodes_Argument *std_mem_alloc__14(u32 count);
compiler_ast_nodes_ImportPart *std_mem_alloc__15(u32 count);
compiler_ast_nodes_MatchCond *std_mem_alloc__16(u32 count);
compiler_ast_nodes_AST *std_mem_alloc__17(u32 count);
compiler_attributes_Attribute *std_mem_alloc__18(u32 count);
char *std_mem_alloc__19(u32 count);
compiler_tokens_Token *std_mem_alloc__20(u32 count);
compiler_types_Type *std_mem_alloc__21(u32 count);
compiler_errors_Error *std_mem_alloc__22(u32 count);
i32 *std_mem_alloc__23(u32 count);
std_compact_map_Map__0 *std_mem_alloc__24(u32 count);
std_compact_map_Map__1 *std_mem_alloc__25(u32 count);
std_compact_map_Map__2 *std_mem_alloc__26(u32 count);
u8 *std_mem_alloc__27(u32 count);
std_set_Set__0 *std_mem_alloc__28(u32 count);
std_set_Set__1 *std_mem_alloc__29(u32 count);
std_set_Set__2 *std_mem_alloc__30(u32 count);
std_set_Set__3 *std_mem_alloc__31(u32 count);
std_value_Value *std_mem_alloc__32(u32 count);
std_map_Item__0 *std_mem_alloc__33(u32 count);
std_map_Item__0 **std_mem_alloc__34(u32 count);
std_map_Map__0 *std_mem_alloc__35(u32 count);
std_map_Item__1 *std_mem_alloc__36(u32 count);
std_map_Item__1 **std_mem_alloc__37(u32 count);
std_map_Map__1 *std_mem_alloc__38(u32 count);
std_map_Item__2 *std_mem_alloc__39(u32 count);
std_map_Item__2 **std_mem_alloc__40(u32 count);
std_map_Map__2 *std_mem_alloc__41(u32 count);
std_map_Item__3 *std_mem_alloc__42(u32 count);
std_map_Item__3 **std_mem_alloc__43(u32 count);
std_map_Map__3 *std_mem_alloc__44(u32 count);
std_map_Item__4 *std_mem_alloc__45(u32 count);
std_map_Item__4 **std_mem_alloc__46(u32 count);
std_map_Map__4 *std_mem_alloc__47(u32 count);
std_map_Item__5 *std_mem_alloc__48(u32 count);
std_map_Item__5 **std_mem_alloc__49(u32 count);
std_map_Map__5 *std_mem_alloc__50(u32 count);
std_map_Item__6 *std_mem_alloc__51(u32 count);
std_map_Item__6 **std_mem_alloc__52(u32 count);
std_map_Map__6 *std_mem_alloc__53(u32 count);
std_map_Item__7 *std_mem_alloc__54(u32 count);
std_map_Item__7 **std_mem_alloc__55(u32 count);
std_map_Map__7 *std_mem_alloc__56(u32 count);
std_map_Item__8 *std_mem_alloc__57(u32 count);
std_map_Item__8 **std_mem_alloc__58(u32 count);
std_map_Map__8 *std_mem_alloc__59(u32 count);
std_map_Item__9 *std_mem_alloc__60(u32 count);
std_map_Item__9 **std_mem_alloc__61(u32 count);
std_map_Map__9 *std_mem_alloc__62(u32 count);
std_map_Item__10 *std_mem_alloc__63(u32 count);
std_map_Item__10 **std_mem_alloc__64(u32 count);
std_map_Map__10 *std_mem_alloc__65(u32 count);
std_map_Item__11 *std_mem_alloc__66(u32 count);
std_map_Item__11 **std_mem_alloc__67(u32 count);
std_map_Map__11 *std_mem_alloc__68(u32 count);
std_map_Item__12 *std_mem_alloc__69(u32 count);
std_map_Item__12 **std_mem_alloc__70(u32 count);
std_map_Map__12 *std_mem_alloc__71(u32 count);
std_map_Item__13 *std_mem_alloc__72(u32 count);
std_map_Item__13 **std_mem_alloc__73(u32 count);
std_map_Map__13 *std_mem_alloc__74(u32 count);
std_vector_Vector__0 *std_mem_alloc__75(u32 count);
compiler_types_Type **std_mem_alloc__76(u32 count);
std_vector_Vector__1 *std_mem_alloc__77(u32 count);
char **std_mem_alloc__78(u32 count);
std_vector_Vector__2 *std_mem_alloc__79(u32 count);
compiler_ast_scopes_Scope **std_mem_alloc__80(u32 count);
std_vector_Vector__3 *std_mem_alloc__81(u32 count);
compiler_ast_program_Namespace **std_mem_alloc__82(u32 count);
std_vector_Vector__4 *std_mem_alloc__83(u32 count);
compiler_ast_nodes_Variable **std_mem_alloc__84(u32 count);
std_vector_Vector__5 *std_mem_alloc__85(u32 count);
compiler_ast_scopes_TemplateInstance **std_mem_alloc__86(u32 count);
std_vector_Vector__6 *std_mem_alloc__87(u32 count);
compiler_ast_nodes_MatchCond **std_mem_alloc__88(u32 count);
std_vector_Vector__7 *std_mem_alloc__89(u32 count);
compiler_ast_nodes_ImportPart **std_mem_alloc__90(u32 count);
std_vector_Vector__8 *std_mem_alloc__91(u32 count);
compiler_ast_nodes_Function **std_mem_alloc__92(u32 count);
std_vector_Vector__9 *std_mem_alloc__93(u32 count);
compiler_ast_nodes_Argument **std_mem_alloc__94(u32 count);
std_vector_Vector__10 *std_mem_alloc__95(u32 count);
compiler_ast_scopes_Symbol **std_mem_alloc__96(u32 count);
std_vector_Vector__11 *std_mem_alloc__97(u32 count);
compiler_tokens_Token **std_mem_alloc__98(u32 count);
std_vector_Vector__12 *std_mem_alloc__99(u32 count);
compiler_attributes_Attribute **std_mem_alloc__100(u32 count);
std_vector_Vector__13 *std_mem_alloc__101(u32 count);
compiler_ast_nodes_Structure **std_mem_alloc__102(u32 count);
std_vector_Vector__14 *std_mem_alloc__103(u32 count);
compiler_ast_nodes_Enum **std_mem_alloc__104(u32 count);
std_vector_Vector__15 *std_mem_alloc__105(u32 count);
compiler_ast_nodes_AST **std_mem_alloc__106(u32 count);
std_vector_Vector__16 *std_mem_alloc__107(u32 count);
compiler_errors_Error **std_mem_alloc__108(u32 count);
std_vector_Vector__17 *std_mem_alloc__109(u32 count);
jmp_buf *std_mem_alloc__110(u32 count);
std_vector_Vector__18 *std_mem_alloc__111(u32 count);
compiler_ast_scopes_Reference *std_mem_alloc__112(u32 count);
std_vector_Vector__19 *std_mem_alloc__113(u32 count);
compiler_ast_nodes_MatchCondArg **std_mem_alloc__114(u32 count);
std_vector_Vector__20 *std_mem_alloc__115(u32 count);
compiler_ast_nodes_EnumVariant **std_mem_alloc__116(u32 count);
std_vector_Vector__21 *std_mem_alloc__117(u32 count);
compiler_ast_operators_Operator *std_mem_alloc__118(u32 count);
std_vector_Vector__22 *std_mem_alloc__119(u32 count);
std_vector_Vector__7 **std_mem_alloc__120(u32 count);
std_vector_Vector__23 *std_mem_alloc__121(u32 count);
compiler_ast_nodes_IfBranch *std_mem_alloc__122(u32 count);
std_vector_Vector__24 *std_mem_alloc__123(u32 count);
compiler_ast_nodes_MatchCase *std_mem_alloc__124(u32 count);
std_vector_Vector__25 *std_mem_alloc__125(u32 count);
compiler_ast_nodes_MapLiteralPair *std_mem_alloc__126(u32 count);
std_vector_Vector__26 *std_mem_alloc__127(u32 count);
std_compact_map_Item__0 *std_mem_alloc__128(u32 count);
std_vector_Vector__27 *std_mem_alloc__129(u32 count);
std_span_Span *std_mem_alloc__130(u32 count);
std_vector_Vector__28 *std_mem_alloc__131(u32 count);
std_value_Value **std_mem_alloc__132(u32 count);
std_vector_Vector__29 *std_mem_alloc__133(u32 count);
std_compact_map_Item__1 *std_mem_alloc__134(u32 count);
std_vector_Vector__30 *std_mem_alloc__135(u32 count);
std_compact_map_Item__2 *std_mem_alloc__136(u32 count);
std_vector_Vector__31 *std_mem_alloc__137(u32 count);
u32 *std_mem_alloc__138(u32 count);
void std_mem_free(void *ptr);
u8 *std_mem_realloc__0(u8 *ptr, u32 old_count, u32 new_count);
compiler_types_Type **std_mem_realloc__1(compiler_types_Type **ptr, u32 old_count, u32 new_count);
char **std_mem_realloc__2(char **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Scope **std_mem_realloc__3(compiler_ast_scopes_Scope **ptr, u32 old_count, u32 new_count);
compiler_ast_program_Namespace **std_mem_realloc__4(compiler_ast_program_Namespace **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Variable **std_mem_realloc__5(compiler_ast_nodes_Variable **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_TemplateInstance **std_mem_realloc__6(compiler_ast_scopes_TemplateInstance **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCond **std_mem_realloc__7(compiler_ast_nodes_MatchCond **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_ImportPart **std_mem_realloc__8(compiler_ast_nodes_ImportPart **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Function **std_mem_realloc__9(compiler_ast_nodes_Function **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Argument **std_mem_realloc__10(compiler_ast_nodes_Argument **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Symbol **std_mem_realloc__11(compiler_ast_scopes_Symbol **ptr, u32 old_count, u32 new_count);
compiler_tokens_Token **std_mem_realloc__12(compiler_tokens_Token **ptr, u32 old_count, u32 new_count);
compiler_attributes_Attribute **std_mem_realloc__13(compiler_attributes_Attribute **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Structure **std_mem_realloc__14(compiler_ast_nodes_Structure **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Enum **std_mem_realloc__15(compiler_ast_nodes_Enum **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_AST **std_mem_realloc__16(compiler_ast_nodes_AST **ptr, u32 old_count, u32 new_count);
compiler_errors_Error **std_mem_realloc__17(compiler_errors_Error **ptr, u32 old_count, u32 new_count);
jmp_buf *std_mem_realloc__18(jmp_buf *ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Reference *std_mem_realloc__19(compiler_ast_scopes_Reference *ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCondArg **std_mem_realloc__20(compiler_ast_nodes_MatchCondArg **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_EnumVariant **std_mem_realloc__21(compiler_ast_nodes_EnumVariant **ptr, u32 old_count, u32 new_count);
compiler_ast_operators_Operator *std_mem_realloc__22(compiler_ast_operators_Operator *ptr, u32 old_count, u32 new_count);
std_vector_Vector__7 **std_mem_realloc__23(std_vector_Vector__7 **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_IfBranch *std_mem_realloc__24(compiler_ast_nodes_IfBranch *ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCase *std_mem_realloc__25(compiler_ast_nodes_MatchCase *ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MapLiteralPair *std_mem_realloc__26(compiler_ast_nodes_MapLiteralPair *ptr, u32 old_count, u32 new_count);
std_compact_map_Item__0 *std_mem_realloc__27(std_compact_map_Item__0 *ptr, u32 old_count, u32 new_count);
std_span_Span *std_mem_realloc__28(std_span_Span *ptr, u32 old_count, u32 new_count);
std_value_Value **std_mem_realloc__29(std_value_Value **ptr, u32 old_count, u32 new_count);
std_compact_map_Item__1 *std_mem_realloc__30(std_compact_map_Item__1 *ptr, u32 old_count, u32 new_count);
std_compact_map_Item__2 *std_mem_realloc__31(std_compact_map_Item__2 *ptr, u32 old_count, u32 new_count);
u32 *std_mem_realloc__32(u32 *ptr, u32 old_count, u32 new_count);
void *std_mem_impl_my_calloc(void *state, u32 size);
void *std_mem_impl_my_realloc(void *state, void *ptr, u32 old_size, u32 size);
void std_mem_impl_my_free(void *state, void *ptr);
void std_gc_init(void *base);
void *std_gc_alloc(u32 size);
void std_gc_collect(void);
void std_gc_human_readable_size(i64 bytes, char *output);
void std_gc_print_stats(void);
void std_gc_shutdown(void);
void *std_gc_impl__alloc_fn(void *_, u32 size);
void *std_gc_impl__realloc_fn(void *_, void *ptr, u32 old_size, u32 size);
void std_gc_impl__free_fn(void *_, void *ptr);
void std_gc_impl_mark_range(void *start, void *end);
void std_gc_impl_mark_object(std_gc_impl_Header *header);
char *std_libc_errno_get_err(void);
void std_compact_map_Map__0_remove(std_compact_map_Map__0 *this, std_sv_SV key);
bool std_compact_map_Map__0_contains(std_compact_map_Map__0 *this, std_sv_SV key);
compiler_lsp_server_TextDocument std_compact_map_Map__0_at(std_compact_map_Map__0 *this, std_sv_SV key);
void std_compact_map_Map__0_insert(std_compact_map_Map__0 *this, std_sv_SV key, compiler_lsp_server_TextDocument value);
u32 std_compact_map_Map__0_get_index(std_compact_map_Map__0 *this, std_sv_SV key, u32 hash);
void std_compact_map_Map__0_resize(std_compact_map_Map__0 *this, u32 new_capacity);
std_compact_map_Item__0 *std_compact_map_Map__0_get_item(std_compact_map_Map__0 *this, std_sv_SV key);
std_compact_map_Map__0 *std_compact_map_Map__0_new(u32 capacity);
void std_compact_map_Map__0_resize_if_necessary(std_compact_map_Map__0 *this);
u32 std_compact_map_Map__1_size(std_compact_map_Map__1 *this);
bool std_compact_map_Map__1_contains(std_compact_map_Map__1 *this, char *key);
std_compact_map_Iterator__1 std_compact_map_Map__1_iter(std_compact_map_Map__1 *this);
std_compact_map_Item__1 std_compact_map_Iterator__1_cur(std_compact_map_Iterator__1 *this);
void std_compact_map_Iterator__1_next(std_compact_map_Iterator__1 *this);
bool std_compact_map_Iterator__1_has_value(std_compact_map_Iterator__1 *this);
void std_compact_map_Map__1_insert(std_compact_map_Map__1 *this, char *key, std_value_Value *value);
u32 std_compact_map_Map__1_get_index(std_compact_map_Map__1 *this, char *key, u32 hash);
std_value_Value *std_compact_map_Map__1_get(std_compact_map_Map__1 *this, char *key, std_value_Value *defolt);
bool std_compact_map_Map__1_is_empty(std_compact_map_Map__1 *this);
void std_compact_map_Map__1_resize(std_compact_map_Map__1 *this, u32 new_capacity);
std_compact_map_Item__1 *std_compact_map_Map__1_get_item(std_compact_map_Map__1 *this, char *key);
std_compact_map_Map__1 *std_compact_map_Map__1_new(u32 capacity);
void std_compact_map_Map__1_resize_if_necessary(std_compact_map_Map__1 *this);
void std_compact_map_Map__2_insert(std_compact_map_Map__2 *this, char *key, std_span_Span value);
u32 std_compact_map_Map__2_get_index(std_compact_map_Map__2 *this, char *key, u32 hash);
void std_compact_map_Map__2_resize(std_compact_map_Map__2 *this, u32 new_capacity);
std_compact_map_Item__2 *std_compact_map_Map__2_get_item(std_compact_map_Map__2 *this, char *key);
std_compact_map_Map__2 *std_compact_map_Map__2_new(u32 capacity);
void std_compact_map_Map__2_resize_if_necessary(std_compact_map_Map__2 *this);
std_buffer_Buffer std_buffer_Buffer_make(u32 capacity);
std_buffer_Buffer std_buffer_Buffer_from_str(char *s);
void std_buffer_Buffer_resize_if_necessary(std_buffer_Buffer *this, u32 new_size);
void std_buffer_Buffer_write_str(std_buffer_Buffer *this, char *s);
void std_buffer_Buffer_write_str_f(std_buffer_Buffer *this, char *s);
void std_buffer_Buffer_write_char(std_buffer_Buffer *this, char c);
void std_buffer_Buffer_write_bytes(std_buffer_Buffer *this, void *bytes, u32 size);
void std_buffer_Buffer_write_u8(std_buffer_Buffer *this, u8 value);
char *std_buffer_Buffer_new_str(std_buffer_Buffer this);
char *std_buffer_Buffer_str(std_buffer_Buffer this);
std_sv_SV std_buffer_Buffer_sv(std_buffer_Buffer this);
void std_buffer_Buffer_clear(std_buffer_Buffer *this);
void std_buffer_Buffer_free(std_buffer_Buffer *this);
void std_logging_init_logging(std_logging_LogLevel level, char *time_format);
void std_logging_vlog(std_logging_LogLevel level, char *fmt, va_list vargs);
void std_logging_log(std_logging_LogLevel level, char *fmt, ...);
void std_set_Set__0_free(std_set_Set__0 *this);
void std_set_Set__0_add(std_set_Set__0 *this, u64 key);
bool std_set_Set__0_contains(std_set_Set__0 *this, u64 key);
std_set_Set__0 *std_set_Set__0_new(void);
void std_set_Set__1_free(std_set_Set__1 *this);
void std_set_Set__1_add(std_set_Set__1 *this, void *key);
bool std_set_Set__1_contains(std_set_Set__1 *this, void *key);
std_set_Set__1 *std_set_Set__1_new(void);
void std_set_Set__2_free(std_set_Set__2 *this);
void std_set_Set__2_add(std_set_Set__2 *this, char *key);
bool std_set_Set__2_contains(std_set_Set__2 *this, char *key);
std_set_Set__2 *std_set_Set__2_new(void);
void std_set_Set__3_free(std_set_Set__3 *this);
void std_set_Set__3_add(std_set_Set__3 *this, std_span_Span key);
std_set_Set__3 *std_set_Set__3_new(void);
std_set_Iterator__3 std_set_Set__3_iter(std_set_Set__3 *this);
std_span_Span std_set_Iterator__3_cur(std_set_Iterator__3 *this);
void std_set_Iterator__3_next(std_set_Iterator__3 *this);
bool std_set_Iterator__3_has_value(std_set_Iterator__3 *this);
std_set_Iterator__3 std_set_Iterator__3_make(std_set_Set__3 *set);
std_span_Location std_span_Location_default(void);
u32 std_span_Location_hash(std_span_Location this);
bool std_span_Location_eq(std_span_Location this, std_span_Location other);
char *std_span_Location_str(std_span_Location *this);
bool std_span_Location_is_valid(std_span_Location *this);
bool std_span_Location_is_before(std_span_Location *this, std_span_Location other);
std_span_Span std_span_Span_default(void);
u32 std_span_Span_hash(std_span_Span this);
bool std_span_Span_eq(std_span_Span this, std_span_Span other);
bool std_span_Span_is_valid(std_span_Span this);
std_span_Span std_span_Span_join(std_span_Span this, std_span_Span other);
bool std_span_Span_contains_loc(std_span_Span this, std_span_Location loc);
bool std_span_Span_starts_right_after(std_span_Span this, std_span_Span other);
bool u64_eq(u64 this, u64 other);
bool untyped_ptr_eq(void *this, void *other);
u32 std_traits_hash_hash_bytes(u8 *data, u32 len);
u32 std_traits_hash_pair_hash(u32 a, u32 b);
u32 std_traits_hash_ptr_hash(void *ptr);
u32 untyped_ptr_hash(void *this);
u32 str_hash(char *this);
u32 u32_hash(u32 this);
u32 u64_hash(u64 this);
char *std_value_ValueType_str(std_value_ValueType this);
std_value_Value *std_value_Value_new(std_value_ValueType type);
std_value_Value *std_value_Value_new_str(char *s);
std_value_Value *std_value_Value_new_bool(bool bul);
std_value_Value *std_value_Value_new_int(i64 num);
std_value_Value *std_value_Value_new_list(std_vector_Vector__28 *vec);
std_value_Value *std_value_Value_new_dict(std_compact_map_Map__1 *map);
void std_value_Value_ensure(std_value_Value *this, std_value_ValueType type);
bool std_value_Value_is(std_value_Value this, std_value_ValueType type);
std_value_Value *std_value_Value_at(std_value_Value *this, u32 idx);
std_value_Value *std_value_Value_at_key(std_value_Value *this, char *key);
void std_value_Value_push(std_value_Value *this, std_value_Value *value);
bool std_value_Value_contains(std_value_Value *this, char *key);
std_value_Value *std_value_Value_get(std_value_Value *this, char *key, std_value_Value *defolt);
void std_value_Value_insert(std_value_Value *this, char *key, std_value_Value *value);
void std_value_Value_insert_str(std_value_Value *this, char *key, char *s);
void std_value_Value_insert_u32(std_value_Value *this, char *key, u32 i);
i64 std_value_Value_as_int(std_value_Value *this);
std_buffer_Buffer std_value_Value_as_str(std_value_Value *this);
std_vector_Vector__28 *std_value_Value_as_list(std_value_Value *this);
std_compact_map_Map__1 *std_value_Value_as_dict(std_value_Value *this);
char *std_value_Value_dbg(std_value_Value *this);
bool std_value_Value_eq_str(std_value_Value *this, char *other);
std_process_Output std_process_Output_from_error(i32 error_code);
std_process_Output std_process_get_output(char *cmd, _ClosureTy_32 callback, bool capture_stderr, char *shell);
f64 std_time_get_time_monotonic_ms(void);
char *std_fs_realpath(char *path);
i32 std_fs_File_read(FILE *this, void *buf, u32 size);
i32 std_fs_File_write(FILE *this, void *buf, u32 size);
bool std_fs_file_exists(char *path);
void std_fs_write_file_bytes(char *path, void *data, u32 size);
void std_fs_write_file_str(char *path, char *data);
void std_fs_write_file(char *path, std_buffer_Buffer data);
std_buffer_Buffer std_fs_read_file(char *path);
bool std_fs_directory_exists(char *path);
std_fs_DirectoryIterator std_fs_iterate_directory(char *path, bool skip_self_and_parent);
bool std_fs_DirectoryIterator_has_value(std_fs_DirectoryIterator *this);
void std_fs_DirectoryIterator_next(std_fs_DirectoryIterator *this);
std_fs_DirectoryEntry std_fs_DirectoryIterator_cur(std_fs_DirectoryIterator *this);
std_map_Item__0 *std_map_Item__0_new(u64 key, bool value, std_map_Item__0 *next);
void std_map_Item__0_free_list(std_map_Item__0 *this);
void std_map_Map__0_free(std_map_Map__0 *this);
void std_map_Map__0_insert(std_map_Map__0 *this, u64 key, bool value);
bool std_map_Map__0_contains(std_map_Map__0 *this, u64 key);
void std_map_Map__0_resize(std_map_Map__0 *this);
u32 std_map_Map__0_hash(std_map_Map__0 *this, u64 key);
std_map_Map__0 *std_map_Map__0_new(u32 capacity);
std_map_Item__0 *std_map_Map__0_get_item(std_map_Map__0 *this, u64 key);
std_map_Item__1 *std_map_Item__1_new(char *key, compiler_ast_nodes_MatchCond *value, std_map_Item__1 *next);
void std_map_Item__1_free_list(std_map_Item__1 *this);
void std_map_Map__1_free(std_map_Map__1 *this);
void std_map_Map__1_insert(std_map_Map__1 *this, char *key, compiler_ast_nodes_MatchCond *value);
compiler_ast_nodes_MatchCond *std_map_Map__1_get(std_map_Map__1 *this, char *key, compiler_ast_nodes_MatchCond *defolt);
bool std_map_Map__1_contains(std_map_Map__1 *this, char *key);
void std_map_Map__1_resize(std_map_Map__1 *this);
u32 std_map_Map__1_hash(std_map_Map__1 *this, char *key);
std_map_Map__1 *std_map_Map__1_new(u32 capacity);
std_map_Item__1 *std_map_Map__1_get_item(std_map_Map__1 *this, char *key);
std_map_Item__2 *std_map_Item__2_new(char *key, compiler_types_Type *value, std_map_Item__2 *next);
void std_map_Item__2_free_list(std_map_Item__2 *this);
void std_map_Map__2_free(std_map_Map__2 *this);
void std_map_Map__2_insert(std_map_Map__2 *this, char *key, compiler_types_Type *value);
compiler_types_Type *std_map_Map__2_get(std_map_Map__2 *this, char *key, compiler_types_Type *defolt);
std_map_Item__2 *std_map_Iterator__2_cur(std_map_Iterator__2 *this);
void std_map_Iterator__2_next(std_map_Iterator__2 *this);
bool std_map_Iterator__2_has_value(std_map_Iterator__2 *this);
std_map_Iterator__2 std_map_Iterator__2_make(std_map_Map__2 *map);
bool std_map_Map__2_is_empty(std_map_Map__2 *this);
void std_map_Map__2_resize(std_map_Map__2 *this);
u32 std_map_Map__2_hash(std_map_Map__2 *this, char *key);
std_map_Map__2 *std_map_Map__2_new(u32 capacity);
std_map_Item__2 *std_map_Map__2_get_item(std_map_Map__2 *this, char *key);
void std_map_Map__2_clear(std_map_Map__2 *this);
std_map_Iterator__2 std_map_Map__2_iter(std_map_Map__2 *this);
std_map_Item__3 *std_map_Item__3_new(void *key, bool value, std_map_Item__3 *next);
void std_map_Item__3_free_list(std_map_Item__3 *this);
void std_map_Map__3_free(std_map_Map__3 *this);
void std_map_Map__3_insert(std_map_Map__3 *this, void *key, bool value);
bool std_map_Map__3_contains(std_map_Map__3 *this, void *key);
void std_map_Map__3_resize(std_map_Map__3 *this);
u32 std_map_Map__3_hash(std_map_Map__3 *this, void *key);
std_map_Map__3 *std_map_Map__3_new(u32 capacity);
std_map_Item__3 *std_map_Map__3_get_item(std_map_Map__3 *this, void *key);
std_map_Item__4 *std_map_Item__4_new(char *key, compiler_ast_program_Namespace *value, std_map_Item__4 *next);
void std_map_Item__4_free_list(std_map_Item__4 *this);
compiler_ast_program_Namespace *std_map_Map__4_at(std_map_Map__4 *this, char *key);
void std_map_Map__4_insert(std_map_Map__4 *this, char *key, compiler_ast_program_Namespace *value);
compiler_ast_program_Namespace *std_map_Map__4_get(std_map_Map__4 *this, char *key, compiler_ast_program_Namespace *defolt);
std_map_Item__4 *std_map_Iterator__4_cur(std_map_Iterator__4 *this);
void std_map_Iterator__4_next(std_map_Iterator__4 *this);
bool std_map_Iterator__4_has_value(std_map_Iterator__4 *this);
std_map_Iterator__4 std_map_Iterator__4_make(std_map_Map__4 *map);
bool std_map_Map__4_is_empty(std_map_Map__4 *this);
bool std_map_Map__4_contains(std_map_Map__4 *this, char *key);
void std_map_Map__4_resize(std_map_Map__4 *this);
u32 std_map_Map__4_hash(std_map_Map__4 *this, char *key);
std_map_ValueIterator__4 std_map_Map__4_iter_values(std_map_Map__4 *this);
compiler_ast_program_Namespace *std_map_ValueIterator__4_cur(std_map_ValueIterator__4 *this);
void std_map_ValueIterator__4_next(std_map_ValueIterator__4 *this);
bool std_map_ValueIterator__4_has_value(std_map_ValueIterator__4 *this);
std_map_Map__4 *std_map_Map__4_new(u32 capacity);
std_map_Item__4 *std_map_Map__4_get_item(std_map_Map__4 *this, char *key);
std_map_Iterator__4 std_map_Map__4_iter(std_map_Map__4 *this);
std_map_Item__5 *std_map_Item__5_new(char *key, compiler_ast_scopes_Symbol *value, std_map_Item__5 *next);
void std_map_Item__5_free_list(std_map_Item__5 *this);
compiler_ast_scopes_Symbol *std_map_Map__5_at(std_map_Map__5 *this, char *key);
void std_map_Map__5_insert(std_map_Map__5 *this, char *key, compiler_ast_scopes_Symbol *value);
compiler_ast_scopes_Symbol *std_map_Map__5_get(std_map_Map__5 *this, char *key, compiler_ast_scopes_Symbol *defolt);
std_map_Item__5 *std_map_Iterator__5_cur(std_map_Iterator__5 *this);
void std_map_Iterator__5_next(std_map_Iterator__5 *this);
bool std_map_Iterator__5_has_value(std_map_Iterator__5 *this);
std_map_Iterator__5 std_map_Iterator__5_make(std_map_Map__5 *map);
bool std_map_Map__5_contains(std_map_Map__5 *this, char *key);
void std_map_Map__5_resize(std_map_Map__5 *this);
u32 std_map_Map__5_hash(std_map_Map__5 *this, char *key);
std_map_ValueIterator__5 std_map_Map__5_iter_values(std_map_Map__5 *this);
compiler_ast_scopes_Symbol *std_map_ValueIterator__5_cur(std_map_ValueIterator__5 *this);
void std_map_ValueIterator__5_next(std_map_ValueIterator__5 *this);
bool std_map_ValueIterator__5_has_value(std_map_ValueIterator__5 *this);
std_map_Map__5 *std_map_Map__5_new(u32 capacity);
std_map_Item__5 *std_map_Map__5_get_item(std_map_Map__5 *this, char *key);
std_map_Iterator__5 std_map_Map__5_iter(std_map_Map__5 *this);
std_map_Item__6 *std_map_Item__6_new(compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value, std_map_Item__6 *next);
void std_map_Item__6_free_list(std_map_Item__6 *this);
void std_map_Map__6_insert(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value);
compiler_ast_nodes_Function *std_map_Map__6_get(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *defolt);
void std_map_Map__6_resize(std_map_Map__6 *this);
u32 std_map_Map__6_hash(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key);
std_map_Map__6 *std_map_Map__6_new(u32 capacity);
std_map_Item__6 *std_map_Map__6_get_item(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key);
std_map_Item__7 *std_map_Item__7_new(char *key, char *value, std_map_Item__7 *next);
void std_map_Item__7_free_list(std_map_Item__7 *this);
void std_map_Map__7_insert(std_map_Map__7 *this, char *key, char *value);
char *std_map_Map__7_get(std_map_Map__7 *this, char *key, char *defolt);
std_map_Item__7 *std_map_Iterator__7_cur(std_map_Iterator__7 *this);
void std_map_Iterator__7_next(std_map_Iterator__7 *this);
bool std_map_Iterator__7_has_value(std_map_Iterator__7 *this);
std_map_Iterator__7 std_map_Iterator__7_make(std_map_Map__7 *map);
bool std_map_Map__7_contains(std_map_Map__7 *this, char *key);
void std_map_Map__7_resize(std_map_Map__7 *this);
u32 std_map_Map__7_hash(std_map_Map__7 *this, char *key);
std_map_Map__7 *std_map_Map__7_new(u32 capacity);
std_map_Item__7 *std_map_Map__7_get_item(std_map_Map__7 *this, char *key);
std_map_Iterator__7 std_map_Map__7_iter(std_map_Map__7 *this);
std_map_Item__8 *std_map_Item__8_new(char *key, bool value, std_map_Item__8 *next);
void std_map_Item__8_free_list(std_map_Item__8 *this);
void std_map_Map__8_free(std_map_Map__8 *this);
void std_map_Map__8_insert(std_map_Map__8 *this, char *key, bool value);
bool std_map_Map__8_contains(std_map_Map__8 *this, char *key);
void std_map_Map__8_resize(std_map_Map__8 *this);
u32 std_map_Map__8_hash(std_map_Map__8 *this, char *key);
std_map_Map__8 *std_map_Map__8_new(u32 capacity);
std_map_Item__8 *std_map_Map__8_get_item(std_map_Map__8 *this, char *key);
std_map_Item__9 *std_map_Item__9_new(char *key, compiler_ast_nodes_Function *value, std_map_Item__9 *next);
void std_map_Item__9_free_list(std_map_Item__9 *this);
compiler_ast_nodes_Function *std_map_Map__9_at(std_map_Map__9 *this, char *key);
void std_map_Map__9_insert(std_map_Map__9 *this, char *key, compiler_ast_nodes_Function *value);
compiler_ast_nodes_Function *std_map_Map__9_get(std_map_Map__9 *this, char *key, compiler_ast_nodes_Function *defolt);
std_map_Item__9 *std_map_Iterator__9_cur(std_map_Iterator__9 *this);
void std_map_Iterator__9_next(std_map_Iterator__9 *this);
bool std_map_Iterator__9_has_value(std_map_Iterator__9 *this);
std_map_Iterator__9 std_map_Iterator__9_make(std_map_Map__9 *map);
void std_map_Map__9_resize(std_map_Map__9 *this);
u32 std_map_Map__9_hash(std_map_Map__9 *this, char *key);
std_map_ValueIterator__9 std_map_Map__9_iter_values(std_map_Map__9 *this);
compiler_ast_nodes_Function *std_map_ValueIterator__9_cur(std_map_ValueIterator__9 *this);
void std_map_ValueIterator__9_next(std_map_ValueIterator__9 *this);
bool std_map_ValueIterator__9_has_value(std_map_ValueIterator__9 *this);
std_map_Map__9 *std_map_Map__9_new(u32 capacity);
std_map_Item__9 *std_map_Map__9_get_item(std_map_Map__9 *this, char *key);
std_map_Iterator__9 std_map_Map__9_iter(std_map_Map__9 *this);
std_map_Item__10 *std_map_Item__10_new(char *key, compiler_ast_nodes_Argument *value, std_map_Item__10 *next);
void std_map_Item__10_free_list(std_map_Item__10 *this);
void std_map_Map__10_free(std_map_Map__10 *this);
void std_map_Map__10_insert(std_map_Map__10 *this, char *key, compiler_ast_nodes_Argument *value);
void std_map_Map__10_resize(std_map_Map__10 *this);
u32 std_map_Map__10_hash(std_map_Map__10 *this, char *key);
std_map_Map__10 *std_map_Map__10_new(u32 capacity);
std_map_Item__10 *std_map_Map__10_get_item(std_map_Map__10 *this, char *key);
std_map_Item__11 *std_map_Item__11_new(char *key, compiler_ast_nodes_Variable *value, std_map_Item__11 *next);
void std_map_Item__11_free_list(std_map_Item__11 *this);
void std_map_Map__11_free(std_map_Map__11 *this);
void std_map_Map__11_insert(std_map_Map__11 *this, char *key, compiler_ast_nodes_Variable *value);
void std_map_Map__11_resize(std_map_Map__11 *this);
u32 std_map_Map__11_hash(std_map_Map__11 *this, char *key);
std_map_Map__11 *std_map_Map__11_new(u32 capacity);
std_map_Item__11 *std_map_Map__11_get_item(std_map_Map__11 *this, char *key);
std_map_Item__12 *std_map_Item__12_new(char *key, std_span_Span value, std_map_Item__12 *next);
void std_map_Item__12_free_list(std_map_Item__12 *this);
void std_map_Map__12_free(std_map_Map__12 *this);
void std_map_Map__12_insert(std_map_Map__12 *this, char *key, std_span_Span value);
void std_map_Map__12_resize(std_map_Map__12 *this);
u32 std_map_Map__12_hash(std_map_Map__12 *this, char *key);
std_map_Map__12 *std_map_Map__12_new(u32 capacity);
std_map_Item__12 *std_map_Map__12_get_item(std_map_Map__12 *this, char *key);
std_map_Item__13 *std_map_Item__13_new(std_span_Span key, bool value, std_map_Item__13 *next);
void std_map_Item__13_free_list(std_map_Item__13 *this);
void std_map_Map__13_free(std_map_Map__13 *this);
void std_map_Map__13_insert(std_map_Map__13 *this, std_span_Span key, bool value);
std_map_Item__13 *std_map_Iterator__13_cur(std_map_Iterator__13 *this);
void std_map_Iterator__13_next(std_map_Iterator__13 *this);
bool std_map_Iterator__13_has_value(std_map_Iterator__13 *this);
std_map_Iterator__13 std_map_Iterator__13_make(std_map_Map__13 *map);
void std_map_Map__13_resize(std_map_Map__13 *this);
u32 std_map_Map__13_hash(std_map_Map__13 *this, std_span_Span key);
std_map_Map__13 *std_map_Map__13_new(u32 capacity);
std_map_Item__13 *std_map_Map__13_get_item(std_map_Map__13 *this, std_span_Span key);
std_map_Iterator__13 std_map_Map__13_iter(std_map_Map__13 *this);
void std_signal_set_signal_handler(i32 sig, void (*callback)(i32));
std_vector_Iterator__0 std_vector_Vector__0_iter(std_vector_Vector__0 *this);
compiler_types_Type *std_vector_Iterator__0_cur(std_vector_Iterator__0 *this);
void std_vector_Iterator__0_next(std_vector_Iterator__0 *this);
bool std_vector_Iterator__0_has_value(std_vector_Iterator__0 *this);
std_vector_Iterator__0 std_vector_Iterator__0_make(std_vector_Vector__0 *vec);
compiler_types_Type *std_vector_Vector__0_at(std_vector_Vector__0 *this, u32 i);
void std_vector_Vector__0_resize(std_vector_Vector__0 *this, u32 new_capacity);
std_vector_Vector__0 *std_vector_Vector__0_new(u32 capacity);
void std_vector_Vector__0_push(std_vector_Vector__0 *this, compiler_types_Type *value);
char *std_vector_Vector__1_pop(std_vector_Vector__1 *this);
char *std_vector_Vector__1_back(std_vector_Vector__1 *this, u32 i);
std_vector_Iterator__1 std_vector_Vector__1_iter(std_vector_Vector__1 *this);
char *std_vector_Iterator__1_cur(std_vector_Iterator__1 *this);
void std_vector_Iterator__1_next(std_vector_Iterator__1 *this);
bool std_vector_Iterator__1_has_value(std_vector_Iterator__1 *this);
std_vector_Iterator__1 std_vector_Iterator__1_make(std_vector_Vector__1 *vec);
char *std_vector_Vector__1_at(std_vector_Vector__1 *this, u32 i);
void std_vector_Vector__1_free(std_vector_Vector__1 *this);
void std_vector_Vector__1_resize(std_vector_Vector__1 *this, u32 new_capacity);
std_vector_Vector__1 *std_vector_Vector__1_new(u32 capacity);
void std_vector_Vector__1_push(std_vector_Vector__1 *this, char *value);
compiler_ast_scopes_Scope *std_vector_Vector__2_pop(std_vector_Vector__2 *this);
compiler_ast_scopes_Scope *std_vector_Vector__2_back(std_vector_Vector__2 *this, u32 i);
compiler_ast_scopes_Scope *std_vector_Vector__2_at(std_vector_Vector__2 *this, u32 i);
void std_vector_Vector__2_resize(std_vector_Vector__2 *this, u32 new_capacity);
std_vector_Vector__2 *std_vector_Vector__2_new(u32 capacity);
void std_vector_Vector__2_push(std_vector_Vector__2 *this, compiler_ast_scopes_Scope *value);
compiler_ast_program_Namespace *std_vector_Vector__3_pop(std_vector_Vector__3 *this);
compiler_ast_program_Namespace *std_vector_Vector__3_at(std_vector_Vector__3 *this, u32 i);
void std_vector_Vector__3_free(std_vector_Vector__3 *this);
bool std_vector_Vector__3_is_empty(std_vector_Vector__3 *this);
void std_vector_Vector__3_resize(std_vector_Vector__3 *this, u32 new_capacity);
std_vector_Vector__3 *std_vector_Vector__3_new(u32 capacity);
void std_vector_Vector__3_push(std_vector_Vector__3 *this, compiler_ast_program_Namespace *value);
void std_vector_Vector__4_zero_unused(std_vector_Vector__4 *this);
compiler_ast_nodes_Variable *std_vector_Vector__4_back(std_vector_Vector__4 *this, u32 i);
std_vector_Iterator__4 std_vector_Vector__4_iter(std_vector_Vector__4 *this);
compiler_ast_nodes_Variable *std_vector_Iterator__4_cur(std_vector_Iterator__4 *this);
void std_vector_Iterator__4_next(std_vector_Iterator__4 *this);
bool std_vector_Iterator__4_has_value(std_vector_Iterator__4 *this);
std_vector_Iterator__4 std_vector_Iterator__4_make(std_vector_Vector__4 *vec);
compiler_ast_nodes_Variable *std_vector_Vector__4_at(std_vector_Vector__4 *this, u32 i);
void std_vector_Vector__4_free(std_vector_Vector__4 *this);
bool std_vector_Vector__4_is_empty(std_vector_Vector__4 *this);
void std_vector_Vector__4_resize(std_vector_Vector__4 *this, u32 new_capacity);
std_vector_Vector__4 *std_vector_Vector__4_new(u32 capacity);
void std_vector_Vector__4_push(std_vector_Vector__4 *this, compiler_ast_nodes_Variable *value);
void std_vector_Vector__4_clear(std_vector_Vector__4 *this);
std_vector_Iterator__5 std_vector_Vector__5_iter(std_vector_Vector__5 *this);
compiler_ast_scopes_TemplateInstance *std_vector_Iterator__5_cur(std_vector_Iterator__5 *this);
void std_vector_Iterator__5_next(std_vector_Iterator__5 *this);
bool std_vector_Iterator__5_has_value(std_vector_Iterator__5 *this);
std_vector_Iterator__5 std_vector_Iterator__5_make(std_vector_Vector__5 *vec);
void std_vector_Vector__5_resize(std_vector_Vector__5 *this, u32 new_capacity);
std_vector_Vector__5 *std_vector_Vector__5_new(u32 capacity);
void std_vector_Vector__5_push(std_vector_Vector__5 *this, compiler_ast_scopes_TemplateInstance *value);
std_vector_Iterator__6 std_vector_Vector__6_iter(std_vector_Vector__6 *this);
compiler_ast_nodes_MatchCond *std_vector_Iterator__6_cur(std_vector_Iterator__6 *this);
void std_vector_Iterator__6_next(std_vector_Iterator__6 *this);
bool std_vector_Iterator__6_has_value(std_vector_Iterator__6 *this);
std_vector_Iterator__6 std_vector_Iterator__6_make(std_vector_Vector__6 *vec);
compiler_ast_nodes_MatchCond *std_vector_Vector__6_at(std_vector_Vector__6 *this, u32 i);
void std_vector_Vector__6_resize(std_vector_Vector__6 *this, u32 new_capacity);
std_vector_Vector__6 *std_vector_Vector__6_new(u32 capacity);
void std_vector_Vector__6_push(std_vector_Vector__6 *this, compiler_ast_nodes_MatchCond *value);
std_vector_Iterator__7 std_vector_Vector__7_iter(std_vector_Vector__7 *this);
compiler_ast_nodes_ImportPart *std_vector_Iterator__7_cur(std_vector_Iterator__7 *this);
void std_vector_Iterator__7_next(std_vector_Iterator__7 *this);
bool std_vector_Iterator__7_has_value(std_vector_Iterator__7 *this);
std_vector_Iterator__7 std_vector_Iterator__7_make(std_vector_Vector__7 *vec);
compiler_ast_nodes_ImportPart *std_vector_Vector__7_at(std_vector_Vector__7 *this, u32 i);
void std_vector_Vector__7_resize(std_vector_Vector__7 *this, u32 new_capacity);
std_vector_Vector__7 *std_vector_Vector__7_new(u32 capacity);
void std_vector_Vector__7_push(std_vector_Vector__7 *this, compiler_ast_nodes_ImportPart *value);
compiler_ast_nodes_Function *std_vector_Vector__8_pop(std_vector_Vector__8 *this);
std_vector_Iterator__8 std_vector_Vector__8_iter(std_vector_Vector__8 *this);
compiler_ast_nodes_Function *std_vector_Iterator__8_cur(std_vector_Iterator__8 *this);
void std_vector_Iterator__8_next(std_vector_Iterator__8 *this);
bool std_vector_Iterator__8_has_value(std_vector_Iterator__8 *this);
std_vector_Iterator__8 std_vector_Iterator__8_make(std_vector_Vector__8 *vec);
bool std_vector_Vector__8_is_empty(std_vector_Vector__8 *this);
void std_vector_Vector__8_resize(std_vector_Vector__8 *this, u32 new_capacity);
std_vector_Vector__8 *std_vector_Vector__8_new(u32 capacity);
void std_vector_Vector__8_push(std_vector_Vector__8 *this, compiler_ast_nodes_Function *value);
void std_vector_Vector__9_push_front(std_vector_Vector__9 *this, compiler_ast_nodes_Argument *value);
std_vector_Iterator__9 std_vector_Vector__9_iter(std_vector_Vector__9 *this);
compiler_ast_nodes_Argument *std_vector_Iterator__9_cur(std_vector_Iterator__9 *this);
void std_vector_Iterator__9_next(std_vector_Iterator__9 *this);
bool std_vector_Iterator__9_has_value(std_vector_Iterator__9 *this);
std_vector_Iterator__9 std_vector_Iterator__9_make(std_vector_Vector__9 *vec);
compiler_ast_nodes_Argument *std_vector_Vector__9_at(std_vector_Vector__9 *this, u32 i);
void std_vector_Vector__9_free(std_vector_Vector__9 *this);
void std_vector_Vector__9_resize(std_vector_Vector__9 *this, u32 new_capacity);
std_vector_Vector__9 *std_vector_Vector__9_new(u32 capacity);
void std_vector_Vector__9_push(std_vector_Vector__9 *this, compiler_ast_nodes_Argument *value);
std_vector_Iterator__10 std_vector_Vector__10_iter(std_vector_Vector__10 *this);
compiler_ast_scopes_Symbol *std_vector_Iterator__10_cur(std_vector_Iterator__10 *this);
void std_vector_Iterator__10_next(std_vector_Iterator__10 *this);
bool std_vector_Iterator__10_has_value(std_vector_Iterator__10 *this);
std_vector_Iterator__10 std_vector_Iterator__10_make(std_vector_Vector__10 *vec);
compiler_ast_scopes_Symbol *std_vector_Vector__10_at(std_vector_Vector__10 *this, u32 i);
void std_vector_Vector__10_free(std_vector_Vector__10 *this);
bool std_vector_Vector__10_is_empty(std_vector_Vector__10 *this);
void std_vector_Vector__10_resize(std_vector_Vector__10 *this, u32 new_capacity);
std_vector_Vector__10 *std_vector_Vector__10_new(u32 capacity);
void std_vector_Vector__10_push(std_vector_Vector__10 *this, compiler_ast_scopes_Symbol *value);
compiler_tokens_Token *std_vector_Vector__11_at(std_vector_Vector__11 *this, u32 i);
void std_vector_Vector__11_free(std_vector_Vector__11 *this);
compiler_tokens_Token *std_vector_Vector__11_unchecked_at(std_vector_Vector__11 *this, u32 i);
void std_vector_Vector__11_resize(std_vector_Vector__11 *this, u32 new_capacity);
std_vector_Vector__11 *std_vector_Vector__11_new(u32 capacity);
void std_vector_Vector__11_push(std_vector_Vector__11 *this, compiler_tokens_Token *value);
void std_vector_Vector__12_zero_unused(std_vector_Vector__12 *this);
std_vector_Iterator__12 std_vector_Vector__12_iter(std_vector_Vector__12 *this);
compiler_attributes_Attribute *std_vector_Iterator__12_cur(std_vector_Iterator__12 *this);
void std_vector_Iterator__12_next(std_vector_Iterator__12 *this);
bool std_vector_Iterator__12_has_value(std_vector_Iterator__12 *this);
std_vector_Iterator__12 std_vector_Iterator__12_make(std_vector_Vector__12 *vec);
void std_vector_Vector__12_free(std_vector_Vector__12 *this);
void std_vector_Vector__12_resize(std_vector_Vector__12 *this, u32 new_capacity);
std_vector_Vector__12 *std_vector_Vector__12_new(u32 capacity);
void std_vector_Vector__12_push(std_vector_Vector__12 *this, compiler_attributes_Attribute *value);
void std_vector_Vector__12_clear(std_vector_Vector__12 *this);
std_vector_Iterator__13 std_vector_Vector__13_iter(std_vector_Vector__13 *this);
compiler_ast_nodes_Structure *std_vector_Iterator__13_cur(std_vector_Iterator__13 *this);
void std_vector_Iterator__13_next(std_vector_Iterator__13 *this);
bool std_vector_Iterator__13_has_value(std_vector_Iterator__13 *this);
std_vector_Iterator__13 std_vector_Iterator__13_make(std_vector_Vector__13 *vec);
bool std_vector_Vector__13_is_empty(std_vector_Vector__13 *this);
void std_vector_Vector__13_resize(std_vector_Vector__13 *this, u32 new_capacity);
std_vector_Vector__13 *std_vector_Vector__13_new(u32 capacity);
void std_vector_Vector__13_push(std_vector_Vector__13 *this, compiler_ast_nodes_Structure *value);
std_vector_Iterator__14 std_vector_Vector__14_iter(std_vector_Vector__14 *this);
compiler_ast_nodes_Enum *std_vector_Iterator__14_cur(std_vector_Iterator__14 *this);
void std_vector_Iterator__14_next(std_vector_Iterator__14 *this);
bool std_vector_Iterator__14_has_value(std_vector_Iterator__14 *this);
std_vector_Iterator__14 std_vector_Iterator__14_make(std_vector_Vector__14 *vec);
bool std_vector_Vector__14_is_empty(std_vector_Vector__14 *this);
void std_vector_Vector__14_resize(std_vector_Vector__14 *this, u32 new_capacity);
std_vector_Vector__14 *std_vector_Vector__14_new(u32 capacity);
void std_vector_Vector__14_push(std_vector_Vector__14 *this, compiler_ast_nodes_Enum *value);
compiler_ast_nodes_AST *std_vector_Vector__15_pop(std_vector_Vector__15 *this);
std_vector_Iterator__15 std_vector_Vector__15_iter(std_vector_Vector__15 *this);
compiler_ast_nodes_AST *std_vector_Iterator__15_cur(std_vector_Iterator__15 *this);
void std_vector_Iterator__15_next(std_vector_Iterator__15 *this);
bool std_vector_Iterator__15_has_value(std_vector_Iterator__15 *this);
std_vector_Iterator__15 std_vector_Iterator__15_make(std_vector_Vector__15 *vec);
compiler_ast_nodes_AST *std_vector_Vector__15_at(std_vector_Vector__15 *this, u32 i);
void std_vector_Vector__15_free(std_vector_Vector__15 *this);
bool std_vector_Vector__15_is_empty(std_vector_Vector__15 *this);
void std_vector_Vector__15_resize(std_vector_Vector__15 *this, u32 new_capacity);
std_vector_Vector__15 *std_vector_Vector__15_new(u32 capacity);
void std_vector_Vector__15_push(std_vector_Vector__15 *this, compiler_ast_nodes_AST *value);
std_vector_Iterator__16 std_vector_Vector__16_iter(std_vector_Vector__16 *this);
compiler_errors_Error *std_vector_Iterator__16_cur(std_vector_Iterator__16 *this);
void std_vector_Iterator__16_next(std_vector_Iterator__16 *this);
bool std_vector_Iterator__16_has_value(std_vector_Iterator__16 *this);
std_vector_Iterator__16 std_vector_Iterator__16_make(std_vector_Vector__16 *vec);
compiler_errors_Error *std_vector_Vector__16_at(std_vector_Vector__16 *this, u32 i);
bool std_vector_Vector__16_is_empty(std_vector_Vector__16 *this);
void std_vector_Vector__16_resize(std_vector_Vector__16 *this, u32 new_capacity);
std_vector_Vector__16 *std_vector_Vector__16_new(u32 capacity);
void std_vector_Vector__16_push(std_vector_Vector__16 *this, compiler_errors_Error *value);
jmp_buf *std_vector_Vector__17_back_ptr(std_vector_Vector__17 *this, u32 i);
void std_vector_Vector__17_resize(std_vector_Vector__17 *this, u32 new_capacity);
std_vector_Vector__17 *std_vector_Vector__17_new(u32 capacity);
std_vector_Iterator__18 std_vector_Vector__18_iter(std_vector_Vector__18 *this);
compiler_ast_scopes_Reference std_vector_Iterator__18_cur(std_vector_Iterator__18 *this);
void std_vector_Iterator__18_next(std_vector_Iterator__18 *this);
bool std_vector_Iterator__18_has_value(std_vector_Iterator__18 *this);
std_vector_Iterator__18 std_vector_Iterator__18_make(std_vector_Vector__18 *vec);
void std_vector_Vector__18_resize(std_vector_Vector__18 *this, u32 new_capacity);
std_vector_Vector__18 *std_vector_Vector__18_new(u32 capacity);
void std_vector_Vector__18_push(std_vector_Vector__18 *this, compiler_ast_scopes_Reference value);
std_vector_Iterator__19 std_vector_Vector__19_iter(std_vector_Vector__19 *this);
compiler_ast_nodes_MatchCondArg *std_vector_Iterator__19_cur(std_vector_Iterator__19 *this);
void std_vector_Iterator__19_next(std_vector_Iterator__19 *this);
bool std_vector_Iterator__19_has_value(std_vector_Iterator__19 *this);
std_vector_Iterator__19 std_vector_Iterator__19_make(std_vector_Vector__19 *vec);
compiler_ast_nodes_MatchCondArg *std_vector_Vector__19_at(std_vector_Vector__19 *this, u32 i);
void std_vector_Vector__19_resize(std_vector_Vector__19 *this, u32 new_capacity);
std_vector_Vector__19 *std_vector_Vector__19_new(u32 capacity);
void std_vector_Vector__19_push(std_vector_Vector__19 *this, compiler_ast_nodes_MatchCondArg *value);
std_vector_Iterator__20 std_vector_Vector__20_iter(std_vector_Vector__20 *this);
compiler_ast_nodes_EnumVariant *std_vector_Iterator__20_cur(std_vector_Iterator__20 *this);
void std_vector_Iterator__20_next(std_vector_Iterator__20 *this);
bool std_vector_Iterator__20_has_value(std_vector_Iterator__20 *this);
std_vector_Iterator__20 std_vector_Iterator__20_make(std_vector_Vector__20 *vec);
void std_vector_Vector__20_resize(std_vector_Vector__20 *this, u32 new_capacity);
std_vector_Vector__20 *std_vector_Vector__20_new(u32 capacity);
void std_vector_Vector__20_push(std_vector_Vector__20 *this, compiler_ast_nodes_EnumVariant *value);
std_vector_Iterator__21 std_vector_Vector__21_iter(std_vector_Vector__21 *this);
compiler_ast_operators_Operator std_vector_Iterator__21_cur(std_vector_Iterator__21 *this);
void std_vector_Iterator__21_next(std_vector_Iterator__21 *this);
bool std_vector_Iterator__21_has_value(std_vector_Iterator__21 *this);
std_vector_Iterator__21 std_vector_Iterator__21_make(std_vector_Vector__21 *vec);
void std_vector_Vector__21_resize(std_vector_Vector__21 *this, u32 new_capacity);
std_vector_Vector__21 *std_vector_Vector__21_new(u32 capacity);
void std_vector_Vector__21_push(std_vector_Vector__21 *this, compiler_ast_operators_Operator value);
std_vector_Iterator__22 std_vector_Vector__22_iter(std_vector_Vector__22 *this);
std_vector_Vector__7 *std_vector_Iterator__22_cur(std_vector_Iterator__22 *this);
void std_vector_Iterator__22_next(std_vector_Iterator__22 *this);
bool std_vector_Iterator__22_has_value(std_vector_Iterator__22 *this);
std_vector_Iterator__22 std_vector_Iterator__22_make(std_vector_Vector__22 *vec);
std_vector_Vector__7 *std_vector_Vector__22_at(std_vector_Vector__22 *this, u32 i);
void std_vector_Vector__22_resize(std_vector_Vector__22 *this, u32 new_capacity);
std_vector_Vector__22 *std_vector_Vector__22_new(u32 capacity);
void std_vector_Vector__22_push(std_vector_Vector__22 *this, std_vector_Vector__7 *value);
std_vector_Iterator__23 std_vector_Vector__23_iter(std_vector_Vector__23 *this);
compiler_ast_nodes_IfBranch std_vector_Iterator__23_cur(std_vector_Iterator__23 *this);
void std_vector_Iterator__23_next(std_vector_Iterator__23 *this);
bool std_vector_Iterator__23_has_value(std_vector_Iterator__23 *this);
std_vector_Iterator__23 std_vector_Iterator__23_make(std_vector_Vector__23 *vec);
compiler_ast_nodes_IfBranch std_vector_Vector__23_at(std_vector_Vector__23 *this, u32 i);
void std_vector_Vector__23_resize(std_vector_Vector__23 *this, u32 new_capacity);
std_vector_Vector__23 *std_vector_Vector__23_new(u32 capacity);
void std_vector_Vector__23_push(std_vector_Vector__23 *this, compiler_ast_nodes_IfBranch value);
std_vector_Iterator__24 std_vector_Vector__24_iter(std_vector_Vector__24 *this);
compiler_ast_nodes_MatchCase std_vector_Iterator__24_cur(std_vector_Iterator__24 *this);
void std_vector_Iterator__24_next(std_vector_Iterator__24 *this);
bool std_vector_Iterator__24_has_value(std_vector_Iterator__24 *this);
std_vector_Iterator__24 std_vector_Iterator__24_make(std_vector_Vector__24 *vec);
compiler_ast_nodes_MatchCase std_vector_Vector__24_at(std_vector_Vector__24 *this, u32 i);
void std_vector_Vector__24_resize(std_vector_Vector__24 *this, u32 new_capacity);
std_vector_Vector__24 *std_vector_Vector__24_new(u32 capacity);
void std_vector_Vector__24_push(std_vector_Vector__24 *this, compiler_ast_nodes_MatchCase value);
std_vector_Iterator__25 std_vector_Vector__25_iter(std_vector_Vector__25 *this);
compiler_ast_nodes_MapLiteralPair std_vector_Iterator__25_cur(std_vector_Iterator__25 *this);
void std_vector_Iterator__25_next(std_vector_Iterator__25 *this);
bool std_vector_Iterator__25_has_value(std_vector_Iterator__25 *this);
std_vector_Iterator__25 std_vector_Iterator__25_make(std_vector_Vector__25 *vec);
void std_vector_Vector__25_resize(std_vector_Vector__25 *this, u32 new_capacity);
std_vector_Vector__25 *std_vector_Vector__25_new(u32 capacity);
void std_vector_Vector__25_push(std_vector_Vector__25 *this, compiler_ast_nodes_MapLiteralPair value);
void std_vector_Vector__26_zero_unused(std_vector_Vector__26 *this);
std_compact_map_Item__0 std_vector_Vector__26_pop(std_vector_Vector__26 *this);
std_compact_map_Item__0 std_vector_Vector__26_at(std_vector_Vector__26 *this, u32 i);
void std_vector_Vector__26_resize(std_vector_Vector__26 *this, u32 new_capacity);
std_vector_Vector__26 *std_vector_Vector__26_new(u32 capacity);
void std_vector_Vector__26_push(std_vector_Vector__26 *this, std_compact_map_Item__0 value);
std_vector_Iterator__27 std_vector_Vector__27_iter(std_vector_Vector__27 *this);
std_span_Span std_vector_Iterator__27_cur(std_vector_Iterator__27 *this);
void std_vector_Iterator__27_next(std_vector_Iterator__27 *this);
bool std_vector_Iterator__27_has_value(std_vector_Iterator__27 *this);
std_vector_Iterator__27 std_vector_Iterator__27_make(std_vector_Vector__27 *vec);
void std_vector_Vector__27_free(std_vector_Vector__27 *this);
void std_vector_Vector__27_resize(std_vector_Vector__27 *this, u32 new_capacity);
std_vector_Vector__27 *std_vector_Vector__27_new(u32 capacity);
void std_vector_Vector__27_push(std_vector_Vector__27 *this, std_span_Span value);
std_vector_Iterator__28 std_vector_Vector__28_iter(std_vector_Vector__28 *this);
std_value_Value *std_vector_Iterator__28_cur(std_vector_Iterator__28 *this);
void std_vector_Iterator__28_next(std_vector_Iterator__28 *this);
bool std_vector_Iterator__28_has_value(std_vector_Iterator__28 *this);
std_vector_Iterator__28 std_vector_Iterator__28_make(std_vector_Vector__28 *vec);
std_value_Value *std_vector_Vector__28_at(std_vector_Vector__28 *this, u32 i);
void std_vector_Vector__28_resize(std_vector_Vector__28 *this, u32 new_capacity);
std_vector_Vector__28 *std_vector_Vector__28_new(u32 capacity);
void std_vector_Vector__28_push(std_vector_Vector__28 *this, std_value_Value *value);
std_vector_Iterator__29 std_vector_Vector__29_iter(std_vector_Vector__29 *this);
std_compact_map_Item__1 std_vector_Iterator__29_cur(std_vector_Iterator__29 *this);
void std_vector_Iterator__29_next(std_vector_Iterator__29 *this);
bool std_vector_Iterator__29_has_value(std_vector_Iterator__29 *this);
std_vector_Iterator__29 std_vector_Iterator__29_make(std_vector_Vector__29 *vec);
std_compact_map_Item__1 std_vector_Vector__29_at(std_vector_Vector__29 *this, u32 i);
void std_vector_Vector__29_resize(std_vector_Vector__29 *this, u32 new_capacity);
std_vector_Vector__29 *std_vector_Vector__29_new(u32 capacity);
void std_vector_Vector__29_push(std_vector_Vector__29 *this, std_compact_map_Item__1 value);
std_compact_map_Item__2 std_vector_Vector__30_at(std_vector_Vector__30 *this, u32 i);
void std_vector_Vector__30_resize(std_vector_Vector__30 *this, u32 new_capacity);
std_vector_Vector__30 *std_vector_Vector__30_new(u32 capacity);
void std_vector_Vector__30_push(std_vector_Vector__30 *this, std_compact_map_Item__2 value);
u32 std_vector_Vector__31_at(std_vector_Vector__31 *this, u32 i);
void std_vector_Vector__31_free(std_vector_Vector__31 *this);
void std_vector_Vector__31_resize(std_vector_Vector__31 *this, u32 new_capacity);
std_vector_Vector__31 *std_vector_Vector__31_new(u32 capacity);
void std_vector_Vector__31_push(std_vector_Vector__31 *this, u32 value);
std_json_Parser std_json_Parser_make(std_vector_Vector__11 *tokens);
compiler_tokens_Token *std_json_Parser_token(std_json_Parser *this);
compiler_tokens_Token *std_json_Parser_consume(std_json_Parser *this, compiler_tokens_TokenType type);
std_value_Value *std_json_Parser_parse_object(std_json_Parser *this);
std_value_Value *std_json_Parser_parse_array(std_json_Parser *this);
std_value_Value *std_json_Parser_parse_value(std_json_Parser *this);
std_value_Value *std_json_Parser_parse(std_json_Parser *this);
std_value_Value *std_json_parse(char *source, char *filename);
std_value_Value *std_json_parse_sv(std_sv_SV source, char *filename);
void std_json_serialize_into(std_value_Value *val, std_buffer_Buffer *sb);
std_buffer_Buffer std_json_serialize(std_value_Value *val);
void std_json_write_to_file(std_value_Value *val, char *filename);
void compiler_lsp_cli_handle_validate__Closure_0(void *__C, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1(void *__C, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_create_match_for_error_prop__Closure_2(void *__C, compiler_ast_nodes_AST *node);
void compiler_passes_visitor__Closure_3(void *__C, compiler_ast_nodes_AST *node);
void compiler_passes_visitor__Closure_4(void *__C, compiler_types_Type *type);
void compiler_lsp_server_run_lsp_backend_raw__Closure_5(void *__C);
void compiler_lsp_server_run_lsp_backend_raw__Closure_6(void *__C);
jmp_buf compiler_lsp_cli_global_err_ctx = {0};
bool compiler_lsp_cli_utils_verbose = false;
char *exec_path = "./out";
char *c_path = NULL;
char *filename = NULL;
bool compile_c = true;
bool silent = false;
bool debug = false;
u32 error_level = 2;
char *docs_path = NULL;
bool include_stdlib = true;
std_vector_Vector__1 *extra_c_flags;
bool run_after_compile = false;
bool compile_asan = false;
bool backtrace = false;
jmp_buf *global_err_ctx;
void *std_mem_state_allocator = NULL;
void *(*std_mem_state_alloc_fn)(void *, u32) = std_mem_impl_my_calloc;
void *(*std_mem_state_realloc_fn)(void *, void *, u32, u32) = std_mem_impl_my_realloc;
void (*std_mem_state_free_fn)(void *, void *) = std_mem_impl_my_free;
std_gc_impl_Header *std_gc_impl_alloc_list = NULL;
void *std_gc_impl_stack_bottom = NULL;
u32 std_gc_impl_total_allocations = 0;
u32 std_gc_impl_total_alloc_bytes = 0;
u32 std_gc_impl_live_allocations = 0;
u32 std_gc_impl_live_alloc_bytes = 0;
u32 std_gc_impl_freed_allocations = 0;
u32 std_gc_impl_freed_alloc_bytes = 0;
std_logging_LogLevel std_logging_log_level = std_logging_LogLevel_Warn;
char *std_logging_log_time_format = "%H:%M:%S";
/* function implementations */
std_value_Value *compiler_docgen_DocGenerator_gen_enum(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Enum *enom) {
  std_value_Value *enum_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(enum_doc, "id", std_format("%x", enom->type));
  std_value_Value_insert_str(enum_doc, "name", enom->sym->name);
  if (((bool)enom->sym->comment)) {
    std_value_Value_insert_str(enum_doc, "description", enom->sym->comment);
  }
  std_value_Value_insert_str(enum_doc, "kind", "enum");
  if (enom->sym->is_extern) {
    std_value_Value_insert_str(enum_doc, "extern", compiler_ast_scopes_Symbol_out_name(enom->sym));
  } else {
    compiler_docgen_DocGenerator_gen_location(this, enum_doc, enom->sym->span);
  }
  std_value_Value *shared_fields_doc = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__4 _i272 = std_vector_Vector__4_iter(enom->shared_fields); std_vector_Iterator__4_has_value(&_i272); std_vector_Iterator__4_next(&_i272)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i272);
    {
      std_value_Value *field_doc = std_value_Value_new(std_value_ValueType_Dictionary);
      std_value_Value_insert_str(field_doc, "name", field->sym->name);
      std_value_Value_insert(field_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, field->type));
      if (((bool)field->sym->comment)) {
        std_value_Value_insert_str(field_doc, "description", field->sym->comment);
      }
      std_value_Value_push(shared_fields_doc, field_doc);
    }
  }
  std_value_Value_insert(enum_doc, "shared_fields", shared_fields_doc);
  std_value_Value *variants_doc = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__20 _i273 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i273); std_vector_Iterator__20_next(&_i273)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i273);
    {
      std_value_Value *variant_doc = std_value_Value_new(std_value_ValueType_Dictionary);
      std_value_Value_insert_str(variant_doc, "name", variant->sym->name);
      if (((bool)variant->sym->comment)) {
        std_value_Value_insert_str(variant_doc, "description", variant->sym->comment);
      }
      if (variant->sym->is_extern) {
        std_value_Value_insert_str(variant_doc, "extern", compiler_ast_scopes_Symbol_out_name(variant->sym));
      }
      std_value_Value *fields_doc = std_value_Value_new(std_value_ValueType_List);
      for (std_vector_Iterator__4 _i274 = std_vector_Vector__4_iter(variant->specific_fields); std_vector_Iterator__4_has_value(&_i274); std_vector_Iterator__4_next(&_i274)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i274);
        {
          std_value_Value_push(fields_doc, compiler_docgen_DocGenerator_gen_typename(this, field->type));
        }
      }
      std_value_Value_insert(variant_doc, "fields", fields_doc);
      std_value_Value_push(variants_doc, variant_doc);
    }
  }
  std_value_Value_insert(enum_doc, "variants", variants_doc);
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, enom->type);
  std_value_Value_insert(enum_doc, "methods", methods_doc);
  return enum_doc;
}

void compiler_docgen_DocGenerator_gen_location(compiler_docgen_DocGenerator *this, std_value_Value *obj, std_span_Span span) {
  std_span_Location start = span.start;
  if (std_span_Location_is_valid(&start)) {
    char *filename = start.filename;
    if (str_starts_with(filename, this->ocen_root.data)) {
      filename=&filename[this->ocen_root.len];
      if (filename[0]=='/') {
        filename=&filename[1];
      }
    }
    std_value_Value_insert_str(obj, "source", std_format("%s#L%u", filename, start.line));
  }
}

char *compiler_docgen_DocGenerator_gen_templated_type(compiler_docgen_DocGenerator *this, compiler_types_Type *base, std_vector_Vector__0 *args) {
  char *base_name = compiler_docgen_DocGenerator_gen_typename_str(this, base);
  std_buffer_Buffer buf = std_buffer_Buffer_make(16);
  std_buffer_Buffer_write_str(&buf, base_name);
  std_buffer_Buffer_write_str(&buf, "<");
  bool first = true;
  for (std_vector_Iterator__0 _i275 = std_vector_Vector__0_iter(args); std_vector_Iterator__0_has_value(&_i275); std_vector_Iterator__0_next(&_i275)) {
    compiler_types_Type *arg_type = std_vector_Iterator__0_cur(&_i275);
    {
      if (!(first)) {
        std_buffer_Buffer_write_str(&buf, ", ");
      }
      first=false;
      char *param_name = compiler_docgen_DocGenerator_gen_typename_str(this, arg_type);
      std_buffer_Buffer_write_str(&buf, param_name);
    }
  }
  std_buffer_Buffer_write_str(&buf, ">");
  return std_buffer_Buffer_str(buf);
}

char *compiler_docgen_DocGenerator_gen_typename_str(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {
  if(!(((bool)type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:108:12: Assertion failed: `type?`", "gen_typename_str called with null type"); }
switch ((type->base)) {
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    case compiler_types_BaseType_Alias:
    case compiler_types_BaseType_Enum:
    m_337_0:
      {
        return std_format("{{%x}}", type);
      } break;
    case compiler_types_BaseType_Structure:
    m_337_1:
      {
        if (!(((bool)type->template_instance))) {
          return std_format("{{%x}}", type);
        } else {
          compiler_ast_nodes_Structure *struc = type->u.struc;
          compiler_ast_scopes_TemplateInstance *instance = type->template_instance;
          compiler_ast_scopes_Symbol *parent = instance->parent;
          if(!(parent->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:123:24: Assertion failed: `parent.type == Structure`", "Template instance parent is not a structure"); }
          compiler_ast_nodes_Structure *parent_struc = parent->u.struc;
          return compiler_docgen_DocGenerator_gen_templated_type(this, parent_struc->type, instance->args);
        }
      } break;
    case compiler_types_BaseType_UnresolvedTemplate:
    m_337_2:
      {
        compiler_types_UnresolvedTemplate uspec = type->u.unresolved_spec;
        return compiler_docgen_DocGenerator_gen_templated_type(this, uspec.base, uspec.args);
      } break;
    case compiler_types_BaseType_Pointer:
    m_337_3:
      {
        char *sub = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.ptr);
        str_replace_with(&sub, std_format("&%s", sub));
        return sub;
      } break;
    case compiler_types_BaseType_Array:
    m_337_4:
      {
        char *sub = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.arr.elem_type);
        str_replace_with(&sub, std_format("[%s]", sub));
        return sub;
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_337_5:
      {
        std_buffer_Buffer buf = std_buffer_Buffer_make(16);
        std_buffer_Buffer_write_str(&buf, "fn(");
        bool first = true;
        for (std_vector_Iterator__4 _i276 = std_vector_Vector__4_iter(type->u.func.params); std_vector_Iterator__4_has_value(&_i276); std_vector_Iterator__4_next(&_i276)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i276);
          {
            if (!(first)) {
              std_buffer_Buffer_write_str(&buf, ", ");
            }
            first=false;
            char *param_name = compiler_docgen_DocGenerator_gen_typename_str(this, param->type);
            std_buffer_Buffer_write_str_f(&buf, param_name);
          }
        }
        std_buffer_Buffer_write_str(&buf, "): ");
        char *return_name = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.func.return_type);
        std_buffer_Buffer_write_str_f(&buf, return_name);
        return std_buffer_Buffer_str(buf);
      } break;
    case compiler_types_BaseType_Unresolved:
    m_337_6:
      {
        compiler_ast_nodes_AST *node = type->u.unresolved;
switch ((node->type)) {
          case compiler_ast_nodes_ASTType_Identifier:
          m_338_0:
            {
              return strdup(node->u.ident.name);
            } break;
          default:
            {
              compiler_ast_program_Program_error(this->program, compiler_errors_Error_new(node->span, std_format("Unhandled node in gen_typename_str: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
              return "<unknown>";
            } break;
        }      } break;
    default:
      {
        compiler_ast_program_Program_error(this->program, compiler_errors_Error_new(type->span, std_format("Unhandled type in gen_typename_str: %s", compiler_types_BaseType_dbg(type->base))));
        return "<unknown>";
      } break;
  }}

std_value_Value *compiler_docgen_DocGenerator_gen_typename(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {
  if(!(((bool)type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:183:12: Assertion failed: `type?`", "gen_typename called with null type"); }
  return std_value_Value_new_str(compiler_docgen_DocGenerator_gen_typename_str(this, type));
}

std_value_Value *compiler_docgen_DocGenerator_gen_methods(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {
  if(!(compiler_types_Type_can_have_methods(type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:188:12: Assertion failed: `type.can_have_methods()`", "gen_methods called with type that can't have methods"); }
  std_value_Value *methods_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  for (std_map_Iterator__9 _i277 = std_map_Map__9_iter(type->methods); std_map_Iterator__9_has_value(&_i277); std_map_Iterator__9_next(&_i277)) {
    std_map_Item__9 *it = std_map_Iterator__9_cur(&_i277);
    {
      compiler_ast_nodes_Function *method = it->value;
      std_value_Value_insert(methods_doc, method->sym->name, compiler_docgen_DocGenerator_gen_function(this, method));
    }
  }
  return methods_doc;
}

std_value_Value *compiler_docgen_DocGenerator_gen_function(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Function *func) {
  std_value_Value *func_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(func_doc, "id", std_format("%x", func));
  std_value_Value_insert_str(func_doc, "name", std_format("%s", func->sym->name));
  if (((bool)func->sym->comment)) {
    std_value_Value_insert_str(func_doc, "description", func->sym->comment);
  }
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    std_value_Value_insert_str(func_doc, "kind", "method");
    std_value_Value_insert(func_doc, "parent", compiler_docgen_DocGenerator_gen_typename(this, func->parent_type));
  } else {
    std_value_Value_insert_str(func_doc, "kind", "function");
  }
  if (func->sym->is_extern) {
    std_value_Value_insert_str(func_doc, "extern", compiler_ast_scopes_Symbol_out_name(func->sym));
  } else {
    compiler_docgen_DocGenerator_gen_location(this, func_doc, func->span);
  }
  std_value_Value *return_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  compiler_types_Type *ret_type = func->return_type;
  std_value_Value_insert(return_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, ret_type));
  std_value_Value *params_doc = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__4 _i278 = std_vector_Vector__4_iter(func->params); std_vector_Iterator__4_has_value(&_i278); std_vector_Iterator__4_next(&_i278)) {
    compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i278);
    {
      std_value_Value *param_doc = std_value_Value_new(std_value_ValueType_Dictionary);
      std_value_Value_insert_str(param_doc, "name", std_format("%s", param->sym->name));
      if (((bool)param->sym->comment)) {
        std_value_Value_insert_str(param_doc, "description", param->sym->comment);
      }
      std_value_Value_insert(param_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, param->type));
      compiler_ast_nodes_AST *default_value = param->default_value;
      if (((bool)default_value)) {
        std_value_Value *value_str = std_value_Value_new_str(compiler_ast_program_Program_get_source_text(this->program, default_value->span));
        std_value_Value_insert(param_doc, "default_value", value_str);
      }
      std_value_Value_push(params_doc, param_doc);
    }
  }
  std_value_Value_insert(func_doc, "params", params_doc);
  std_value_Value_insert(func_doc, "return", return_doc);
  return func_doc;
}

std_value_Value *compiler_docgen_DocGenerator_gen_struct(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Structure *struc) {
  std_value_Value *struc_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(struc_doc, "id", std_format("%x", struc->type));
  std_value_Value_insert_str(struc_doc, "name", std_format("%s", struc->sym->name));
  if (((bool)struc->sym->comment)) {
    std_value_Value_insert_str(struc_doc, "description", struc->sym->comment);
  }
  if (struc->is_union) {
    std_value_Value_insert_str(struc_doc, "kind", "union");
  } else {
    std_value_Value_insert_str(struc_doc, "kind", "struct");
  }
  std_value_Value_insert(struc_doc, "is_templated", std_value_Value_new_bool(compiler_ast_scopes_Symbol_is_templated(struc->sym)));
  if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {
    std_value_Value *params_doc = std_value_Value_new(std_value_ValueType_List);
    for (std_vector_Iterator__10 _i279 = std_vector_Vector__10_iter(struc->sym->template->params); std_vector_Iterator__10_has_value(&_i279); std_vector_Iterator__10_next(&_i279)) {
      compiler_ast_scopes_Symbol *sym = std_vector_Iterator__10_cur(&_i279);
      {
        std_value_Value_push(params_doc, std_value_Value_new_str(sym->name));
      }
    }
    std_value_Value_insert(struc_doc, "template_params", params_doc);
  }
  if (struc->sym->is_extern) {
    std_value_Value_insert_str(struc_doc, "extern", compiler_ast_scopes_Symbol_out_name(struc->sym));
  } else {
    compiler_docgen_DocGenerator_gen_location(this, struc_doc, struc->span);
  }
  std_value_Value *fields_doc = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__4 _i280 = std_vector_Vector__4_iter(struc->fields); std_vector_Iterator__4_has_value(&_i280); std_vector_Iterator__4_next(&_i280)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i280);
    {
      std_value_Value *field_doc = std_value_Value_new(std_value_ValueType_Dictionary);
      std_value_Value_insert_str(field_doc, "name", field->sym->name);
      std_value_Value_insert(field_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, field->type));
      if (((bool)field->sym->comment)) {
        std_value_Value_insert_str(field_doc, "description", field->sym->comment);
      }
      if (field->sym->is_extern) {
        std_value_Value_insert_str(field_doc, "extern", compiler_ast_scopes_Symbol_out_name(field->sym));
      }
      std_value_Value_push(fields_doc, field_doc);
    }
  }
  std_value_Value_insert(struc_doc, "fields", fields_doc);
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, struc->type);
  std_value_Value_insert(struc_doc, "methods", methods_doc);
  return struc_doc;
}

std_value_Value *compiler_docgen_DocGenerator_gen_ns(compiler_docgen_DocGenerator *this, compiler_ast_program_Namespace *ns) {
  std_value_Value *ns_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(ns_doc, "id", std_format("%x", ns));
  if (((bool)ns->sym->comment)) {
    std_value_Value_insert_str(ns_doc, "description", ns->sym->comment);
  }
  std_value_Value_insert_str(ns_doc, "name", ns->sym->name);
  std_value_Value_insert_str(ns_doc, "kind", "namespace");
  if (ns->is_a_file || ns->is_dir_with_mod) {
    compiler_docgen_DocGenerator_gen_location(this, ns_doc, ns->span);
  }
  if (!(std_vector_Vector__14_is_empty(ns->enums))) {
    std_value_Value *enums_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_vector_Iterator__14 _i281 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i281); std_vector_Iterator__14_next(&_i281)) {
      compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i281);
      {
        std_value_Value_insert(enums_doc, enom->sym->name, compiler_docgen_DocGenerator_gen_enum(this, enom));
      }
    }
    std_value_Value_insert(ns_doc, "enums", enums_doc);
  }
  if (!(std_vector_Vector__13_is_empty(ns->structs))) {
    std_value_Value *structs_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    std_value_Value *unions_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_vector_Iterator__13 _i282 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i282); std_vector_Iterator__13_next(&_i282)) {
      compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i282);
      {
        std_value_Value *struct_doc = compiler_docgen_DocGenerator_gen_struct(this, struc);
        if (!(struc->is_union)) {
          std_value_Value_insert(structs_doc, struc->sym->name, struct_doc);
        } else {
          std_value_Value_insert(unions_doc, struc->sym->name, struct_doc);
        }
      }
    }
    if (!(std_compact_map_Map__1_is_empty(std_value_Value_as_dict(structs_doc)))) {
      std_value_Value_insert(ns_doc, "structs", structs_doc);
    }
    if (!(std_compact_map_Map__1_is_empty(std_value_Value_as_dict(unions_doc)))) {
      std_value_Value_insert(ns_doc, "unions", unions_doc);
    }
  }
  if (!(std_vector_Vector__15_is_empty(ns->variables))) {
    std_value_Value *vars_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_vector_Iterator__15 _i283 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i283); std_vector_Iterator__15_next(&_i283)) {
      compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i283);
      {
        compiler_ast_nodes_Variable *var = node->u.var_decl;
        std_value_Value *var_doc = std_value_Value_new(std_value_ValueType_Dictionary);
        std_value_Value_insert_str(var_doc, "id", std_format("%x", var));
        if (((bool)var->sym->comment)) {
          std_value_Value_insert_str(var_doc, "description", var->sym->comment);
        }
        std_value_Value_insert_str(var_doc, "name", var->sym->name);
        std_value_Value_insert_str(var_doc, "kind", "variable");
        std_value_Value_insert(var_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, var->type));
        compiler_docgen_DocGenerator_gen_location(this, var_doc, var->sym->span);
        if (var->sym->is_extern) {
          std_value_Value_insert_str(var_doc, "extern", compiler_ast_scopes_Symbol_out_name(var->sym));
        }
        std_value_Value_insert(vars_doc, var->sym->name, var_doc);
      }
    }
    std_value_Value_insert(ns_doc, "variables", vars_doc);
  }
  if (!(std_vector_Vector__15_is_empty(ns->constants))) {
    std_value_Value *consts_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_vector_Iterator__15 _i284 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i284); std_vector_Iterator__15_next(&_i284)) {
      compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i284);
      {
        compiler_ast_nodes_Variable *var = node->u.var_decl;
        std_value_Value *const_doc = std_value_Value_new(std_value_ValueType_Dictionary);
        std_value_Value_insert_str(const_doc, "id", std_format("%x", var));
        if (((bool)var->sym->comment)) {
          std_value_Value_insert_str(const_doc, "description", var->sym->comment);
        }
        std_value_Value_insert_str(const_doc, "name", var->sym->name);
        std_value_Value_insert_str(const_doc, "kind", "constant");
        std_value_Value_insert(const_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, var->type));
        compiler_docgen_DocGenerator_gen_location(this, const_doc, var->sym->span);
        if (var->sym->is_extern) {
          std_value_Value_insert_str(const_doc, "extern", compiler_ast_scopes_Symbol_out_name(var->sym));
        }
        std_value_Value_insert(consts_doc, var->sym->name, const_doc);
      }
    }
    std_value_Value_insert(ns_doc, "constants", consts_doc);
  }
  if (!(std_vector_Vector__8_is_empty(ns->functions))) {
    std_value_Value *funcs_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_vector_Iterator__8 _i285 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i285); std_vector_Iterator__8_next(&_i285)) {
      compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i285);
      {
        if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
          continue;
        }
        std_value_Value *func_doc = compiler_docgen_DocGenerator_gen_function(this, func);
        std_value_Value_insert(funcs_doc, func->sym->name, func_doc);
      }
    }
    std_value_Value_insert(ns_doc, "functions", funcs_doc);
  }
  if (!(std_map_Map__2_is_empty(ns->typedefs))) {
    std_value_Value *typedefs_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_map_Iterator__2 _i286 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i286); std_map_Iterator__2_next(&_i286)) {
      std_map_Item__2 *it = std_map_Iterator__2_cur(&_i286);
      {
        std_value_Value *typedef_doc = std_value_Value_new(std_value_ValueType_Dictionary);
        std_value_Value_insert_str(typedef_doc, "kind", "typedef");
        std_value_Value_insert_str(typedef_doc, "name", strdup(it->key));
        std_value_Value_insert(typedef_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, it->value));
        std_value_Value_insert(typedefs_doc, it->key, typedef_doc);
      }
    }
    std_value_Value_insert(ns_doc, "typedefs", typedefs_doc);
  }
  if (!(std_map_Map__4_is_empty(ns->namespaces))) {
    std_value_Value *namespaces_doc = std_value_Value_new(std_value_ValueType_Dictionary);
    for (std_map_Iterator__4 _i287 = std_map_Map__4_iter(ns->namespaces); std_map_Iterator__4_has_value(&_i287); std_map_Iterator__4_next(&_i287)) {
      std_map_Item__4 *it = std_map_Iterator__4_cur(&_i287);
      {
        std_value_Value *ns_doc = compiler_docgen_DocGenerator_gen_ns(this, it->value);
        std_value_Value_insert(namespaces_doc, it->key, ns_doc);
      }
    }
    std_value_Value_insert(ns_doc, "namespaces", namespaces_doc);
  }
  return ns_doc;
}

std_value_Value *compiler_docgen_DocGenerator_gen_builtin(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {
  std_value_Value *type_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(type_doc, "id", std_format("%x", type));
  std_value_Value_insert_str(type_doc, "name", std_format("%s", type->sym->name));
  std_value_Value_insert_str(type_doc, "description", std_format("Built-in type %s", type->sym->name));
  std_value_Value_insert_str(type_doc, "kind", "builtin");
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, type);
  std_value_Value_insert(type_doc, "methods", methods_doc);
  return type_doc;
}

std_value_Value *compiler_docgen_DocGenerator_gen_builtins(compiler_docgen_DocGenerator *this, compiler_ast_program_Program *program) {
  std_value_Value *builtins_doc = std_value_Value_new(std_value_ValueType_Dictionary);
  for (u32 i = 0; i < ((u32)compiler_types_BaseType_NUM_BASE_TYPES); i+=1) {
    compiler_types_Type *type = compiler_ast_program_Program_get_base_type(program, ((compiler_types_BaseType)i), std_span_Span_default());
    std_value_Value_insert(builtins_doc, type->name, compiler_docgen_DocGenerator_gen_builtin(this, type));
  }
  compiler_types_Type *str_type = compiler_ast_program_Program_get_type_by_name(program, "str", std_span_Span_default());
  std_value_Value_insert(builtins_doc, "str", compiler_docgen_DocGenerator_gen_builtin(this, str_type));
  compiler_types_Type *untyped_ptr_type = compiler_ast_program_Program_get_type_by_name(program, "untyped_ptr", std_span_Span_default());
  std_value_Value_insert(builtins_doc, "untyped_ptr", compiler_docgen_DocGenerator_gen_builtin(this, untyped_ptr_type));
  return builtins_doc;
}

void compiler_docgen_generate_doc_json(compiler_ast_program_Program *program, char *json_path) {
  char *ocen_root = getenv("OCEN_ROOT");
  if (!(((bool)ocen_root))) {
    ocen_root="";
  }
  compiler_docgen_DocGenerator docs_generator = (compiler_docgen_DocGenerator){.program=program, .ocen_root=std_sv_SV_from_str(ocen_root)};
  std_value_Value *docs = compiler_docgen_DocGenerator_gen_ns(&docs_generator, program->global);
  std_value_Value *builtins = compiler_docgen_DocGenerator_gen_builtins(&docs_generator, program);
  std_value_Value_insert(docs, "builtins", builtins);
  std_value_Value *container = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert(container, "ocen", docs);
  std_json_write_to_file(container, json_path);
}

bool compiler_utils_directory_exists(char *path) {
  DIR *dir = opendir(path);
  if (dir==NULL) {
    return false;
  }
  closedir(dir);
  return true;
}

void compiler_passes_run_typecheck_passes(compiler_ast_program_Program *program) {
  compiler_passes_register_types_RegisterTypes_run(program);
  compiler_passes_typechecker_TypeChecker_run(program);
}

char *compiler_passes_run_codegen_passes(compiler_ast_program_Program *program) {
  compiler_passes_mark_dead_code_MarkDeadCode_run(program);
  compiler_passes_reorder_symbols_ReorderSymbols_run(program);
  char *code = compiler_passes_code_generator_CodeGenerator_run(program);
  return code;
}

void compiler_passes_register_types_RegisterTypes_register_struct(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *struc) {
  compiler_ast_scopes_Symbol *item = struc->sym;
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Structure, struc->sym->span);
  typ->u.struc=struc;
  struc->type=typ;
  typ->sym=struc->sym;
}

void compiler_passes_register_types_RegisterTypes_register_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *enum_) {
  compiler_ast_scopes_Symbol *item = enum_->sym;
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Enum, enum_->sym->span);
  typ->u.enom=enum_;
  enum_->type=typ;
  typ->sym=enum_->sym;
  std_compact_map_Map__2 *values = std_compact_map_Map__2_new(16);
  for (std_vector_Iterator__20 _i255 = std_vector_Vector__20_iter(enum_->variants); std_vector_Iterator__20_has_value(&_i255); std_vector_Iterator__20_next(&_i255)) {
    compiler_ast_nodes_EnumVariant *var = std_vector_Iterator__20_cur(&_i255);
    {
      var->parent=enum_;
      char *name = var->sym->name;
      std_compact_map_Item__2 *res = std_compact_map_Map__2_get_item(values, name);
      if (((bool)res)) {
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(var->sym->span, std_format("Duplicate enum variant: %s", var->sym->name), res->value, "Previous definition here"));
      } else {
        std_compact_map_Map__2_insert(values, name, var->sym->span);
      }
    }
  }
}

void compiler_passes_register_types_RegisterTypes_register_globals(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Variable *var = node->u.var_decl;
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, var->sym, NULL);
}

void compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_Enum *enom) {
  std_span_Span span = enom->sym->span;
  if (enom->has_values || compiler_ast_scopes_Symbol_is_templated(enom->sym)) {
    return;
  }
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();
  func->span=std_span_Span_default();
  func->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Function, enom->sym->ns, enom->sym, "dbg", span);
  func->sym->u.func=func;
  func->return_type=compiler_ast_program_Program_get_type_by_name(this->o->program, "str", span);
  func->kind=compiler_ast_nodes_FunctionKind_Method;
  func->parent_type=enom->type;
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(enom->type);
  var->sym=compiler_ast_scopes_Symbol_from_local_variable("this", var, span);
  std_vector_Vector__4_push(func->params, var);
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, span);
  typ->u.func=(compiler_types_FunctionType){.orig=func, .params=func->params, .return_type=func->return_type, .is_variadic=func->is_variadic};
  func->type=typ;
  std_map_Map__9_insert(enom->type->methods, "dbg", func);
}

void compiler_passes_register_types_RegisterTypes_register_namespace(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns) {
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  for (std_vector_Iterator__13 _i256 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i256); std_vector_Iterator__13_next(&_i256)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i256);
    {
      compiler_passes_register_types_RegisterTypes_register_struct(this, ns, struc);
    }
  }
  for (std_vector_Iterator__14 _i257 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i257); std_vector_Iterator__14_next(&_i257)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i257);
    {
      compiler_passes_register_types_RegisterTypes_register_enum(this, ns, enom);
      compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(this, enom);
    }
  }
  for (std_vector_Iterator__15 _i258 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i258); std_vector_Iterator__15_next(&_i258)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i258);
    {
      compiler_passes_register_types_RegisterTypes_register_globals(this, node);
    }
  }
  for (std_vector_Iterator__15 _i259 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i259); std_vector_Iterator__15_next(&_i259)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i259);
    {
      compiler_passes_register_types_RegisterTypes_register_globals(this, node);
    }
  }
  for (std_map_Iterator__2 _i260 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i260); std_map_Iterator__2_next(&_i260)) {
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i260);
    {
      compiler_passes_register_types_RegisterTypes_register_alias(this, it->key, it->value);
    }
  }
  for (std_map_ValueIterator__4 _i261 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i261); std_map_ValueIterator__4_next(&_i261)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i261);
    {
      if (child->always_add_to_scope) {
        compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, child->sym, NULL);
      }
      compiler_passes_register_types_RegisterTypes_register_namespace(this, child);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_register_types_RegisterTypes_register_base_type(compiler_passes_register_types_RegisterTypes *this, compiler_types_BaseType base) {
  char *name = compiler_types_BaseType_str(base);
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, name, name, name, std_span_Span_default());
  compiler_types_Type *typ = compiler_types_Type_new_resolved(base, std_span_Span_default());
  typ->sym=sym;
  sym->u.type_def=typ;
  std_map_Map__5_insert(this->o->program->global->scope->items, name, sym);
}

void compiler_passes_register_types_RegisterTypes_register_alias(compiler_passes_register_types_RegisterTypes *this, char *name, compiler_types_Type *orig) {
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, name, name, name, std_span_Span_default());
  compiler_types_Type *alias = compiler_types_Type_new_resolved(compiler_types_BaseType_Alias, std_span_Span_default());
  alias->name=name;
  alias->u.ptr=orig;
  alias->sym=sym;
  sym->u.type_def=alias;
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, sym, name);
}

void compiler_passes_register_types_RegisterTypes_register_print_function(compiler_passes_register_types_RegisterTypes *this, char *name) {
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Function, NULL, name, name, name, std_span_Span_default());
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();
  func->sym=sym;
  func->sym->u.func=func;
  std_vector_Vector__4 *params = std_vector_Vector__4_new(16);
  compiler_ast_nodes_Variable *param = compiler_ast_nodes_Variable_new(compiler_ast_program_Program_get_type_by_name(this->o->program, "str", std_span_Span_default()));
  param->sym=compiler_ast_scopes_Symbol_from_local_variable("fmt", param, std_span_Span_default());
  std_vector_Vector__4_push(params, param);
  func->params=params;
  func->is_variadic=true;
  func->is_variadic_format=true;
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, std_span_Span_default());
  typ->u.func=(compiler_types_FunctionType){.orig=func, .params=params, .return_type=compiler_ast_program_Program_get_type_by_name(this->o->program, "void", std_span_Span_default()), .is_variadic=true};
  func->type=typ;
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, sym, name);
}

void compiler_passes_register_types_RegisterTypes_register_builtin_types(compiler_passes_register_types_RegisterTypes *this) {
  for (u32 i = 0; i < ((u32)compiler_types_BaseType_NUM_BASE_TYPES); i+=1) {
    compiler_passes_register_types_RegisterTypes_register_base_type(this, ((compiler_types_BaseType)i));
  }
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, this->o->program->global->scope);
  {
    compiler_types_Type *base = compiler_ast_program_Program_get_base_type(this->o->program, compiler_types_BaseType_Void, std_span_Span_default());
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_default());
    typ->u.ptr=base;
    compiler_passes_register_types_RegisterTypes_register_alias(this, "untyped_ptr", typ);
  }
  {
    compiler_types_Type *base = compiler_ast_program_Program_get_base_type(this->o->program, compiler_types_BaseType_Char, std_span_Span_default());
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_default());
    typ->u.ptr=base;
    compiler_passes_register_types_RegisterTypes_register_alias(this, "str", typ);
  }
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "print");
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "println");
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "eprint");
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "eprintln");
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

compiler_passes_register_types_Finder compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder this, char *name, bool error) {
  if (!(((bool)this.sym))) {
    return this;
  }
  compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol(this.o, this.sym, name, true);
  if (((bool)res)) {
switch ((res->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_339_0:
        {
          this.type=res->u.type_def;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_339_1:
        {
          this.type=res->u.struc->type;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_339_2:
        {
          this.type=res->u.enom->type;
        } break;
      default:
        {
          this.type=NULL;
        } break;
    }  } else if (error) {
    compiler_errors_Error_panic(compiler_passes_generic_pass_GenericPass_error(this.o, compiler_errors_Error_new_note(this.sym->span, std_format("Could not find %s::%s", this.sym->display, name), "The compiler expects this internally (in RegisterTypes)")));
  }
  this.sym=res;
  return this;
}

compiler_passes_register_types_Finder compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder this, char *name) {
  return compiler_passes_register_types_Finder_to(this, name, true);}

compiler_passes_register_types_Finder compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder this, char *name) {
  return compiler_passes_register_types_Finder_to(this, name, false);}

void compiler_passes_register_types_RegisterTypes_register_cached_types(compiler_passes_register_types_RegisterTypes *this) {
  compiler_passes_register_types_Finder finder = (compiler_passes_register_types_Finder){.o=this->o, .sym=this->o->program->global->sym, .type=NULL};
  compiler_ast_scopes_Symbol *fmt_string_fn = compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(finder, "std"), "format").sym;
  compiler_ast_scopes_Symbol *alloc_fn = compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(finder, "std"), "mem"), "state"), "alloc_fn").sym;
  compiler_ast_scopes_Symbol *allocator = compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(compiler_passes_register_types_Finder_get(finder, "std"), "mem"), "state"), "allocator").sym;
  if(!(alloc_fn->type==compiler_ast_scopes_SymbolType_Variable && alloc_fn->u.var->type->base==compiler_types_BaseType_FunctionPtr)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:236:12: Assertion failed: `alloc_fn.type == Variable and alloc_fn.u.var.type.base == FunctionPtr`", NULL); }
  if(!(allocator->type==compiler_ast_scopes_SymbolType_Variable)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:237:12: Assertion failed: `allocator.type == Variable`", NULL); }
  if(!(alloc_fn->u.var->type->u.func.params->size==2)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:238:12: Assertion failed: `alloc_fn.u.var.type.u.func.params.size == 2`", NULL); }
  compiler_ast_scopes_Symbol *std_vector = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "vector"), "Vector").sym;
  if (((bool)std_vector)) {
    if(!(std_vector->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:243:16: Assertion failed: `std_vector.type == Structure`", NULL); }
    if(!(compiler_ast_scopes_Symbol_is_templated(std_vector))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:244:16: Assertion failed: `std_vector.is_templated()`", NULL); }
  }
  compiler_ast_scopes_Symbol *std_map = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "compact_map"), "Map").sym;
  if (((bool)std_map)) {
    if(!(std_map->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:250:16: Assertion failed: `std_map.type == Structure`", NULL); }
    if(!(compiler_ast_scopes_Symbol_is_templated(std_map))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:251:16: Assertion failed: `std_map.is_templated()`", NULL); }
  }
  compiler_ast_scopes_Symbol *std_result = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "result"), "Result").sym;
  if (((bool)std_result)) {
    if(!(std_result->type==compiler_ast_scopes_SymbolType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:258:16: Assertion failed: `std_result.type == Enum`", NULL); }
    if(!(compiler_ast_scopes_Symbol_is_templated(std_result))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:259:16: Assertion failed: `std_result.is_templated()`", NULL); }
    compiler_ast_scopes_Symbol *error = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "result"), "Result"), "Error").sym;
    if(!(error->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:262:16: Assertion failed: `error.type == EnumVariant`", NULL); }
    if(!(error->u.enum_var->specific_fields->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:263:16: Assertion failed: `error.u.enum_var.specific_fields.size == 1`", NULL); }
    if(!(str_eq(std_vector_Vector__4_at(error->u.enum_var->specific_fields, 0)->sym->name, "err"))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:264:16: Assertion failed: `error.u.enum_var.specific_fields[0].sym.name.eq(\"err\")`", NULL); }
    compiler_ast_scopes_Symbol *ok = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "result"), "Result"), "Ok").sym;
    if(!(ok->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:267:16: Assertion failed: `ok.type == EnumVariant`", NULL); }
    if(!(ok->u.enum_var->specific_fields->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:268:16: Assertion failed: `ok.u.enum_var.specific_fields.size == 1`", NULL); }
    if(!(str_eq(std_vector_Vector__4_at(ok->u.enum_var->specific_fields, 0)->sym->name, "val"))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:269:16: Assertion failed: `ok.u.enum_var.specific_fields[0].sym.name.eq(\"val\")`", NULL); }
  }
  compiler_ast_scopes_Symbol *std_option = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "option"), "Option").sym;
  if (((bool)std_option)) {
    if(!(std_option->type==compiler_ast_scopes_SymbolType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:276:16: Assertion failed: `std_option.type == Enum`", NULL); }
    if(!(compiler_ast_scopes_Symbol_is_templated(std_option))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:277:16: Assertion failed: `std_option.is_templated()`", NULL); }
    compiler_ast_scopes_Symbol *none = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "option"), "Option"), "None").sym;
    if(!(none->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:280:16: Assertion failed: `none.type == EnumVariant`", NULL); }
    if(!(none->u.enum_var->specific_fields->size==0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:281:16: Assertion failed: `none.u.enum_var.specific_fields.size == 0`", NULL); }
    compiler_ast_scopes_Symbol *some = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "option"), "Option"), "Some").sym;
    if(!(some->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:284:16: Assertion failed: `some.type == EnumVariant`", NULL); }
    if(!(some->u.enum_var->specific_fields->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:285:16: Assertion failed: `some.u.enum_var.specific_fields.size == 1`", NULL); }
    if(!(str_eq(std_vector_Vector__4_at(some->u.enum_var->specific_fields, 0)->sym->name, "val"))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:286:16: Assertion failed: `some.u.enum_var.specific_fields[0].sym.name.eq(\"val\")`", NULL); }
  }
  compiler_ast_scopes_Symbol *std_run_test = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "testing"), "run_test").sym;
  if (this->o->program->is_test_mode) {
    if(!(((bool)std_run_test))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:291:16: Assertion failed: `std_run_test?`", "Did not import std::testing"); }
    if(!(std_run_test->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:292:16: Assertion failed: `std_run_test.type == Function`", NULL); }
    if(!(std_run_test->u.func->params->size==2)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:293:16: Assertion failed: `std_run_test.u.func.params.size == 2`", NULL); }
  }
  compiler_ast_scopes_Symbol *std_print_test_stats = compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(compiler_passes_register_types_Finder_try_get(finder, "std"), "testing"), "print_test_stats").sym;
  if (this->o->program->is_test_mode) {
    if(!(((bool)std_print_test_stats))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:298:16: Assertion failed: `std_print_test_stats?`", "Did not import std::testing"); }
    if(!(std_print_test_stats->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:299:16: Assertion failed: `std_print_test_stats.type == Function`", NULL); }
    if(!(std_print_test_stats->u.func->params->size==0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:300:16: Assertion failed: `std_print_test_stats.u.func.params.size == 0`", NULL); }
  }
  this->o->program->cached_symbols=(compiler_ast_program_CachedSymbols){.fmt_string_fn=fmt_string_fn, .mem_alloc_fn=alloc_fn, .mem_allocator=allocator, .std_vector=std_vector, .std_map=std_map, .std_result=std_result, .std_option=std_option, .std_run_test=std_run_test, .std_print_test_stats=std_print_test_stats};
}

void compiler_passes_register_types_RegisterTypes_create_namespace_scopes(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_program_Namespace *parent) {
  compiler_ast_scopes_Scope *parent_scope = ({compiler_ast_scopes_Scope *__yv_340;
    if (!(((bool)parent))) {
      __yv_340 = NULL;
      goto _l___yv_340;
    } else if (parent->is_dir_with_mod) {
      __yv_340 = parent->scope->parent;
      goto _l___yv_340;
    } else {
      __yv_340 = parent->scope;
      goto _l___yv_340;
    }

_l___yv_340:
  __yv_340;});
  ns->scope=compiler_ast_scopes_Scope_new(parent_scope);
  for (std_map_ValueIterator__4 _i262 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i262); std_map_ValueIterator__4_next(&_i262)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i262);
    {
      compiler_passes_register_types_RegisterTypes_create_namespace_scopes(this, child, ns);
    }
  }
}

void compiler_passes_register_types_RegisterTypes_run(compiler_ast_program_Program *program) {
  compiler_passes_register_types_RegisterTypes pass = (compiler_passes_register_types_RegisterTypes){.o=compiler_passes_generic_pass_GenericPass_new(program)};
  compiler_passes_register_types_RegisterTypes_create_namespace_scopes(&pass, program->global, NULL);
  compiler_passes_register_types_RegisterTypes_register_builtin_types(&pass);
  compiler_passes_register_types_RegisterTypes_register_namespace(&pass, program->global);
  if (program->include_stdlib) {
    compiler_passes_register_types_RegisterTypes_register_cached_types(&pass);
    program->did_cache_symbols=true;
  }
}

void compiler_passes_visitor_Visitor_visit_var(compiler_passes_visitor_Visitor *this, compiler_ast_nodes_Variable *var) {
  if (!(((bool)var)) || !(((bool)var->type))) {
    return;
  }
  this->type_fn.fn(this->type_fn._C, var->type);
  compiler_passes_visitor_Visitor_visit_po(this, var->default_value);
}

void compiler_passes_visitor_Visitor_visit_po(compiler_passes_visitor_Visitor *this, compiler_ast_nodes_AST *node) {
  if (!(((bool)node))) {
    return;
  }
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_BoolLiteral:
    case compiler_ast_nodes_ASTType_IntLiteral:
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    case compiler_ast_nodes_ASTType_Error:
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_Null:
    case compiler_ast_nodes_ASTType_Import:
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    case compiler_ast_nodes_ASTType_StringLiteral:
    case compiler_ast_nodes_ASTType_SizeOf:
    case compiler_ast_nodes_ASTType_CharLiteral:
    case compiler_ast_nodes_ASTType_FloatLiteral:
    m_341_0:
      {
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_341_1:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.assertion.expr);
        compiler_passes_visitor_Visitor_visit_po(this, node->u.assertion.msg);
      } break;
    case compiler_ast_nodes_ASTType_Is:
    m_341_2:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.is_expr.lhs);
        for (std_vector_Iterator__6 _i237 = std_vector_Vector__6_iter(node->u.is_expr.conds); std_vector_Iterator__6_has_value(&_i237); std_vector_Iterator__6_next(&_i237)) {
          compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i237);
          {
            compiler_passes_visitor_Visitor_visit_po(this, cond->expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_341_3:
      {
        for (std_vector_Iterator__15 _i238 = std_vector_Vector__15_iter(node->u.block.statements); std_vector_Iterator__15_has_value(&_i238); std_vector_Iterator__15_next(&_i238)) {
          compiler_ast_nodes_AST *stmt = std_vector_Iterator__15_cur(&_i238);
          {
            compiler_passes_visitor_Visitor_visit_po(this, stmt);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_341_4:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.call.callee);
        for (std_vector_Iterator__9 _i239 = std_vector_Vector__9_iter(node->u.call.args); std_vector_Iterator__9_has_value(&_i239); std_vector_Iterator__9_next(&_i239)) {
          compiler_ast_nodes_Argument *arg = std_vector_Iterator__9_cur(&_i239);
          {
            compiler_passes_visitor_Visitor_visit_po(this, arg->expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_341_5:
      {
        for (std_vector_Iterator__23 _i240 = std_vector_Vector__23_iter(node->u.if_stmt.branches); std_vector_Iterator__23_has_value(&_i240); std_vector_Iterator__23_next(&_i240)) {
          compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i240);
          {
            compiler_passes_visitor_Visitor_visit_po(this, branch.cond);
            compiler_passes_visitor_Visitor_visit_po(this, branch.body);
          }
        }
        compiler_passes_visitor_Visitor_visit_po(this, node->u.if_stmt.els);
      } break;
    case compiler_ast_nodes_ASTType_Member:
    case compiler_ast_nodes_ASTType_TryMember:
    m_341_6:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.member.lhs);
      } break;
    case compiler_ast_nodes_ASTType_NSLookup:
    m_341_7:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.lookup.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Return:
    m_341_8:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.ret.expr);
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    m_341_9:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_341_10:
      {
        compiler_passes_visitor_Visitor_visit_var(this, node->u.var_decl);
      } break;
    case compiler_ast_nodes_ASTType_While:
    case compiler_ast_nodes_ASTType_For:
    m_341_11:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.loop.cond);
        compiler_passes_visitor_Visitor_visit_po(this, node->u.loop.body);
        compiler_passes_visitor_Visitor_visit_po(this, node->u.loop.step);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_341_12:
      {
        for (std_vector_Iterator__15 _i241 = std_vector_Vector__15_iter(node->u.fmt_str.exprs); std_vector_Iterator__15_has_value(&_i241); std_vector_Iterator__15_next(&_i241)) {
          compiler_ast_nodes_AST *arg = std_vector_Iterator__15_cur(&_i241);
          {
            compiler_passes_visitor_Visitor_visit_po(this, arg);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_341_13:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.cast.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_341_14:
      {
        compiler_ast_nodes_Match mtch = node->u.match_stmt;
        compiler_passes_visitor_Visitor_visit_po(this, mtch.expr);
        for (std_vector_Iterator__24 _i242 = std_vector_Vector__24_iter(mtch.cases); std_vector_Iterator__24_has_value(&_i242); std_vector_Iterator__24_next(&_i242)) {
          compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i242);
          {
            for (std_vector_Iterator__6 _i243 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i243); std_vector_Iterator__6_next(&_i243)) {
              compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i243);
              {
                compiler_passes_visitor_Visitor_visit_po(this, cond->expr);
              }
            }
            compiler_passes_visitor_Visitor_visit_po(this, _case.body);
          }
        }
        compiler_passes_visitor_Visitor_visit_po(this, mtch.defolt);
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    m_341_15:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Specialization:
    m_341_16:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.spec.base);
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_341_17:
      {
        for (std_vector_Iterator__15 _i244 = std_vector_Vector__15_iter(node->u.array_literal.elements); std_vector_Iterator__15_has_value(&_i244); std_vector_Iterator__15_next(&_i244)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i244);
          {
            compiler_passes_visitor_Visitor_visit_po(this, elem);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_VectorLiteral:
    m_341_18:
      {
        for (std_vector_Iterator__15 _i245 = std_vector_Vector__15_iter(node->u.vec_literal.elements); std_vector_Iterator__15_has_value(&_i245); std_vector_Iterator__15_next(&_i245)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i245);
          {
            compiler_passes_visitor_Visitor_visit_po(this, elem);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_MapLiteral:
    m_341_19:
      {
        for (std_vector_Iterator__25 _i246 = std_vector_Vector__25_iter(node->u.map_literal.elements); std_vector_Iterator__25_has_value(&_i246); std_vector_Iterator__25_next(&_i246)) {
          compiler_ast_nodes_MapLiteralPair elem = std_vector_Iterator__25_cur(&_i246);
          {
            compiler_passes_visitor_Visitor_visit_po(this, elem.key);
            compiler_passes_visitor_Visitor_visit_po(this, elem.value);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_341_20:
      {
        compiler_ast_nodes_Function *func = node->u.closure;
        compiler_passes_visitor_Visitor_visit_po(this, func->body);
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_341_21:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_341_22:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.unary.expr);
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_341_23:
      {
        compiler_passes_visitor_Visitor_visit_po(this, node->u.binary.lhs);
        compiler_passes_visitor_Visitor_visit_po(this, node->u.binary.rhs);
      } break;
  }  this->node_fn.fn(this->node_fn._C, node);
}

compiler_passes_mark_dead_code_MarkDeadCode *compiler_passes_mark_dead_code_MarkDeadCode_new(compiler_ast_program_Program *program) {
  compiler_passes_mark_dead_code_MarkDeadCode *pass = std_mem_alloc__0(1);
  (*pass)=(compiler_passes_mark_dead_code_MarkDeadCode){.o=compiler_passes_generic_pass_GenericPass_new(program), .done=std_set_Set__0_new()};
  return pass;
}

void compiler_passes_mark_dead_code_MarkDeadCode_free(compiler_passes_mark_dead_code_MarkDeadCode *this) {
  std_set_Set__0_free(this->done);
  std_mem_free(this->o);
  std_mem_free(this);
}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym) {
  if (!(((bool)sym)) || std_set_Set__0_contains(this->done, ((u64)sym))) {
    return;
  }
  std_set_Set__0_add(this->done, ((u64)sym));
  sym->is_dead=false;
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Function:
    m_342_0:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_342_1:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_342_2:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Constant:
    case compiler_ast_scopes_SymbolType_Variable:
    m_342_3:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, sym->u.var->type);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, sym->u.var->default_value);
        sym->u.var->sym->is_dead=false;
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_342_4:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, sym->u.closure);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_342_5:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, sym->u.type_def);
      } break;
    case compiler_ast_scopes_SymbolType_ClosedVariable:
    m_342_6:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, sym->u.closed_var.orig->sym);
      } break;
    default:
      {
      } break;
  }}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Function *f) {
  if (!(((bool)f)) || std_set_Set__0_contains(this->done, ((u64)f))) {
    return;
  }
  std_set_Set__0_add(this->done, ((u64)f));
  f->sym->is_dead=false;
  compiler_passes_mark_dead_code_MarkDeadCode_mark(this, f->body);
  for (std_vector_Iterator__4 _i76 = std_vector_Vector__4_iter(f->params); std_vector_Iterator__4_has_value(&_i76); std_vector_Iterator__4_next(&_i76)) {
    compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i76);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, ({compiler_types_Type *_t343 = param->type; _t343 ? _t343->sym : NULL;}));
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, param->type);
    }
  }
  compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, f->type->sym);
  compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, f->return_type);
}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_type(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_types_Type *typ) {
  if (!(((bool)typ))) {
    return;
  }
switch ((typ->base)) {
    case compiler_types_BaseType_Pointer:
    case compiler_types_BaseType_Alias:
    m_344_0:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, typ->u.ptr);
      } break;
    case compiler_types_BaseType_Array:
    m_344_1:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, typ->u.arr.elem_type);
      } break;
    case compiler_types_BaseType_FunctionPtr:
    case compiler_types_BaseType_Closure:
    m_344_2:
      {
        compiler_types_FunctionType ft = typ->u.func;
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, ft.return_type);
        for (std_vector_Iterator__4 _i77 = std_vector_Vector__4_iter(ft.params); std_vector_Iterator__4_has_value(&_i77); std_vector_Iterator__4_next(&_i77)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i77);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, param->type);
          }
        }
      } break;
    default:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, typ->sym);
        if (((bool)typ->template_instance)) {
          for (std_vector_Iterator__0 _i78 = std_vector_Vector__0_iter(typ->template_instance->args); std_vector_Iterator__0_has_value(&_i78); std_vector_Iterator__0_next(&_i78)) {
            compiler_types_Type *arg = std_vector_Iterator__0_cur(&_i78);
            {
              compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, arg);
            }
          }
        }
      } break;
  }}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Structure *s) {
  if (!(((bool)s)) || std_set_Set__0_contains(this->done, ((u64)s))) {
    return;
  }
  std_set_Set__0_add(this->done, ((u64)s));
  s->sym->is_dead=false;
  for (std_vector_Iterator__4 _i79 = std_vector_Vector__4_iter(s->fields); std_vector_Iterator__4_has_value(&_i79); std_vector_Iterator__4_next(&_i79)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i79);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, field->type);
    }
  }
}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Enum *e) {
  if (!(((bool)e)) || std_set_Set__0_contains(this->done, ((u64)e))) {
    return;
  }
  std_set_Set__0_add(this->done, ((u64)e));
  e->sym->is_dead=false;
  for (std_vector_Iterator__20 _i80 = std_vector_Vector__20_iter(e->variants); std_vector_Iterator__20_has_value(&_i80); std_vector_Iterator__20_next(&_i80)) {
    compiler_ast_nodes_EnumVariant *var = std_vector_Iterator__20_cur(&_i80);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, var->sym);
      for (std_vector_Iterator__4 _i81 = std_vector_Vector__4_iter(var->specific_fields); std_vector_Iterator__4_has_value(&_i81); std_vector_Iterator__4_next(&_i81)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i81);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, field->sym);
          compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, field->type);
          compiler_passes_mark_dead_code_MarkDeadCode_mark(this, field->default_value);
        }
      }
    }
  }
  for (std_vector_Iterator__4 _i82 = std_vector_Vector__4_iter(e->shared_fields); std_vector_Iterator__4_has_value(&_i82); std_vector_Iterator__4_next(&_i82)) {
    compiler_ast_nodes_Variable *var = std_vector_Iterator__4_cur(&_i82);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, var->sym);
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, var->type);
      compiler_passes_mark_dead_code_MarkDeadCode_mark(this, var->default_value);
    }
  }
}

void compiler_passes_mark_dead_code_MarkDeadCode_mark(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_AST *node) {
  if (!(((bool)node))) {
    return;
  }
  compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, node->resolved_symbol);
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Import:
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    case compiler_ast_nodes_ASTType_IntLiteral:
    case compiler_ast_nodes_ASTType_FloatLiteral:
    case compiler_ast_nodes_ASTType_BoolLiteral:
    case compiler_ast_nodes_ASTType_StringLiteral:
    case compiler_ast_nodes_ASTType_CharLiteral:
    case compiler_ast_nodes_ASTType_Null:
    m_345_0:
      {
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    case compiler_ast_nodes_ASTType_Defer:
    m_345_1:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_345_2:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.child);
        if (this->o->program->did_cache_symbols) {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.mem_alloc_fn);
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.mem_allocator);
        }
      } break;
    case compiler_ast_nodes_ASTType_Return:
    m_345_3:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.ret.expr);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_345_4:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.unary.expr);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_345_5:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, node->u.size_of_type);
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_345_6:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, node->u.var_decl->sym);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_345_7:
      {
        for (std_vector_Iterator__15 _i83 = std_vector_Vector__15_iter(node->u.block.statements); std_vector_Iterator__15_has_value(&_i83); std_vector_Iterator__15_next(&_i83)) {
          compiler_ast_nodes_AST *statement = std_vector_Iterator__15_cur(&_i83);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, statement);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_345_8:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, node->u.closure);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_345_9:
      {
        for (std_vector_Iterator__23 _i84 = std_vector_Vector__23_iter(node->u.if_stmt.branches); std_vector_Iterator__23_has_value(&_i84); std_vector_Iterator__23_next(&_i84)) {
          compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i84);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, branch.cond);
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, branch.body);
          }
        }
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.if_stmt.els);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_345_10:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.match_stmt.expr);
        for (std_vector_Iterator__24 _i85 = std_vector_Vector__24_iter(node->u.match_stmt.cases); std_vector_Iterator__24_has_value(&_i85); std_vector_Iterator__24_next(&_i85)) {
          compiler_ast_nodes_MatchCase c = std_vector_Iterator__24_cur(&_i85);
          {
            for (std_vector_Iterator__6 _i86 = std_vector_Vector__6_iter(c.conds); std_vector_Iterator__6_has_value(&_i86); std_vector_Iterator__6_next(&_i86)) {
              compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i86);
              {
                compiler_passes_mark_dead_code_MarkDeadCode_mark(this, cond->expr);
                if (((bool)cond->cmp_fn)) {
                  compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, cond->cmp_fn);
                }
              }
            }
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, c.body);
          }
        }
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.match_stmt.defolt);
      } break;
    case compiler_ast_nodes_ASTType_While:
    case compiler_ast_nodes_ASTType_For:
    m_345_11:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.init);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.cond);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.step);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.body);
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_345_12:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.assertion.expr);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.assertion.msg);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_345_13:
      {
        if (this->o->program->did_cache_symbols) {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.fmt_string_fn);
        }
        for (std_vector_Iterator__15 _i87 = std_vector_Vector__15_iter(node->u.fmt_str.exprs); std_vector_Iterator__15_has_value(&_i87); std_vector_Iterator__15_next(&_i87)) {
          compiler_ast_nodes_AST *expr = std_vector_Iterator__15_cur(&_i87);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Member:
    case compiler_ast_nodes_ASTType_TryMember:
    m_345_14:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.member.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_Specialization:
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_345_15:
      {
      } break;
    case compiler_ast_nodes_ASTType_NSLookup:
    m_345_16:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.lookup.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_345_17:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.call.callee);
        for (std_vector_Iterator__9 _i88 = std_vector_Vector__9_iter(node->u.call.args); std_vector_Iterator__9_has_value(&_i88); std_vector_Iterator__9_next(&_i88)) {
          compiler_ast_nodes_Argument *arg = std_vector_Iterator__9_cur(&_i88);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, arg->expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_345_18:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.binary.lhs);
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.binary.rhs);
      } break;
    case compiler_ast_nodes_ASTType_Is:
    m_345_19:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.is_expr.lhs);
        for (std_vector_Iterator__6 _i89 = std_vector_Vector__6_iter(node->u.is_expr.conds); std_vector_Iterator__6_has_value(&_i89); std_vector_Iterator__6_next(&_i89)) {
          compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i89);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, cond->expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_345_20:
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.cast.lhs);
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, node->u.cast.to);
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_345_21:
      {
        for (std_vector_Iterator__15 _i90 = std_vector_Vector__15_iter(node->u.array_literal.elements); std_vector_Iterator__15_has_value(&_i90); std_vector_Iterator__15_next(&_i90)) {
          compiler_ast_nodes_AST *expr = std_vector_Iterator__15_cur(&_i90);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_VectorLiteral:
    m_345_22:
      {
        compiler_ast_nodes_VectorLiteral vec_lit = node->u.vec_literal;
        for (std_vector_Iterator__15 _i91 = std_vector_Vector__15_iter(vec_lit.elements); std_vector_Iterator__15_has_value(&_i91); std_vector_Iterator__15_next(&_i91)) {
          compiler_ast_nodes_AST *expr = std_vector_Iterator__15_cur(&_i91);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr);
          }
        }
        if (((bool)vec_lit.vec_type)) {
          compiler_types_Type *vec_type = vec_lit.vec_type;
          compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, vec_type);
          compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, std_map_Map__9_get(vec_type->methods, "push", NULL));
          compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, std_map_Map__9_get(vec_type->methods, "new", NULL));
        }
      } break;
    case compiler_ast_nodes_ASTType_MapLiteral:
    m_345_23:
      {
        compiler_ast_nodes_MapLiteral map_lit = node->u.map_literal;
        for (std_vector_Iterator__25 _i92 = std_vector_Vector__25_iter(map_lit.elements); std_vector_Iterator__25_has_value(&_i92); std_vector_Iterator__25_next(&_i92)) {
          compiler_ast_nodes_MapLiteralPair expr = std_vector_Iterator__25_cur(&_i92);
          {
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr.key);
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr.value);
          }
        }
        if (((bool)map_lit.map_type)) {
          compiler_types_Type *map_type = map_lit.map_type;
          compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, map_type);
          compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, std_map_Map__9_get(map_type->methods, "insert", NULL));
          compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, std_map_Map__9_get(map_type->methods, "new", NULL));
        }
      } break;
    default:
      {
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(node->span, std_format("Unhandled expression type in MarkDeadCode: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
      } break;
  }}

compiler_ast_nodes_Function *compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_program_Program *program) {
  for (compiler_ast_program_NSIterator _i93 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i93); compiler_ast_program_NSIterator_next(&_i93)) {
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i93);
    {
      for (std_vector_Iterator__8 _i94 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i94); std_vector_Iterator__8_next(&_i94)) {
        compiler_ast_nodes_Function *f = std_vector_Iterator__8_cur(&_i94);
        {
          if (str_eq(f->sym->full_name, "main")) {
            return f;
          }
        }
      }
    }
  }
  return NULL;
}

void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym) {
  if (!(((bool)sym))) {
    return;
  }
  sym->is_dead=true;
  if (((bool)sym->template)) {
    for (std_vector_Iterator__5 _i95 = std_vector_Vector__5_iter(sym->template->instances); std_vector_Iterator__5_has_value(&_i95); std_vector_Iterator__5_next(&_i95)) {
      compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i95);
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(this, instance->resolved);
      }
    }
  }
}

void compiler_passes_mark_dead_code_MarkDeadCode_run(compiler_ast_program_Program *program) {
  compiler_passes_mark_dead_code_MarkDeadCode *pass = compiler_passes_mark_dead_code_MarkDeadCode_new(program);
  compiler_ast_nodes_Function *main = compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(pass, program);
  bool any_alive = (((bool)main) || !(std_vector_Vector__10_is_empty(program->explicit_alive_symbols)));
  if (!(any_alive) && !(program->is_test_mode)) {
    printf("[+] No alive functions found, not marking any functions as dead.""\n");
    /* defers */
    compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
    return;
  }
  if (program->keep_all_code) {
    /* defers */
    compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
    return;
  }
  for (compiler_ast_program_NSIterator _i96 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i96); compiler_ast_program_NSIterator_next(&_i96)) {
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i96);
    {
      for (std_vector_Iterator__8 _i97 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i97); std_vector_Iterator__8_next(&_i97)) {
        compiler_ast_nodes_Function *f = std_vector_Iterator__8_cur(&_i97);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, f->sym);
        }
      }
      for (std_vector_Iterator__13 _i98 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i98); std_vector_Iterator__13_next(&_i98)) {
        compiler_ast_nodes_Structure *s = std_vector_Iterator__13_cur(&_i98);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, s->sym);
        }
      }
      for (std_vector_Iterator__14 _i99 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i99); std_vector_Iterator__14_next(&_i99)) {
        compiler_ast_nodes_Enum *e = std_vector_Iterator__14_cur(&_i99);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, e->sym);
        }
      }
      for (std_vector_Iterator__15 _i100 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i100); std_vector_Iterator__15_next(&_i100)) {
        compiler_ast_nodes_AST *v = std_vector_Iterator__15_cur(&_i100);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, v->u.var_decl->sym);
        }
      }
      for (std_vector_Iterator__15 _i101 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i101); std_vector_Iterator__15_next(&_i101)) {
        compiler_ast_nodes_AST *c = std_vector_Iterator__15_cur(&_i101);
        {
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, c->u.var_decl->sym);
        }
      }
    }
  }
  for (std_vector_Iterator__0 _i102 = std_vector_Vector__0_iter(program->closure_types); std_vector_Iterator__0_has_value(&_i102); std_vector_Iterator__0_next(&_i102)) {
    compiler_types_Type *cty = std_vector_Iterator__0_cur(&_i102);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, cty->sym);
    }
  }
  for (std_vector_Iterator__8 _i103 = std_vector_Vector__8_iter(program->closures); std_vector_Iterator__8_has_value(&_i103); std_vector_Iterator__8_next(&_i103)) {
    compiler_ast_nodes_Function *clos = std_vector_Iterator__8_cur(&_i103);
    {
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, clos->sym);
    }
  }
  if (program->is_test_mode) {
    for (compiler_ast_program_NSIterator _i104 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i104); compiler_ast_program_NSIterator_next(&_i104)) {
      compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i104);
      {
        for (std_vector_Iterator__8 _i105 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i105); std_vector_Iterator__8_next(&_i105)) {
          compiler_ast_nodes_Function *f = std_vector_Iterator__8_cur(&_i105);
          {
            if (f->is_test_function) {
              compiler_passes_mark_dead_code_MarkDeadCode_mark_function(pass, f);
            }
          }
        }
      }
    }
    compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(pass, program->cached_symbols.std_run_test);
    compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(pass, program->cached_symbols.std_print_test_stats);
  } else {
    compiler_passes_mark_dead_code_MarkDeadCode_mark_function(pass, main);
    for (std_vector_Iterator__10 _i106 = std_vector_Vector__10_iter(program->explicit_alive_symbols); std_vector_Iterator__10_has_value(&_i106); std_vector_Iterator__10_next(&_i106)) {
      compiler_ast_scopes_Symbol *sym = std_vector_Iterator__10_cur(&_i106);
      {
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(pass, sym);
      }
    }
  }
  /* defers */
  compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
}

compiler_passes_generic_pass_GenericPass *compiler_passes_generic_pass_GenericPass_new(compiler_ast_program_Program *program) {
  compiler_passes_generic_pass_GenericPass *pass = std_mem_alloc__1(1);
  pass->scope_stack=std_vector_Vector__2_new(16);
  pass->namespace_stack=std_vector_Vector__3_new(16);
  pass->program=program;
  pass->error_type=compiler_types_Type_new_resolved(compiler_types_BaseType_Error, std_span_Span_default());
  return pass;
}

void compiler_passes_generic_pass_GenericPass_push_scope(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Scope *scope) {
  std_vector_Vector__2_push(this->scope_stack, scope);
}

void compiler_passes_generic_pass_GenericPass_push_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns) {
  std_vector_Vector__3_push(this->namespace_stack, ns);
}

compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_pop_scope(compiler_passes_generic_pass_GenericPass *this) {
  if (this->scope_stack->size==0) {
    return NULL;
  }
  return ((compiler_ast_scopes_Scope *)std_vector_Vector__2_pop(this->scope_stack));
}

compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_pop_namespace(compiler_passes_generic_pass_GenericPass *this) {
  if (this->namespace_stack->size==0) {
    return NULL;
  }
  return ((compiler_ast_program_Namespace *)std_vector_Vector__3_pop(this->namespace_stack));
}

compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_scope(compiler_passes_generic_pass_GenericPass *this) {
  if (this->scope_stack->size==0) {
    return NULL;
  }
  return std_vector_Vector__2_at(this->scope_stack, (this->scope_stack->size - 1));
}

compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_ns(compiler_passes_generic_pass_GenericPass *this) {
  if (this->namespace_stack->size==0) {
    return NULL;
  }
  return std_vector_Vector__3_at(this->namespace_stack, (this->namespace_stack->size - 1));
}

compiler_errors_Error *compiler_passes_generic_pass_GenericPass_error(compiler_passes_generic_pass_GenericPass *this, compiler_errors_Error *err) {
  std_vector_Vector__16_push(this->program->errors, err);
  return err;
}

void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(compiler_passes_generic_pass_GenericPass *this, bool export, compiler_ast_scopes_Symbol *item, char *name) {
  if (!(((bool)name))) {
    name=item->name;
  }
  compiler_ast_scopes_Symbol *prev = compiler_ast_scopes_Scope_lookup_local(compiler_passes_generic_pass_GenericPass_scope(this), name);
  if (((bool)prev)) {
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(item->span, std_format("Name %s already exists in scope", name), prev->span, std_format("Previous use of %s", name)));
    return;
  }
  compiler_ast_scopes_Scope_insert(compiler_passes_generic_pass_GenericPass_scope(this), name, item);
  if (!(export)) {
    return;
  }
  std_map_Map__5 *exported = compiler_passes_generic_pass_GenericPass_ns(this)->exported_symbols;
  std_map_Item__5 *it = std_map_Map__5_get_item(exported, name);
  if (((bool)it)) {
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(item->span, std_format("Name %s already exported from namespace", name), it->value->span, std_format("Previous export of %s", name)));
    return;
  }
  std_map_Map__5_insert(compiler_passes_generic_pass_GenericPass_ns(this)->exported_symbols, name, item);
}

void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *item, char *name) {
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, false, item, name);
}

compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, bool allow_templated) {
  return ({compiler_ast_scopes_Symbol *__yv_346;
switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_Namespace:
      m_347_0:
        {
          __yv_346 = compiler_ast_program_Namespace_find_importable_symbol(sym->u.ns, name);
          goto _l___yv_346;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_347_1:
        {
          if (compiler_ast_scopes_Symbol_is_templated(sym) && !(allow_templated)) {
            return NULL;
          }
          compiler_ast_nodes_Structure *struc = sym->u.struc;
          compiler_ast_nodes_Function *method = std_map_Map__9_get(struc->type->methods, name, NULL);
          if (!(((bool)method))) {
            return NULL;
          }
          __yv_346 = method->sym;
          goto _l___yv_346;
        } break;
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_347_2:
        {
          compiler_types_Type *type_def = sym->u.type_def;
          compiler_ast_nodes_Function *method = std_map_Map__9_get(type_def->methods, name, NULL);
          if (!(((bool)method))) {
            return NULL;
          }
          __yv_346 = method->sym;
          goto _l___yv_346;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_347_3:
        {
          compiler_ast_nodes_Enum *enom = sym->u.enom;
          compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_Enum_get_variant(enom, name);
          if (((bool)variant)) {
            return variant->sym;
          }
          compiler_ast_nodes_Function *method = std_map_Map__9_get(enom->type->methods, name, NULL);
          if (((bool)method)) {
            return method->sym;
          }
          __yv_346 = NULL;
          goto _l___yv_346;
        } break;
      default:
        {
          __yv_346 = NULL;
          goto _l___yv_346;
        } break;
    }
_l___yv_346:
  __yv_346;});}

compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, std_span_Span span, bool error) {
  if (error && compiler_ast_scopes_Symbol_is_templated(sym)) {
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(span, std_format("Need to specify template specialization for %s", sym->display), sym->span, std_format("Template was defined here")));
  }
  compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol(this, sym, name, true);
  if (((bool)res) || !(error)) {
    return res;
  }
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Namespace:
    m_348_0:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find symbol %s in namespace %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_348_1:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find method %s in structure %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_348_2:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find method %s in type %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_348_3:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find variant/method %s in enum %s", name, sym->display)));
      } break;
    default:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Can't lookup a name inside a %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));
      } break;
  }  return NULL;
}

void compiler_passes_generic_pass_GenericPass_import_all_from_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns, bool export) {
  for (std_vector_Iterator__8 _i114 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i114); std_vector_Iterator__8_next(&_i114)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i114);
    {
      if (func->kind != compiler_ast_nodes_FunctionKind_Method) {
        compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, func->sym, NULL);
      }
    }
  }
  for (std_vector_Iterator__13 _i115 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i115); std_vector_Iterator__13_next(&_i115)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i115);
    {
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, struc->sym, NULL);
    }
  }
  for (std_vector_Iterator__14 _i116 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i116); std_vector_Iterator__14_next(&_i116)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i116);
    {
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, enom->sym, NULL);
    }
  }
  for (std_vector_Iterator__15 _i117 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i117); std_vector_Iterator__15_next(&_i117)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i117);
    {
      compiler_ast_nodes_Variable *var = node->u.var_decl;
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, var->sym, NULL);
    }
  }
  for (std_vector_Iterator__15 _i118 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i118); std_vector_Iterator__15_next(&_i118)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i118);
    {
      compiler_ast_nodes_Variable *var = node->u.var_decl;
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, var->sym, NULL);
    }
  }
  for (std_map_Iterator__2 _i119 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i119); std_map_Iterator__2_next(&_i119)) {
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i119);
    {
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, it->value->sym, it->key);
    }
  }
  for (std_map_Iterator__5 _i120 = std_map_Map__5_iter(ns->exported_symbols); std_map_Iterator__5_has_value(&_i120); std_map_Iterator__5_next(&_i120)) {
    std_map_Item__5 *it = std_map_Iterator__5_cur(&_i120);
    {
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, it->value, it->key);
    }
  }
}

void compiler_passes_generic_pass_GenericPass_import_all_from_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, bool export) {
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Namespace:
    m_349_0:
      {
        compiler_passes_generic_pass_GenericPass_import_all_from_namespace(this, sym->u.ns, export);
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_349_1:
      {
        for (std_map_ValueIterator__9 _i121 = std_map_Map__9_iter_values(sym->u.type_def->methods); std_map_ValueIterator__9_has_value(&_i121); std_map_ValueIterator__9_next(&_i121)) {
          compiler_ast_nodes_Function *method = std_map_ValueIterator__9_cur(&_i121);
          {
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, method->sym, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_349_2:
      {
        for (std_map_ValueIterator__9 _i122 = std_map_Map__9_iter_values(sym->u.struc->type->methods); std_map_ValueIterator__9_has_value(&_i122); std_map_ValueIterator__9_next(&_i122)) {
          compiler_ast_nodes_Function *method = std_map_ValueIterator__9_cur(&_i122);
          {
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, method->sym, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_349_3:
      {
        for (std_vector_Iterator__20 _i123 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i123); std_vector_Iterator__20_next(&_i123)) {
          compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i123);
          {
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, variant->sym, NULL);
          }
        }
      } break;
    default:
      {
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(sym->span, std_format("Can't imdo wildcard import from a %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));
      } break;
  }}

compiler_ast_nodes_Function *compiler_passes_generic_pass_GenericPass_current_func(compiler_passes_generic_pass_GenericPass *this) {
  return ({compiler_ast_scopes_Scope *_t350 = compiler_passes_generic_pass_GenericPass_scope(this); _t350 ? _t350->cur_func : NULL;});}

compiler_errors_Error *compiler_passes_typechecker_TypeChecker_error(compiler_passes_typechecker_TypeChecker *this, compiler_errors_Error *err) {
  return compiler_passes_generic_pass_GenericPass_error(this->o, err);}

compiler_ast_scopes_Scope *compiler_passes_typechecker_TypeChecker_scope(compiler_passes_typechecker_TypeChecker *this) {
  return compiler_passes_generic_pass_GenericPass_scope(this->o);}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_base_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_BaseType base, std_span_Span span) {
  return compiler_ast_program_Program_get_base_type(this->o->program, base, span);}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_type_by_name(compiler_passes_typechecker_TypeChecker *this, char *name, std_span_Span span) {
  return compiler_ast_program_Program_get_type_by_name(this->o->program, name, span);}

void compiler_passes_typechecker_TypeChecker_set_resolved_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym) {
  node->resolved_symbol=sym;
  if (node->type==compiler_ast_nodes_ASTType_Import) {
    return;
  }
  compiler_ast_scopes_ReferenceType ref_type = compiler_ast_scopes_ReferenceType_Normal;
  std_span_Span span = ({std_span_Span __yv_351;
switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_352_0:
        {
          __yv_351 = node->span;
          goto _l___yv_351;
        } break;
      case compiler_ast_nodes_ASTType_Import:
      case compiler_ast_nodes_ASTType_Specialization:
      m_352_1:
        {
          return;
        } break;
      case compiler_ast_nodes_ASTType_OverloadedOperator:
      m_352_2:
        {
          ref_type=compiler_ast_scopes_ReferenceType_OperatorOverload;
          __yv_351 = node->u.operator_span;
          goto _l___yv_351;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_352_3:
        {
          __yv_351 = node->u.lookup.rhs_span;
          goto _l___yv_351;
        } break;
      case compiler_ast_nodes_ASTType_Member:
      case compiler_ast_nodes_ASTType_TryMember:
      m_352_4:
        {
          if (str_eq(sym->name, "this") && node->u.member.dot_shorthand) {
            ref_type=compiler_ast_scopes_ReferenceType_DotShorthand;
          }
          __yv_351 = node->u.member.rhs_span;
          goto _l___yv_351;
        } break;
      case compiler_ast_nodes_ASTType_VarDeclaration:
      m_352_5:
        {
          __yv_351 = sym->span;
          goto _l___yv_351;
        } break;
      default:
        {
          if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:69:20: Assertion failed: `false`", std_format("Unhandled node type in set_resolved_symbol: %s", compiler_ast_nodes_ASTType_dbg(node->type))); exit(1); }
        } break;
    }
_l___yv_351:
  __yv_351;});
  if (((bool)sym) && !(this->in_template_instance)) {
    compiler_ast_scopes_Symbol_add_reference(sym, ref_type, span);
  }
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_closure_type(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__4 *params, compiler_types_Type *return_type, compiler_types_Type *old) {
  compiler_types_Type *canon = compiler_ast_program_Program_find_closure_type(this->o->program, params, return_type);
  if (!(((bool)canon))) {
    std_span_Span span = (((bool)old) ? old->span : std_span_Span_default());
    if (((bool)old)) {
      compiler_types_FunctionType func_ty = old->u.func;
      canon=compiler_types_Type_shallow_copy(old);
      canon->u.func=(compiler_types_FunctionType){.orig=func_ty.orig, .params=params, .return_type=return_type, .is_variadic=func_ty.is_variadic};
    } else {
      canon=compiler_types_Type_new_resolved(compiler_types_BaseType_Closure, span);
      canon->u.func=(compiler_types_FunctionType){.orig=NULL, .params=params, .return_type=return_type, .is_variadic=false};
    }
    char *closure_name = std_format("_ClosureTy_%u", this->o->program->closure_types->size);
    std_vector_Vector__0_push(this->o->program->closure_types, canon);
    compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_ClosureType, NULL, closure_name, closure_name, closure_name, span);
    sym->u.type_def=canon;
    canon->sym=sym;
  }
  return canon;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_resolve_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old, bool allow_incomplete, bool error, bool resolve_templates) {
  bool p_a = allow_incomplete;
  bool p_e = error;
  bool p_r = resolve_templates;
  compiler_types_Type *resolved = old;
  if (!(((bool)old))) {
    return NULL;
  }
switch ((old->base)) {
    case compiler_types_BaseType_Pointer:
    m_353_0:
      {
        compiler_types_Type *ptr = compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.ptr, p_a, p_e, p_r);
        if (!(((bool)ptr))) {
          return NULL;
        }
switch ((ptr->base)) {
          case compiler_types_BaseType_Char:
          m_354_0:
            {
              resolved=compiler_ast_program_Program_get_type_by_name(this->o->program, "str", old->span);
            } break;
          case compiler_types_BaseType_Void:
          m_354_1:
            {
              resolved=compiler_ast_program_Program_get_type_by_name(this->o->program, "untyped_ptr", old->span);
            } break;
          default:
            {
              resolved=compiler_types_Type_shallow_copy(old);
              resolved->u.ptr=ptr;
            } break;
        }      } break;
    case compiler_types_BaseType_Alias:
    m_353_1:
      {
        if (!(((bool)old->u.ptr))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(old->span, "This type does not point to anything", "Cannot use a typedef for a type when defining any of it's members.\nUse fully qualified type for all field / method definitions."));
          return NULL;
        }
        return compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.ptr, p_a, p_e, p_r);
      } break;
    case compiler_types_BaseType_Closure:
    case compiler_types_BaseType_FunctionPtr:
    m_353_2:
      {
        std_vector_Vector__4 *checked_params = std_vector_Vector__4_new(16);
        compiler_types_FunctionType func = old->u.func;
        for (std_vector_Iterator__4 _i173 = std_vector_Vector__4_iter(func.params); std_vector_Iterator__4_has_value(&_i173); std_vector_Iterator__4_next(&_i173)) {
          compiler_ast_nodes_Variable *var = std_vector_Iterator__4_cur(&_i173);
          {
            var->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, p_a, p_e, p_r);
            if (!(((bool)var->type))) {
              return NULL;
            }
            std_vector_Vector__4_push(checked_params, var);
          }
        }
        compiler_types_Type *return_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, func.return_type, p_a, p_e, p_r);
        if (!(((bool)return_type))) {
          return NULL;
        }
        if (old->base==compiler_types_BaseType_Closure) {
          resolved=compiler_passes_typechecker_TypeChecker_get_closure_type(this, checked_params, return_type, old);
        } else {
          resolved=compiler_types_Type_shallow_copy(old);
          resolved->u.func=(compiler_types_FunctionType){.orig=func.orig, .params=checked_params, .return_type=return_type, .is_variadic=func.is_variadic};
        }
      } break;
    case compiler_types_BaseType_Unresolved:
    m_353_3:
      {
        compiler_ast_nodes_AST *node = old->u.unresolved;
        compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, p_e, NULL, p_r);
        if (((bool)res)) {
switch ((res->type)) {
            case compiler_ast_scopes_SymbolType_TypeDef:
            m_355_0:
              {
                resolved=compiler_passes_typechecker_TypeChecker_resolve_type(this, res->u.type_def, p_a, p_e, p_r);
              } break;
            case compiler_ast_scopes_SymbolType_Structure:
            m_355_1:
              {
                compiler_ast_nodes_Structure *struc = res->u.struc;
                if (compiler_ast_scopes_Symbol_is_templated(res) && !(allow_incomplete)) {
                  if (error) {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Cannot use templated struct %s as a type", struc->sym->name)));
                  }
                  return resolved;
                }
                resolved=res->u.struc->type;
                if (node->type==compiler_ast_nodes_ASTType_Specialization && compiler_ast_scopes_Symbol_is_templated(res)) {
                  if(!(!(resolve_templates))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:183:36: Assertion failed: `not resolve_templates`", "Should have been errored in resolve_scoped_identifier"); }
                  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_UnresolvedTemplate, node->span);
                  type->u.unresolved_spec=(compiler_types_UnresolvedTemplate){.base=resolved, .args=node->u.spec.template_args};
                  resolved=type;
                }
              } break;
            case compiler_ast_scopes_SymbolType_Function:
            m_355_2:
              {
                compiler_ast_nodes_Function *func = res->u.func;
                if (compiler_ast_scopes_Symbol_is_templated(res) && !(allow_incomplete)) {
                  if (error) {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Cannot use templated function %s as a type", func->sym->name)));
                  }
                  return resolved;
                }
                resolved=res->u.func->type;
                if (node->type==compiler_ast_nodes_ASTType_Specialization && compiler_ast_scopes_Symbol_is_templated(res)) {
                  if(!(!(resolve_templates))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:199:36: Assertion failed: `not resolve_templates`", "Should have been errored in resolve_scoped_identifier"); }
                  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_UnresolvedTemplate, node->span);
                  type->u.unresolved_spec=(compiler_types_UnresolvedTemplate){.base=resolved, .args=node->u.spec.template_args};
                  resolved=type;
                }
              } break;
            case compiler_ast_scopes_SymbolType_Enum:
            m_355_3:
              {
                compiler_ast_nodes_Enum *enom = res->u.enom;
                if (compiler_ast_scopes_Symbol_is_templated(res) && !(allow_incomplete)) {
                  if (error) {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Cannot use templated enum %s as a type", enom->sym->name)));
                  }
                  return resolved;
                }
                resolved=res->u.enom->type;
                if (node->type==compiler_ast_nodes_ASTType_Specialization && compiler_ast_scopes_Symbol_is_templated(res)) {
                  if(!(!(resolve_templates))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:215:36: Assertion failed: `not resolve_templates`", "Should have been errored in resolve_scoped_identifier"); }
                  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_UnresolvedTemplate, node->span);
                  type->u.unresolved_spec=(compiler_types_UnresolvedTemplate){.base=resolved, .args=node->u.spec.template_args};
                  resolved=type;
                }
              } break;
            default:
              {
                if (error) {
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(res->span, std_format("Cannot use %s as a type", res->display)));
                  resolved=NULL;
                }
              } break;
          }        } else {
          if (error) {
            resolved=NULL;
          }
        }
      } break;
    case compiler_types_BaseType_Array:
    m_353_4:
      {
        compiler_types_ArrayType arr = old->u.arr;
        compiler_types_Type *elem_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, arr.elem_type, p_a, p_e, p_r);
        compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, arr.size_expr, NULL);
        resolved=compiler_types_Type_shallow_copy(old);
        resolved->u.arr.elem_type=elem_type;
        compiler_passes_typechecker_TypeChecker_try_infer_array_size(this, &resolved->u.arr);
      } break;
    case compiler_types_BaseType_VectorShorthand:
    m_353_5:
      {
        if (!((this->o->program->did_cache_symbols && ((bool)this->o->program->cached_symbols.std_vector)))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, "Vector shorthand not available"));
          resolved=NULL;
        } else {
          compiler_ast_scopes_Symbol *std_vector = this->o->program->cached_symbols.std_vector;
          compiler_types_Type *elem_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.ptr, p_a, p_e, p_r);
          if (!(((bool)elem_type))) {
            return NULL;
          }
          compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, std_vector, ({
            std_vector_Vector__0 *_vc356 = std_vector_Vector__0_new(1);
            std_vector_Vector__0_push(_vc356, elem_type);
            _vc356;}), old->span);
          if(!(res->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:253:24: Assertion failed: `res.type == Structure`", NULL); }
          old->sym=res;
          resolved=compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, old->span);
          resolved->u.ptr=res->u.struc->type;
        }
      } break;
    case compiler_types_BaseType_MapShorthand:
    m_353_6:
      {
        if (!((this->o->program->did_cache_symbols && ((bool)this->o->program->cached_symbols.std_map)))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, "Map shorthand not available"));
          resolved=NULL;
        } else {
          compiler_ast_scopes_Symbol *std_map = this->o->program->cached_symbols.std_map;
          compiler_types_Type *key_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.map_types.key, p_a, p_e, p_r);
          compiler_types_Type *value_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.map_types.value, p_a, p_e, p_r);
          if (!((((bool)key_type) && ((bool)value_type)))) {
            return NULL;
          }
          compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, std_map, ({
            std_vector_Vector__0 *_vc357 = std_vector_Vector__0_new(2);
            std_vector_Vector__0_push(_vc357, key_type);
            std_vector_Vector__0_push(_vc357, value_type);
            _vc357;}), old->span);
          if(!(res->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:270:24: Assertion failed: `res.type == Structure`", NULL); }
          old->sym=res;
          resolved=compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, old->span);
          resolved->u.ptr=res->u.struc->type;
        }
      } break;
    case compiler_types_BaseType_Structure:
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    case compiler_types_BaseType_Enum:
    m_353_7:
      {
      } break;
    default:
      {
        if (error) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Unhandled type in resolve %s", compiler_types_BaseType_str(old->base))));
          resolved=NULL;
        }
      } break;
  }  return resolved;
}

void compiler_passes_typechecker_TypeChecker_try_infer_array_size(compiler_passes_typechecker_TypeChecker *this, compiler_types_ArrayType *arr_typ) {
  compiler_ast_nodes_AST *size_expr = arr_typ->size_expr;
  if (size_expr->type==compiler_ast_nodes_ASTType_IntLiteral) {
    if (((bool)size_expr->u.num_literal.suffix)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(size_expr->span, "Array size literal cannot have a suffix"));
    }
    arr_typ->size_known=true;
    arr_typ->size=str_to_u32(size_expr->u.num_literal.text);
  }
}

void compiler_passes_typechecker_TypeChecker_resolve_templated_methods(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old_type, compiler_types_Type *cur_type) {
  std_map_Map__9 *old_methods = old_type->methods;
  std_map_Map__9 *cur_methods = cur_type->methods;
  compiler_ast_program_Namespace *parent_ns = old_type->sym->ns;
  for (std_map_Iterator__9 _i174 = std_map_Map__9_iter(old_methods); std_map_Iterator__9_has_value(&_i174); std_map_Iterator__9_next(&_i174)) {
    std_map_Item__9 *iter = std_map_Iterator__9_cur(&_i174);
    {
      char *name = iter->key;
      compiler_ast_nodes_Function *method = iter->value;
      compiler_ast_nodes_Function *new_method = compiler_ast_program_get_deep_copy__0(this->o->program, method, parent_ns, compiler_parser_Parser_parse_function);
      new_method->operator_overloads=method->operator_overloads;
      new_method->parent_type=cur_type;
      std_map_Map__9_insert(cur_methods, name, new_method);
      compiler_ast_scopes_Symbol_update_parent(new_method->sym, cur_type->sym);
      std_vector_Vector__8_push(parent_ns->functions, new_method);
      if (!(method->is_static)) {
        compiler_ast_nodes_Variable *this_param = std_vector_Vector__4_at(new_method->params, 0);
        if (this_param->type->base==compiler_types_BaseType_Pointer) {
          this_param->type->u.ptr=cur_type;
        } else {
          this_param->type=cur_type;
        }
      }
      new_method->scope=compiler_passes_typechecker_TypeChecker_scope(this);
      compiler_passes_typechecker_TypeChecker_check_function_declaration(this, new_method);
      std_vector_Vector__8_push(this->unchecked_functions, new_method);
    }
  }
}

void compiler_passes_typechecker_TypeChecker_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc, compiler_ast_scopes_TemplateInstance *instance) {
  compiler_ast_scopes_Symbol *sym = instance->resolved;
  compiler_ast_nodes_Structure *resolved_struc = compiler_ast_program_get_deep_copy__1(this->o->program, struc, struc->sym->ns, compiler_parser_Parser_parse_struct);
  resolved_struc->sym->template=NULL;
  resolved_struc->sym=sym;
  sym->u.struc=resolved_struc;
  resolved_struc->format_spec=struc->format_spec;
  resolved_struc->format_args=struc->format_args;
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Structure, sym->span);
  typ->u.struc=resolved_struc;
  resolved_struc->type=typ;
  typ->sym=sym;
  typ->template_instance=instance;
  compiler_passes_typechecker_TypeChecker_resolve_struct(this, resolved_struc);
  compiler_passes_typechecker_TypeChecker_resolve_templated_methods(this, struc->type, resolved_struc->type);
}

void compiler_passes_typechecker_TypeChecker_resolve_templated_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_scopes_TemplateInstance *instance) {
  compiler_ast_scopes_Symbol *sym = instance->resolved;
  compiler_ast_nodes_Enum *resolved_enom = compiler_ast_program_get_deep_copy__2(this->o->program, enom, enom->sym->ns, compiler_parser_Parser_parse_enum);
  resolved_enom->sym->template=NULL;
  resolved_enom->sym=sym;
  sym->u.enom=resolved_enom;
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Enum, sym->span);
  typ->u.enom=resolved_enom;
  resolved_enom->type=typ;
  typ->sym=sym;
  typ->template_instance=instance;
  for (std_vector_Iterator__20 _i175 = std_vector_Vector__20_iter(resolved_enom->variants); std_vector_Iterator__20_has_value(&_i175); std_vector_Iterator__20_next(&_i175)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i175);
    {
      compiler_ast_scopes_Symbol *variant_sym = variant->sym;
      compiler_ast_scopes_Symbol_update_parent(variant_sym, sym);
    }
  }
  for (std_vector_Iterator__4 _i176 = std_vector_Vector__4_iter(resolved_enom->shared_fields); std_vector_Iterator__4_has_value(&_i176); std_vector_Iterator__4_next(&_i176)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i176);
    {
      compiler_ast_scopes_Symbol *field_sym = field->sym;
      compiler_ast_scopes_Symbol_update_parent(field_sym, sym);
    }
  }
  compiler_passes_typechecker_TypeChecker_resolve_enum(this, resolved_enom);
  compiler_passes_typechecker_TypeChecker_resolve_templated_methods(this, enom->type, resolved_enom->type);
}

void compiler_passes_typechecker_TypeChecker_resolve_templated_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_scopes_TemplateInstance *instance) {
  compiler_ast_scopes_Symbol *sym = instance->resolved;
  compiler_ast_nodes_Function *resolved_func = compiler_ast_program_get_deep_copy__0(this->o->program, func, func->sym->ns, compiler_parser_Parser_parse_function);
  resolved_func->operator_overloads=func->operator_overloads;
  resolved_func->sym->template=NULL;
  resolved_func->sym=sym;
  if (((bool)func->parent_type)) {
    compiler_ast_scopes_Symbol_update_parent(sym, func->parent_type->sym);
  }
  sym->u.func=resolved_func;
  resolved_func->scope=compiler_passes_typechecker_TypeChecker_scope(this);
  compiler_passes_typechecker_TypeChecker_check_function_declaration(this, resolved_func);
  resolved_func->type->template_instance=instance;
  std_vector_Vector__8_push(this->unchecked_functions, resolved_func);
}

compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_find_template_instance(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__5 *template_instances, std_vector_Vector__0 *args) {
  for (std_vector_Iterator__5 _i177 = std_vector_Vector__5_iter(template_instances); std_vector_Iterator__5_has_value(&_i177); std_vector_Iterator__5_next(&_i177)) {
    compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i177);
    {
      if (compiler_ast_scopes_TemplateInstance_matches(instance, args)) {
        return instance->resolved;
      }
    }
  }
  return NULL;
}

compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym, std_vector_Vector__0 *template_args, std_span_Span span) {
  std_vector_Vector__10 *template_params = sym->template->params;
  if (template_params->size != template_args->size) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Invalid number of template arguments for %s", sym->name)));
    return NULL;
  }
  {
    compiler_ast_scopes_Symbol *found = compiler_passes_typechecker_TypeChecker_find_template_instance(this, sym->template->instances, template_args);
    if (((bool)found)) {
      return found;
    }
  }
  compiler_ast_program_Namespace *parent_ns = sym->ns;
  std_buffer_Buffer new_display_name = std_buffer_Buffer_make(16);
  std_buffer_Buffer_write_str(&new_display_name, sym->display);
  std_buffer_Buffer_write_str(&new_display_name, "<");
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(sym->ns->scope);
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);
  bool was_in_template_instance = this->in_template_instance;
  this->in_template_instance=true;
  for (u32 i = 0; i < template_params->size; i+=1) {
    compiler_ast_scopes_Symbol *sym = std_vector_Vector__10_at(template_params, i);
    compiler_types_Type *arg = std_vector_Vector__0_at(template_args, i);
    if (i > 0) {
      std_buffer_Buffer_write_str(&new_display_name, ", ");
    }
    std_buffer_Buffer_write_str(&new_display_name, compiler_types_Type_str(arg));
    compiler_ast_scopes_Symbol *cur_sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, sym->name, sym->name, sym->name, sym->span);
    cur_sym->u.type_def=arg;
    compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, cur_sym, NULL);
  }
  std_buffer_Buffer_write_str(&new_display_name, ">");
  char *new_out_name = std_format("%s__%u", sym->name, sym->template->instances->size);
  compiler_ast_scopes_Symbol *new_sym = compiler_ast_scopes_Symbol_new_with_parent(sym->type, parent_ns, parent_ns->sym, new_out_name, sym->span);
  new_sym->display=std_buffer_Buffer_str(new_display_name);
  compiler_ast_scopes_TemplateInstance *instance = compiler_ast_scopes_TemplateInstance_new(template_args, sym, new_sym);
  std_vector_Vector__5_push(sym->template->instances, instance);
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_358_0:
      {
        compiler_passes_typechecker_TypeChecker_resolve_templated_struct(this, sym->u.struc, instance);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_358_1:
      {
        compiler_passes_typechecker_TypeChecker_resolve_templated_enum(this, sym->u.enom, instance);
      } break;
    case compiler_ast_scopes_SymbolType_Function:
    m_358_2:
      {
        compiler_passes_typechecker_TypeChecker_resolve_templated_function(this, sym->u.func, instance);
      } break;
    default:
      {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Cannot specialize non-templated symbol %s", sym->name)));
        /* defers */
        this->in_template_instance=was_in_template_instance;
        return NULL;
      } break;
  }  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
  /* defers */
  this->in_template_instance=was_in_template_instance;
  return new_sym;
}

compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool error, compiler_types_Type *hint, bool resolve_templates) {
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_NSLookup:
    m_359_0:
      {
        std_span_Span lhs_span = node->u.lookup.lhs->span;
        compiler_ast_scopes_Symbol *lhs = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node->u.lookup.lhs, error, NULL, resolve_templates);
        if (!(((bool)lhs))) {
          return NULL;
        }
        char *name = node->u.lookup.rhs_name;
        if (!(((bool)name))) {
          return NULL;
        }
        compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(this->o, lhs, name, node->span, error);
        compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, res);
        return res;
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    m_359_1:
      {
        char *name = node->u.ident.name;
        compiler_ast_scopes_Symbol *res = NULL;
        if (((bool)hint)) {
switch ((hint->base)) {
            case compiler_types_BaseType_Enum:
            m_360_0:
              {
                compiler_ast_nodes_Enum *enom = hint->u.enom;
                compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_Enum_get_variant(enom, name);
                if (((bool)variant)) {
                  res=variant->sym;
                }
              } break;
            default:
              {
              } break;
          }        }
        if (!(((bool)res))) {
          res=compiler_ast_scopes_Scope_lookup_recursive(compiler_passes_typechecker_TypeChecker_scope(this), name);
        }
        if (!(((bool)res))) {
          compiler_ast_scopes_Scope *scope = compiler_passes_typechecker_TypeChecker_scope(this);
          if (((bool)scope->cur_func)) {
            compiler_ast_nodes_Function *cur_func = scope->cur_func;
            if (cur_func->kind==compiler_ast_nodes_FunctionKind_Closure) {
              compiler_ast_scopes_Symbol *tmp = compiler_ast_scopes_Scope_lookup_recursive(scope->cur_func->closure_scope, name);
              if (!(((bool)tmp))) {
              } else if (tmp->type != compiler_ast_scopes_SymbolType_Variable) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can't close over non-variable %s", name)));
              } else {
                std_map_Item__5 *it = std_map_Map__5_get_item(cur_func->closed_vars, name);
                if (((bool)it)) {
                  res=it->value;
                } else {
                  compiler_ast_scopes_Symbol *closed_sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_ClosedVariable, NULL, name, name, name, node->span);
                  closed_sym->u.closed_var=(compiler_ast_scopes_ClosedVariable){.orig=tmp->u.var, .closure=cur_func};
                  std_map_Map__5_insert(cur_func->closed_vars, name, closed_sym);
                  res=closed_sym;
                }
              }
            }
          }
        }
        compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, res);
        if (error && !(((bool)res))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Couldn't find this identifier: %s", name)));
        }
        return res;
      } break;
    case compiler_ast_nodes_ASTType_Specialization:
    m_359_2:
      {
        compiler_ast_scopes_Symbol *base = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node->u.spec.base, error, hint, resolve_templates);
        if (!(((bool)base))) {
          return NULL;
        }
        base=compiler_ast_scopes_Symbol_remove_alias(base);
        if (!(compiler_ast_scopes_Symbol_is_templated(base))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot specialize non-templated symbol %s", base->name)));
          return NULL;
        }
        std_vector_Vector__0 *args = node->u.spec.parsed_template_args;
        std_vector_Vector__0 *resolved_args = std_vector_Vector__0_new(args->size);
        bool failed = false;
        for (u32 i = 0; i < args->size; i+=1) {
          compiler_types_Type *resolved_arg = compiler_passes_typechecker_TypeChecker_resolve_type(this, std_vector_Vector__0_at(args, i), true, error, resolve_templates);
          if (!(((bool)resolved_arg))) {
            failed=true;
            continue;
          }
          std_vector_Vector__0_push(resolved_args, resolved_arg);
        }
        if (failed) {
          return NULL;
        }
        node->u.spec.template_args=resolved_args;
        if (!(resolve_templates)) {
          compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, base);
          return base;
        }
        return compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, base, resolved_args, node->span);
      } break;
    default:
      {
        if (error) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Don't know how to resolve node type %s", compiler_ast_nodes_ASTType_dbg(node->type))));
        }
        return NULL;
      } break;
  }}

void compiler_passes_typechecker_TypeChecker_check_block(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {
  compiler_ast_nodes_Block *block = &node->u.block;
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));
  scope->can_yield=(scope->can_yield || is_expr);
  block->scope=scope;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, block->scope);
  std_vector_Vector__15 *stmts = block->statements;
  std_span_Span yield_span = std_span_Span_default();
  for (std_vector_Iterator__15 _i178 = std_vector_Vector__15_iter(stmts); std_vector_Iterator__15_has_value(&_i178); std_vector_Iterator__15_next(&_i178)) {
    compiler_ast_nodes_AST *stmt = std_vector_Iterator__15_cur(&_i178);
    {
      compiler_passes_typechecker_TypeChecker_check_statement(this, stmt);
      if (stmt->returns) {
        node->returns=true;
      }
      if (stmt->type != compiler_ast_nodes_ASTType_Yield) {
        continue;
      }
      if (((bool)node->etype)) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(stmt->span, "Cannot yield multiple times in a block", yield_span, "Previously yielded here"));
      }
      node->etype=stmt->etype;
      yield_span=stmt->span;
      node->u.block.final_stmt=stmt;
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_check_method_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *method, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  if ((callee->type != compiler_ast_nodes_ASTType_Member) && (callee->type != compiler_ast_nodes_ASTType_NSLookup)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, "Method call is not to a member, internal compiler error"));
    return;
  }
  if (callee->type != compiler_ast_nodes_ASTType_Member) {
    return;
  }
  if (method->params->size==0) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, "Instance method should have `this` argument, internal error"));
    return;
  }
  compiler_types_Type *method_param = std_vector_Vector__4_at(method->params, 0)->type;
  if (!(((bool)method_param))) {
    return;
  }
  compiler_ast_nodes_Member member = callee->u.member;
  compiler_ast_nodes_AST *first_arg = member.lhs;
  if (member.is_pointer && (method_param->base != compiler_types_BaseType_Pointer)) {
    first_arg=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Dereference, first_arg->span, first_arg);
  } else if (!(member.is_pointer) && method_param->base==compiler_types_BaseType_Pointer) {
    first_arg=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, first_arg->span, first_arg);
  }
  std_vector_Vector__9_push_front(node->u.call.args, compiler_ast_nodes_Argument_new(first_arg, NULL));
}

void compiler_passes_typechecker_TypeChecker_check_union_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params) {
  std_vector_Vector__9 *args = node->u.call.args;
  if (args->size != 1) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Union constructors must have exactly one field")));
    for (std_vector_Iterator__9 _i179 = std_vector_Vector__9_iter(args); std_vector_Iterator__9_has_value(&_i179); std_vector_Iterator__9_next(&_i179)) {
      compiler_ast_nodes_Argument *arg = std_vector_Iterator__9_cur(&_i179);
      {
        compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      }
    }
    return;
  }
  compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, 0);
  if (!(((bool)arg->label))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Union constructors must have a label for the field")));
    compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
    return;
  }
  compiler_ast_nodes_Variable *param = NULL;
  for (std_vector_Iterator__4 _i180 = std_vector_Vector__4_iter(params); std_vector_Iterator__4_has_value(&_i180); std_vector_Iterator__4_next(&_i180)) {
    compiler_ast_nodes_Variable *p = std_vector_Iterator__4_cur(&_i180);
    {
      if (((bool)p->sym) && str_eq(p->sym->name, arg->label)) {
        param=p;
        break;
      }
    }
  }
  if (!(((bool)param))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Unknown field %s in union constructor", arg->label)));
    compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
    return;
  }
  compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, param->type);
  if (((bool)arg_type) && !(compiler_types_Type_eq(arg_type, param->type, false))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", arg->label, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type)), param->sym->span, "Parameter defined here"));
  }
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  node->u.call.call_type=compiler_ast_nodes_CallType_StructConstructor;
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  compiler_ast_scopes_Symbol *type_sym = compiler_ast_scopes_Symbol_remove_alias(callee->resolved_symbol);
  if(!(type_sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:710:12: Assertion failed: `type_sym.type == Structure`", std_format("Got non-struct type in check_constructor: %s", compiler_ast_scopes_SymbolType_dbg(type_sym->type))); }
  compiler_ast_nodes_Structure *struc = type_sym->u.struc;
  std_vector_Vector__4 *params = struc->fields;
  if (struc->is_union) {
    compiler_passes_typechecker_TypeChecker_check_union_constructor(this, node, params);
  } else {
    compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, false);
  }
  return struc->type;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_enum_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  node->u.call.call_type=compiler_ast_nodes_CallType_EnumConstructor;
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  compiler_ast_scopes_Symbol *type_sym = compiler_ast_scopes_Symbol_remove_alias(callee->resolved_symbol);
  if(!(type_sym->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:729:12: Assertion failed: `type_sym.type == EnumVariant`", std_format("Got non-struct type in check_constructor: %s", compiler_ast_scopes_SymbolType_dbg(type_sym->type))); }
  compiler_ast_nodes_EnumVariant *variant = type_sym->u.enum_var;
  compiler_ast_nodes_Enum *enom = variant->parent;
  u32 num_expected_fields = compiler_ast_nodes_EnumVariant_num_fields(variant);
  std_vector_Vector__4 *params = std_vector_Vector__4_new(16);
  for (u32 i = 0; i < num_expected_fields; i+=1) {
    compiler_ast_nodes_Variable *field = compiler_ast_nodes_EnumVariant_get_field_by_idx(variant, i);
    std_vector_Vector__4_push(params, field);
  }
  std_vector_Vector__9 *args = node->u.call.args;
  if (num_expected_fields==0 && args->size==0) {
    std_span_Span span = std_span_Span_join(node->u.call.open_paren_span, node->u.call.close_paren_span);
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Unnecessary empty constructor for %s, no fields expected", variant->sym->display)));
    return variant->parent->type;
  }
  compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, false);
  std_vector_Vector__4_clear(params);
  return enom->type;
}

void compiler_passes_typechecker_TypeChecker_check_call_args_labelled(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params, u32 start) {
  std_vector_Vector__9 *args = node->u.call.args;
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  std_vector_Vector__9 *new_args = std_vector_Vector__9_new(16);
  std_map_Map__10 *kwargs = std_map_Map__10_new(8);
  std_map_Map__11 *expected_params = std_map_Map__11_new(8);
  for (u32 i = 0; i < params->size; i++) {
    compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(params, i);
    if (!(((bool)param->sym))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(param->type->span, "Not allowed to have unlabeled parameter here"));
      continue;
    }
    std_map_Map__11_insert(expected_params, param->sym->name, param);
    if (i < start) {
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      std_map_Map__10_insert(kwargs, param->sym->name, arg);
      std_vector_Vector__9_push(new_args, std_vector_Vector__9_at(args, i));
    }
  }
  for (u32 i = start; i < args->size; i++) {
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    if (!(((bool)arg->label))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, "Can't have positional arguments after labelled arguments"));
      continue;
    }
    std_map_Item__11 *param_item = std_map_Map__11_get_item(expected_params, arg->label);
    std_map_Item__10 *kwarg_item = std_map_Map__10_get_item(kwargs, arg->label);
    compiler_types_Type *expected_type = NULL;
    if (!(((bool)param_item))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, std_format("Unknown labelled argument `%s`", arg->label)));
    } else if (((bool)kwarg_item)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->label_span, std_format("Duplicate argument for parameter `%s`", arg->label), kwarg_item->value->expr->span, "Previously specified here"));
    } else {
      std_map_Map__10_insert(kwargs, arg->label, arg);
      expected_type=param_item->value->type;
    }
    compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, expected_type);
    if ((((bool)arg_type) && ((bool)expected_type)) && !(compiler_types_Type_eq(arg_type, expected_type, false))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", arg->label, compiler_types_Type_str(expected_type), compiler_types_Type_str(arg_type)), param_item->value->sym->span, "Parameter defined here"));
    }
  }
  for (u32 i = start; i < params->size; i++) {
    compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(params, i);
    if(!(((bool)param->sym))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:809:16: Assertion failed: `param.sym?`", std_format("Expected a symbol for parameter %u", i)); }
    std_map_Item__10 *item = std_map_Map__10_get_item(kwargs, param->sym->name);
    if (((bool)item)) {
      std_vector_Vector__9_push(new_args, item->value);
    } else if (((bool)param->default_value)) {
      compiler_ast_nodes_Argument *new_arg = compiler_ast_nodes_Argument_new(param->default_value, NULL);
      std_vector_Vector__9_push(new_args, new_arg);
    } else {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->u.call.close_paren_span, std_format("Missing required argument `%s` of type %s", param->sym->name, compiler_types_Type_str(param->type)), param->sym->span, "Parameter defined here"));
    }
  }
  std_vector_Vector__9_free(args);
  std_map_Map__10_free(kwargs);
  std_map_Map__11_free(expected_params);
  node->u.call.args=new_args;
}

void compiler_passes_typechecker_TypeChecker_check_call_args(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__4 *params, bool is_variadic) {
  std_vector_Vector__9 *args = node->u.call.args;
  for (u32 i = 0; i < params->size; i++) {
    compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(params, i);
    if (i >= args->size) {
      if (((bool)param->default_value)) {
        compiler_ast_nodes_Argument *new_arg = compiler_ast_nodes_Argument_new(param->default_value, NULL);
        std_vector_Vector__9_push(args, new_arg);
      } else {
        if (((bool)param->sym)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->u.call.close_paren_span, std_format("Missing required argument `%s` of type %s", param->sym->name, compiler_types_Type_str(param->type)), param->sym->span, "Parameter defined here"));
        } else {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.call.close_paren_span, std_format("Missing required field %u of type %s", i, compiler_types_Type_str(param->type))));
        }
      }
      continue;
    }
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    if (((bool)arg->label)) {
      if (!(((bool)param->sym))) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, "Cannot use a labelled argument for a non-labeled parameter"));
      } else if (!(str_eq(arg->label, param->sym->name))) {
        if (is_variadic) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, std_format("Variadic functions not allowed with default arguments")));
        }
        compiler_passes_typechecker_TypeChecker_check_call_args_labelled(this, node, params, i);
        break;
      } else {
      }
    }
    compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, param->type);
    if (!(((bool)arg_type)) || !(((bool)param->type))) {
      continue;
    }
    if (!(compiler_types_Type_eq(arg_type, param->type, false))) {
      if (((bool)param->sym)) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", param->sym->name, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type)), param->sym->span, "Parameter defined here"));
      } else {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Expected field %u with type %s, but got %s", i, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type))));
      }
    }
  }
  args=node->u.call.args;
  if (is_variadic) {
    for (u32 i = params->size; i < args->size; i++) {
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      if (!(((bool)arg_type))) {
        continue;
      }
    }
  } else {
    for (u32 i = params->size; i < args->size; i++) {
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Unexpected argument, expected only %u", params->size)));
    }
  }
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  std_vector_Vector__9 *args = node->u.call.args;
  compiler_types_Type *res = ({compiler_types_Type *__yv_361;
switch ((callee->type)) {
      case compiler_ast_nodes_ASTType_Member:
      m_362_0:
        {
          __yv_361 = compiler_passes_typechecker_TypeChecker_check_member(this, callee, true, false, NULL);
          goto _l___yv_361;
        } break;
      case compiler_ast_nodes_ASTType_TryMember:
      m_362_1:
        {
          __yv_361 = compiler_passes_typechecker_TypeChecker_check_member(this, callee, true, true, NULL);
          goto _l___yv_361;
        } break;
      case compiler_ast_nodes_ASTType_Identifier:
      case compiler_ast_nodes_ASTType_NSLookup:
      case compiler_ast_nodes_ASTType_Specialization:
      m_362_2:
        {
          compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, callee, true, hint, true);
          __yv_361 = ({compiler_types_Type *__yv_363;
            if (((bool)sym)) {
              sym=compiler_ast_scopes_Symbol_remove_alias(sym);
              compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, callee, sym);
              __yv_363 = ({compiler_types_Type *__yv_364;
switch ((sym->type)) {
                  case compiler_ast_scopes_SymbolType_Structure:
                  case compiler_ast_scopes_SymbolType_TypeDef:
                  m_365_0:
                    {
                      node->u.call.call_type=compiler_ast_nodes_CallType_StructConstructor;
                      return compiler_passes_typechecker_TypeChecker_check_constructor(this, node);
                    } break;
                  case compiler_ast_scopes_SymbolType_EnumVariant:
                  m_365_1:
                    {
                      node->u.call.call_type=compiler_ast_nodes_CallType_EnumConstructor;
                      return compiler_passes_typechecker_TypeChecker_check_enum_constructor(this, node);
                    } break;
                  default:
                    {
                      __yv_364 = compiler_passes_typechecker_TypeChecker_check_expression(this, callee, NULL);
                      goto _l___yv_364;
                    } break;
                }
_l___yv_364:
              __yv_364;});
              goto _l___yv_363;
            } else {
              __yv_363 = this->o->error_type;
              goto _l___yv_363;
            }
_l___yv_363:
          __yv_363;});
          goto _l___yv_361;
        } break;
      default:
        {
          __yv_361 = compiler_passes_typechecker_TypeChecker_check_expression(this, callee, NULL);
          goto _l___yv_361;
        } break;
    }
_l___yv_361:
  __yv_361;});
  node->u.call.call_type=compiler_ast_nodes_CallType_Normal;
  if (((bool)res)) {
    if (res->base==compiler_types_BaseType_Pointer && res->u.ptr->base==compiler_types_BaseType_FunctionPtr) {
      res=res->u.ptr;
    } else if (!(compiler_types_BaseType_is_callable(res->base))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, std_format("Cannot call a non-function type: %s", compiler_types_Type_str(res))));
      res=this->o->error_type;
    }
  } else {
    res=this->o->error_type;
  }
  if (res->base==compiler_types_BaseType_Error) {
    for (std_vector_Iterator__9 _i181 = std_vector_Vector__9_iter(args); std_vector_Iterator__9_has_value(&_i181); std_vector_Iterator__9_next(&_i181)) {
      compiler_ast_nodes_Argument *arg = std_vector_Iterator__9_cur(&_i181);
      {
        compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      }
    }
    return NULL;
  }
  compiler_types_FunctionType func = res->u.func;
  if (((bool)func.orig) && func.orig->exits) {
    node->returns=true;
  }
  std_vector_Vector__4 *params = func.params;
  if ((((bool)func.orig) && func.orig->kind==compiler_ast_nodes_FunctionKind_Method) && !(func.orig->is_static)) {
    compiler_passes_typechecker_TypeChecker_check_method_call(this, func.orig, node);
  }
  if (res->base==compiler_types_BaseType_Closure) {
    node->u.call.call_type=compiler_ast_nodes_CallType_Closure;
  }
  compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, func.is_variadic);
  bool is_variadic_format = (((bool)func.orig) && func.orig->is_variadic_format);
  if (is_variadic_format && (args->size >= params->size)) {
    std_vector_Vector__9 *args = node->u.call.args;
    compiler_ast_nodes_Variable *param = std_vector_Vector__4_back(params, 0);
    compiler_ast_nodes_AST *arg = std_vector_Vector__9_at(args, (params->size - 1))->expr;
    if (!(compiler_types_Type_is_str(param->type))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func.orig->sym->span, "Variadic-format function must have last positional argument of type 'str'"));
    }
switch ((arg->type)) {
      case compiler_ast_nodes_ASTType_StringLiteral:
      case compiler_ast_nodes_ASTType_FormatStringLiteral:
      m_366_0:
        {
        } break;
      default:
                  if (arg->etype==compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", arg->span)) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->span, "Expected a string literal for variadic-format function"));
          }
         break;
    }    for (u32 i = params->size; i < args->size; i++) {
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(this, &arg->expr);
    }
  }
  if (((bool)func.orig)) {
    node->u.call.is_function_pointer=false;
    node->u.call.func=func.orig;
  }
  return func.return_type;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_pointer_arith(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {
  compiler_ast_operators_Operator op = node->u.binary.op;
  if (op==compiler_ast_operators_Operator_Plus || op==compiler_ast_operators_Operator_Minus) {
    if (lhs->base==compiler_types_BaseType_Pointer && compiler_types_Type_is_integer(rhs)) {
      return lhs;
    }
    if (compiler_types_Type_is_integer(lhs) && rhs->base==compiler_types_BaseType_Pointer) {
      return rhs;
    }
    if (compiler_types_Type_eq(lhs, rhs, false) && lhs->base==compiler_types_BaseType_Pointer) {
      if (op==compiler_ast_operators_Operator_Minus) {
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I64, node->span);
      }
    }
  }
  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Invalid pointer arithmetic"));
  return NULL;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_operators_Operator op, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *arg1, compiler_ast_nodes_AST *arg2, compiler_ast_nodes_AST *arg3) {
  if (compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(op)) {
    if (compiler_ast_nodes_AST_is_lvalue(arg1) && (arg1->etype->base != compiler_types_BaseType_Pointer)) {
      arg1=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, arg1->span, arg1);
      if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg1, NULL)))) {
        return NULL;
      }
    }
  }
  compiler_ast_operators_OperatorOverload overload = {0};
  overload.op=op;
  if (((bool)arg1)) {
    overload.type1=arg1->etype;
  }
  if (((bool)arg2)) {
    overload.type2=arg2->etype;
  }
  if (((bool)arg3)) {
    overload.type3=arg3->etype;
  }
  compiler_ast_nodes_Function *func = std_map_Map__6_get(this->o->program->operator_overloads, overload, NULL);
  if (!(((bool)func))) {
    return NULL;
  }
  compiler_ast_nodes_AST *callee = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_OverloadedOperator, node->u.binary.op_span);
  callee->u.operator_span=({std_span_Span __yv_367;
switch ((node->type)) {
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_368_0:
        {
          __yv_367 = node->u.binary.op_span;
          goto _l___yv_367;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_368_1:
        {
          __yv_367 = node->u.unary.op_span;
          goto _l___yv_367;
        } break;
      default:
        {
          __yv_367 = node->span;
          goto _l___yv_367;
        } break;
    }
_l___yv_367:
  __yv_367;});
  compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, callee, func->sym);
  std_vector_Vector__9 *args = std_vector_Vector__9_new(16);
  if (((bool)arg1)) {
    std_vector_Vector__9_push(args, compiler_ast_nodes_Argument_new(arg1, NULL));
  }
  if (((bool)arg2)) {
    std_vector_Vector__9_push(args, compiler_ast_nodes_Argument_new(arg2, NULL));
  }
  if (((bool)arg3)) {
    std_vector_Vector__9_push(args, compiler_ast_nodes_Argument_new(arg3, NULL));
  }
  node->type=compiler_ast_nodes_ASTType_Call;
  node->u.call.callee=callee;
  node->u.call.args=args;
  node->etype=func->return_type;
  return func->return_type;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_binary_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {
  compiler_ast_operators_Operator op = node->u.binary.op;
  compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, op, node, node->u.binary.lhs, node->u.binary.rhs, NULL);
  if (((bool)res)) {
    return res;
  }
switch ((op)) {
    case compiler_ast_operators_Operator_Plus:
    case compiler_ast_operators_Operator_Minus:
    case compiler_ast_operators_Operator_Multiply:
    case compiler_ast_operators_Operator_Divide:
    m_369_0:
      {
        if (lhs->base==compiler_types_BaseType_Pointer || rhs->base==compiler_types_BaseType_Pointer) {
          return compiler_passes_typechecker_TypeChecker_check_pointer_arith(this, node, lhs, rhs);
        } else if (!(compiler_types_Type_is_numeric(lhs)) || !(compiler_types_Type_is_numeric(rhs))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        } else if (!(compiler_types_Type_eq(lhs, rhs, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        } else {
          return lhs;
        }
      } break;
    case compiler_ast_operators_Operator_PlusEquals:
    case compiler_ast_operators_Operator_MinusEquals:
    case compiler_ast_operators_Operator_DivideEquals:
    case compiler_ast_operators_Operator_MultiplyEquals:
    m_369_1:
      {
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;
        if (!(compiler_ast_nodes_AST_is_lvalue(lhs_node))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Left hand side of assignment must be assignable"));
          return NULL;
        }
        if (!(compiler_types_Type_is_numeric(lhs)) || !(compiler_types_Type_is_numeric(rhs))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        return lhs;
      } break;
    case compiler_ast_operators_Operator_LessThan:
    case compiler_ast_operators_Operator_LessThanEquals:
    case compiler_ast_operators_Operator_GreaterThan:
    case compiler_ast_operators_Operator_GreaterThanEquals:
    m_369_2:
      {
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }
        lhs=compiler_types_Type_unaliased(lhs);
        if (!(compiler_types_Type_is_numeric_or_char(lhs)) && (lhs->base != compiler_types_BaseType_Pointer)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_Equals:
    m_369_3:
      {
        bool is_invalid = ({bool __yv_370;
          if (!(compiler_types_Type_eq(lhs, rhs, false))) {
            __yv_370 = true;
            goto _l___yv_370;
          } else if (lhs->base==compiler_types_BaseType_Structure) {
            __yv_370 = true;
            goto _l___yv_370;
          } else if (lhs->base==compiler_types_BaseType_Enum) {
            __yv_370 = ({bool __yv_371;
              if (lhs->u.enom->has_values) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support non-trivial enum `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs))));
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              } else {
                __yv_371 = false;
                goto _l___yv_371;
              }
_l___yv_371:
            __yv_371;});
            goto _l___yv_370;
          } else {
            __yv_370 = false;
            goto _l___yv_370;
          }

_l___yv_370:
        __yv_370;});
        if (is_invalid) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_NotEquals:
    m_369_4:
      {
        bool is_invalid = ({bool __yv_372;
          if (!(compiler_types_Type_eq(lhs, rhs, false))) {
            __yv_372 = true;
            goto _l___yv_372;
          } else if (lhs->base==compiler_types_BaseType_Structure) {
            __yv_372 = true;
            goto _l___yv_372;
          } else if (lhs->base==compiler_types_BaseType_Enum && lhs->u.enom->has_values) {
            __yv_372 = true;
            goto _l___yv_372;
          } else {
            __yv_372 = false;
            goto _l___yv_372;
          }

_l___yv_372:
        __yv_372;});
        if (is_invalid) {
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_Equals, node, node->u.binary.lhs, node->u.binary.rhs, NULL);
          if (((bool)res)) {
            compiler_ast_nodes_AST *copy = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_UnaryOp, node->span);
            (*copy)=(*node);
            (*node)=(*compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Not, node->span, copy));
            compiler_passes_typechecker_TypeChecker_check_expression(this, node, NULL);
          } else if (lhs->base==compiler_types_BaseType_Enum) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support non-trivial enum `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs))));
          } else {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          }
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_And:
    case compiler_ast_operators_Operator_Or:
    m_369_5:
      {
        if (!(compiler_types_Type_eq(lhs, rhs, false)) || (lhs->base != compiler_types_BaseType_Bool)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_BitwiseXor:
    m_369_6:
      {
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        if ((lhs->base != compiler_types_BaseType_Bool) && !(compiler_types_Type_is_integer(lhs))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Operator requires integer types"));
        }
        return lhs;
      } break;
    case compiler_ast_operators_Operator_Modulus:
    case compiler_ast_operators_Operator_BitwiseOr:
    case compiler_ast_operators_Operator_BitwiseAnd:
    case compiler_ast_operators_Operator_LeftShift:
    case compiler_ast_operators_Operator_RightShift:
    case compiler_ast_operators_Operator_LeftShiftEquals:
    case compiler_ast_operators_Operator_RightShiftEquals:
    m_369_7:
      {
        if (!(compiler_types_Type_is_integer(lhs)) || !(compiler_types_Type_is_integer(rhs))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          return NULL;
        }
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;
switch ((op)) {
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          m_373_0:
                          if (!(compiler_ast_nodes_AST_is_lvalue(lhs_node))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs_node->span, std_format("Must be an l-value")));
                return NULL;
              }
             break;
          default:
            {
            } break;
        }        return lhs;
      } break;
    default:
      {
        std_panic(std_format("Internal error: unhandled op in check_binary_op: %s", compiler_ast_nodes_ASTType_dbg(node->type)));
      } break;
  }}

compiler_passes_typechecker_Formattable compiler_passes_typechecker_TypeChecker_is_formattable(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *typ, compiler_ast_nodes_AST *expr) {
switch ((typ->base)) {
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    case compiler_types_BaseType_Pointer:
    m_374_0:
      {
      } break;
    case compiler_types_BaseType_Enum:
    m_374_1:
              if (typ->u.enom->has_values) {
          return compiler_passes_typechecker_Formattable_No;
        } else {
          return compiler_passes_typechecker_Formattable_Yes;
        }
       break;
    default:
      {
        bool can_format = false;
        if (typ->base==compiler_types_BaseType_Structure) {
          compiler_ast_nodes_Structure *struc = typ->u.struc;
          if (((bool)struc) && ((bool)struc->format_spec)) {
            can_format=true;
          }
        }
        if (can_format) {
switch ((expr->type)) {
            case compiler_ast_nodes_ASTType_Identifier:
            case compiler_ast_nodes_ASTType_Member:
            case compiler_ast_nodes_ASTType_NSLookup:
            m_375_0:
              {
                return compiler_passes_typechecker_Formattable_Yes;
              } break;
            default:
              {
                return compiler_passes_typechecker_Formattable_NotHere;
              } break;
          }        } else {
          return compiler_passes_typechecker_Formattable_No;
        }
      } break;
  }  return compiler_passes_typechecker_Formattable_Yes;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_format_string(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  std_vector_Vector__1 *parts = node->u.fmt_str.parts;
  std_vector_Vector__15 *exprs = node->u.fmt_str.exprs;
  if (parts->size != (exprs->size + 1)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Number of format string parts does not match number of expressions"));
  }
  for (u32 i = 0; i < exprs->size; i+=1) {
    compiler_ast_nodes_AST *expr = std_vector_Vector__15_at(exprs, i);
    compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);
    if (!(((bool)typ))) {
      continue;
    }
    typ=compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(this, &expr);
    exprs->data[i]=expr;
    if (!(((bool)typ))) {
      continue;
    }
    typ=compiler_types_Type_unaliased(typ);
switch ((compiler_passes_typechecker_TypeChecker_is_formattable(this, typ, expr))) {
      case compiler_passes_typechecker_Formattable_No:
      m_376_0:
        {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Type '%s' cannot be formatted automatically", compiler_types_Type_str(typ))));
        } break;
      case compiler_passes_typechecker_Formattable_NotHere:
      m_376_1:
        {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(expr->span, std_format("Can only format %s in simple expressions", typ->sym->display), "Try moving the expression into a variable and formatting that instead"));
        } break;
      default:
        {
        } break;
    }  }
  return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_member(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_being_called, bool is_try, compiler_types_Type *hint) {
  compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.member.lhs, NULL);
  if (!(((bool)lhs))) {
    return NULL;
  }
  if (is_try) {
    if (!(lhs->base==compiler_types_BaseType_Pointer)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.member.lhs->span, "Cannot use ?. on non-pointer LHS"));
    }
  }
  bool is_pointer = false;
  if (lhs->base==compiler_types_BaseType_Pointer) {
    is_pointer=true;
    if (!(((bool)lhs->u.ptr))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs->span, "Got unresolved type"));
      return hint;
    }
    lhs=lhs->u.ptr;
  }
  if (lhs->base==compiler_types_BaseType_UnresolvedTemplate) {
    lhs=lhs->u.unresolved_spec.base;
  }
  char *rhs_name = node->u.member.rhs_name;
  if (!(((bool)rhs_name))) {
    return hint;
  }
  compiler_types_Type *res = ({compiler_types_Type *__yv_377;
switch ((lhs->base)) {
      case compiler_types_BaseType_Structure:
      m_378_0:
        {
          compiler_ast_nodes_Structure *struc = lhs->u.struc;
          compiler_ast_nodes_Variable *field = compiler_ast_nodes_Structure_get_field(struc, rhs_name);
          __yv_377 = ({compiler_types_Type *__yv_379;
            if (((bool)field)) {
              node->u.member.is_pointer=is_pointer;
              compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, field->sym);
              __yv_379 = field->type;
              goto _l___yv_379;
            } else {
              __yv_379 = NULL;
              goto _l___yv_379;
            }

_l___yv_379:
          __yv_379;});
          goto _l___yv_377;
        } break;
      case compiler_types_BaseType_Enum:
      m_378_1:
        {
          compiler_ast_nodes_Enum *enom = lhs->u.enom;
          compiler_ast_nodes_Variable *field = compiler_ast_nodes_Enum_get_shared_field(enom, rhs_name);
          __yv_377 = ({compiler_types_Type *__yv_380;
            if (((bool)field)) {
              node->u.member.is_pointer=is_pointer;
              compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, field->sym);
              __yv_380 = field->type;
              goto _l___yv_380;
            } else {
              __yv_380 = NULL;
              goto _l___yv_380;
            }

_l___yv_380:
          __yv_380;});
          goto _l___yv_377;
        } break;
      default:
        {
          __yv_377 = NULL;
          goto _l___yv_377;
        } break;
    }
_l___yv_377:
  __yv_377;});
  if (((bool)res)) {
    if (is_try && (res->base != compiler_types_BaseType_Pointer)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.member.lhs->span, std_format("Cannot use ?. with non-pointer member type %s", compiler_types_Type_str(res))));
    }
    return res;
  }
  if (!(is_try) && compiler_types_Type_can_have_methods(lhs)) {
    compiler_ast_nodes_Function *method = std_map_Map__9_get(lhs->methods, rhs_name, NULL);
    if (((bool)method)) {
      if (!(is_being_called)) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot access method without calling it"));
        return hint;
      }
      if (method->is_static) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot call static method as instance method"));
        return hint;
      }
      node->u.member.is_pointer=is_pointer;
      compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, method->sym);
      return method->type;
    }
  }
  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Type %s has no member named '%s'", compiler_types_Type_str(lhs), rhs_name)));
  return hint;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {
  if (((bool)node->etype)) {
    return node->etype;
  }
  compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression_helper(this, node, hint);
  if (((bool)typ) && (node->type != compiler_ast_nodes_ASTType_ArrayLiteral)) {
    typ=compiler_types_Type_decay_array(typ);
  }
  node->etype=typ;
  node->hint=(((bool)typ) ? typ : hint);
  return typ;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_index(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint, bool is_being_assigned) {
  compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);
  compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, NULL);
  if (!(((bool)lhs)) || !(((bool)rhs))) {
    return NULL;
  }
  if (!(is_being_assigned)) {
    compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_Index, node, node->u.binary.lhs, node->u.binary.rhs, NULL);
    if (((bool)res)) {
      return res;
    }
  }
  rhs=compiler_types_Type_unaliased(rhs);
  if (!(compiler_types_Type_is_integer(rhs))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Index must be an integer, got %s", compiler_types_Type_str(rhs))));
    return NULL;
  }
  lhs=compiler_types_Type_unaliased(lhs);
switch ((lhs->base)) {
    case compiler_types_BaseType_Array:
    m_381_0:
      {
        return lhs->u.arr.elem_type;
      } break;
    case compiler_types_BaseType_Pointer:
    m_381_1:
      {
        return lhs->u.ptr;
      } break;
    default:
      {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot index type %s", compiler_types_Type_str(lhs))));
        return NULL;
      } break;
  }}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_assignment(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {
  if (!(compiler_ast_nodes_AST_is_lvalue(node->u.binary.lhs))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.binary.lhs->span, "Must be an l-value"));
  }
  if (!(compiler_types_Type_eq(lhs, rhs, false))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.binary.rhs->span, std_format("Variable type does not match assignment type, Expected type '%s', got '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_passes_typechecker_TypeChecker_create_match_for_error_unwrap(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *expr, compiler_passes_typechecker_ErrorPropBase error_prop_base) {
  std_span_Span op_span = node->u.unary.op_span;
  char *res_text = ({char *__yv_382;
switch ((error_prop_base)) {
      case compiler_passes_typechecker_ErrorPropBase_Result:
      m_383_0:
        {
          compiler_types_Type *err_type = std_vector_Vector__0_at(expr->etype->template_instance->args, 1);
          char *panic_txt = ({char *__yv_384;
switch ((compiler_passes_typechecker_TypeChecker_is_formattable(this, err_type, expr))) {
              case compiler_passes_typechecker_Formattable_Yes:
              m_385_0:
                {
                  __yv_384 = std_format("Error unwrapping: {err} (%s:%u:%u)", (expr->span.end).filename, (expr->span.end).line, (expr->span.end).col);
                  goto _l___yv_384;
                } break;
              default:
                {
                  __yv_384 = std_format("Error unwrapping (%s:%u:%u)", (expr->span.end).filename, (expr->span.end).line, (expr->span.end).col);
                  goto _l___yv_384;
                } break;
            }
_l___yv_384:
          __yv_384;});
          __yv_382 = std_format("\n            match x {\n                Ok(val) => val,\n                Error(err) => std::panic(`%s`)\n            }\n            ", panic_txt);
          goto _l___yv_382;
        } break;
      case compiler_passes_typechecker_ErrorPropBase_Option:
      m_383_1:
        {
          __yv_382 = std_format("\n            match x {\n                Some(val) => val,\n                None => std::panic(`Error unwrapping: None (%s:%u:%u)`)\n            }\n            ", (expr->span.end).filename, (expr->span.end).line, (expr->span.end).col);
          goto _l___yv_382;
        } break;
    }
_l___yv_382:
  __yv_382;});
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(res_text, op_span.start.filename, NULL);
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  compiler_parser_Parser parser = compiler_parser_Parser_make(this->o->program, compiler_passes_generic_pass_GenericPass_ns(this->o));
  parser.tokens=tokens;
  parser.curr=0;
  compiler_ast_nodes_AST *match_stmt = compiler_parser_Parser_parse_match(&parser);
  compiler_passes_visitor_Visitor visitor = (compiler_passes_visitor_Visitor){.node_fn=({compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx *_C386 = alloca(sizeof(compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx));_C386->op_span = &op_span;_ClosureTy_2 _ci387 = {._C=_C386, .fn=&compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1};_ci387;}), .type_fn=({compiler_passes_visitor__Closure_4Ctx *_C388 = alloca(sizeof(compiler_passes_visitor__Closure_4Ctx));_ClosureTy_3 _ci389 = {._C=_C388, .fn=&compiler_passes_visitor__Closure_4};_ci389;})};
  compiler_passes_visitor_Visitor_visit_po(&visitor, match_stmt);
  match_stmt->u.match_stmt.expr=expr;
  return match_stmt;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_error_unwrap(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_AST *expr = node->u.unary.expr;
  compiler_types_Type *expr_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);
  if (!(((bool)expr_typ))) {
    return NULL;
  }
  compiler_ast_scopes_Symbol *parent = ({compiler_ast_scopes_TemplateInstance *_t390 = expr_typ->template_instance; _t390 ? _t390->parent : NULL;});
  compiler_passes_typechecker_ErrorPropBase error_prop_base = ({compiler_passes_typechecker_ErrorPropBase __yv_391;
    if (parent==this->o->program->cached_symbols.std_result) {
      __yv_391 = compiler_passes_typechecker_ErrorPropBase_Result;
      goto _l___yv_391;
    } else if (parent==this->o->program->cached_symbols.std_option) {
      __yv_391 = compiler_passes_typechecker_ErrorPropBase_Option;
      goto _l___yv_391;
    } else {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only use !! on Result/Option types, got %s", compiler_types_Type_str(expr_typ))));
      return NULL;
    }

_l___yv_391:
  __yv_391;});
  compiler_types_Type *ok_hint = ({compiler_types_Type *__yv_392;
switch ((error_prop_base)) {
      case compiler_passes_typechecker_ErrorPropBase_Result:
      m_393_0:
        {
          __yv_392 = std_vector_Vector__0_at(expr_typ->template_instance->args, 0);
          goto _l___yv_392;
        } break;
      case compiler_passes_typechecker_ErrorPropBase_Option:
      m_393_1:
        {
          __yv_392 = std_vector_Vector__0_at(expr_typ->template_instance->args, 0);
          goto _l___yv_392;
        } break;
    }
_l___yv_392:
  __yv_392;});
  compiler_ast_nodes_Function *cur_func = compiler_passes_generic_pass_GenericPass_current_func(this->o);
  if (!(((bool)cur_func))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use !! outside of a function"));
    return ok_hint;
  }
  compiler_ast_nodes_AST *match_stmt = compiler_passes_typechecker_TypeChecker_create_match_for_error_unwrap(this, node, expr, error_prop_base);
  compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, match_stmt, ok_hint);
  (*node)=(*match_stmt);
  return res;
}

compiler_ast_nodes_AST *compiler_passes_typechecker_TypeChecker_create_match_for_error_prop(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *expr, compiler_passes_typechecker_ErrorPropBase error_prop_base) {
  std_span_Span op_span = node->u.unary.op_span;
  char *res_text = ({char *__yv_394;
switch ((error_prop_base)) {
      case compiler_passes_typechecker_ErrorPropBase_Result:
      m_395_0:
        {
          __yv_394 = "\n            match x {\n                Ok(val) => val,\n                Error(err) => { return Error(err) }\n            }\n            ";
          goto _l___yv_394;
        } break;
      case compiler_passes_typechecker_ErrorPropBase_Option:
      m_395_1:
        {
          __yv_394 = "\n            match x {\n                Some(val) => val,\n                None => { return None }\n            }\n            ";
          goto _l___yv_394;
        } break;
    }
_l___yv_394:
  __yv_394;});
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(res_text, op_span.start.filename, NULL);
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  compiler_parser_Parser parser = compiler_parser_Parser_make(this->o->program, compiler_passes_generic_pass_GenericPass_ns(this->o));
  parser.tokens=tokens;
  parser.curr=0;
  compiler_ast_nodes_AST *match_stmt = compiler_parser_Parser_parse_match(&parser);
  compiler_passes_visitor_Visitor visitor = (compiler_passes_visitor_Visitor){.node_fn=({compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx *_C396 = alloca(sizeof(compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx));_C396->op_span = &op_span;_ClosureTy_2 _ci397 = {._C=_C396, .fn=&compiler_passes_typechecker_create_match_for_error_prop__Closure_2};_ci397;}), .type_fn=({compiler_passes_visitor__Closure_4Ctx *_C398 = alloca(sizeof(compiler_passes_visitor__Closure_4Ctx));_ClosureTy_3 _ci399 = {._C=_C398, .fn=&compiler_passes_visitor__Closure_4};_ci399;})};
  compiler_passes_visitor_Visitor_visit_po(&visitor, match_stmt);
  match_stmt->u.match_stmt.expr=expr;
  return match_stmt;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_error_prop(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_AST *expr = node->u.unary.expr;
  compiler_types_Type *expr_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);
  if (!(((bool)expr_typ))) {
    return NULL;
  }
  compiler_ast_nodes_Function *cur_func = compiler_passes_generic_pass_GenericPass_current_func(this->o);
  if (!(((bool)cur_func))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use ! outside of a function"));
    return NULL;
  }
  compiler_ast_scopes_Symbol *parent = ({compiler_ast_scopes_TemplateInstance *_t400 = expr_typ->template_instance; _t400 ? _t400->parent : NULL;});
  compiler_passes_typechecker_ErrorPropBase error_prop_base = ({compiler_passes_typechecker_ErrorPropBase __yv_401;
    if (parent==this->o->program->cached_symbols.std_result) {
      __yv_401 = compiler_passes_typechecker_ErrorPropBase_Result;
      goto _l___yv_401;
    } else if (parent==this->o->program->cached_symbols.std_option) {
      __yv_401 = compiler_passes_typechecker_ErrorPropBase_Option;
      goto _l___yv_401;
    } else {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only use ! on Result/Option types, got %s", compiler_types_Type_str(expr_typ))));
      return NULL;
    }

_l___yv_401:
  __yv_401;});
  compiler_types_Type *ok_hint = ({compiler_types_Type *__yv_402;
switch ((error_prop_base)) {
      case compiler_passes_typechecker_ErrorPropBase_Result:
      m_403_0:
        {
          __yv_402 = std_vector_Vector__0_at(expr_typ->template_instance->args, 0);
          goto _l___yv_402;
        } break;
      case compiler_passes_typechecker_ErrorPropBase_Option:
      m_403_1:
        {
          __yv_402 = std_vector_Vector__0_at(expr_typ->template_instance->args, 0);
          goto _l___yv_402;
        } break;
    }
_l___yv_402:
  __yv_402;});
  compiler_types_Type *ret_type = cur_func->return_type;
  if (({compiler_ast_scopes_TemplateInstance *_t404 = ({compiler_types_Type *_t405 = ret_type; _t405 ? _t405->template_instance : NULL;}); _t404 ? _t404->parent : NULL;}) != parent) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->span, std_format("Cannot use ! here, expression is %s but function returns %s", compiler_types_Type_str(expr_typ), compiler_types_Type_str(ret_type)), cur_func->parsed_return_type->span, std_format("Function returns %s", compiler_types_Type_str(ret_type))));
    return ok_hint;
  }
switch ((error_prop_base)) {
    case compiler_passes_typechecker_ErrorPropBase_Result:
    m_406_0:
      {
        compiler_types_Type *expr_err_type = std_vector_Vector__0_at(expr_typ->template_instance->args, 1);
        compiler_types_Type *ret_err_type = std_vector_Vector__0_at(ret_type->template_instance->args, 1);
        if (!(compiler_types_Type_eq(expr_err_type, ret_err_type, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->span, std_format("Cannot propagate error type %s, expected %s", compiler_types_Type_str(expr_err_type), compiler_types_Type_str(ret_err_type)), cur_func->parsed_return_type->span, std_format("Function returns %s", compiler_types_Type_str(ret_type))));
          return ok_hint;
        }
      } break;
    case compiler_passes_typechecker_ErrorPropBase_Option:
    m_406_1:
      {
      } break;
  }  compiler_ast_nodes_AST *match_stmt = compiler_passes_typechecker_TypeChecker_create_match_for_error_prop(this, node, expr, error_prop_base);
  compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, match_stmt, ok_hint);
  (*node)=(*match_stmt);
  return res;
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression_helper(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    m_407_0:
      {
        if (((bool)node->u.num_literal.suffix)) {
          return compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.num_literal.suffix, false, true, true);
        }
        if (((bool)hint) && compiler_types_Type_is_integer(hint)) {
          return hint;
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_U32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_FloatLiteral:
    m_407_1:
      {
        if (((bool)node->u.num_literal.suffix)) {
          return compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.num_literal.suffix, false, true, true);
        }
        if (((bool)hint) && compiler_types_Type_is_float(hint)) {
          return hint;
        }
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_F32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_StringLiteral:
    m_407_2:
      {
        return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
      } break;
    case compiler_ast_nodes_ASTType_Null:
    m_407_3:
      {
        if (((bool)hint)) {
switch ((hint->base)) {
            case compiler_types_BaseType_Pointer:
            case compiler_types_BaseType_FunctionPtr:
            case compiler_types_BaseType_Closure:
            m_408_0:
              {
                return hint;
              } break;
            default:
              {
              } break;
          }        }
        return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "untyped_ptr", node->span);
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_407_4:
      {
        compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.cast.lhs, NULL);
        if (!(((bool)typ))) {
          return NULL;
        }
        compiler_types_Type *target = compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.cast.to, false, true, true);
        if (!(((bool)target))) {
          return NULL;
        }
        node->u.cast.to=target;
        return target;
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_407_5:
      {
        return compiler_passes_typechecker_TypeChecker_check_format_string(this, node);
      } break;
    case compiler_ast_nodes_ASTType_CharLiteral:
    m_407_6:
      {
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Char, node->span);
      } break;
    case compiler_ast_nodes_ASTType_BoolLiteral:
    m_407_7:
      {
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_407_8:
      {
switch ((node->u.unary.op)) {
          case compiler_ast_operators_Operator_PreIncrement:
          case compiler_ast_operators_Operator_PostIncrement:
          case compiler_ast_operators_Operator_PreDecrement:
          case compiler_ast_operators_Operator_PostDecrement:
          m_409_0:
            {
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);
              if (!(((bool)lhs))) {
                return NULL;
              }
              if (!(compiler_types_Type_is_integer(lhs)) && (lhs->base != compiler_types_BaseType_Pointer)) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot increment or decrement non-integer type: %s", compiler_types_Type_str(lhs))));
                return NULL;
              }
              if (!(compiler_ast_nodes_AST_is_lvalue(node->u.unary.expr))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can't perform %s on a non-lvalue", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
              }
              return lhs;
            } break;
          case compiler_ast_operators_Operator_Negate:
          m_409_1:
            {
              if (!((((bool)hint) && compiler_types_Type_is_numeric(hint)))) {
                hint=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
              }
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, hint);
              if (!(((bool)typ))) {
                return NULL;
              }
              if (!(compiler_types_Type_is_numeric(typ))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-numeric type: %s", compiler_types_Type_str(typ))));
                return NULL;
              }
              return typ;
            } break;
          case compiler_ast_operators_Operator_BitwiseNot:
          m_409_2:
            {
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, hint);
              if (!(((bool)typ))) {
                return NULL;
              }
              if (!(compiler_types_Type_is_integer(typ))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot do bitwise-not on non-integer type: %s", compiler_types_Type_str(typ))));
                return NULL;
              }
              return typ;
            } break;
          case compiler_ast_operators_Operator_IsNotNull:
          m_409_3:
            {
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);
              if (!(((bool)typ))) {
                return NULL;
              }
              typ=compiler_types_Type_unaliased(typ);
switch ((typ->base)) {
                case compiler_types_BaseType_Pointer:
                case compiler_types_BaseType_FunctionPtr:
                case compiler_types_BaseType_Closure:
                m_410_0:
                  {
                  } break;
                default:
                  {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only use ? on pointer types, got %s", compiler_types_Type_str(typ))));
                    return NULL;
                  } break;
              }              return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
            } break;
          case compiler_ast_operators_Operator_Not:
          m_409_4:
            {
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));
              if (!(((bool)typ))) {
                return NULL;
              }
              if (typ->base != compiler_types_BaseType_Bool) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-boolean type: %s", compiler_types_Type_str(typ))));
                return NULL;
              }
              return typ;
            } break;
          case compiler_ast_operators_Operator_Address:
          m_409_5:
            {
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);
              if (!(((bool)typ))) {
                return NULL;
              }
switch ((typ->base)) {
                case compiler_types_BaseType_Char:
                m_411_0:
                  {
                    return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
                  } break;
                case compiler_types_BaseType_Void:
                m_411_1:
                  {
                    return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "untyped_ptr", node->span);
                  } break;
                default:
                  {
                    compiler_types_Type *ptr = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);
                    ptr->u.ptr=typ;
                    return ptr;
                  } break;
              }            } break;
          case compiler_ast_operators_Operator_Dereference:
          m_409_6:
            {
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);
              if (!(((bool)typ))) {
                return NULL;
              }
              if (typ->base != compiler_types_BaseType_Pointer) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot dereference non-pointer type: %s", compiler_types_Type_str(typ))));
                return NULL;
              }
              return typ->u.ptr;
            } break;
          case compiler_ast_operators_Operator_ErrorProp:
          m_409_7:
            {
              return compiler_passes_typechecker_TypeChecker_check_error_prop(this, node);
            } break;
          case compiler_ast_operators_Operator_ErrorUnwrap:
          m_409_8:
            {
              return compiler_passes_typechecker_TypeChecker_check_error_unwrap(this, node);
            } break;
          default:
            {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Unknown unary operator in check_expression: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
              return NULL;
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_407_9:
      {
        return compiler_passes_typechecker_TypeChecker_check_member(this, node, false, false, hint);
      } break;
    case compiler_ast_nodes_ASTType_TryMember:
    m_407_10:
      {
        return compiler_passes_typechecker_TypeChecker_check_member(this, node, false, true, hint);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_407_11:
      {
        compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.size_of_type, false, true, true);
        if (!(((bool)typ))) {
          return NULL;
        }
        node->u.size_of_type=typ;
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_U32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_407_12:
      {
        compiler_passes_typechecker_TypeChecker_check_if(this, node, true, hint);
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_407_13:
      {
        compiler_passes_typechecker_TypeChecker_check_block(this, node, true, hint);
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_407_14:
      {
        compiler_passes_typechecker_TypeChecker_check_match(this, node, true, hint);
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_NSLookup:
    case compiler_ast_nodes_ASTType_Specialization:
    m_407_15:
      {
        compiler_ast_scopes_Symbol *item = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, true, hint, true);
        if (!(((bool)item))) {
          return NULL;
        }
        item=compiler_ast_scopes_Symbol_remove_alias(item);
switch ((item->type)) {
          case compiler_ast_scopes_SymbolType_Function:
          m_412_0:
            {
              return item->u.func->type;
            } break;
          case compiler_ast_scopes_SymbolType_Variable:
          case compiler_ast_scopes_SymbolType_Constant:
          m_412_1:
            {
              return item->u.var->type;
            } break;
          case compiler_ast_scopes_SymbolType_ClosedVariable:
          m_412_2:
            {
              return item->u.closed_var.orig->type;
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_412_3:
            {
              compiler_ast_nodes_EnumVariant *variant = item->u.enum_var;
              if (compiler_ast_nodes_EnumVariant_num_fields(variant) != 0) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s needs %u fields to construct", item->display, compiler_ast_nodes_EnumVariant_num_fields(variant))));
              }
              return variant->parent->type;
            } break;
          case compiler_ast_scopes_SymbolType_TypeDef:
          m_412_4:
            {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot use type `%s` as an expression", item->name)));
              return NULL;
            } break;
          case compiler_ast_scopes_SymbolType_Structure:
          case compiler_ast_scopes_SymbolType_Namespace:
          case compiler_ast_scopes_SymbolType_Enum:
          m_412_5:
            {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot use %s `%s` as an expression", compiler_ast_scopes_SymbolType_dbg(item->type), item->name)));
              return NULL;
            } break;
          default:
            {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Should not get %s `%s` as an expression", compiler_ast_scopes_SymbolType_dbg(item->type), item->name)));
              return NULL;
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_407_16:
      {
        return compiler_passes_typechecker_TypeChecker_check_call(this, node, hint);
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_407_17:
      {
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;
        compiler_ast_nodes_AST *rhs_node = node->u.binary.rhs;
        compiler_ast_operators_Operator op = node->u.binary.op;
switch ((op)) {
          case compiler_ast_operators_Operator_Plus:
          case compiler_ast_operators_Operator_Minus:
          case compiler_ast_operators_Operator_Multiply:
          case compiler_ast_operators_Operator_Divide:
          case compiler_ast_operators_Operator_LessThan:
          case compiler_ast_operators_Operator_LessThanEquals:
          case compiler_ast_operators_Operator_GreaterThan:
          case compiler_ast_operators_Operator_GreaterThanEquals:
          case compiler_ast_operators_Operator_NotEquals:
          case compiler_ast_operators_Operator_PlusEquals:
          case compiler_ast_operators_Operator_MinusEquals:
          case compiler_ast_operators_Operator_MultiplyEquals:
          case compiler_ast_operators_Operator_DivideEquals:
          case compiler_ast_operators_Operator_And:
          case compiler_ast_operators_Operator_Or:
          case compiler_ast_operators_Operator_Modulus:
          case compiler_ast_operators_Operator_BitwiseOr:
          case compiler_ast_operators_Operator_BitwiseAnd:
          case compiler_ast_operators_Operator_BitwiseXor:
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          case compiler_ast_operators_Operator_LeftShift:
          case compiler_ast_operators_Operator_RightShift:
          m_413_0:
            {
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, lhs_node, hint);
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, rhs_node, lhs);
              if (!(((bool)lhs)) || !(((bool)rhs))) {
                return NULL;
              }
              return compiler_passes_typechecker_TypeChecker_check_binary_op(this, node, compiler_types_Type_unaliased(lhs), compiler_types_Type_unaliased(rhs));
            } break;
          case compiler_ast_operators_Operator_Equals:
          m_413_1:
            {
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, lhs_node, hint);
              if ((!(((bool)lhs)) || (lhs->base != compiler_types_BaseType_Enum)) || !(lhs->u.enom->has_values)) {
                compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, rhs_node, lhs);
                if (!(((bool)lhs)) || !(((bool)rhs))) {
                  return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
                }
                return compiler_passes_typechecker_TypeChecker_check_binary_op(this, node, compiler_types_Type_unaliased(lhs), compiler_types_Type_unaliased(rhs));
              }
switch ((rhs_node->type)) {
                case compiler_ast_nodes_ASTType_Identifier:
                case compiler_ast_nodes_ASTType_NSLookup:
                case compiler_ast_nodes_ASTType_Specialization:
                m_414_0:
                  {
                  } break;
                case compiler_ast_nodes_ASTType_Call:
                m_414_1:
                  {
                    compiler_ast_nodes_FuncCall call = rhs_node->u.call;
                    std_span_Span args_span = std_span_Span_join(call.open_paren_span, call.close_paren_span);
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(args_span, std_format("Can only compare against the variant name here, remove this")));
                    compiler_passes_typechecker_TypeChecker_check_expression(this, rhs_node, lhs);
                    return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
                  } break;
                default:
                  {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(rhs_node->span, std_format("Expected explicit enum variant, got: %s", compiler_ast_nodes_ASTType_dbg(rhs_node->type))));
                    compiler_passes_typechecker_TypeChecker_check_expression(this, rhs_node, lhs);
                    return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
                  } break;
              }              compiler_ast_scopes_Symbol *rhs_sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, rhs_node, true, lhs, true);
              if (!(((bool)rhs_sym))) {
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              }
              if (rhs_sym->type != compiler_ast_scopes_SymbolType_EnumVariant) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(rhs_node->span, std_format("Expected enum variant, got: %s", compiler_ast_scopes_SymbolType_dbg(rhs_sym->type))));
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              } else if (!(compiler_types_Type_eq(({compiler_ast_nodes_Enum *_t415 = ({compiler_ast_nodes_EnumVariant *_t416 = rhs_sym->u.enum_var; _t416 ? _t416->parent : NULL;}); _t415 ? _t415->type : NULL;}), lhs, false))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(rhs_node->span, std_format("Expected enum variant of type %s, got: %s", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs_sym->u.enum_var->parent->type))));
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              }
              node->u.binary.op=compiler_ast_operators_Operator_EqualsValueEnumVariant;
              return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
            } break;
          case compiler_ast_operators_Operator_In:
          m_413_2:
            {
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, NULL);
              if (!(((bool)lhs)) || !(((bool)rhs))) {
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              }
              compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_In, node, node->u.binary.rhs, node->u.binary.lhs, NULL);
              return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
            } break;
          case compiler_ast_operators_Operator_Index:
          m_413_3:
            {
              return compiler_passes_typechecker_TypeChecker_check_index(this, node, hint, false);
            } break;
          case compiler_ast_operators_Operator_Assignment:
          m_413_4:
            {
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, lhs);
              if (!(((bool)lhs)) || !(((bool)rhs))) {
                return NULL;
              }
              return compiler_passes_typechecker_TypeChecker_check_assignment(this, node, lhs, rhs);
            } break;
          case compiler_ast_operators_Operator_IndexAssign:
          m_413_5:
            {
              compiler_ast_nodes_AST *index = node->u.binary.lhs;
              compiler_ast_nodes_AST *arg1 = index->u.binary.lhs;
              compiler_ast_nodes_AST *arg2 = index->u.binary.rhs;
              compiler_ast_nodes_AST *arg3 = node->u.binary.rhs;
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg1, NULL)))) {
                return NULL;
              }
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg2, NULL)))) {
                return NULL;
              }
              compiler_types_Type *arg3_hint = NULL;
              compiler_types_Type *arg1_typ = compiler_types_Type_unaliased(arg1->etype);
              if (arg1_typ->base==compiler_types_BaseType_Pointer) {
                arg3_hint=arg1_typ->u.ptr;
              }
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg3, arg3_hint)))) {
                return NULL;
              }
              compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_IndexAssign, node, arg1, arg2, arg3);
              if (((bool)res)) {
                return res;
              }
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_index(this, index, NULL, true);
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, arg3, lhs);
              if (!(((bool)lhs)) || !(((bool)rhs))) {
                return NULL;
              }
              return compiler_passes_typechecker_TypeChecker_check_assignment(this, node, lhs, rhs);
            } break;
          default:
            {
              std_panic(std_format("Internal error: unhandled op in check_expression binary_op: %s", compiler_ast_operators_Operator_dbg(node->u.binary.op)));
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_MapLiteral:
    m_407_18:
      {
        if (!(this->o->program->did_cache_symbols) || !(((bool)this->o->program->cached_symbols.std_map))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Could not find std::compact_map, please import it."));
        }
        compiler_ast_scopes_Symbol *std_map = this->o->program->cached_symbols.std_map;
        compiler_types_Type *key_hint_type = NULL;
        compiler_types_Type *value_hint_type = NULL;
        if (((bool)hint) && hint->base==compiler_types_BaseType_Pointer) {
          compiler_types_Type *ptr = hint->u.ptr;
          if ((((bool)ptr) && ((bool)ptr->template_instance)) && ptr->template_instance->parent==std_map) {
            if(!(ptr->template_instance->args->size==2)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:1984:28: Assertion failed: `ptr.template_instance.args.size == 2`", NULL); }
            key_hint_type=std_vector_Vector__0_at(ptr->template_instance->args, 0);
            value_hint_type=std_vector_Vector__0_at(ptr->template_instance->args, 1);
          }
        }
        compiler_types_Type *key_type = NULL;
        compiler_types_Type *value_type = NULL;
        std_span_Span first_key_span = std_span_Span_default();
        std_span_Span first_value_span = std_span_Span_default();
        std_vector_Vector__25 *elements = node->u.map_literal.elements;
        for (std_vector_Iterator__25 _i182 = std_vector_Vector__25_iter(elements); std_vector_Iterator__25_has_value(&_i182); std_vector_Iterator__25_next(&_i182)) {
          compiler_ast_nodes_MapLiteralPair elem = std_vector_Iterator__25_cur(&_i182);
          {
            compiler_types_Type *key = compiler_passes_typechecker_TypeChecker_check_expression(this, elem.key, key_hint_type);
            compiler_types_Type *value = compiler_passes_typechecker_TypeChecker_check_expression(this, elem.value, value_hint_type);
            if (!(((bool)key_type))) {
              key_type=key;
              value_type=value;
              key_hint_type=key_type;
              value_hint_type=value_type;
              first_key_span=elem.key->span;
              first_value_span=elem.value->span;
            } else {
              if (((bool)key) && !(compiler_types_Type_eq(key, key_type, false))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(elem.key->span, std_format("Expected type %s, but got %s", compiler_types_Type_str(key_type), compiler_types_Type_str(key)), first_key_span, std_format("First key was of type %s", compiler_types_Type_str(key_type))));
              }
              if (((bool)value) && !(compiler_types_Type_eq(value, value_type, false))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(elem.value->span, std_format("Expected type %s, but got %s", compiler_types_Type_str(value_type), compiler_types_Type_str(value)), first_value_span, std_format("First value was of type %s", compiler_types_Type_str(value_type))));
              }
            }
          }
        }
        if (elements->size==0) {
          key_type=key_hint_type;
          value_type=value_hint_type;
        }
        if (!((((bool)key_type) && ((bool)value_type)))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Can't infer type of Map literal"));
          return NULL;
        }
        if (!(((bool)std_map))) {
          return NULL;
        }
        compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, std_map, ({
          std_vector_Vector__0 *_vc417 = std_vector_Vector__0_new(2);
          std_vector_Vector__0_push(_vc417, key_type);
          std_vector_Vector__0_push(_vc417, value_type);
          _vc417;}), node->span);
        if (!(((bool)res)) || (res->type != compiler_ast_scopes_SymbolType_Structure)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Internal error: Failed to resolve std::compact_map specialization"));
          return NULL;
        }
        node->u.map_literal.map_struc=res->u.struc;
        node->u.map_literal.map_type=res->u.struc->type;
        compiler_types_Type *ptr_type = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);
        ptr_type->u.ptr=res->u.struc->type;
        return ptr_type;
      } break;
    case compiler_ast_nodes_ASTType_VectorLiteral:
    m_407_19:
      {
        if (!(this->o->program->did_cache_symbols) || !(((bool)this->o->program->cached_symbols.std_vector))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Could not find std::vector, please import it."));
        }
        compiler_ast_scopes_Symbol *std_vector = this->o->program->cached_symbols.std_vector;
        compiler_types_Type *hint_elem_type = NULL;
        if (((bool)hint) && hint->base==compiler_types_BaseType_Pointer) {
          compiler_types_Type *ptr = hint->u.ptr;
          if ((((bool)ptr) && ((bool)ptr->template_instance)) && ptr->template_instance->parent==std_vector) {
            if(!(ptr->template_instance->args->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:2066:28: Assertion failed: `ptr.template_instance.args.size == 1`", NULL); }
            hint_elem_type=std_vector_Vector__0_at(ptr->template_instance->args, 0);
          }
        }
        compiler_types_Type *elem_type = NULL;
        std_span_Span first_span = std_span_Span_default();
        std_vector_Vector__15 *elements = node->u.vec_literal.elements;
        for (std_vector_Iterator__15 _i183 = std_vector_Vector__15_iter(elements); std_vector_Iterator__15_has_value(&_i183); std_vector_Iterator__15_next(&_i183)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i183);
          {
            compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, elem, hint_elem_type);
            if (!(((bool)typ))) {
              continue;
            }
            if (!(((bool)elem_type))) {
              elem_type=typ;
              hint_elem_type=elem_type;
              first_span=elem->span;
            } else if (!(compiler_types_Type_eq(elem_type, typ, false))) {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(elem->span, std_format("Expected type %s, but got %s", compiler_types_Type_str(elem_type), compiler_types_Type_str(typ)), first_span, std_format("First element was of type %s", compiler_types_Type_str(elem_type))));
              return NULL;
            }
          }
        }
        if (elements->size==0) {
          elem_type=hint_elem_type;
        }
        if (!(((bool)elem_type))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Can't infer type of Vector literal"));
          return NULL;
        }
        if (!(((bool)std_vector))) {
          return NULL;
        }
        compiler_ast_scopes_Symbol *vec_sym = std_vector;
        std_vector_Vector__0 *template_args = std_vector_Vector__0_new(16);
        std_vector_Vector__0_push(template_args, elem_type);
        compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, vec_sym, template_args, node->span);
        if (!(((bool)res)) || (res->type != compiler_ast_scopes_SymbolType_Structure)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Internal error: Failed to resolve std::vector specialization"));
          return NULL;
        }
        node->u.vec_literal.vec_struc=res->u.struc;
        node->u.vec_literal.vec_type=res->u.struc->type;
        compiler_types_Type *ptr_type = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);
        ptr_type->u.ptr=res->u.struc->type;
        return ptr_type;
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_407_20:
      {
        compiler_types_Type *hint_elem_type = NULL;
        if (((bool)hint) && hint->base==compiler_types_BaseType_Array) {
          hint_elem_type=hint->u.arr.elem_type;
        }
        compiler_types_Type *elem_type = NULL;
        std_span_Span first_span = std_span_Span_default();
        for (std_vector_Iterator__15 _i184 = std_vector_Vector__15_iter(node->u.array_literal.elements); std_vector_Iterator__15_has_value(&_i184); std_vector_Iterator__15_next(&_i184)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i184);
          {
            compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, elem, hint_elem_type);
            if (!(((bool)typ))) {
              continue;
            }
            if (!(((bool)elem_type))) {
              elem_type=typ;
              hint_elem_type=elem_type;
              first_span=elem->span;
            } else if (!(compiler_types_Type_eq(elem_type, typ, false))) {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(elem->span, std_format("Expected type %s, but got %s", compiler_types_Type_str(elem_type), compiler_types_Type_str(typ)), first_span, std_format("First element was of type %s", compiler_types_Type_str(elem_type))));
              return NULL;
            }
          }
        }
        if (!(((bool)elem_type))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Array literal must have at least one element"));
          return NULL;
        }
        compiler_types_Type *arr = compiler_types_Type_new_resolved(compiler_types_BaseType_Array, node->span);
        arr->u.arr.elem_type=elem_type;
        arr->u.arr.size_known=true;
        arr->u.arr.size=node->u.array_literal.elements->size;
        return arr;
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_407_21:
      {
        if (!(this->o->program->did_cache_symbols)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use `@new` without using stdlib"));
        }
        compiler_types_Type *hint_type = ((((bool)hint) && hint->base==compiler_types_BaseType_Pointer) ? hint->u.ptr : NULL);
        compiler_types_Type *child_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.child, hint_type);
        if (!(((bool)child_typ))) {
          return NULL;
        }
        if (child_typ->base==compiler_types_BaseType_Pointer) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use `@new` on a pointer type"));
        }
        compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);
        typ->u.ptr=child_typ;
        return typ;
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_407_22:
      {
        compiler_ast_nodes_Function *clos = node->u.closure;
        clos->scope=compiler_passes_generic_pass_GenericPass_ns(this->o)->scope;
        clos->closure_scope=compiler_passes_generic_pass_GenericPass_scope(this->o);
        clos->closed_vars=std_map_Map__5_new(8);
        bool hint_matches = ({bool __yv_418;
          if (!(((bool)hint))) {
            __yv_418 = false;
            goto _l___yv_418;
          } else if (hint->base != compiler_types_BaseType_Closure) {
            __yv_418 = false;
            goto _l___yv_418;
          } else if (hint->u.func.params->size != clos->params->size) {
            __yv_418 = false;
            goto _l___yv_418;
          } else {
            __yv_418 = true;
            goto _l___yv_418;
          }

_l___yv_418:
        __yv_418;});
        if (hint_matches) {
          compiler_types_FunctionType hfunc = hint->u.func;
          for (u32 i = 0; i < clos->params->size; i+=1) {
            compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(clos->params, i);
            compiler_types_Type *hint_type = std_vector_Vector__4_at(hfunc.params, i)->type;
            compiler_types_Type *param_type = (((bool)param->type) ? param->type : hint_type);
            param->type=param_type;
          }
          compiler_types_Type *hint_ret_type = hfunc.return_type;
          compiler_types_Type *clos_ret_type = (((bool)clos->return_type) ? clos->return_type : hint_ret_type);
          clos->return_type=clos_ret_type;
        } else {
          for (std_vector_Iterator__4 _i185 = std_vector_Vector__4_iter(clos->params); std_vector_Iterator__4_has_value(&_i185); std_vector_Iterator__4_next(&_i185)) {
            compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i185);
            {
              if (!(((bool)param->type))) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(param->sym->span, "Cannot infer type, specify it explicitly"));
              }
            }
          }
        }
        if (!(((bool)clos->return_type))) {
          clos->return_type=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Void, node->span);
        }
        compiler_passes_typechecker_TypeChecker_check_function_declaration(this, clos);
        compiler_passes_typechecker_TypeChecker_check_function(this, clos);
        return clos->type;
      } break;
    case compiler_ast_nodes_ASTType_Error:
    m_407_23:
      {
        return hint;
      } break;
    case compiler_ast_nodes_ASTType_Is:
    m_407_24:
      {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Can only use `is` inside an if statement condition. Use `==` for standalone enum comparison"));
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    default:
      {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Invalid expression in TypeChecker::check_expression: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
        return NULL;
      } break;
  }}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST **node_ptr) {
  compiler_ast_nodes_AST *node = (*node_ptr);
  if (!(((bool)node->etype))) {
    return NULL;
  }
switch ((node->etype->base)) {
    case compiler_types_BaseType_Enum:
    m_419_0:
      {
      } break;
    default:
      {
        return node->etype;
      } break;
  }  compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, node->span);
  member->u.member.lhs=node;
  member->u.member.rhs_name="dbg";
  member->u.member.rhs_span=node->span;
  compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, node->span);
  call->u.call.callee=member;
  call->u.call.args=std_vector_Vector__9_new(16);
  (*node_ptr)=call;
  return compiler_passes_typechecker_TypeChecker_check_expression(this, call, NULL);
}

void compiler_passes_typechecker_TypeChecker_check_match_case_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *lhs_node, compiler_types_Type *enom_type, std_vector_Vector__6 *conds, std_map_Map__1 *mapping, std_map_Map__2 *current_args) {
  if(!(enom_type->base==compiler_types_BaseType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:2272:12: Assertion failed: `enom_type.base == Enum`", NULL); }
  compiler_ast_nodes_Enum *enom = enom_type->u.enom;
  std_map_Map__2_clear(current_args);
  for (u32 i = 0; i < conds->size; i++) {
    compiler_ast_nodes_MatchCond *cond = std_vector_Vector__6_at(conds, i);
    char *name;
    compiler_ast_nodes_AST *expr = cond->expr;
    expr->hint=enom_type;
switch ((expr->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      case compiler_ast_nodes_ASTType_NSLookup:
      case compiler_ast_nodes_ASTType_Specialization:
      m_420_0:
        {
        } break;
      default:
        {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Expected value enum variant, got %s", compiler_ast_nodes_ASTType_dbg(expr->type))));
          continue;
        } break;
    }    compiler_ast_scopes_Symbol *resolved_sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, expr, true, enom_type, true);
    if (!(((bool)resolved_sym))) {
      continue;
    }
    if (resolved_sym->type != compiler_ast_scopes_SymbolType_EnumVariant) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Expected value enum variant, got %s (%s)", compiler_ast_scopes_SymbolType_dbg(resolved_sym->type), resolved_sym->display)));
      continue;
    }
    compiler_ast_nodes_EnumVariant *variant = resolved_sym->u.enum_var;
    if (variant->parent != enom) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(expr->span, "Condition does not match expression type", lhs_node->span, std_format("Match expression is of type '%s'", compiler_types_Type_str(enom->type))));
    }
    expr->etype=enom_type;
    std_vector_Vector__19 *args = cond->args;
    if (i==0) {
      if (((bool)args)) {
        for (u32 j = 0; j < args->size; j+=1) {
          compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, j);
          compiler_ast_nodes_Variable *sp_field = compiler_ast_nodes_EnumVariant_get_specific_field(variant, arg->var->sym->name);
          compiler_ast_nodes_Variable *sh_field = compiler_ast_nodes_Enum_get_shared_field(enom, arg->var->sym->name);
          compiler_ast_nodes_Variable *field = ({compiler_ast_nodes_Variable *__yv_421;
            if (((bool)sp_field)) {
              __yv_421 = sp_field;
              goto _l___yv_421;
            } else if (((bool)sh_field)) {
              arg->is_shared=true;
              __yv_421 = sh_field;
              goto _l___yv_421;
            } else {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, std_format("Field `%s` does not exist in enum variant %s", arg->var->sym->name, variant->sym->display)));
              __yv_421 = NULL;
              goto _l___yv_421;
            }

_l___yv_421:
          __yv_421;});
          if (((bool)field)) {
            arg->var->type=field->type;
            std_map_Map__2_insert(current_args, arg->var->sym->name, field->type);
          }
        }
      }
    } else {
      u32 found_args = 0;
      for (u32 j = 0; ((bool)args) && (j < args->size); j+=1) {
        compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, j);
        compiler_ast_nodes_Variable *sp_field = compiler_ast_nodes_EnumVariant_get_specific_field(variant, arg->var->sym->name);
        compiler_ast_nodes_Variable *sh_field = compiler_ast_nodes_Enum_get_shared_field(enom, arg->var->sym->name);
        compiler_ast_nodes_Variable *field = ({compiler_ast_nodes_Variable *__yv_422;
          if (((bool)sp_field)) {
            __yv_422 = sp_field;
            goto _l___yv_422;
          } else if (((bool)sh_field)) {
            arg->is_shared=true;
            __yv_422 = sh_field;
            goto _l___yv_422;
          } else {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, "Field does not exist in enum variant"));
            __yv_422 = NULL;
            goto _l___yv_422;
          }

_l___yv_422:
        __yv_422;});
        if (((bool)field)) {
          arg->var->type=field->type;
        }
        std_map_Item__2 *item = std_map_Map__2_get_item(current_args, arg->var->sym->name);
        if (!(((bool)item))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, "All conditions in this branch must have the same fields"));
          continue;
        }
        found_args+=1;
        if (((bool)field) && !(compiler_types_Type_eq(item->value, field->type, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, std_format("Field type does not match previous branch: %s", compiler_types_Type_str(item->value))));
          continue;
        }
      }
      if (found_args != current_args->size) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, "All conditions in this branch must have the same fields"));
      }
    }
    name=expr->resolved_symbol->name;
    compiler_ast_nodes_MatchCond *prev = std_map_Map__1_get(mapping, name, NULL);
    if (((bool)prev)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(expr->span, "Duplicate condition name in match", prev->expr->span, "This condition was previously used here"));
    }
    std_map_Map__1_insert(mapping, name, cond);
  }
}

void compiler_passes_typechecker_TypeChecker_check_match_for_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {
  std_map_Map__1 *mapping = std_map_Map__1_new(8);
  std_vector_Vector__24 *cases = node->u.match_stmt.cases;
  node->returns=(cases->size > 0);
  std_map_Map__2 *current_args = std_map_Map__2_new(8);
  for (std_vector_Iterator__24 _i186 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i186); std_vector_Iterator__24_next(&_i186)) {
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i186);
    {
      std_vector_Vector__6 *conds = _case.conds;
      compiler_passes_typechecker_TypeChecker_check_match_case_enum(this, node->u.match_stmt.expr, enom->type, conds, mapping, current_args);
      if (((bool)_case.body)) {
        compiler_passes_generic_pass_GenericPass_push_scope(this->o, compiler_ast_scopes_Scope_new(compiler_passes_generic_pass_GenericPass_scope(this->o)));
        for (std_map_Iterator__2 _i187 = std_map_Map__2_iter(current_args); std_map_Iterator__2_has_value(&_i187); std_map_Iterator__2_next(&_i187)) {
          std_map_Item__2 *arg = std_map_Iterator__2_cur(&_i187);
          {
            compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(arg->value);
            var->sym=compiler_ast_scopes_Symbol_from_local_variable(arg->key, var, arg->value->span);
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, var->sym, NULL);
          }
        }
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);
        compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
      }
    }
  }
  compiler_ast_nodes_AST *defolt = node->u.match_stmt.defolt;
  if (mapping->size != enom->variants->size) {
    std_buffer_Buffer buf = std_buffer_Buffer_make(16);
    std_buffer_Buffer_write_str(&buf, "Remaining fields: ");
    bool first = true;
    for (std_vector_Iterator__20 _i188 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i188); std_vector_Iterator__20_next(&_i188)) {
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i188);
      {
        if (!(std_map_Map__1_contains(mapping, variant->sym->name))) {
          if (!(first)) {
            std_buffer_Buffer_write_str(&buf, " | ");
          }
          std_buffer_Buffer_write_str(&buf, variant->sym->name);
          first=false;
        }
      }
    }
    if (!(((bool)defolt))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->u.match_stmt.expr->span, std_format("Match does not cover all cases (Only %u of %u)", mapping->size, enom->variants->size), std_buffer_Buffer_str(buf)));
    } else {
      compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, defolt, is_expr, hint);
    }
  } else {
    if (((bool)defolt)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.defolt_span, "`else` case is not needed for this match"));
    }
  }
  if (is_expr && !(((bool)node->etype))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.match_span, "Expression-match must yield a value"));
  }
  /* defers */
  std_map_Map__1_free(mapping);
}

void compiler_passes_typechecker_TypeChecker_check_match_for_bool(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;
  if ((match_stmt->cases->size != 2) || ((bool)match_stmt->defolt)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Match for bool must have exactly `true` and `false` cases"));
  }
  bool seen_true = false;
  bool seen_false = false;
  node->returns=true;
  for (std_vector_Iterator__24 _i189 = std_vector_Vector__24_iter(match_stmt->cases); std_vector_Iterator__24_has_value(&_i189); std_vector_Iterator__24_next(&_i189)) {
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i189);
    {
      for (std_vector_Iterator__6 _i190 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i190); std_vector_Iterator__6_next(&_i190)) {
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i190);
        {
          compiler_ast_nodes_AST *expr = cond->expr;
          compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);
          if (expr->type != compiler_ast_nodes_ASTType_BoolLiteral) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, "Expected either `true` or `false`"));
          } else {
            if (expr->u.bool_literal) {
              seen_true=true;
            } else {
              seen_false=true;
            }
          }
        }
      }
      if (((bool)_case.body)) {
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);
      } else {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Case must have a body"));
      }
    }
  }
  if (!(seen_true)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Missing `true` case"));
  }
  if (!(seen_false)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Missing `false` case"));
  }
  if (is_expr && !(((bool)node->etype))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Expression-match must yield a value"));
  }
}

compiler_ast_nodes_Function *compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *expr, compiler_ast_nodes_MatchCond *cond) {
  compiler_types_Type *lhs = expr->etype;
  compiler_types_Type *rhs = cond->expr->etype;
  if (compiler_types_Type_eq(lhs, rhs, false)) {
    if (compiler_types_Type_is_numeric_or_char(lhs)) {
      return NULL;
    }
    if (lhs->base==compiler_types_BaseType_Bool) {
      return NULL;
    }
  }
  compiler_ast_operators_OperatorOverload overload = {0};
  overload.op=compiler_ast_operators_Operator_Equals;
  overload.type1=lhs;
  overload.type2=rhs;
  compiler_ast_nodes_Function *func = std_map_Map__6_get(this->o->program->operator_overloads, overload, NULL);
  if (!(((bool)func))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(cond->expr->span, std_format("Cannot match %s with this case: %s", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs)), expr->span, std_format("Match expression is of type %s", compiler_types_Type_str(lhs))));
    return NULL;
  }
  compiler_types_Type *ret = compiler_types_Type_unaliased(func->return_type);
  if (ret->base != compiler_types_BaseType_Bool) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(cond->expr->span, std_format("Overload %s must return a boolean", func->sym->display), func->sym->span, std_format("Defined here, return type is %s", compiler_types_Type_str(ret))));
    return NULL;
  }
  cond->cmp_fn=func;
  return func;
}

void compiler_passes_typechecker_TypeChecker_check_match(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;
  compiler_ast_nodes_AST *expr = match_stmt->expr;
  compiler_types_Type *expr_type = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);
  if (!(((bool)expr_type))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Match statement must have a valid expression"));
    return;
  }
  compiler_ast_scopes_Scope *match_scope = compiler_ast_scopes_Scope_new(compiler_passes_generic_pass_GenericPass_scope(this->o));
  match_scope->is_for_match=true;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, match_scope);
switch ((expr_type->base)) {
    case compiler_types_BaseType_Enum:
    m_423_0:
      {
        compiler_passes_typechecker_TypeChecker_check_match_for_enum(this, expr_type->u.enom, node, is_expr, hint);
        /* defers */
        compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
        return;
      } break;
    case compiler_types_BaseType_Bool:
    m_423_1:
      {
        compiler_passes_typechecker_TypeChecker_check_match_for_bool(this, node, is_expr, hint);
        /* defers */
        compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
        return;
      } break;
    default:
      {
      } break;
  }  std_vector_Vector__24 *cases = match_stmt->cases;
  node->returns=(cases->size > 0);
  for (std_vector_Iterator__24 _i191 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i191); std_vector_Iterator__24_next(&_i191)) {
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i191);
    {
      for (std_vector_Iterator__6 _i192 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i192); std_vector_Iterator__6_next(&_i192)) {
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i192);
        {
          compiler_ast_nodes_AST *cond_expr = cond->expr;
          compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond_expr, expr_type);
          if (!(((bool)cond_type))) {
            continue;
          }
          compiler_ast_nodes_Function *cmp_fn = compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(this, expr, cond);
          if (((bool)cmp_fn)) {
            match_stmt->is_custom_match=true;
          } else {
            bool is_constant = (((bool)cond_expr->resolved_symbol) && cond_expr->resolved_symbol->type==compiler_ast_scopes_SymbolType_Constant);
            if (((cond_expr->type != compiler_ast_nodes_ASTType_IntLiteral) && (cond_expr->type != compiler_ast_nodes_ASTType_CharLiteral)) && !(is_constant)) {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(cond_expr->span, "Match condition must use only literals"));
            }
          }
        }
      }
      if (((bool)_case.body)) {
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);
      }
    }
  }
  compiler_ast_nodes_AST *defolt = node->u.match_stmt.defolt;
  if (!(((bool)defolt))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.match_span, "`else` case is missing"));
  } else {
    compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, defolt, is_expr, hint);
  }
  if ((is_expr && !(((bool)node->etype))) && !(node->returns)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Expression-match must yield a value"));
  }
  /* defers */
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_check_is_expr_in_if_condition(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *cond) {
  if(!(cond->type==compiler_ast_nodes_ASTType_Is)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:2616:12: Assertion failed: `cond.type == Is`", std_format("Expected 'Is' node, got '%s'", compiler_ast_nodes_ASTType_dbg(cond->type))); }
  compiler_ast_nodes_IsExpression *is_expr = &cond->u.is_expr;
  compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, is_expr->lhs, NULL);
  std_map_Map__1 *mapping = std_map_Map__1_new(8);
  std_map_Map__2 *current_args = std_map_Map__2_new(8);
  compiler_passes_typechecker_TypeChecker_check_match_case_enum(this, is_expr->lhs, lhs, is_expr->conds, mapping, current_args);
  for (std_map_Iterator__2 _i193 = std_map_Map__2_iter(current_args); std_map_Iterator__2_has_value(&_i193); std_map_Iterator__2_next(&_i193)) {
    std_map_Item__2 *arg = std_map_Iterator__2_cur(&_i193);
    {
      compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(arg->value);
      var->sym=compiler_ast_scopes_Symbol_from_local_variable(arg->key, var, arg->value->span);
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, var->sym, NULL);
    }
  }
  /* defers */
  std_map_Map__2_free(current_args);
  std_map_Map__1_free(mapping);
}

void compiler_passes_typechecker_TypeChecker_check_if(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {
  node->returns=true;
  std_vector_Vector__23 *branches = node->u.if_stmt.branches;
  u32 num_is_expr = 0;
  std_span_Span bad_span = std_span_Span_default();
  for (std_vector_Iterator__23 _i194 = std_vector_Vector__23_iter(branches); std_vector_Iterator__23_has_value(&_i194); std_vector_Iterator__23_next(&_i194)) {
    compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i194);
    {
switch ((branch.cond->type)) {
        case compiler_ast_nodes_ASTType_Is:
        m_424_0:
          {
            compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));
            scope->is_for_match=true;
            compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);
            compiler_passes_typechecker_TypeChecker_check_is_expr_in_if_condition(this, branch.cond);
            compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, branch.body, is_expr, hint);
            compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
            num_is_expr++;
          } break;
        default:
          {
            compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, branch.cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));
            if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(branch.cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
            }
            compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, branch.body, is_expr, hint);
          } break;
      }    }
  }
  if (((bool)node->u.if_stmt.els)) {
    compiler_ast_nodes_AST *else_stmt = node->u.if_stmt.els;
    compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, else_stmt, is_expr, hint);
  } else if (is_expr) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.if_stmt.if_span, "If expressions must have an else branch"));
  } else {
    node->returns=false;
  }
}

void compiler_passes_typechecker_TypeChecker_check_expression_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body, bool is_expr, compiler_types_Type *hint) {
switch ((body->type)) {
    case compiler_ast_nodes_ASTType_Match:
    m_425_0:
      {
        compiler_passes_typechecker_TypeChecker_check_match(this, body, is_expr, hint);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_425_1:
      {
        compiler_passes_typechecker_TypeChecker_check_if(this, body, is_expr, hint);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_425_2:
      {
        compiler_passes_typechecker_TypeChecker_check_block(this, body, is_expr, hint);
      } break;
    default:
      {
        if (is_expr) {
          compiler_passes_typechecker_TypeChecker_check_expression(this, body, hint);
        } else {
          compiler_passes_typechecker_TypeChecker_check_statement(this, body);
        }
      } break;
  }  node->returns=(node->returns && body->returns);
  if (!(is_expr)) {
    return;
  }
  compiler_types_Type *ret = body->etype;
  if (body->returns) {
  } else if (!(((bool)ret))) {
    std_span_Span start_span = (std_span_Span){.start=body->span.start, .end=body->span.start};
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(start_span, std_format("Must yield a value in this branch, body type is %s", compiler_ast_nodes_ASTType_dbg(body->type))));
  } else if (!(((bool)node->etype))) {
    node->etype=ret;
  } else if (!(compiler_types_Type_eq(node->etype, ret, false))) {
    compiler_ast_nodes_AST *yield_stmt = (node->type==compiler_ast_nodes_ASTType_Block ? node->u.block.final_stmt : body);
    if (!(((bool)yield_stmt))) {
      yield_stmt=body;
    }
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(compiler_ast_nodes_AST_display_span(yield_stmt), "Yield type of branch doesn't match previous branches", std_format("Expected type '%s', got '%s'", compiler_types_Type_str(node->etype), compiler_types_Type_str(ret))));
  }
}

void compiler_passes_typechecker_TypeChecker_check_while(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));
  scope->loop_count+=1;
  scope->parent_loop=node;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);
  compiler_ast_nodes_AST *cond = node->u.loop.cond;
  compiler_ast_nodes_AST *body = node->u.loop.body;
  compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));
  if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
  }
  compiler_passes_typechecker_TypeChecker_check_statement(this, body);
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_check_for(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));
  scope->loop_count+=1;
  scope->parent_loop=node;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);
  compiler_ast_nodes_AST *init = node->u.loop.init;
  compiler_ast_nodes_AST *cond = node->u.loop.cond;
  compiler_ast_nodes_AST *step = node->u.loop.step;
  compiler_ast_nodes_AST *body = node->u.loop.body;
  if (((bool)init)) {
    compiler_passes_typechecker_TypeChecker_check_statement(this, init);
  }
  if (((bool)cond)) {
    compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));
    if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
    }
  }
  if (((bool)step)) {
    compiler_passes_typechecker_TypeChecker_check_expression(this, step, NULL);
  }
  if (((bool)body)) {
    compiler_passes_typechecker_TypeChecker_check_statement(this, body);
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_check_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Return:
    m_426_0:
      {
        compiler_ast_nodes_Function *cur_func = compiler_passes_typechecker_TypeChecker_scope(this)->cur_func;
        if (!(((bool)cur_func))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot return from outside a function"));
          return;
        }
        compiler_types_Type *expected = cur_func->return_type;
        compiler_types_Type *res = NULL;
        compiler_ast_nodes_AST *child = node->u.ret.expr;
        std_span_Span ret_span = node->u.ret.return_span;
        if (((bool)child)) {
          res=compiler_passes_typechecker_TypeChecker_check_expression(this, child, expected);
        }
        if (((bool)child) && child->returns) {
        } else if (expected->base==compiler_types_BaseType_Void) {
          if (((bool)node->u.child)) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, "Cannot return a value from a void function"));
          }
        } else if (((bool)child)) {
          if (((bool)res) && !(compiler_types_Type_eq(res, expected, false))) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, std_format("Return type %s does not match function return type %s", compiler_types_Type_str(res), compiler_types_Type_str(expected))));
          }
        } else {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, "Expected a return value for non-void function"));
        }
        node->returns=true;
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_426_1:
      {
        compiler_ast_nodes_AST *expr = node->u.assertion.expr;
        compiler_types_Type *expr_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));
        if (((bool)expr_typ) && (expr_typ->base != compiler_types_BaseType_Bool)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only assert boolean types, got %s", compiler_types_Type_str(expr_typ))));
        }
        if (((bool)node->u.assertion.msg)) {
          compiler_types_Type *msg_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.assertion.msg, NULL);
          if (((bool)msg_typ) && (msg_typ != compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span))) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only assert strings, got %s", compiler_types_Type_str(msg_typ))));
          }
        }
        if (expr->type==compiler_ast_nodes_ASTType_BoolLiteral && expr->u.bool_literal==false) {
          node->returns=true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    m_426_2:
      {
        compiler_passes_typechecker_TypeChecker_check_statement(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    m_426_3:
      {
        if (!(compiler_passes_typechecker_TypeChecker_scope(this)->can_yield)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot yield here"));
        }
        node->etype=compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.child, NULL);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_426_4:
      {
        compiler_passes_typechecker_TypeChecker_handle_import_statement(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_426_5:
      {
        if (compiler_passes_typechecker_TypeChecker_scope(this)->loop_count==0) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s statement outside of loop", compiler_ast_nodes_ASTType_dbg(node->type))));
        }
        compiler_ast_nodes_AST *target_loop = NULL;
        bool needs_goto_break = false;
        for (compiler_ast_scopes_Scope *scope = compiler_passes_generic_pass_GenericPass_scope(this->o); ((bool)scope); scope=scope->parent) {
          if (((bool)scope->parent_loop)) {
            target_loop=scope->parent_loop;
            break;
          }
          if (scope->is_for_match && node->type==compiler_ast_nodes_ASTType_Break) {
            needs_goto_break=true;
          }
        }
        if (!(((bool)target_loop))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Internal error: Could not find loop for break/continue"));
        } else {
          node->u.target_loop=target_loop;
          target_loop->u.loop.needs_goto_break=needs_goto_break;
        }
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_426_6:
      {
        compiler_passes_typechecker_TypeChecker_check_if(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_While:
    m_426_7:
      {
        compiler_passes_typechecker_TypeChecker_check_while(this, node);
      } break;
    case compiler_ast_nodes_ASTType_For:
    m_426_8:
      {
        compiler_passes_typechecker_TypeChecker_check_for(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_426_9:
      {
        compiler_passes_typechecker_TypeChecker_check_block(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_426_10:
      {
        compiler_passes_typechecker_TypeChecker_check_match(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_426_11:
      {
        compiler_ast_nodes_Variable *var = node->u.var_decl;
        compiler_ast_scopes_Symbol *res = compiler_ast_scopes_Scope_lookup_local(compiler_passes_typechecker_TypeChecker_scope(this), var->sym->name);
        if (((bool)res)) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Variable %s already exists in this scope", var->sym->name)));
          return;
        }
        compiler_ast_scopes_Symbol *sym = var->sym;
        compiler_ast_scopes_Scope_insert(compiler_passes_typechecker_TypeChecker_scope(this), var->sym->name, sym);
        bool is_inferred = var->type==NULL;
        if (is_inferred) {
          var->type=compiler_types_Type_new_unresolved("<inferred>", node->span);
        } else {
          var->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, false, true, true);
          if (!(((bool)var->type))) {
            return;
          }
        }
        compiler_ast_nodes_AST *init = node->u.var_decl->default_value;
        if (((bool)init)) {
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, init, var->type);
          if (!(((bool)res))) {
            return;
          }
          if (is_inferred) {
            var->type=res;
          } else if (!(compiler_types_Type_eq(res, var->type, false))) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(init->span, std_format("Variable %s has type %s but initializer has type %s", var->sym->name, compiler_types_Type_str(var->type), compiler_types_Type_str(res))));
          }
        } else if (is_inferred) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Variable %s has no type and no initializer", var->sym->name)));
        }
      } break;
    default:
      {
        compiler_passes_typechecker_TypeChecker_check_expression(this, node, NULL);
      } break;
  }}

void compiler_passes_typechecker_TypeChecker_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func) {
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, func->sym);
  bool is_templated = false;
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    compiler_ast_scopes_Symbol *parent_sym = func->parent_type->sym;
    if (compiler_ast_scopes_Symbol_is_templated(parent_sym)) {
      is_templated=true;
    }
  }
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {
    is_templated=true;
  }
  if (func->checked) {
    return;
  }
  func->checked=true;
  compiler_ast_scopes_Scope *new_scope = compiler_ast_scopes_Scope_new(func->scope);
  std_vector_Vector__4 *params = func->params;
  bool was_in_template_instance = this->in_template_instance;
  this->in_template_instance=(this->in_template_instance || compiler_ast_nodes_Function_is_template_instance(func));
  u32 error_count_before = this->o->program->errors->size;
  for (std_vector_Iterator__4 _i195 = std_vector_Vector__4_iter(params); std_vector_Iterator__4_has_value(&_i195); std_vector_Iterator__4_next(&_i195)) {
    compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i195);
    {
      if (!(((bool)param->type))) {
        continue;
      }
      compiler_ast_nodes_AST *default_expr = param->default_value;
      if (((bool)default_expr)) {
        compiler_types_Type *default_type = compiler_passes_typechecker_TypeChecker_check_expression(this, default_expr, param->type);
        if (((bool)default_type) && !(compiler_types_Type_eq(default_type, param->type, false))) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(default_expr->span, std_format("Default argument has type %s but expected %s", compiler_types_Type_str(default_type), compiler_types_Type_str(param->type))));
        }
      }
      std_map_Map__5_insert(new_scope->items, param->sym->name, param->sym);
    }
  }
  new_scope->cur_func=func;
  if (((bool)func->sym) && func->sym->is_extern) {
    /* defers */
    this->in_template_instance=was_in_template_instance;
    return;
  }
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, new_scope);
  compiler_types_Type *ret_type = func->return_type;
  if ((func->is_arrow && ((bool)ret_type)) && (ret_type->base != compiler_types_BaseType_Void)) {
    compiler_types_Type *stmt_type = compiler_passes_typechecker_TypeChecker_check_expression(this, func->body, ret_type);
    if (!(((bool)stmt_type))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->body->span, "Arrow function must yield a value"));
    } else if (!(compiler_types_Type_eq(stmt_type, ret_type, false))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(func->body->span, std_format("Expected return type %s, but got %s", compiler_types_Type_str(ret_type), compiler_types_Type_str(stmt_type)), ret_type->span, std_format("Arrow function has return type %s", compiler_types_Type_str(ret_type))));
    } else {
      func->body->returns=true;
    }
  } else {
    compiler_passes_typechecker_TypeChecker_check_statement(this, func->body);
  }
  if ((!(func->body->returns) && (func->return_type->base != compiler_types_BaseType_Void)) && !(str_eq(func->sym->full_name, "main"))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, "Function does not always return"));
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
  if (is_templated) {
    if (this->o->program->errors->size > error_count_before) {
      this->o->program->errors->size=error_count_before;
    }
  }
  /* defers */
  this->in_template_instance=was_in_template_instance;
}

void compiler_passes_typechecker_TypeChecker_handle_imports(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool is_global) {
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  for (std_map_ValueIterator__4 _i196 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i196); std_map_ValueIterator__4_next(&_i196)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i196);
    {
      compiler_passes_typechecker_TypeChecker_handle_imports(this, child, false);
    }
  }
  for (std_vector_Iterator__15 _i197 = std_vector_Vector__15_iter(ns->imports); std_vector_Iterator__15_has_value(&_i197); std_vector_Iterator__15_next(&_i197)) {
    compiler_ast_nodes_AST *import_ = std_vector_Iterator__15_cur(&_i197);
    {
      compiler_passes_typechecker_TypeChecker_handle_import_statement(this, import_);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);
}

void compiler_passes_typechecker_TypeChecker_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const) {
  compiler_ast_nodes_Variable *var = node->u.var_decl;
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, var->sym);
  compiler_ast_nodes_AST *init = node->u.var_decl->default_value;
  if (is_const) {
    if (((bool)init)) {
      compiler_passes_typechecker_TypeChecker_check_const_expression(this, init, NULL);
    } else if (!(node->u.var_decl->sym->is_extern)) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Constant must have an initializer"));
    }
  } else if (((bool)init)) {
    compiler_types_Type *init_type = compiler_passes_typechecker_TypeChecker_check_expression(this, init, var->type);
    if (!(((bool)init_type)) || !(((bool)var->type))) {
      return;
    }
    if (!(compiler_types_Type_eq(init_type, var->type, false))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(init->span, std_format("Variable %s has type %s but got %s", var->sym->name, compiler_types_Type_str(var->type), compiler_types_Type_str(init_type))));
    }
  }
  compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, var->sym);
}

void compiler_passes_typechecker_TypeChecker_check_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, ns->sym);
  for (std_vector_Iterator__8 _i198 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i198); std_vector_Iterator__8_next(&_i198)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i198);
    {
      compiler_passes_typechecker_TypeChecker_check_function(this, func);
    }
  }
  for (std_vector_Iterator__15 _i199 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i199); std_vector_Iterator__15_next(&_i199)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i199);
    {
      compiler_passes_typechecker_TypeChecker_check_globals(this, node, true);
    }
  }
  for (std_vector_Iterator__15 _i200 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i200); std_vector_Iterator__15_next(&_i200)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i200);
    {
      compiler_passes_typechecker_TypeChecker_check_globals(this, node, false);
    }
  }
  for (std_vector_Iterator__14 _i201 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i201); std_vector_Iterator__14_next(&_i201)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i201);
    {
      compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, enom->sym);
      for (std_vector_Iterator__20 _i202 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i202); std_vector_Iterator__20_next(&_i202)) {
        compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i202);
        {
          compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, variant->sym);
        }
      }
    }
  }
  for (std_map_ValueIterator__4 _i203 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i203); std_map_ValueIterator__4_next(&_i203)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i203);
    {
      compiler_passes_typechecker_TypeChecker_check_namespace(this, child);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_resolve_doc_links(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym) {
  if (!((((bool)sym) && ((bool)sym->comment)))) {
    return;
  }
  std_buffer_Buffer buffer = std_buffer_Buffer_make(16);
  u32 prev = 0;
  char *doc = sym->comment;
  u32 doc_len = strlen(doc);
  for (u32 i = 0; i < (doc_len - 1); i++) {
    if (doc[i]=='\\') {
      i++;
    } else if (doc[i]==doc[(i + 1)] && doc[(i + 1)]=='{') {
      std_buffer_Buffer_write_str_f(&buffer, str_substring(doc, prev, (i - prev)));
      prev=(i + 2);
      i++;
    } else if (doc[i]==doc[(i + 1)] && doc[(i + 1)]=='}') {
      char *part = str_substring(doc, prev, (i - prev));
      if (!(this->o->program->check_doc_links)) {
        std_buffer_Buffer_write_char(&buffer, '`');
        std_buffer_Buffer_write_str_f(&buffer, part);
        std_buffer_Buffer_write_char(&buffer, '`');
        prev=(i + 2);
        i++;
        continue;
      }
      compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(part, sym->span.start.filename, NULL);
      std_span_Span span = (std_span_Span){.start=sym->comment_loc, .end=sym->comment_loc};
      std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
      if (lexer.errors->size > 0) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Invalid link: '%s' in this doc", part)));
        return;
      }
      compiler_parser_Parser parser = compiler_parser_Parser_make(this->o->program, compiler_passes_generic_pass_GenericPass_ns(this->o));
      parser.tokens=tokens;
      parser.curr=0;
      compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(&parser, true);
      if (!(((bool)ident))) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Invalid link: '%s' in this doc", part)));
        return;
      }
      compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, ident, false, NULL, true);
      if (!(((bool)sym))) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Couldn't find symbol '%s' in this doc link", part)));
        return;
      }
      char *linked_part = ({char *__yv_427;
switch ((sym->type)) {
          case compiler_ast_scopes_SymbolType_Structure:
          m_428_0:
            {
              compiler_types_Type *typ = sym->u.struc->type;
              if (((bool)typ->template_instance)) {
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(span, std_format("Cannot link directly to specialezed type '%s'", part), "Try doing `{{A}}<{{B}}>` instead of `{{A<B>}}`"));
                return;
              }
              __yv_427 = std_format("%x", sym->u.struc->type);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_Function:
          m_428_1:
            {
              __yv_427 = std_format("%x", sym->u.func);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_Enum:
          m_428_2:
            {
              __yv_427 = std_format("%x", sym->u.enom);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_428_3:
            {
              __yv_427 = std_format("%x", sym->u.enum_var);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_TypeDef:
          m_428_4:
            {
              __yv_427 = std_format("%x", sym->u.type_def);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_Variable:
          m_428_5:
            {
              __yv_427 = std_format("%x", sym->u.var);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_Constant:
          m_428_6:
            {
              __yv_427 = std_format("%x", sym->u.var);
              goto _l___yv_427;
            } break;
          case compiler_ast_scopes_SymbolType_Namespace:
          m_428_7:
            {
              __yv_427 = std_format("%x", sym->u.ns);
              goto _l___yv_427;
            } break;
          default:
            {
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Cannot link to symbol of type %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));
              return;
            } break;
        }
_l___yv_427:
      __yv_427;});
      std_buffer_Buffer_write_str(&buffer, "{{");
      std_buffer_Buffer_write_str_f(&buffer, linked_part);
      std_buffer_Buffer_write_str(&buffer, "}}");
      std_mem_free(part);
      prev=(i + 2);
      i++;
    }
  }
  std_buffer_Buffer_write_str_f(&buffer, str_substring(doc, prev, (doc_len - prev)));
  sym->comment=std_buffer_Buffer_str(buffer);
}

compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_const_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {
  compiler_types_Type *typ = ({compiler_types_Type *__yv_429;
switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      case compiler_ast_nodes_ASTType_NSLookup:
      m_430_0:
        {
          compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, true, hint, true);
          if (!(((bool)sym))) {
            return NULL;
          }
          if (sym->type != compiler_ast_scopes_SymbolType_Constant) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->span, "Cannot use a non-constant value in a constant expression", sym->span, "Value was defined here"));
            return hint;
          }
          __yv_429 = sym->u.var->type;
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_IntLiteral:
      m_430_1:
        {
          __yv_429 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_FloatLiteral:
      m_430_2:
        {
          __yv_429 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_F32, node->span);
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_BoolLiteral:
      m_430_3:
        {
          __yv_429 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_CharLiteral:
      m_430_4:
        {
          __yv_429 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Char, node->span);
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_StringLiteral:
      m_430_5:
        {
          __yv_429 = compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_430_6:
        {
          compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.binary.lhs, NULL);
          compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.binary.rhs, NULL);
          if (!(((bool)lhs)) || !(((bool)rhs))) {
            return NULL;
          }
          if (lhs->base==compiler_types_BaseType_Pointer || rhs->base==compiler_types_BaseType_Pointer) {
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot do pointer arithmetic in constant expressions"));
          }
          __yv_429 = compiler_passes_typechecker_TypeChecker_check_binary_op(this, node, compiler_types_Type_unaliased(lhs), compiler_types_Type_unaliased(rhs));
          goto _l___yv_429;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_430_7:
        {
          __yv_429 = ({compiler_types_Type *__yv_431;
switch ((node->u.unary.op)) {
              case compiler_ast_operators_Operator_BitwiseNot:
              case compiler_ast_operators_Operator_Negate:
              m_432_0:
                {
                  if (!(((bool)hint)) || !(compiler_types_Type_is_numeric(hint))) {
                    hint=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
                  }
                  compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.unary.expr, hint);
                  if (!(((bool)typ))) {
                    return NULL;
                  }
                  if (!(compiler_types_Type_is_numeric(typ))) {
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-numeric type: %s", compiler_types_Type_str(typ))));
                    return NULL;
                  }
                  __yv_431 = typ;
                  goto _l___yv_431;
                } break;
              default:
                {
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Unsupported operator in constant expression: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
                  return NULL;
                } break;
            }
_l___yv_431:
          __yv_431;});
          goto _l___yv_429;
        } break;
      default:
        {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Unsupported operator in constant expression"));
          return NULL;
        } break;
    }
_l___yv_429:
  __yv_429;});
  node->etype=typ;
  return typ;
}

void compiler_passes_typechecker_TypeChecker_handle_import_path_base(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Import *imp, std_vector_Vector__7 *parts, compiler_ast_scopes_Symbol *base, bool search_in_ns_scope, char *alias) {
  for (u32 i = 0; i < parts->size; i+=1) {
    compiler_ast_nodes_ImportPart *part = std_vector_Vector__7_at(parts, i);
switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_433_0:
        {
          compiler_passes_generic_pass_GenericPass_import_all_from_symbol(this->o, base, imp->export);
          return;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_433_1:
        {
          std_vector_Vector__22 *paths = part->u.multiple.paths;
          for (u32 j = 0; j < paths->size; j+=1) {
            std_vector_Vector__7 *path = std_vector_Vector__22_at(paths, j);
            compiler_passes_typechecker_TypeChecker_handle_import_path_base(this, node, imp, path, base, search_in_ns_scope, alias);
          }
          return;
        } break;
      case compiler_ast_nodes_ImportPartType_Single:
      m_433_2:
        {
        } break;
    }    char *name = part->u.single.name;
    if (!(((bool)name))) {
      return;
    }
    if (str_eq(name, "this")) {
      if ((i + 1) != parts->size) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, "`this` can only be used as the last part of an import path"));
        return;
      }
      if (((bool)part->u.single.alias)) {
        alias=part->u.single.alias;
      }
      break;
    }
    std_span_Span err_span = part->u.single.alias_span;
    compiler_ast_scopes_Symbol *new_base = ({compiler_ast_scopes_Symbol *__yv_434;
      if (search_in_ns_scope) {
        if (base->type != compiler_ast_scopes_SymbolType_Namespace) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, "Cannot scope-import from a non-namespace"));
          return;
        }
        compiler_ast_scopes_Symbol *res = compiler_ast_scopes_Scope_lookup_recursive(base->u.ns->scope, name);
        search_in_ns_scope=false;
        __yv_434 = res;
        goto _l___yv_434;
      } else {
        __yv_434 = compiler_passes_generic_pass_GenericPass_find_in_symbol(this->o, base, name, false);
        goto _l___yv_434;
      }
_l___yv_434:
    __yv_434;});
    if (!(((bool)new_base))) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, std_format("Invalid import, %s::%s does not exist", base->name, name)));
      return;
    }
    base=new_base;
    alias=part->u.single.alias;
    if (!(((bool)alias))) {
      alias=name;
    }
    part->resolved_symbol=base;
    compiler_ast_scopes_Symbol_add_reference(base, compiler_ast_scopes_ReferenceType_Normal, part->u.single.name_span);
  }
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, base, alias);
  if (imp->export) {
    std_map_Map__5_insert(compiler_passes_generic_pass_GenericPass_ns(this->o)->exported_symbols, alias, base);
  }
}

void compiler_passes_typechecker_TypeChecker_handle_import_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Import path = node->u.import_path;
  bool search_in_ns_scope = false;
  compiler_ast_program_Namespace *base_ns = ({compiler_ast_program_Namespace *__yv_435;
switch ((path.type)) {
      case compiler_ast_nodes_ImportType_GlobalNamespace:
      m_436_0:
        {
          __yv_435 = this->o->program->global;
          goto _l___yv_435;
        } break;
      case compiler_ast_nodes_ImportType_ProjectNamespace:
      m_436_1:
        {
          __yv_435 = compiler_ast_program_Namespace_get_project_root(compiler_passes_generic_pass_GenericPass_ns(this->o), node->span, this->o->program);
          goto _l___yv_435;
        } break;
      case compiler_ast_nodes_ImportType_ParentNamespace:
      m_436_2:
        {
          compiler_ast_program_Namespace *cur = compiler_passes_generic_pass_GenericPass_ns(this->o);
          for (u32 i = 0; i < path.parent_count; i+=1) {
            if (!(((bool)cur->parent))) {
              compiler_errors_Error_panic(compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot import from parent of root namespace")));
              return;
            }
            cur=cur->parent;
          }
          __yv_435 = cur;
          goto _l___yv_435;
        } break;
      case compiler_ast_nodes_ImportType_CurrentScope:
      m_436_3:
        {
          search_in_ns_scope=true;
          __yv_435 = compiler_passes_generic_pass_GenericPass_ns(this->o);
          goto _l___yv_435;
        } break;
    }
_l___yv_435:
  __yv_435;});
  if (!(((bool)base_ns))) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Couldn't resolve the search base for the import"));
    return;
  }
  node->u.import_path.root_sym=base_ns->sym;
  compiler_passes_typechecker_TypeChecker_handle_import_path_base(this, node, &path, path.parts, base_ns->sym, search_in_ns_scope, NULL);
}

void compiler_passes_typechecker_TypeChecker_pre_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *func) {
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    std_span_Span parent_span = func->parent_type->span;
    compiler_types_Type *parent_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, func->parent_type, true, true, true);
    if (!(((bool)parent_type))) {
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(parent_span, "Could not find this type"));
      return;
    }
    if (!(compiler_types_Type_can_have_methods(parent_type))) {
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(parent_span, "This type cannot have methods"));
      return;
    }
switch ((parent_type->base)) {
      case compiler_types_BaseType_Structure:
      m_437_0:
        {
          compiler_ast_nodes_Structure *struc = parent_type->u.struc;
          compiler_ast_nodes_Variable *name = compiler_ast_nodes_Structure_get_field(struc, func->sym->name);
          if (((bool)name)) {
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Field with name `%s` already exists", func->sym->name), name->sym->span, "Previous definition here"));
          }
        } break;
      case compiler_types_BaseType_Enum:
      m_437_1:
        {
          compiler_ast_nodes_Enum *enom = parent_type->u.enom;
          compiler_ast_nodes_EnumVariant *var = compiler_ast_nodes_Enum_get_variant(enom, func->sym->name);
          if (((bool)var)) {
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Enum variant with name `%s` already exists", func->sym->name), var->sym->span, "Previous definition here"));
          }
          compiler_ast_nodes_Variable *field = compiler_ast_nodes_Enum_get_shared_field(enom, func->sym->name);
          if (((bool)field)) {
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Field with name `%s` already exists", func->sym->name), field->sym->span, "Previous definition here"));
          }
        } break;
      default:
        {
        } break;
    }    compiler_ast_nodes_Function *res = std_map_Map__9_get(parent_type->methods, func->sym->name, NULL);
    if (((bool)res)) {
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, "Method with this name already exists", res->sym->span, "Previous definition here"));
      return;
    }
    compiler_ast_scopes_Symbol_update_parent(func->sym, parent_type->sym);
    std_map_Map__9_insert(parent_type->methods, func->sym->name, func);
    func->parent_type=parent_type;
  } else {
    compiler_ast_scopes_Symbol *item = func->sym;
    compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);
  }
  func->scope=compiler_passes_typechecker_TypeChecker_scope(this);
}

void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc) {
  for (std_vector_Iterator__4 _i204 = std_vector_Vector__4_iter(struc->fields); std_vector_Iterator__4_has_value(&_i204); std_vector_Iterator__4_next(&_i204)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i204);
    {
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, true, false, false);
      field->type=res;
    }
  }
}

void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom) {
  for (std_vector_Iterator__4 _i205 = std_vector_Vector__4_iter(enom->shared_fields); std_vector_Iterator__4_has_value(&_i205); std_vector_Iterator__4_next(&_i205)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i205);
    {
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, true, false, false);
      field->type=res;
    }
  }
  for (std_vector_Iterator__20 _i206 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i206); std_vector_Iterator__20_next(&_i206)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i206);
    {
      for (std_vector_Iterator__4 _i207 = std_vector_Vector__4_iter(variant->specific_fields); std_vector_Iterator__4_has_value(&_i207); std_vector_Iterator__4_next(&_i207)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i207);
        {
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, true, false, false);
          field->type=res;
        }
      }
    }
  }
}

void compiler_passes_typechecker_TypeChecker_resolve_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc) {
  std_vector_Vector__4 *fields = struc->fields;
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, struc->sym);
  if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {
    compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(this, struc);
    return;
  }
  for (std_vector_Iterator__4 _i208 = std_vector_Vector__4_iter(fields); std_vector_Iterator__4_has_value(&_i208); std_vector_Iterator__4_next(&_i208)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i208);
    {
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);
      compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, field->sym);
      if (!(((bool)res))) {
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(field->sym->span, "Couldn't resolve type"));
      } else {
        field->type=res;
      }
      if (((bool)field->default_value)) {
        compiler_passes_typechecker_TypeChecker_check_expression(this, field->default_value, field->type);
      }
    }
  }
}

void compiler_passes_typechecker_TypeChecker_resolve_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom) {
  if (compiler_ast_scopes_Symbol_is_templated(enom->sym)) {
    compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_enum(this, enom);
    return;
  }
  std_map_Map__12 *seen_fields = std_map_Map__12_new(8);
  for (std_vector_Iterator__4 _i209 = std_vector_Vector__4_iter(enom->shared_fields); std_vector_Iterator__4_has_value(&_i209); std_vector_Iterator__4_next(&_i209)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i209);
    {
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);
      if (((bool)res)) {
        field->type=res;
      }
      std_map_Item__12 *item = std_map_Map__12_get_item(seen_fields, field->sym->name);
      if (((bool)item)) {
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(field->sym->span, std_format("Field with name `%s` already exists", field->sym->name), item->value, "Previous definition here"));
      }
      std_map_Map__12_insert(seen_fields, field->sym->name, field->sym->span);
      if (((bool)field->default_value)) {
        compiler_passes_typechecker_TypeChecker_check_expression(this, field->default_value, field->type);
      }
    }
  }
  for (std_vector_Iterator__20 _i210 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i210); std_vector_Iterator__20_next(&_i210)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i210);
    {
      for (std_vector_Iterator__4 _i211 = std_vector_Vector__4_iter(variant->specific_fields); std_vector_Iterator__4_has_value(&_i211); std_vector_Iterator__4_next(&_i211)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i211);
        {
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);
          if (((bool)res)) {
            field->type=res;
          }
        }
      }
    }
  }
  /* defers */
  std_map_Map__12_free(seen_fields);
}

void compiler_passes_typechecker_TypeChecker_check_operator_overload_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_operators_Operator op) {
  u32 num_params_needed = compiler_ast_operators_Operator_num_overload_params(op);
  if (num_params_needed != func->params->size) {
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, std_format("Operator overload for %s must have %u parameters", compiler_ast_operators_Operator_dbg(op), num_params_needed)));
    return;
  }
  if (compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(op)) {
    compiler_ast_nodes_Variable *lhs = std_vector_Vector__4_at(func->params, 0);
    compiler_types_Type *lhs_type = compiler_types_Type_unaliased(lhs->type);
    if (lhs_type->base != compiler_types_BaseType_Pointer) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs->sym->span, std_format("First parameter of %s operator must be a pointer-type", compiler_ast_operators_Operator_dbg(op))));
      return;
    }
  }
switch ((op)) {
    case compiler_ast_operators_Operator_Equals:
    case compiler_ast_operators_Operator_NotEquals:
    case compiler_ast_operators_Operator_IsNotNull:
    m_438_0:
              if (func->return_type->base != compiler_types_BaseType_Bool) {
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, "`==` operator must return a boolean"));
          return;
        }
       break;
    default:
      {
      } break;
  }  compiler_ast_operators_OperatorOverload overload = {0};
  overload.op=op;
  if (num_params_needed > 0) {
    overload.type1=std_vector_Vector__4_at(func->params, 0)->type;
  }
  if (num_params_needed > 1) {
    overload.type2=std_vector_Vector__4_at(func->params, 1)->type;
  }
  if (num_params_needed > 2) {
    overload.type3=std_vector_Vector__4_at(func->params, 2)->type;
  }
  std_map_Item__6 *it = std_map_Map__6_get_item(this->o->program->operator_overloads, overload);
  if (((bool)it)) {
    if (it->value != func) {
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(func->sym->span, std_format("Operator overload for %s already exists (%s)", compiler_ast_operators_Operator_dbg(op), func->sym->display), it->value->sym->span, std_format("Previous definition here (%s)", it->value->sym->display)));
    }
    return;
  }
  std_map_Map__6_insert(this->o->program->operator_overloads, overload, func);
}

void compiler_passes_typechecker_TypeChecker_check_function_declaration(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func) {
  bool allow_incomplete = false;
  bool error = true;
  bool resolve_templates = true;
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    compiler_ast_scopes_Symbol *parent_sym = func->parent_type->sym;
    if (compiler_ast_scopes_Symbol_is_templated(parent_sym)) {
      allow_incomplete=true;
      error=false;
      resolve_templates=false;
    }
  }
  std_span_Span func_span = ({std_span_Span __yv_439;
switch ((func->kind)) {
      case compiler_ast_nodes_FunctionKind_Closure:
      m_440_0:
        {
          __yv_439 = func->span;
          goto _l___yv_439;
        } break;
      default:
        {
          __yv_439 = func->sym->span;
          goto _l___yv_439;
        } break;
    }
_l___yv_439:
  __yv_439;});
  if (((bool)func->sym) && compiler_ast_scopes_Symbol_is_templated(func->sym)) {
    allow_incomplete=true;
    error=false;
    resolve_templates=false;
  }
  func->return_type=compiler_passes_typechecker_TypeChecker_resolve_type(this, func->return_type, allow_incomplete, error, resolve_templates);
  if (!(((bool)func->return_type))) {
    func->return_type=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Void, func_span);
  }
  for (std_vector_Iterator__4 _i212 = std_vector_Vector__4_iter(func->params); std_vector_Iterator__4_has_value(&_i212); std_vector_Iterator__4_next(&_i212)) {
    compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i212);
    {
      param->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, param->type, allow_incomplete, error, resolve_templates);
    }
  }
  if (((bool)func->operator_overloads)) {
    for (std_vector_Iterator__21 _i213 = std_vector_Vector__21_iter(func->operator_overloads); std_vector_Iterator__21_has_value(&_i213); std_vector_Iterator__21_next(&_i213)) {
      compiler_ast_operators_Operator op = std_vector_Iterator__21_cur(&_i213);
      {
        compiler_passes_typechecker_TypeChecker_check_operator_overload_function(this, func, op);
      }
    }
  }
  if (((bool)func->name_ast) && func->name_ast->type==compiler_ast_nodes_ASTType_NSLookup) {
    compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, func->name_ast->u.lookup.lhs, false, NULL, false);
  }
  if (func->kind==compiler_ast_nodes_FunctionKind_Closure) {
    func->type=compiler_passes_typechecker_TypeChecker_get_closure_type(this, func->params, func->return_type, func->type);
  } else {
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, func_span);
    typ->u.func=(compiler_types_FunctionType){.orig=func, .params=func->params, .return_type=func->return_type, .is_variadic=func->is_variadic};
    func->type=typ;
  }
}

void compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool pre_import) {
  for (std_map_Iterator__2 _i214 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i214); std_map_Iterator__2_next(&_i214)) {
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i214);
    {
      if (compiler_types_Type_is_resolved(it->value)) {
        continue;
      }
      compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_recursive(compiler_passes_generic_pass_GenericPass_scope(this->o), it->key);
      if(!(((bool)sym))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:3598:16: Assertion failed: `sym?`", "Should have added the symbol into scope already"); }
      if(!(sym->type==compiler_ast_scopes_SymbolType_TypeDef)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:3602:16: Assertion failed: `sym.type == TypeDef`", NULL); }
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, it->value, false, !(pre_import), true);
      if (!(((bool)res))) {
        continue;
      }
      sym->u.type_def->u.ptr=res;
      sym->u.type_def=res;
      it->value=res;
    }
  }
}

void compiler_passes_typechecker_TypeChecker_check_post_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);
  for (std_vector_Iterator__8 _i215 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i215); std_vector_Iterator__8_next(&_i215)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i215);
    {
      compiler_passes_typechecker_TypeChecker_check_function_declaration(this, func);
    }
  }
  for (std_vector_Iterator__13 _i216 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i216); std_vector_Iterator__13_next(&_i216)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i216);
    {
      compiler_passes_typechecker_TypeChecker_resolve_struct(this, struc);
    }
  }
  for (std_vector_Iterator__14 _i217 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i217); std_vector_Iterator__14_next(&_i217)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i217);
    {
      compiler_passes_typechecker_TypeChecker_resolve_enum(this, enom);
    }
  }
  for (std_vector_Iterator__15 _i218 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i218); std_vector_Iterator__15_next(&_i218)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i218);
    {
      compiler_passes_typechecker_TypeChecker_pre_check_globals(this, node, true);
    }
  }
  for (std_vector_Iterator__15 _i219 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i219); std_vector_Iterator__15_next(&_i219)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i219);
    {
      compiler_passes_typechecker_TypeChecker_pre_check_globals(this, node, false);
    }
  }
  compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(this, ns, false);
  for (std_map_ValueIterator__4 _i220 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i220); std_map_ValueIterator__4_next(&_i220)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i220);
    {
      compiler_passes_typechecker_TypeChecker_check_post_import(this, child);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);
}

void compiler_passes_typechecker_TypeChecker_pre_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const) {
  compiler_ast_nodes_Variable *var = node->u.var_decl;
  if (!(((bool)var->type))) {
    char *c = (is_const ? "Constant" : "Global variable");
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s must have a type", c)));
    return;
  }
  compiler_types_Type *type = compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, false, true, true);
  if (!(((bool)type))) {
    return;
  }
  var->type=type;
}

void compiler_passes_typechecker_TypeChecker_check_pre_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  for (std_vector_Iterator__8 _i221 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i221); std_vector_Iterator__8_next(&_i221)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i221);
    {
      compiler_passes_typechecker_TypeChecker_pre_check_function(this, ns, func);
    }
  }
  compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(this, ns, true);
  for (std_map_ValueIterator__4 _i222 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i222); std_map_ValueIterator__4_next(&_i222)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i222);
    {
      compiler_passes_typechecker_TypeChecker_check_pre_import(this, child);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_typechecker_TypeChecker_run(compiler_ast_program_Program *program) {
  compiler_passes_typechecker_TypeChecker pass = (compiler_passes_typechecker_TypeChecker){.o=compiler_passes_generic_pass_GenericPass_new(program), .unchecked_functions=std_vector_Vector__8_new(16), .in_template_instance=false};
  compiler_passes_typechecker_TypeChecker_check_pre_import(&pass, program->global);
  compiler_passes_typechecker_TypeChecker_handle_imports(&pass, program->global, true);
  compiler_passes_typechecker_TypeChecker_check_post_import(&pass, program->global);
  compiler_passes_typechecker_TypeChecker_check_namespace(&pass, program->global);
  compiler_passes_generic_pass_GenericPass_push_namespace(pass.o, program->global);
  while (pass.unchecked_functions->size > 0) {
    compiler_ast_nodes_Function *func = std_vector_Vector__8_pop(pass.unchecked_functions);
    compiler_passes_typechecker_TypeChecker_check_function(&pass, func);
  }
  compiler_passes_generic_pass_GenericPass_pop_namespace(pass.o);
}

void compiler_passes_code_generator_CodeGenerator_gen_indent(compiler_passes_code_generator_CodeGenerator *this) {
  for (u32 i = 0; i < this->indent; i+=1) {
    std_buffer_Buffer_write_str(&this->out, "  ");
  }
}

void str_replace(char **this, char *other) {
  char *s = (*this);
  std_mem_free(s);
  (*this)=other;
}

compiler_errors_Error *compiler_passes_code_generator_CodeGenerator_error(compiler_passes_code_generator_CodeGenerator *this, compiler_errors_Error *err) {
  return compiler_passes_generic_pass_GenericPass_error(this->o, err);}

compiler_ast_scopes_Scope *compiler_passes_code_generator_CodeGenerator_scope(compiler_passes_code_generator_CodeGenerator *this) {
  return compiler_passes_generic_pass_GenericPass_scope(this->o);}

void compiler_passes_code_generator_CodeGenerator_gen_debug_info(compiler_passes_code_generator_CodeGenerator *this, std_span_Span span, bool force) {
  if (!(this->o->program->gen_debug_info) && !(force)) {
    return;
  }
  std_span_Location loc = span.start;
  std_buffer_Buffer_write_str_f(&this->out, std_format("\n#line %u \"%s\"\n", loc.line, loc.filename));
}

char *compiler_passes_code_generator_CodeGenerator_get_op(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  return ({char *__yv_441;
switch ((node->type)) {
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_442_0:
        {
          __yv_441 = ({char *__yv_443;
switch ((node->u.binary.op)) {
              case compiler_ast_operators_Operator_And:
              m_444_0:
                {
                  __yv_443 = "&&";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Assignment:
              case compiler_ast_operators_Operator_IndexAssign:
              m_444_1:
                {
                  __yv_443 = "=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_BitwiseAnd:
              m_444_2:
                {
                  __yv_443 = "&";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_BitwiseOr:
              m_444_3:
                {
                  __yv_443 = "|";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_BitwiseXor:
              m_444_4:
                {
                  __yv_443 = "^";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Divide:
              m_444_5:
                {
                  __yv_443 = "/";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Equals:
              m_444_6:
                {
                  __yv_443 = "==";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_GreaterThan:
              m_444_7:
                {
                  __yv_443 = ">";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_GreaterThanEquals:
              m_444_8:
                {
                  __yv_443 = ">=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_LeftShift:
              m_444_9:
                {
                  __yv_443 = "<<";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_LessThan:
              m_444_10:
                {
                  __yv_443 = "<";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_LessThanEquals:
              m_444_11:
                {
                  __yv_443 = "<=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Minus:
              m_444_12:
                {
                  __yv_443 = "-";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Modulus:
              m_444_13:
                {
                  __yv_443 = "%";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Multiply:
              m_444_14:
                {
                  __yv_443 = "*";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_NotEquals:
              m_444_15:
                {
                  __yv_443 = "!=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Or:
              m_444_16:
                {
                  __yv_443 = "||";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_Plus:
              m_444_17:
                {
                  __yv_443 = "+";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_PlusEquals:
              m_444_18:
                {
                  __yv_443 = "+=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_MinusEquals:
              m_444_19:
                {
                  __yv_443 = "-=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_MultiplyEquals:
              m_444_20:
                {
                  __yv_443 = "*=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_DivideEquals:
              m_444_21:
                {
                  __yv_443 = "/=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_RightShift:
              m_444_22:
                {
                  __yv_443 = ">>";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_LeftShiftEquals:
              m_444_23:
                {
                  __yv_443 = "<<=";
                  goto _l___yv_443;
                } break;
              case compiler_ast_operators_Operator_RightShiftEquals:
              m_444_24:
                {
                  __yv_443 = ">>=";
                  goto _l___yv_443;
                } break;
              default:
                {
                  std_panic(std_format("Unknown binary op type in get_op: %s", compiler_ast_operators_Operator_dbg(node->u.binary.op)));
                  goto _l___yv_443;
                } break;
            }
_l___yv_443:
          __yv_443;});
          goto _l___yv_441;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_442_1:
        {
          __yv_441 = ({char *__yv_445;
switch ((node->u.unary.op)) {
              case compiler_ast_operators_Operator_PreDecrement:
              m_446_0:
                {
                  __yv_445 = "--";
                  goto _l___yv_445;
                } break;
              case compiler_ast_operators_Operator_PreIncrement:
              m_446_1:
                {
                  __yv_445 = "++";
                  goto _l___yv_445;
                } break;
              case compiler_ast_operators_Operator_PostDecrement:
              m_446_2:
                {
                  __yv_445 = "--";
                  goto _l___yv_445;
                } break;
              case compiler_ast_operators_Operator_PostIncrement:
              m_446_3:
                {
                  __yv_445 = "++";
                  goto _l___yv_445;
                } break;
              default:
                {
                  std_panic(std_format("Unknown unary op type in get_op: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op)));
                  goto _l___yv_445;
                } break;
            }
_l___yv_445:
          __yv_445;});
          goto _l___yv_441;
        } break;
      default:
        {
          std_panic(std_format("Unknown op type in get_op: %s", compiler_ast_nodes_ASTType_dbg(node->type)));
          goto _l___yv_441;
        } break;
    }
_l___yv_441:
  __yv_441;});}

void compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(compiler_passes_code_generator_CodeGenerator *this) {
    std_buffer_Buffer_write_str(&this->out, "({");
}

void compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(compiler_passes_code_generator_CodeGenerator *this) {
    std_buffer_Buffer_write_str(&this->out, "})");
}

bool compiler_passes_code_generator_CodeGenerator_gen_internal_print(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after, bool is_stderr) {
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  if (is_stderr) {
    std_buffer_Buffer_write_str(&this->out, "fprintf(stderr, ");
  } else {
    std_buffer_Buffer_write_str(&this->out, "printf(");
  }
  std_vector_Vector__9 *args = node->u.call.args;
  compiler_ast_nodes_Argument *first = std_vector_Vector__9_at(args, 0);
  if (first->expr->type==compiler_ast_nodes_ASTType_FormatStringLiteral) {
    compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, first->expr, newline_after);
    std_buffer_Buffer_write_str(&this->out, ")");
    return true;
  }
  for (u32 i = 0; i < args->size; i+=1) {
    if (i > 0) {
      std_buffer_Buffer_write_str(&this->out, ", ");
    }
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
    if (i==0 && newline_after) {
      std_buffer_Buffer_write_str(&this->out, "\"\\n\"");
    }
  }
  std_buffer_Buffer_write_str(&this->out, ")");
  return true;
}

void compiler_passes_code_generator_CodeGenerator_gen_format_string_part(compiler_passes_code_generator_CodeGenerator *this, char *part) {
  u32 len = strlen(part);
  for (u32 i = 0; i < len; i+=1) {
    switch (part[i]) {
      case '\\': {
        i+=1;
        switch (part[i]) {
          case '`':          case '{':          case '}': {
          } break;
          default: {
            std_buffer_Buffer_write_char(&this->out, '\\');
          } break;
        }
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '"': {
        std_buffer_Buffer_write_char(&this->out, '\\');
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '%': {
        std_buffer_Buffer_write_char(&this->out, '%');
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '\n': {
        std_buffer_Buffer_write_str(&this->out, "\\n");
      } break;
      default: {
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_string_literal(compiler_passes_code_generator_CodeGenerator *this, char *literal) {
  u32 len = strlen(literal);
  for (u32 i = 0; i < len; i+=1) {
    switch (literal[i]) {
      case '\n': {
        std_buffer_Buffer_write_str(&this->out, "\\n");
      } break;
      default: {
        std_buffer_Buffer_write_char(&this->out, literal[i]);
      } break;
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr) {
  if (type->base==compiler_types_BaseType_Structure) {
    compiler_ast_nodes_Structure *struc = type->u.struc;
    if (((bool)struc) && ((bool)struc->format_spec)) {
      std_buffer_Buffer_write_str(&this->out, struc->format_spec);
      return;
    }
  }
  compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(expr->span, std_format("Invalid type in CodeGenerator::format_string_custom_specifier: '%s'", compiler_types_Type_str(type))));
  std_buffer_Buffer_write_str(&this->out, "%s");
}

void compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr) {
  if (type->base==compiler_types_BaseType_Structure) {
    compiler_ast_nodes_Structure *struc = type->u.struc;
    if (((bool)struc) && ((bool)struc->format_args)) {
      for (std_CharIterator _i124 = str_chars(struc->format_args, 0); std_CharIterator_has_value(&_i124); std_CharIterator_next(&_i124)) {
        char c = std_CharIterator_cur(&_i124);
        {
          if (c=='$') {
            std_buffer_Buffer_write_str(&this->out, "(");
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
            std_buffer_Buffer_write_str(&this->out, ")");
          } else {
            std_buffer_Buffer_write_char(&this->out, c);
          }
        }
      }
      return;
    }
  }
  compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(expr->span, std_format("Invalid type in CodeGenerator::format_string_custom_argument: '%s'", compiler_types_Type_str(type))));
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
}

void compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after) {
  std_vector_Vector__1 *parts = node->u.fmt_str.parts;
  std_vector_Vector__15 *exprs = node->u.fmt_str.exprs;
  std_vector_Vector__1 *specs = node->u.fmt_str.specs;
  std_buffer_Buffer_write_char(&this->out, '"');
  for (u32 i = 0; i < exprs->size; i+=1) {
    char *part = std_vector_Vector__1_at(parts, i);
    compiler_ast_nodes_AST *expr = std_vector_Vector__15_at(exprs, i);
    compiler_passes_code_generator_CodeGenerator_gen_format_string_part(this, part);
    char *spec = std_vector_Vector__1_at(specs, i);
    if (((bool)spec)) {
      std_buffer_Buffer_write_str(&this->out, "%");
      std_buffer_Buffer_write_str(&this->out, spec);
      continue;
    }
    compiler_types_Type *expr_type = compiler_types_Type_unaliased(expr->etype);
switch ((expr_type->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      m_447_0:
        {
          std_buffer_Buffer_write_str(&this->out, "%d");
        } break;
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      m_447_1:
        {
          std_buffer_Buffer_write_str(&this->out, "%u");
        } break;
      case compiler_types_BaseType_I64:
      m_447_2:
        {
          std_buffer_Buffer_write_str(&this->out, "%\" PRId64 \"");
        } break;
      case compiler_types_BaseType_U64:
      m_447_3:
        {
          std_buffer_Buffer_write_str(&this->out, "%\" PRIu64 \"");
        } break;
      case compiler_types_BaseType_Bool:
      m_447_4:
        {
          std_buffer_Buffer_write_str(&this->out, "%s");
        } break;
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_447_5:
        {
          std_buffer_Buffer_write_str(&this->out, "%f");
        } break;
      case compiler_types_BaseType_Char:
      m_447_6:
        {
          std_buffer_Buffer_write_str(&this->out, "%c");
        } break;
      case compiler_types_BaseType_Pointer:
      m_447_7:
        {
switch ((expr_type->u.ptr->base)) {
            case compiler_types_BaseType_Char:
            m_448_0:
              {
                std_buffer_Buffer_write_str(&this->out, "%s");
              } break;
            default:
              {
                std_buffer_Buffer_write_str(&this->out, "%p");
              } break;
          }        } break;
      default:
        {
          compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(this, expr_type, expr);
        } break;
    }  }
  char *part = std_vector_Vector__1_back(parts, 0);
  compiler_passes_code_generator_CodeGenerator_gen_format_string_part(this, part);
  if (newline_after) {
    std_buffer_Buffer_write_str(&this->out, "\\n");
  }
  std_buffer_Buffer_write_char(&this->out, '"');
  for (std_vector_Iterator__15 _i125 = std_vector_Vector__15_iter(exprs); std_vector_Iterator__15_has_value(&_i125); std_vector_Iterator__15_next(&_i125)) {
    compiler_ast_nodes_AST *expr = std_vector_Iterator__15_cur(&_i125);
    {
      compiler_types_Type *expr_type = compiler_types_Type_unaliased(expr->etype);
      std_buffer_Buffer_write_str(&this->out, ", ");
switch ((expr_type->base)) {
        case compiler_types_BaseType_I8:
        case compiler_types_BaseType_I16:
        case compiler_types_BaseType_I32:
        case compiler_types_BaseType_U8:
        case compiler_types_BaseType_U16:
        case compiler_types_BaseType_U32:
        case compiler_types_BaseType_I64:
        case compiler_types_BaseType_U64:
        case compiler_types_BaseType_F32:
        case compiler_types_BaseType_F64:
        case compiler_types_BaseType_Char:
        case compiler_types_BaseType_Pointer:
        m_449_0:
          {
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
          } break;
        case compiler_types_BaseType_Bool:
        m_449_1:
          {
            std_buffer_Buffer_write_str(&this->out, "((");
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
            std_buffer_Buffer_write_str(&this->out, ") ? \"true\" : \"false\")");
          } break;
        default:
          {
            compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(this, expr_type, expr);
          } break;
      }    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_format_string(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  if (this->o->program->did_cache_symbols) {
    std_buffer_Buffer_write_str(&this->out, this->o->program->cached_symbols.fmt_string_fn->full_name);
  } else {
    compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, "Can't use format string without using stdlib"));
    std_buffer_Buffer_write_str(&this->out, "unknown");
  }
  std_buffer_Buffer_write_str(&this->out, "(");
  compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, node, false);
  std_buffer_Buffer_write_str(&this->out, ")");
}

void compiler_passes_code_generator_CodeGenerator_gen_vector_literal(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  if(!(node->type==compiler_ast_nodes_ASTType_VectorLiteral)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:283:12: Assertion failed: `node.type == VectorLiteral`", NULL); }
  compiler_ast_nodes_VectorLiteral vec_lit = node->u.vec_literal;
  if(!(((bool)vec_lit.vec_type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:285:12: Assertion failed: `vec_lit.vec_type?`", NULL); }
  compiler_ast_nodes_Function *new_method = std_map_Map__9_at(vec_lit.vec_type->methods, "new");
  compiler_ast_nodes_Function *push_method = std_map_Map__9_at(vec_lit.vec_type->methods, "push");
  char *var = std_format("_vc%u", this->o->program->uid++);
  compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
  std_buffer_Buffer_write_str(&this->out, "\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, new_method->return_type, var);
  std_buffer_Buffer_write_str(&this->out, " = ");
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(new_method->sym));
  u32 size = vec_lit.elements->size;
  if (size==0) {
    size=8;
  }
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%u);\n", size));
  for (std_vector_Iterator__15 _i126 = std_vector_Vector__15_iter(vec_lit.elements); std_vector_Iterator__15_has_value(&_i126); std_vector_Iterator__15_next(&_i126)) {
    compiler_ast_nodes_AST *expr = std_vector_Iterator__15_cur(&_i126);
    {
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);
      std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(push_method->sym));
      std_buffer_Buffer_write_str_f(&this->out, std_format("(%s, ", var));
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
      std_buffer_Buffer_write_str(&this->out, ");\n");
    }
  }
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, var);
  std_buffer_Buffer_write_str(&this->out, ";");
  compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
  this->indent-=1;
}

void compiler_passes_code_generator_CodeGenerator_gen_map_literal(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  if(!(node->type==compiler_ast_nodes_ASTType_MapLiteral)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:320:12: Assertion failed: `node.type == MapLiteral`", NULL); }
  compiler_ast_nodes_MapLiteral map_lit = node->u.map_literal;
  if(!(((bool)map_lit.map_type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:322:12: Assertion failed: `map_lit.map_type?`", NULL); }
  compiler_ast_nodes_Function *new_method = std_map_Map__9_at(map_lit.map_type->methods, "new");
  compiler_ast_nodes_Function *insert_method = std_map_Map__9_at(map_lit.map_type->methods, "insert");
  char *var = std_format("_mc%u", this->o->program->uid++);
  compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
  std_buffer_Buffer_write_str(&this->out, "\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, new_method->return_type, var);
  std_buffer_Buffer_write_str(&this->out, " = ");
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(new_method->sym));
  u32 size = map_lit.elements->size;
  if (size==0) {
    size=8;
  }
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%u);\n", size));
  for (std_vector_Iterator__25 _i127 = std_vector_Vector__25_iter(map_lit.elements); std_vector_Iterator__25_has_value(&_i127); std_vector_Iterator__25_next(&_i127)) {
    compiler_ast_nodes_MapLiteralPair expr = std_vector_Iterator__25_cur(&_i127);
    {
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);
      std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(insert_method->sym));
      std_buffer_Buffer_write_str_f(&this->out, std_format("(%s, ", var));
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr.key, false, false);
      std_buffer_Buffer_write_str(&this->out, ", ");
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr.value, false, false);
      std_buffer_Buffer_write_str(&this->out, ");\n");
    }
  }
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, var);
  std_buffer_Buffer_write_str(&this->out, ";");
  compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
  this->indent-=1;
}

void compiler_passes_code_generator_CodeGenerator_gen_yield_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr) {
  char *yield_var = std_vector_Vector__1_back(this->yield_vars, 0);
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  if (!(expr->returns)) {
    std_buffer_Buffer_write_str(&this->out, yield_var);
    std_buffer_Buffer_write_str(&this->out, " = ");
  }
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
  std_buffer_Buffer_write_str(&this->out, ";\n");
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str_f(&this->out, std_format("goto _l_%s;\n", yield_var));
}

void compiler_passes_code_generator_CodeGenerator_gen_constant(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Variable *const_ = node->u.var_decl;
  if (const_->sym->is_dead) {
    return;
  }
  if (!(const_->sym->is_extern)) {
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "#define ");
    std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(const_->sym));
    std_buffer_Buffer_write_str(&this->out, " (");
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.var_decl->default_value, false, false);
    std_buffer_Buffer_write_str(&this->out, ")\n");
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_constants(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {
  for (std_vector_Iterator__15 _i128 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i128); std_vector_Iterator__15_next(&_i128)) {
    compiler_ast_nodes_AST *const_ = std_vector_Iterator__15_cur(&_i128);
    {
      compiler_passes_code_generator_CodeGenerator_gen_constant(this, const_);
    }
  }
  for (std_map_ValueIterator__4 _i129 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i129); std_map_ValueIterator__4_next(&_i129)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i129);
    {
      compiler_passes_code_generator_CodeGenerator_gen_constants(this, child);
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_global_variables(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {
  for (std_vector_Iterator__15 _i130 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i130); std_vector_Iterator__15_next(&_i130)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i130);
    {
      compiler_ast_nodes_Variable *var = node->u.var_decl;
      if (var->sym->is_dead) {
        continue;
      }
      if (!(var->sym->is_extern)) {
        compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, node);
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }
  }
  for (std_map_ValueIterator__4 _i131 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i131); std_map_ValueIterator__4_next(&_i131)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i131);
    {
      compiler_passes_code_generator_CodeGenerator_gen_global_variables(this, child);
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_control_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body) {
  if (body->type==compiler_ast_nodes_ASTType_Block) {
    compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
  } else {
    bool is_elif = body->type==compiler_ast_nodes_ASTType_If;
    if (!(is_elif)) {
      std_buffer_Buffer_write_str(&this->out, "{\n");
    }
    this->indent+=1;
    if (((bool)node->etype) && (body->type != compiler_ast_nodes_ASTType_Yield)) {
      compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, body);
    } else {
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, body);
    }
    this->indent-=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    if (!(is_elif)) {
      std_buffer_Buffer_write_str(&this->out, "}");
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  char *yield_var = std_format("__yv_%u", this->o->program->uid++);
  std_vector_Vector__1_push(this->yield_vars, yield_var);
  compiler_types_Type *ret_type = node->etype;
  compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, ret_type, yield_var);
  std_buffer_Buffer_write_str(&this->out, ";\n");
  if (node->type==compiler_ast_nodes_ASTType_Block) {
    compiler_passes_code_generator_CodeGenerator_gen_block(this, node, false);
  } else {
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_statement(this, node);
    this->indent-=1;
  }
  std_buffer_Buffer_write_str(&this->out, "\n");
  std_buffer_Buffer_write_str_f(&this->out, std_format("_l_%s:\n", yield_var));
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, yield_var);
  std_buffer_Buffer_write_str(&this->out, ";");
  compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
  std_vector_Vector__1_pop(this->yield_vars);
}

void compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_EnumVariant *variant, std_vector_Vector__9 *args) {
  compiler_ast_nodes_Enum *enom = variant->parent;
  if (!(enom->has_values)) {
    std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));
    return;
  }
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%s){", compiler_ast_scopes_Symbol_out_name(enom->sym)));
  std_buffer_Buffer_write_str_f(&this->out, std_format(".tag=%s,", compiler_ast_scopes_Symbol_out_name(variant->sym)));
  std_vector_Vector__4 *shared_fields = enom->shared_fields;
  u32 i = 0;
  for (NULL; i < shared_fields->size; i+=1) {
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    compiler_ast_nodes_Variable *field = std_vector_Vector__4_at(shared_fields, i);
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
    std_buffer_Buffer_write_str(&this->out, ", ");
  }
  if (((bool)args) && (i < args->size)) {
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s={", compiler_ast_scopes_Symbol_out_name(variant->sym)));
    for (NULL; i < args->size; i+=1) {
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
      std_buffer_Buffer_write_str(&this->out, ", ");
    }
    std_buffer_Buffer_write_str(&this->out, "}");
  }
  std_buffer_Buffer_write_str(&this->out, "}");
}

void compiler_passes_code_generator_CodeGenerator_gen_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Structure *struc) {
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%s){", compiler_ast_scopes_Symbol_out_name(struc->sym)));
  std_vector_Vector__4 *fields = struc->fields;
  std_vector_Vector__9 *args = node->u.call.args;
  if (struc->is_union) {
    if(!(args->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:501:16: Assertion failed: `args.size == 1`", "Should have been checked in the type checker"); }
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, 0);
    if(!(((bool)arg->label))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:503:16: Assertion failed: `arg.label?`", "Should have been checked in the type checker"); }
    compiler_ast_nodes_Variable *field = NULL;
    for (std_vector_Iterator__4 _i132 = std_vector_Vector__4_iter(fields); std_vector_Iterator__4_has_value(&_i132); std_vector_Iterator__4_next(&_i132)) {
      compiler_ast_nodes_Variable *f = std_vector_Iterator__4_cur(&_i132);
      {
        if (((bool)f->sym) && str_eq(f->sym->name, arg->label)) {
          field=f;
          break;
        }
      }
    }
    if(!(((bool)field))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:512:16: Assertion failed: `field?`", "Should have been checked in the type checker"); }
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
  } else {
    for (u32 i = 0; i < args->size; i+=1) {
      if (i != 0) {
        std_buffer_Buffer_write_str(&this->out, ", ");
      }
      compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
      compiler_ast_nodes_Variable *field = std_vector_Vector__4_at(fields, i);
      std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
    }
  }
  std_buffer_Buffer_write_str(&this->out, "}");
}

void compiler_passes_code_generator_CodeGenerator_gen_create_new(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  if(!(node->type==compiler_ast_nodes_ASTType_CreateNew)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:530:12: Assertion failed: `node.type == CreateNew`", std_format("Expected CreateNew, got %s", compiler_ast_nodes_ASTType_dbg(node->type))); }
  compiler_ast_nodes_AST *child = node->u.child;
  char *var_name = std_format("_new_%u", this->o->program->uid++);
  compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, node->etype, var_name);
  std_buffer_Buffer_write_str(&this->out, " = ");
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.mem_alloc_fn));
  std_buffer_Buffer_write_str(&this->out, "(");
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.mem_allocator));
  std_buffer_Buffer_write_str(&this->out, ", sizeof(");
  compiler_passes_code_generator_CodeGenerator_gen_type(this, child->etype);
  std_buffer_Buffer_write_str_f(&this->out, std_format(")); *%s = ", var_name));
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, child, false, false);
  std_buffer_Buffer_write_str_f(&this->out, std_format("; %s; ", var_name));
  compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
  str_free(&var_name);
}

void compiler_passes_code_generator_CodeGenerator_gen_call_args(compiler_passes_code_generator_CodeGenerator *this, std_vector_Vector__9 *args, bool is_variadic_format) {
  for (u32 i = 0; i < args->size; i+=1) {
    if (i != 0) {
      std_buffer_Buffer_write_str(&this->out, ", ");
    }
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    if ((i==(args->size - 1) && is_variadic_format) && arg->expr->type==compiler_ast_nodes_ASTType_FormatStringLiteral) {
      compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, arg->expr, false);
    } else {
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false, false);
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym) {
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false, false);
  std_buffer_Buffer_write_str_f(&this->out, std_format(".%s(", compiler_passes_code_generator_cls_fn_field_name));
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false, false);
  std_buffer_Buffer_write_str(&this->out, ".");
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_cls_ctx_name);
  if (node->u.call.args->size > 0) {
    std_buffer_Buffer_write_str(&this->out, ", ");
    compiler_passes_code_generator_CodeGenerator_gen_call_args(this, node->u.call.args, false);
  }
  std_buffer_Buffer_write_str(&this->out, ")");
}

void compiler_passes_code_generator_CodeGenerator_gen_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_expr) {
  compiler_ast_nodes_AST *callee = node->u.call.callee;
  bool ret_is_void = node->etype->base==compiler_types_BaseType_Void;
  if (this->o->program->backtrace) {
    char *s = std_format("%s \\t(%s:%u:%u)", callee->resolved_symbol->display, (node->span.start).filename, (node->span.start).line, (node->span.start).col);
    std_buffer_Buffer_write_str(&this->out, std_format("({_WITH_BT(\"%s\",", s));
    if (is_expr && !(ret_is_void)) {
      compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, node->etype, "_ret");
      std_buffer_Buffer_write_str(&this->out, " = ");
    }
  }
  if (callee->type==compiler_ast_nodes_ASTType_Identifier) {
    bool matched = ({bool __yv_450;
      {
        char *__match_var_451 = callee->u.ident.name;
        if (str_eq(__match_var_451, "print")) {
          __yv_450 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, false, false);
          goto _l___yv_450;
        } else if (str_eq(__match_var_451, "println")) {
          __yv_450 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, true, false);
          goto _l___yv_450;
        } else if (str_eq(__match_var_451, "eprint")) {
          __yv_450 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, false, true);
          goto _l___yv_450;
        } else if (str_eq(__match_var_451, "eprintln")) {
          __yv_450 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, true, true);
          goto _l___yv_450;
        } else  {
          __yv_450 = false;
          goto _l___yv_450;
        }
      }

_l___yv_450:
    __yv_450;});
    if (matched) {
      /* defers */
      if (this->o->program->backtrace) {
        std_buffer_Buffer_write_str(&this->out, ");");
        if (is_expr && !(ret_is_void)) {
          std_buffer_Buffer_write_str(&this->out, " _ret;");
        }
        std_buffer_Buffer_write_str(&this->out, "})");
      }
      return;
    }
  }
  compiler_ast_scopes_Symbol *sym = compiler_ast_nodes_AST_symbol(callee);
  if (((bool)sym)) {
switch ((node->u.call.call_type)) {
      case compiler_ast_nodes_CallType_StructConstructor:
      m_452_0:
        {
          if(!(sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:625:24: Assertion failed: `sym.type == Structure`", NULL); }
          compiler_passes_code_generator_CodeGenerator_gen_constructor(this, node, sym->u.struc);
          /* defers */
          if (this->o->program->backtrace) {
            std_buffer_Buffer_write_str(&this->out, ");");
            if (is_expr && !(ret_is_void)) {
              std_buffer_Buffer_write_str(&this->out, " _ret;");
            }
            std_buffer_Buffer_write_str(&this->out, "})");
          }
          return;
        } break;
      case compiler_ast_nodes_CallType_EnumConstructor:
      m_452_1:
        {
          if(!(sym->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:630:24: Assertion failed: `sym.type == EnumVariant`", NULL); }
          compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(this, sym->u.enum_var, node->u.call.args);
          /* defers */
          if (this->o->program->backtrace) {
            std_buffer_Buffer_write_str(&this->out, ");");
            if (is_expr && !(ret_is_void)) {
              std_buffer_Buffer_write_str(&this->out, " _ret;");
            }
            std_buffer_Buffer_write_str(&this->out, "})");
          }
          return;
        } break;
      case compiler_ast_nodes_CallType_Closure:
      m_452_2:
        {
          compiler_passes_code_generator_CodeGenerator_gen_closure_call(this, node, sym);
          /* defers */
          if (this->o->program->backtrace) {
            std_buffer_Buffer_write_str(&this->out, ");");
            if (is_expr && !(ret_is_void)) {
              std_buffer_Buffer_write_str(&this->out, " _ret;");
            }
            std_buffer_Buffer_write_str(&this->out, "})");
          }
          return;
        } break;
      default:
        {
        } break;
    }  }
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false, false);
  bool is_variadic_format = (((((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Function) && ((bool)sym->u.func)) && sym->u.func->is_variadic_format);
  std_buffer_Buffer_write_str(&this->out, "(");
  compiler_passes_code_generator_CodeGenerator_gen_call_args(this, node->u.call.args, is_variadic_format);
  std_buffer_Buffer_write_str(&this->out, ")");
  /* defers */
  if (this->o->program->backtrace) {
    std_buffer_Buffer_write_str(&this->out, ");");
    if (is_expr && !(ret_is_void)) {
      std_buffer_Buffer_write_str(&this->out, " _ret;");
    }
    std_buffer_Buffer_write_str(&this->out, "})");
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_top_level, bool is_statement) {
  bool needs_parens = (!(is_top_level) && !(is_statement));
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    m_453_0:
      {
        compiler_ast_nodes_NumLiteral *num_lit = &node->u.num_literal;
        if ((node->etype->base != compiler_types_BaseType_I32) && (node->etype->base != compiler_types_BaseType_U32)) {
          std_buffer_Buffer_write_str(&this->out, "((");
          compiler_passes_code_generator_CodeGenerator_gen_type(this, node->etype);
          std_buffer_Buffer_write_str(&this->out, ")");
          std_buffer_Buffer_write_str_f(&this->out, std_format("%" PRIu64 "", num_lit->as_int));
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {
          std_buffer_Buffer_write_str_f(&this->out, std_format("%" PRIu64 "", num_lit->as_int));
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_453_1:
      {
        compiler_ast_nodes_Function *func = node->u.closure;
        compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
        char *ctx_name = std_format("%s%u", compiler_passes_code_generator_cls_ctx_name, this->o->program->uid++);
        char *ctx_typ = compiler_passes_code_generator_cls_ctx_type(func);
        std_buffer_Buffer_write_str_f(&this->out, std_format("%s *%s = alloca(sizeof(%s));", ctx_typ, ctx_name, ctx_typ));
        for (std_map_Iterator__5 _i133 = std_map_Map__5_iter(func->closed_vars); std_map_Iterator__5_has_value(&_i133); std_map_Iterator__5_next(&_i133)) {
          std_map_Item__5 *it = std_map_Iterator__5_cur(&_i133);
          {
            compiler_ast_nodes_Variable *var = it->value->u.closed_var.orig;
            std_buffer_Buffer_write_str(&this->out, ctx_name);
            std_buffer_Buffer_write_str(&this->out, "->");
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));
            std_buffer_Buffer_write_str(&this->out, " = &");
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));
            std_buffer_Buffer_write_str(&this->out, ";");
          }
        }
        char *cls_name = std_format("_ci%u", this->o->program->uid++);
        std_buffer_Buffer_write_str_f(&this->out, std_format("%s %s = {", compiler_ast_scopes_Symbol_out_name(func->type->sym), cls_name));
        std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=%s, .%s=&%s};", compiler_passes_code_generator_cls_ctx_name, ctx_name, compiler_passes_code_generator_cls_fn_field_name, compiler_ast_scopes_Symbol_out_name(func->sym)));
        std_buffer_Buffer_write_str(&this->out, cls_name);
        std_buffer_Buffer_write_str(&this->out, ";");
        compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
      } break;
    case compiler_ast_nodes_ASTType_FloatLiteral:
    m_453_2:
      {
        compiler_ast_nodes_NumLiteral *num_lit = &node->u.num_literal;
        std_buffer_Buffer_write_str_f(&this->out, std_format("%f", num_lit->as_float));
        if (node->etype->base==compiler_types_BaseType_F32) {
          std_buffer_Buffer_write_str(&this->out, "f");
        }
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_453_3:
      {
        std_vector_Vector__15 *elements = node->u.array_literal.elements;
        std_buffer_Buffer_write_str(&this->out, "{");
        for (u32 i = 0; i < elements->size; i+=1) {
          if (i != 0) {
            std_buffer_Buffer_write_str(&this->out, ", ");
          }
          compiler_ast_nodes_AST *expr = std_vector_Vector__15_at(elements, i);
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
        }
        std_buffer_Buffer_write_str(&this->out, "}");
      } break;
    case compiler_ast_nodes_ASTType_VectorLiteral:
    m_453_4:
      {
        compiler_passes_code_generator_CodeGenerator_gen_vector_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_MapLiteral:
    m_453_5:
      {
        compiler_passes_code_generator_CodeGenerator_gen_map_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_453_6:
      {
        compiler_passes_code_generator_CodeGenerator_gen_format_string(this, node);
      } break;
    case compiler_ast_nodes_ASTType_StringLiteral:
    m_453_7:
      {
        char *str_lit = node->u.string_literal;
        std_buffer_Buffer_write_str(&this->out, "\"");
        compiler_passes_code_generator_CodeGenerator_gen_string_literal(this, str_lit);
        std_buffer_Buffer_write_str(&this->out, "\"");
      } break;
    case compiler_ast_nodes_ASTType_CharLiteral:
    m_453_8:
      {
        char *char_lit = node->u.char_literal;
        std_buffer_Buffer_write_str(&this->out, "'");
        std_buffer_Buffer_write_str(&this->out, char_lit);
        std_buffer_Buffer_write_str(&this->out, "'");
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_453_9:
      {
        std_vector_Vector__23 *branches = node->u.if_stmt.branches;
        compiler_ast_nodes_AST *els = node->u.if_stmt.els;
        if (((branches->size==1 && (std_vector_Vector__23_at(branches, 0).body->type != compiler_ast_nodes_ASTType_Block)) && ((bool)els)) && (els->type != compiler_ast_nodes_ASTType_Block)) {
          compiler_ast_nodes_IfBranch branch = std_vector_Vector__23_at(branches, 0);
          std_buffer_Buffer_write_str(&this->out, "(");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.cond, false, false);
          std_buffer_Buffer_write_str(&this->out, " ? ");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.body, false, false);
          std_buffer_Buffer_write_str(&this->out, " : ");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, els, false, false);
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {
          compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_453_10:
      {
        compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_453_11:
      {
        compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_453_12:
      {
        compiler_ast_scopes_Symbol *sym = node->resolved_symbol;
        if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Function) {
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(sym));
          return;
        }
        compiler_ast_nodes_AST *lhs = node->u.member.lhs;
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false, false);
        if (node->u.member.is_pointer) {
          std_buffer_Buffer_write_str(&this->out, "->");
        } else {
          std_buffer_Buffer_write_str(&this->out, ".");
        }
        std_buffer_Buffer_write_str(&this->out, node->u.member.rhs_name);
      } break;
    case compiler_ast_nodes_ASTType_TryMember:
    m_453_13:
      {
        compiler_ast_nodes_AST *lhs = node->u.member.lhs;
        char *rhs_name = node->u.member.rhs_name;
        char *tmp_var = std_format("_t%u", this->o->program->uid++);
        compiler_passes_code_generator_CodeGenerator_gen_start_expr_statement(this);
        compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, lhs->etype, tmp_var);
        std_buffer_Buffer_write_str(&this->out, " = ");
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false, false);
        std_buffer_Buffer_write_str(&this->out, "; ");
        std_buffer_Buffer_write_str_f(&this->out, std_format("%s ? %s->%s : NULL;", tmp_var, tmp_var, rhs_name));
        compiler_passes_code_generator_CodeGenerator_gen_end_expr_statement(this);
        str_free(&tmp_var);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_NSLookup:
    case compiler_ast_nodes_ASTType_Specialization:
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_453_14:
      {
        compiler_ast_scopes_Symbol *sym = node->resolved_symbol;
        if (!(((bool)sym))) {
          compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, "Symbol not found in CodeGenerator::gen_expression"));
          return;
        }
switch ((sym->type)) {
          case compiler_ast_scopes_SymbolType_Function:
          case compiler_ast_scopes_SymbolType_Variable:
          case compiler_ast_scopes_SymbolType_Constant:
          m_454_0:
            {
              std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(sym));
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_454_1:
            {
              compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(this, sym->u.enum_var, NULL);
            } break;
          case compiler_ast_scopes_SymbolType_ClosedVariable:
          m_454_2:
            {
              compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;
              std_buffer_Buffer_write_str_f(&this->out, std_format("(*%s->", compiler_passes_code_generator_cls_ctx_name));
              std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          default:
            {
              if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:805:32: Assertion failed: `false`", std_format("Unhandled symbol type: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_453_15:
      {
        compiler_passes_code_generator_CodeGenerator_gen_call(this, node, !(is_statement));
      } break;
    case compiler_ast_nodes_ASTType_BoolLiteral:
    m_453_16:
      {
        bool bool_lit = node->u.bool_literal;
        std_buffer_Buffer_write_str(&this->out, (bool_lit ? "true" : "false"));
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_453_17:
      {
        compiler_passes_code_generator_CodeGenerator_gen_create_new(this, node);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_453_18:
      {
switch ((node->u.unary.op)) {
          case compiler_ast_operators_Operator_Address:
          m_455_0:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "&");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
            } break;
          case compiler_ast_operators_Operator_Dereference:
          m_455_1:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "(*");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_Negate:
          m_455_2:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "-");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
            } break;
          case compiler_ast_operators_Operator_BitwiseNot:
          m_455_3:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "~");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
            } break;
          case compiler_ast_operators_Operator_Not:
          m_455_4:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "!(");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_IsNotNull:
          m_455_5:
            {
              compiler_ast_nodes_AST *expr = node->u.unary.expr;
              std_buffer_Buffer_write_str(&this->out, "((bool)");
              compiler_types_Type *type = expr->etype;
              if (((bool)type) && type->base==compiler_types_BaseType_Closure) {
                compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
                std_buffer_Buffer_write_str(&this->out, ".");
                std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_cls_fn_field_name);
              } else {
                compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
              }
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_PreIncrement:
          case compiler_ast_operators_Operator_PreDecrement:
          m_455_6:
            {
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.unary.expr, false, false);
            } break;
          case compiler_ast_operators_Operator_PostIncrement:
          case compiler_ast_operators_Operator_PostDecrement:
          m_455_7:
            {
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.unary.expr, false, false);
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));
            } break;
          default:
            {
              compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled unary op type in CodeGenerator: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_453_19:
      {
        compiler_ast_nodes_AST *expr = node->u.cast.lhs;
        compiler_types_Type *type = node->etype;
        std_buffer_Buffer_write_str(&this->out, "((");
        std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, type, "", false));
        std_buffer_Buffer_write_str(&this->out, ")");
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
        std_buffer_Buffer_write_str(&this->out, ")");
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_453_20:
      {
        std_buffer_Buffer_write_str(&this->out, "((u32)sizeof(");
        compiler_passes_code_generator_CodeGenerator_gen_type(this, node->u.size_of_type);
        std_buffer_Buffer_write_str(&this->out, "))");
      } break;
    case compiler_ast_nodes_ASTType_Null:
    m_453_21:
      {
switch ((node->etype->base)) {
          case compiler_types_BaseType_Closure:
          m_456_0:
            {
              std_buffer_Buffer_write_str_f(&this->out, std_format("((%s){0})", compiler_ast_scopes_Symbol_out_name(node->etype->sym)));
            } break;
          default:
            {
              std_buffer_Buffer_write_str(&this->out, "NULL");
            } break;
        }      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_453_22:
      {
switch ((node->u.binary.op)) {
          case compiler_ast_operators_Operator_Index:
          m_457_0:
            {
              compiler_ast_nodes_AST *lhs = node->u.binary.lhs;
              compiler_ast_nodes_AST *rhs = node->u.binary.rhs;
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false, false);
              std_buffer_Buffer_write_str(&this->out, "[");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, rhs, false, false);
              std_buffer_Buffer_write_str(&this->out, "]");
            } break;
          case compiler_ast_operators_Operator_And:
          case compiler_ast_operators_Operator_BitwiseAnd:
          case compiler_ast_operators_Operator_BitwiseOr:
          case compiler_ast_operators_Operator_BitwiseXor:
          case compiler_ast_operators_Operator_Divide:
          case compiler_ast_operators_Operator_GreaterThan:
          case compiler_ast_operators_Operator_GreaterThanEquals:
          case compiler_ast_operators_Operator_LeftShift:
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          case compiler_ast_operators_Operator_LessThan:
          case compiler_ast_operators_Operator_LessThanEquals:
          case compiler_ast_operators_Operator_Minus:
          case compiler_ast_operators_Operator_Modulus:
          case compiler_ast_operators_Operator_Multiply:
          case compiler_ast_operators_Operator_NotEquals:
          case compiler_ast_operators_Operator_Or:
          case compiler_ast_operators_Operator_Plus:
          case compiler_ast_operators_Operator_RightShift:
          m_457_1:
            {
              compiler_ast_nodes_AST *lhs = node->u.binary.lhs;
              compiler_ast_nodes_AST *rhs = node->u.binary.rhs;
              if (needs_parens) {
                std_buffer_Buffer_write_str(&this->out, "(");
              }
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false, false);
              std_buffer_Buffer_write_str(&this->out, " ");
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));
              std_buffer_Buffer_write_str(&this->out, " ");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, rhs, false, false);
              if (needs_parens) {
                std_buffer_Buffer_write_str(&this->out, ")");
              }
            } break;
          case compiler_ast_operators_Operator_Equals:
          case compiler_ast_operators_Operator_Assignment:
          case compiler_ast_operators_Operator_IndexAssign:
          case compiler_ast_operators_Operator_PlusEquals:
          case compiler_ast_operators_Operator_MinusEquals:
          case compiler_ast_operators_Operator_DivideEquals:
          case compiler_ast_operators_Operator_MultiplyEquals:
          m_457_2:
            {
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.binary.lhs, false, false);
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.binary.rhs, false, false);
            } break;
          case compiler_ast_operators_Operator_EqualsValueEnumVariant:
          m_457_3:
            {
              std_buffer_Buffer_write_str(&this->out, "(");
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.binary.lhs, false, false);
              std_buffer_Buffer_write_str(&this->out, ").tag == ");
              compiler_ast_scopes_Symbol *rhs_sym = node->u.binary.rhs->resolved_symbol;
              if(!(((bool)rhs_sym) && rhs_sym->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:947:24: Assertion failed: `rhs_sym? and rhs_sym.type == EnumVariant`", NULL); }
              std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(rhs_sym));
            } break;
          default:
            {
              compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled binary op type in CodeGenerator: %s", compiler_ast_operators_Operator_dbg(node->u.binary.op))));
            } break;
        }      } break;
    default:
      {
        compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled expression type in CodeGenerator: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
      } break;
  }}

void compiler_passes_code_generator_CodeGenerator_gen_var_declaration(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Variable *var = node->u.var_decl;
  if (var->is_atomic) {
    std_buffer_Buffer_write_str(&this->out, "_Atomic ");
  }
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, var->type, compiler_ast_scopes_Symbol_out_name(var->sym));
  if (((bool)node->u.var_decl->default_value)) {
    std_buffer_Buffer_write_str(&this->out, " = ");
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.var_decl->default_value, false, false);
  } else if (!(var->is_atomic)) {
switch ((var->type->base)) {
      case compiler_types_BaseType_Array:
      case compiler_types_BaseType_Structure:
      m_458_0:
        {
          std_buffer_Buffer_write_str(&this->out, " = {0}");
        } break;
      default:
        {
        } break;
    }  }
}

void compiler_passes_code_generator_CodeGenerator_gen_match_case_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body) {
  if (body->type==compiler_ast_nodes_ASTType_Block) {
    std_buffer_Buffer_write_str(&this->out, " ");
    compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
  } else if (body->type==compiler_ast_nodes_ASTType_Call && body->returns) {
    std_buffer_Buffer_write_str(&this->out, " ");
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, body, false, false);
    std_buffer_Buffer_write_str(&this->out, ";");
  } else if (((bool)node->etype) && (body->type != compiler_ast_nodes_ASTType_Yield)) {
    std_buffer_Buffer_write_str(&this->out, " {\n");
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, body);
    this->indent-=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "}");
  } else {
    std_buffer_Buffer_write_str(&this->out, " {\n");
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_statement(this, body);
    this->indent-=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "}");
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_custom_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Match stmt = node->u.match_stmt;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "{\n");
  char *match_var = std_format("__match_var_%u", this->o->program->uid++);
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, stmt.expr->etype, match_var);
  std_buffer_Buffer_write_str(&this->out, " = ");
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false, false);
  std_buffer_Buffer_write_str(&this->out, ";\n");
  std_vector_Vector__24 *cases = stmt.cases;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  for (u32 i = 0; i < cases->size; i++) {
    compiler_ast_nodes_MatchCase _case = std_vector_Vector__24_at(cases, i);
    std_buffer_Buffer_write_str(&this->out, "if (");
    bool first = true;
    for (std_vector_Iterator__6 _i134 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i134); std_vector_Iterator__6_next(&_i134)) {
      compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i134);
      {
        if (!(first)) {
          std_buffer_Buffer_write_str(&this->out, " || ");
        }
        first=false;
        if (((bool)cond->cmp_fn)) {
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(cond->cmp_fn->sym));
          std_buffer_Buffer_write_str(&this->out, "(");
          std_buffer_Buffer_write_str(&this->out, match_var);
          std_buffer_Buffer_write_str(&this->out, ", ");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false, false);
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {
          std_buffer_Buffer_write_str(&this->out, std_format("(%s == ", match_var));
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false, false);
          std_buffer_Buffer_write_str(&this->out, ")");
        }
      }
    }
    std_buffer_Buffer_write_str(&this->out, ")");
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, _case.body);
    std_buffer_Buffer_write_str(&this->out, " else ");
  }
  if (((bool)stmt.defolt)) {
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, stmt.defolt);
  }
  std_buffer_Buffer_write_str(&this->out, "\n");
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "}\n");
}

char *compiler_passes_code_generator_CodeGenerator_gen_match_enum_switch_line(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr) {
  if(!(((bool)expr->etype) && expr->etype->base==compiler_types_BaseType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1062:12: Assertion failed: `expr.etype? and expr.etype.base == Enum`", NULL); }
  compiler_ast_nodes_Enum *enom = expr->etype->u.enom;
  std_vector_Vector__4 *shared_fields = enom->shared_fields;
  char *var_name = "";
  if (enom->has_values) {
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    var_name=std_format("_m%u", this->o->program->uid++);
    compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, expr->etype, var_name);
    std_buffer_Buffer_write_str(&this->out, " = ");
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
    std_buffer_Buffer_write_str(&this->out, ";\n");
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "switch (");
    std_buffer_Buffer_write_str(&this->out, var_name);
    std_buffer_Buffer_write_str(&this->out, ".tag) {\n");
  } else {
    std_buffer_Buffer_write_str(&this->out, "switch ((");
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false, false);
    std_buffer_Buffer_write_str(&this->out, ")) {\n");
  }
  return var_name;
}

void compiler_passes_code_generator_CodeGenerator_gen_match_enum_cases_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, char *var_name, std_vector_Vector__6 *conds, compiler_ast_nodes_AST *body, u32 uid, u32 case_index) {
  bool has_args = ((conds->size > 0) && ((bool)std_vector_Vector__6_at(conds, 0)->args));
  if (has_args) {
    std_vector_Vector__19 *args = std_vector_Vector__6_at(conds, 0)->args;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "{\n");
    this->indent+=1;
    for (std_vector_Iterator__19 _i135 = std_vector_Vector__19_iter(args); std_vector_Iterator__19_has_value(&_i135); std_vector_Iterator__19_next(&_i135)) {
      compiler_ast_nodes_MatchCondArg *arg = std_vector_Iterator__19_cur(&_i135);
      {
        if (!(str_eq(arg->var->sym->name, "_"))) {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, arg->var->type, compiler_ast_scopes_Symbol_out_name(arg->var->sym));
          std_buffer_Buffer_write_str(&this->out, ";\n");
        }
      }
    }
  }
  for (u32 j = 0; j < conds->size; j++) {
    compiler_ast_nodes_MatchCond *cond = std_vector_Vector__6_at(conds, j);
    compiler_ast_scopes_Symbol *resolved = cond->expr->resolved_symbol;
    if(!(((bool)resolved) && resolved->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1117:16: Assertion failed: `resolved? and resolved.type == EnumVariant`", NULL); }
    compiler_ast_nodes_EnumVariant *variant = resolved->u.enum_var;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "case ");
    std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));
    std_buffer_Buffer_write_str(&this->out, ":\n");
    this->indent+=1;
    if (((bool)cond->args)) {
      std_vector_Vector__19 *args = cond->args;
      for (u32 i = 0; i < args->size; i+=1) {
        compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, i);
        if (arg->is_shared) {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));
          std_buffer_Buffer_write_str(&this->out, " = ");
          std_buffer_Buffer_write_str(&this->out, var_name);
          std_buffer_Buffer_write_str(&this->out, ".");
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));
          std_buffer_Buffer_write_str(&this->out, ";\n");
        } else {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));
          std_buffer_Buffer_write_str(&this->out, " = ");
          std_buffer_Buffer_write_str(&this->out, var_name);
          std_buffer_Buffer_write_str(&this->out, ".");
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));
          std_buffer_Buffer_write_str_f(&this->out, std_format(".%s;\n", compiler_ast_scopes_Symbol_out_name(arg->var->sym)));
        }
      }
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);
      std_buffer_Buffer_write_str(&this->out, std_format("goto m_%u_%u;\n", uid, case_index));
    }
    this->indent-=1;
  }
  if (((bool)body)) {
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, std_format("m_%u_%u:\n", uid, case_index));
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, body);
    std_buffer_Buffer_write_str(&this->out, " break;\n");
    this->indent-=1;
  }
  if (has_args) {
    this->indent-=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "}\n");
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_match_enum(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;
  compiler_ast_nodes_AST *expr = match_stmt->expr;
  char *var_name = compiler_passes_code_generator_CodeGenerator_gen_match_enum_switch_line(this, expr);
  u32 uid = this->o->program->uid++;
  this->indent+=1;
  for (u32 i = 0; i < match_stmt->cases->size; i+=1) {
    compiler_ast_nodes_MatchCase _case = std_vector_Vector__24_at(match_stmt->cases, i);
    std_vector_Vector__6 *conds = _case.conds;
    compiler_passes_code_generator_CodeGenerator_gen_match_enum_cases_body(this, node, var_name, conds, _case.body, uid, i);
  }
  if (((bool)match_stmt->defolt)) {
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "default:\n");
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, match_stmt->defolt);
    std_buffer_Buffer_write_str(&this->out, " break;\n");
    this->indent-=1;
  }
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "}");
}

void compiler_passes_code_generator_CodeGenerator_gen_match_bool(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Match stmt = node->u.match_stmt;
  compiler_ast_nodes_MatchCase true_case = std_vector_Vector__24_at(stmt.cases, 0);
  compiler_ast_nodes_MatchCase false_case = std_vector_Vector__24_at(stmt.cases, 1);
  compiler_ast_nodes_AST *true_expr = std_vector_Vector__6_at(true_case.conds, 0)->expr;
  if(!(true_expr->type==compiler_ast_nodes_ASTType_BoolLiteral)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1219:12: Assertion failed: `true_expr.type == BoolLiteral`", "Expected a boolean literal in gen_match_bool"); }
  if (!(true_expr->u.bool_literal)) {
    compiler_ast_nodes_MatchCase tmp = true_case;
    true_case=false_case;
    false_case=tmp;
  }
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "if (");
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false, false);
  std_buffer_Buffer_write_str(&this->out, ") ");
  compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, true_case.body);
  std_buffer_Buffer_write_str(&this->out, " else ");
  compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, false_case.body);
}

void compiler_passes_code_generator_CodeGenerator_gen_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Match stmt = node->u.match_stmt;
  if (stmt.is_custom_match) {
    compiler_passes_code_generator_CodeGenerator_gen_custom_match(this, node);
    return;
  }
switch ((stmt.expr->etype->base)) {
    case compiler_types_BaseType_Bool:
    m_459_0:
      {
        compiler_passes_code_generator_CodeGenerator_gen_match_bool(this, node);
        return;
      } break;
    case compiler_types_BaseType_Enum:
    m_459_1:
      {
        compiler_passes_code_generator_CodeGenerator_gen_match_enum(this, node);
        return;
      } break;
    default:
      {
      } break;
  }  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "switch (");
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false, false);
  std_buffer_Buffer_write_str(&this->out, ") {\n");
  std_vector_Vector__24 *cases = stmt.cases;
  this->indent+=1;
  for (std_vector_Iterator__24 _i136 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i136); std_vector_Iterator__24_next(&_i136)) {
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i136);
    {
      for (std_vector_Iterator__6 _i137 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i137); std_vector_Iterator__6_next(&_i137)) {
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i137);
        {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          std_buffer_Buffer_write_str(&this->out, "case ");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false, false);
          std_buffer_Buffer_write_str(&this->out, ":");
        }
      }
      if (((bool)_case.body)) {
        compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, _case.body);
        std_buffer_Buffer_write_str(&this->out, " break;\n");
      } else {
        std_buffer_Buffer_write_str(&this->out, "\n");
      }
    }
  }
  if (((bool)stmt.defolt)) {
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "default:");
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, stmt.defolt);
    std_buffer_Buffer_write_str(&this->out, " break;\n");
  }
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "}\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, char *var_name, std_vector_Vector__6 *conds, compiler_ast_nodes_AST *body, char *bool_name) {
  std_buffer_Buffer_write_str(&this->out, "switch (");
  std_buffer_Buffer_write_str(&this->out, var_name);
  std_buffer_Buffer_write_str(&this->out, ".tag) {\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_match_enum_cases_body(this, node, var_name, conds, body, this->o->program->uid++, 0);
  std_buffer_Buffer_write_str(&this->out, std_format("default: %s = false; break;\n", bool_name));
  this->indent-=1;
  std_buffer_Buffer_write_str(&this->out, "}\n");
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
}

void compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_branch(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_IfBranch *branch) {
  if(!(branch->cond->type==compiler_ast_nodes_ASTType_Is)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1362:12: Assertion failed: `branch.cond.type == Is`", NULL); }
  compiler_ast_nodes_IsExpression *is_expr = &branch->cond->u.is_expr;
  std_buffer_Buffer_write_str(&this->out, "if ( ({\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  char *var_name = std_format("_is_%u", this->o->program->uid++);
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, is_expr->lhs->etype, var_name);
  std_buffer_Buffer_write_str(&this->out, " = ");
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, is_expr->lhs, false, false);
  std_buffer_Buffer_write_str(&this->out, ";\n");
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  char *bool_name = std_format("_r_%u", this->o->program->uid++);
  std_buffer_Buffer_write_str_f(&this->out, std_format("bool %s = true;\n", bool_name));
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_body(this, node, var_name, is_expr->conds, branch->body, bool_name);
  std_buffer_Buffer_write_str_f(&this->out, std_format("%s;", bool_name));
  std_buffer_Buffer_write_str(&this->out, "}) ) {\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "// empty\n");
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "}");
}

void compiler_passes_code_generator_CodeGenerator_gen_if(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_vector_Vector__23 *branches = node->u.if_stmt.branches;
  for (u32 i = 0; i < branches->size; i+=1) {
    compiler_ast_nodes_IfBranch branch = std_vector_Vector__23_at(branches, i);
    if (i > 0) {
      std_buffer_Buffer_write_str(&this->out, " else ");
    }
switch ((branch.cond->type)) {
      case compiler_ast_nodes_ASTType_Is:
      m_460_0:
        {
          compiler_passes_code_generator_CodeGenerator_gen_if_is_expr_branch(this, node, &branch);
        } break;
      default:
        {
          std_buffer_Buffer_write_str(&this->out, "if (");
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.cond, true, false);
          std_buffer_Buffer_write_str(&this->out, ") ");
          compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, branch.body);
        } break;
    }  }
  compiler_ast_nodes_AST *else_body = node->u.if_stmt.els;
  if (((bool)else_body)) {
    std_buffer_Buffer_write_str(&this->out, " else ");
    compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, else_body);
    std_buffer_Buffer_write_str(&this->out, "\n");
  } else {
    std_buffer_Buffer_write_str(&this->out, "\n");
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_defers_upto(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Scope *end_scope) {
  bool first = true;
  for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur); cur=cur->parent) {
    for (u32 i = 0; i < cur->defers->size; i+=1) {
      if (first) {
        first=false;
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        std_buffer_Buffer_write_str(&this->out, "/* defers */\n");
      }
      u32 idx = ((cur->defers->size - i) - 1);
      compiler_ast_nodes_AST *stmt = std_vector_Vector__15_at(cur->defers, idx);
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, stmt);
    }
    if (cur==end_scope) {
      break;
    }
  }
}

char *compiler_passes_code_generator_CodeGenerator_get_break_label_for_loop(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Loop *loop = &node->u.loop;
  if (!(((bool)loop->break_label))) {
    loop->break_label=std_format("_%s_break_%u", compiler_ast_nodes_ASTType_dbg(node->type), this->o->program->uid++);
  }
  return loop->break_label;
}

void compiler_passes_code_generator_CodeGenerator_gen_statement(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  compiler_passes_code_generator_CodeGenerator_gen_debug_info(this, node->span, false);
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Return:
    m_461_0:
      {
        compiler_ast_scopes_Scope *upto = compiler_passes_code_generator_CodeGenerator_scope(this);
        for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur) && ((bool)cur->cur_func); cur=cur->parent) {
          upto=cur;
        }
        compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, upto);
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        compiler_ast_nodes_AST *expr = node->u.ret.expr;
        if (((bool)expr)) {
          if (!(expr->returns)) {
            std_buffer_Buffer_write_str(&this->out, "return ");
          }
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, true, false);
          std_buffer_Buffer_write_str(&this->out, ";\n");
        } else {
          std_buffer_Buffer_write_str(&this->out, "return;\n");
        }
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    m_461_1:
      {
        compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_461_2:
      {
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_461_3:
      {
        u32 loop_count = compiler_passes_code_generator_CodeGenerator_scope(this)->loop_count;
        compiler_ast_scopes_Scope *upto = compiler_passes_code_generator_CodeGenerator_scope(this);
        for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur) && cur->loop_count==loop_count; cur=cur->parent) {
          upto=cur;
        }
        compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, upto);
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        if (node->type==compiler_ast_nodes_ASTType_Break) {
          compiler_ast_nodes_AST *target_loop = upto->parent_loop;
          if (target_loop->u.loop.needs_goto_break) {
            char *label = compiler_passes_code_generator_CodeGenerator_get_break_label_for_loop(this, target_loop);
            std_buffer_Buffer_write_str_f(&this->out, std_format("goto %s;\n", label));
          } else {
            std_buffer_Buffer_write_str(&this->out, "break;\n");
          }
        } else {
          std_buffer_Buffer_write_str(&this->out, "continue;\n");
        }
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_461_4:
      {
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, node);
        std_buffer_Buffer_write_str(&this->out, ";\n");
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_461_5:
      {
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        compiler_passes_code_generator_CodeGenerator_gen_block(this, node, true);
        std_buffer_Buffer_write_str(&this->out, "\n");
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    m_461_6:
      {
        std_vector_Vector__15_push(compiler_passes_code_generator_CodeGenerator_scope(this)->defers, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_461_7:
      {
        compiler_passes_code_generator_CodeGenerator_gen_if(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_461_8:
      {
        compiler_passes_code_generator_CodeGenerator_gen_match(this, node);
      } break;
    case compiler_ast_nodes_ASTType_While:
    m_461_9:
      {
        compiler_ast_nodes_AST *cond = node->u.loop.cond;
        compiler_ast_nodes_AST *body = node->u.loop.body;
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        std_buffer_Buffer_write_str(&this->out, "while (");
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond, true, false);
        std_buffer_Buffer_write_str(&this->out, ") ");
        compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
        std_buffer_Buffer_write_str(&this->out, "\n");
        if (node->u.loop.needs_goto_break) {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          char *label = compiler_passes_code_generator_CodeGenerator_get_break_label_for_loop(this, node);
          std_buffer_Buffer_write_str_f(&this->out, std_format("%s:;\n", label));
        }
      } break;
    case compiler_ast_nodes_ASTType_For:
    m_461_10:
      {
        compiler_ast_nodes_AST *init = node->u.loop.init;
        compiler_ast_nodes_AST *cond = node->u.loop.cond;
        compiler_ast_nodes_AST *step = node->u.loop.step;
        compiler_ast_nodes_AST *body = node->u.loop.body;
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        std_buffer_Buffer_write_str(&this->out, "for (");
        if (((bool)init)) {
          if (init->type==compiler_ast_nodes_ASTType_VarDeclaration) {
            compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, init);
          } else {
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, init, false, true);
          }
        }
        std_buffer_Buffer_write_str(&this->out, "; ");
        if (((bool)cond)) {
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond, true, false);
        }
        std_buffer_Buffer_write_str(&this->out, "; ");
        if (((bool)step)) {
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, step, false, true);
        }
        std_buffer_Buffer_write_str(&this->out, ") ");
        compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
        std_buffer_Buffer_write_str(&this->out, "\n");
        if (node->u.loop.needs_goto_break) {
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);
          char *label = compiler_passes_code_generator_CodeGenerator_get_break_label_for_loop(this, node);
          std_buffer_Buffer_write_str_f(&this->out, std_format("%s:;\n", label));
        }
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_461_11:
      {
        compiler_ast_nodes_AST *expr = node->u.assertion.expr;
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        std_buffer_Buffer_write_str(&this->out, "if(!(");
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, true, false);
        std_buffer_Buffer_write_str(&this->out, ")) { ae_assert_fail(");
        {
          std_buffer_Buffer_write_str(&this->out, "\"");
          std_buffer_Buffer_write_str_f(&this->out, std_span_Location_str(&expr->span.start));
          char *expr_str = compiler_ast_program_Program_get_source_text(this->o->program, expr->span);
          std_buffer_Buffer_write_str(&this->out, ": Assertion failed: `");
          u32 len = strlen(expr_str);
          for (u32 i = 0; i < len; i+=1) {
            switch (expr_str[i]) {
              case '"': {
                std_buffer_Buffer_write_str(&this->out, "\\\"");
              } break;
              default: {
                std_buffer_Buffer_write_char(&this->out, expr_str[i]);
              } break;
            }
          }
          std_buffer_Buffer_write_str(&this->out, "`\"");
        }
        std_buffer_Buffer_write_str(&this->out, ", ");
        if (((bool)node->u.assertion.msg)) {
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.assertion.msg, false, false);
        } else {
          std_buffer_Buffer_write_str(&this->out, "NULL");
        }
        std_buffer_Buffer_write_str(&this->out, ");");
        if (expr->type==compiler_ast_nodes_ASTType_BoolLiteral && expr->u.bool_literal==false) {
          std_buffer_Buffer_write_str(&this->out, " exit(1);");
        }
        std_buffer_Buffer_write_str(&this->out, " }\n");
      } break;
    case compiler_ast_nodes_ASTType_StringLiteral:
    m_461_12:
      {
      } break;
    default:
      {
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, node, false, true);
        std_buffer_Buffer_write_str(&this->out, ";\n");
      } break;
  }}

void compiler_passes_code_generator_CodeGenerator_gen_block(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool with_braces) {
  if (with_braces) {
    std_buffer_Buffer_write_str(&this->out, "{\n");
  }
  compiler_ast_scopes_Scope *scope = node->u.block.scope;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, node->u.block.scope);
  std_vector_Vector__15 *statements = node->u.block.statements;
  this->indent+=1;
  for (std_vector_Iterator__15 _i139 = std_vector_Vector__15_iter(statements); std_vector_Iterator__15_has_value(&_i139); std_vector_Iterator__15_next(&_i139)) {
    compiler_ast_nodes_AST *statement = std_vector_Iterator__15_cur(&_i139);
    {
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, statement);
    }
  }
  if (!(node->returns)) {
    compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, scope);
  }
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  if (with_braces) {
    std_buffer_Buffer_write_str(&this->out, "}");
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

char *compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def, char *param_prefix, std_vector_Vector__4 *params) {
  std_buffer_Buffer args_str = std_buffer_Buffer_make(16);
  if (!(((bool)params))) {
    params=cur->u.func.params;
  }
  if (((bool)param_prefix)) {
    std_buffer_Buffer_write_str_f(&args_str, param_prefix);
    if (params->size > 0) {
      std_buffer_Buffer_write_str(&args_str, ", ");
    }
  } else if (params->size==0) {
    std_buffer_Buffer_write_str(&args_str, "void");
  }
  for (u32 i = 0; i < params->size; i+=1) {
    if (i != 0) {
      std_buffer_Buffer_write_str(&args_str, ", ");
    }
    compiler_ast_nodes_Variable *var = std_vector_Vector__4_at(params, i);
    char *arg_str = compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, var->type, compiler_ast_scopes_Symbol_out_name(var->sym), false);
    std_buffer_Buffer_write_str_f(&args_str, arg_str);
  }
  if (cur->u.func.is_variadic) {
    std_buffer_Buffer_write_str(&args_str, ", ...");
  }
  if (is_func_def && cur==top) {
    str_replace(&acc, std_format("%s(%s)", acc, std_buffer_Buffer_str(args_str)));
  } else {
    str_replace(&acc, std_format("(*%s)(%s)", acc, std_buffer_Buffer_str(args_str)));
  }
  std_mem_free(args_str.data);
  return compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.func.return_type, acc, false);
}

char *compiler_passes_code_generator_CodeGenerator_helper_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def) {
switch ((cur->base)) {
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    m_462_0:
      {
        str_replace(&acc, std_format("%s %s", compiler_types_BaseType_str(cur->base), acc));
      } break;
    case compiler_types_BaseType_Structure:
    m_462_1:
      {
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->u.struc->sym), acc));
      } break;
    case compiler_types_BaseType_Enum:
    m_462_2:
      {
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->u.enom->sym), acc));
      } break;
    case compiler_types_BaseType_Alias:
    m_462_3:
      {
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.ptr, acc, false);
      } break;
    case compiler_types_BaseType_Closure:
    m_462_4:
      {
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->sym), acc));
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_462_5:
      {
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, top, cur, acc, is_func_def, NULL, NULL);
      } break;
    case compiler_types_BaseType_Pointer:
    m_462_6:
      {
        bool needs_parens = (((bool)cur->u.ptr) && cur->u.ptr->base==compiler_types_BaseType_Array);
        if (is_func_def) {
        } else if (needs_parens) {
          str_replace(&acc, std_format("(*%s)", acc));
        } else {
          str_replace(&acc, std_format("*%s", acc));
        }
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.ptr, acc, false);
      } break;
    case compiler_types_BaseType_Array:
    m_462_7:
      {
        std_buffer_Buffer prev_buffer = this->out;
        this->out=std_buffer_Buffer_make(16);
        compiler_types_ArrayType *arr_typ = &cur->u.arr;
        if (((bool)arr_typ->size_expr)) {
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, arr_typ->size_expr, false, false);
        } else if (arr_typ->size_known) {
          std_buffer_Buffer_write_str_f(&this->out, std_format("%u", arr_typ->size));
        } else {
          compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(cur->span, "Array size not known at compile time"));
        }
        str_replace(&acc, std_format("%s[%s]", acc, std_buffer_Buffer_str(this->out)));
        std_mem_free(this->out.data);
        this->out=prev_buffer;
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.arr.elem_type, acc, false);
      } break;
    default:
      {
        compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(cur->span, std_format("Unhandled type found in CodeGenerator::helper_gen_type: %s: %s", compiler_types_BaseType_dbg(cur->base), compiler_types_Type_str(cur))));
      } break;
  }  return acc;
}

char *compiler_passes_code_generator_CodeGenerator_get_type_name_string(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name, bool is_func_def) {
  if(!(type != NULL)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1727:12: Assertion failed: `type != null`", NULL); }
  char *final = compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, type, type, strdup(name), is_func_def);
  str_strip_trailing_whitespace(final);
  return final;
}

void compiler_passes_code_generator_CodeGenerator_gen_type_and_name(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name) {
  std_buffer_Buffer_write_str_f(&this->out, compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, type, name, false));
}

void compiler_passes_code_generator_CodeGenerator_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type) {
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, type, "");
}

void compiler_passes_code_generator_CodeGenerator_gen_function_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {
  compiler_types_Type *ret_type = func->return_type;
  if (func->is_arrow) {
    std_buffer_Buffer_write_str(&this->out, "{\n");
    this->indent+=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    if (ret_type->base != compiler_types_BaseType_Void) {
      std_buffer_Buffer_write_str(&this->out, "return ");
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, func->body, false, false);
      std_buffer_Buffer_write_str(&this->out, ";");
    } else {
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, func->body);
    }
    this->indent-=1;
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);
    std_buffer_Buffer_write_str(&this->out, "}");
  } else {
    compiler_passes_code_generator_CodeGenerator_gen_block(this, func->body, true);
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_function(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    compiler_ast_scopes_Symbol *parent_sym = func->parent_type->sym;
    if (compiler_ast_scopes_Symbol_is_templated(parent_sym)) {
      return;
    }
  }
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {
    return;
  }
  if (func->sym->is_dead) {
    return;
  }
  compiler_passes_code_generator_CodeGenerator_gen_debug_info(this, func->sym->span, false);
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);
  std_buffer_Buffer_write_str(&this->out, " ");
  compiler_passes_code_generator_CodeGenerator_gen_function_body(this, func);
  std_buffer_Buffer_write_str(&this->out, "\n\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_function_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {
  char *funfull_name = compiler_ast_scopes_Symbol_out_name(func->sym);
  char *s = compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, func->type, funfull_name, true);
  std_buffer_Buffer_write_str_f(&this->out, s);
}

void compiler_passes_code_generator_CodeGenerator_gen_functions(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {
  std_vector_Vector__8 *functions = ns->functions;
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);
  for (std_vector_Iterator__8 _i140 = std_vector_Vector__8_iter(functions); std_vector_Iterator__8_has_value(&_i140); std_vector_Iterator__8_next(&_i140)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i140);
    {
      if (func->sym->is_extern) {
        continue;
      }
      if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {
        for (std_vector_Iterator__5 _i141 = std_vector_Vector__5_iter(func->sym->template->instances); std_vector_Iterator__5_has_value(&_i141); std_vector_Iterator__5_next(&_i141)) {
          compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i141);
          {
            compiler_ast_scopes_Symbol *sym = instance->resolved;
            if(!(sym->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1797:24: Assertion failed: `sym.type == Function`", NULL); }
            compiler_ast_nodes_Function *func = sym->u.func;
            compiler_passes_code_generator_CodeGenerator_gen_function(this, func);
          }
        }
      } else {
        compiler_passes_code_generator_CodeGenerator_gen_function(this, func);
      }
    }
  }
  for (std_map_ValueIterator__4 _i142 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i142); std_map_ValueIterator__4_next(&_i142)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i142);
    {
      compiler_passes_code_generator_CodeGenerator_gen_functions(this, child);
    }
  }
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}

void compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {
  if (func->sym->is_extern) {
    return;
  }
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
    compiler_ast_scopes_Symbol *parent_sym = func->parent_type->sym;
    if (compiler_ast_scopes_Symbol_is_templated(parent_sym)) {
      return;
    }
  }
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {
    for (std_vector_Iterator__5 _i143 = std_vector_Vector__5_iter(func->sym->template->instances); std_vector_Iterator__5_has_value(&_i143); std_vector_Iterator__5_next(&_i143)) {
      compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i143);
      {
        compiler_ast_scopes_Symbol *sym = instance->resolved;
        if(!(sym->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1824:20: Assertion failed: `sym.type == Function`", NULL); }
        compiler_ast_nodes_Function *func = sym->u.func;
        if (func->sym->is_dead) {
          continue;
        }
        compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);
        if (func->exits) {
          std_buffer_Buffer_write_str(&this->out, " __attribute__((noreturn))");
        }
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }
    return;
  }
  if (func->sym->is_dead) {
    return;
  }
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);
  if (func->exits) {
    std_buffer_Buffer_write_str(&this->out, " __attribute__((noreturn))");
  }
  std_buffer_Buffer_write_str(&this->out, ";\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_function_decls(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {
  for (std_vector_Iterator__8 _i144 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i144); std_vector_Iterator__8_next(&_i144)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i144);
    {
      compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(this, func);
    }
  }
  for (std_map_ValueIterator__4 _i145 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i145); std_map_ValueIterator__4_next(&_i145)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i145);
    {
      compiler_passes_code_generator_CodeGenerator_gen_function_decls(this, child);
    }
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {
  std_map_Item__9 *dbg_it = std_map_Map__9_get_item(enom->type->methods, "dbg");
  if (!(((bool)dbg_it))) {
    return;
  }
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, dbg_it->value);
  std_buffer_Buffer_write_str(&this->out, " {\n");
  this->indent+=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  if (enom->has_values) {
    std_buffer_Buffer_write_str(&this->out, "switch (this.tag) {\n");
  } else {
    std_buffer_Buffer_write_str(&this->out, "switch (this) {\n");
  }
  this->indent+=1;
  for (std_vector_Iterator__20 _i146 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i146); std_vector_Iterator__20_next(&_i146)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i146);
    {
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);
      std_buffer_Buffer_write_str(&this->out, "case ");
      std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));
      std_buffer_Buffer_write_str_f(&this->out, std_format(": return \"%s\";\n", variant->sym->name));
    }
  }
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str_f(&this->out, std_format("default: return \"<unknown>\";\n"));
  this->indent-=1;
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);
  std_buffer_Buffer_write_str(&this->out, "}\n");
  this->indent-=1;
  std_buffer_Buffer_write_str(&this->out, "}\n\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc) {
  if (struc->sym->is_extern) {
    return;
  }
  if (struc->sym->is_dead) {
    return;
  }
  char *strufull_name = compiler_ast_scopes_Symbol_out_name(struc->sym);
  if (struc->is_union) {
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef union %s %s;\n", strufull_name, strufull_name));
  } else {
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", strufull_name, strufull_name));
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  if (sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(sym);
  std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", name, name));
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  if (sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(sym);
  compiler_types_Type *type = sym->u.type_def;
  std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", name));
  std_buffer_Buffer_write_str_f(&this->out, std_format("  void *%s;\n", compiler_passes_code_generator_cls_ctx_name));
  std_buffer_Buffer_write_str(&this->out, "  ");
  char *acc = strdup(compiler_passes_code_generator_cls_fn_field_name);
  std_buffer_Buffer_write_str_f(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, false, std_format("void *_%s", compiler_passes_code_generator_cls_ctx_name), NULL));
  std_buffer_Buffer_write_str(&this->out, ";\n};\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {
  if (clos->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);
  char *type_name = compiler_passes_code_generator_cls_ctx_type(clos);
  std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", type_name, type_name));
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {
  if (clos->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);
  char *type_name = compiler_passes_code_generator_cls_ctx_type(clos);
  std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", type_name));
  compiler_types_Type dummy_ptr_type = {0};
  dummy_ptr_type.base=compiler_types_BaseType_Pointer;
  for (std_map_Iterator__5 _i147 = std_map_Map__5_iter(clos->closed_vars); std_map_Iterator__5_has_value(&_i147); std_map_Iterator__5_next(&_i147)) {
    std_map_Item__5 *it = std_map_Iterator__5_cur(&_i147);
    {
      compiler_ast_scopes_Symbol *sym = it->value;
      if(!(sym->type==compiler_ast_scopes_SymbolType_ClosedVariable)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1952:16: Assertion failed: `sym.type == ClosedVariable`", NULL); }
      std_buffer_Buffer_write_str(&this->out, "  ");
      compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;
      dummy_ptr_type.u.ptr=var->type;
      compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, &dummy_ptr_type, compiler_ast_scopes_Symbol_out_name(var->sym));
      std_buffer_Buffer_write_str(&this->out, ";\n");
    }
  }
  std_buffer_Buffer_write_str(&this->out, "};\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {
  if (clos->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);
  compiler_types_Type *type = clos->type;
  char *acc = strdup(name);
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, true, std_format("void *_%s", compiler_passes_code_generator_cls_ctx_name), clos->params));
  std_buffer_Buffer_write_str(&this->out, ";\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_closure_func(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {
  if (clos->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);
  compiler_types_Type *type = clos->type;
  char *ctx = compiler_passes_code_generator_cls_ctx_name;
  char *ctx_type = compiler_passes_code_generator_cls_ctx_type(clos);
  char *acc = strdup(name);
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, true, std_format("void *_%s", ctx), clos->params));
  std_buffer_Buffer_write_str(&this->out, " {\n");
  std_buffer_Buffer_write_str_f(&this->out, std_format("  %s *%s = (%s *)_%s;\n", ctx_type, ctx, ctx_type, ctx));
  compiler_passes_code_generator_CodeGenerator_gen_function_body(this, clos);
  std_buffer_Buffer_write_str(&this->out, "\n}\n\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_463_0:
      {
        compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_463_1:
      {
        compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_463_2:
      {
        compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_463_3:
      {
        compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(this, sym);
      } break;
    default:
      {
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:2009:20: Assertion failed: `false`", std_format("Unhandled symbol type in CodeGenerator::gen_typedef: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
      } break;
  }}

void compiler_passes_code_generator_CodeGenerator_gen_sym_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_464_0:
      {
        compiler_passes_code_generator_CodeGenerator_gen_struct_def(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_464_1:
      {
        compiler_passes_code_generator_CodeGenerator_gen_enum_def(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_464_2:
      {
        compiler_passes_code_generator_CodeGenerator_gen_closure_def(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_464_3:
      {
        compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(this, sym);
      } break;
    default:
      {
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:2017:20: Assertion failed: `false`", std_format("Unhandled symbol type in CodeGenerator::gen_def: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
      } break;
  }}

void compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {
  if (enom->sym->is_extern) {
    return;
  }
  if (enom->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(enom->sym);
  if (enom->has_values) {
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef enum %s__kind %s__kind;\n", name, name));
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", name, name));
  } else {
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef enum %s %s;\n", name, name));
  }
}

void compiler_passes_code_generator_CodeGenerator_gen_struct_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc) {
  if (struc->sym->is_extern) {
    return;
  }
  if (struc->sym->is_dead) {
    return;
  }
  char *strufull_name = compiler_ast_scopes_Symbol_out_name(struc->sym);
  if (struc->is_union) {
    std_buffer_Buffer_write_str_f(&this->out, std_format("union %s {\n", strufull_name));
  } else {
    std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", strufull_name));
  }
  for (std_vector_Iterator__4 _i148 = std_vector_Vector__4_iter(struc->fields); std_vector_Iterator__4_has_value(&_i148); std_vector_Iterator__4_next(&_i148)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i148);
    {
      std_buffer_Buffer_write_str(&this->out, "  ");
      if (field->is_atomic) {
        std_buffer_Buffer_write_str(&this->out, "_Atomic ");
      }
      compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, compiler_ast_scopes_Symbol_out_name(field->sym));
      std_buffer_Buffer_write_str(&this->out, ";\n");
    }
  }
  std_buffer_Buffer_write_str(&this->out, "};\n\n");
}

void compiler_passes_code_generator_CodeGenerator_gen_enum_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {
  if (enom->sym->is_dead) {
    return;
  }
  char *name = compiler_ast_scopes_Symbol_out_name(enom->sym);
  if (enom->sym->is_extern) {
    /* defers */
    compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(this, enom);
    return;
  }
  if (enom->has_values) {
    std_buffer_Buffer_write_str_f(&this->out, std_format("enum %s__kind {\n", name));
  } else {
    std_buffer_Buffer_write_str_f(&this->out, std_format("enum %s {\n", name));
  }
  for (std_vector_Iterator__20 _i149 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i149); std_vector_Iterator__20_next(&_i149)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i149);
    {
      std_buffer_Buffer_write_str_f(&this->out, std_format("  %s,\n", compiler_ast_scopes_Symbol_out_name(variant->sym)));
    }
  }
  std_buffer_Buffer_write_str(&this->out, "};\n\n");
  if (enom->has_values) {
    std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", name));
    std_buffer_Buffer_write_str_f(&this->out, std_format("  %s__kind tag;\n", name));
    for (std_vector_Iterator__4 _i150 = std_vector_Vector__4_iter(enom->shared_fields); std_vector_Iterator__4_has_value(&_i150); std_vector_Iterator__4_next(&_i150)) {
      compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i150);
      {
        std_buffer_Buffer_write_str(&this->out, "  ");
        compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, compiler_ast_scopes_Symbol_out_name(field->sym));
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }
    std_buffer_Buffer_write_str(&this->out, "  union {\n");
    for (std_vector_Iterator__20 _i151 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i151); std_vector_Iterator__20_next(&_i151)) {
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i151);
      {
        if (variant->specific_fields->size > 0) {
          std_buffer_Buffer_write_str(&this->out, "    struct {\n");
          for (u32 i = 0; i < variant->specific_fields->size; i+=1) {
            compiler_ast_nodes_Variable *field = std_vector_Vector__4_at(variant->specific_fields, i);
            char *name = compiler_ast_scopes_Symbol_out_name(field->sym);
            std_buffer_Buffer_write_str(&this->out, "      ");
            compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, name);
            std_buffer_Buffer_write_str(&this->out, ";\n");
          }
          std_buffer_Buffer_write_str_f(&this->out, std_format("    } %s;\n", compiler_ast_scopes_Symbol_out_name(variant->sym)));
        }
      }
    }
    std_buffer_Buffer_write_str(&this->out, "  };\n");
    std_buffer_Buffer_write_str(&this->out, "};\n\n");
  }
  /* defers */
  compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(this, enom);
}

void compiler_passes_code_generator_CodeGenerator_gen_test_mode_main(compiler_passes_code_generator_CodeGenerator *this) {
  std_buffer_Buffer_write_str(&this->out, "i32 main(void) {\n");
  for (compiler_ast_program_NSIterator _i152 = compiler_ast_program_Program_iter_namespaces(this->o->program); compiler_ast_program_NSIterator_has_value(&_i152); compiler_ast_program_NSIterator_next(&_i152)) {
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i152);
    {
      for (std_vector_Iterator__8 _i153 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i153); std_vector_Iterator__8_next(&_i153)) {
        compiler_ast_nodes_Function *f = std_vector_Iterator__8_cur(&_i153);
        {
          if (f->is_test_function) {
            char *run_test = compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.std_run_test);
            std_buffer_Buffer_write_str(&this->out, std_format("  %s(%s, \"%s\");\n", run_test, compiler_ast_scopes_Symbol_out_name(f->sym), f->sym->display));
          }
        }
      }
    }
  }
  char *print_test_stats = compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.std_print_test_stats);
  std_buffer_Buffer_write_str(&this->out, std_format("  %s();\n", print_test_stats));
  std_buffer_Buffer_write_str(&this->out, "  return 0;\n");
  std_buffer_Buffer_write_str(&this->out, "}\n");
}

char *compiler_passes_code_generator_CodeGenerator_generate(compiler_passes_code_generator_CodeGenerator *this) {
  for (std_vector_Iterator__1 _i154 = std_vector_Vector__1_iter(this->o->program->c_includes); std_vector_Iterator__1_has_value(&_i154); std_vector_Iterator__1_next(&_i154)) {
    char *include = std_vector_Iterator__1_cur(&_i154);
    {
      std_buffer_Buffer_write_str_f(&this->out, std_format("#include \"%s\"\n", include));
    }
  }
  std_buffer_Buffer_write_str(&this->out, "\n");
  for (std_map_Iterator__7 _i155 = std_map_Map__7_iter(this->o->program->c_embeds); std_map_Iterator__7_has_value(&_i155); std_map_Iterator__7_next(&_i155)) {
    std_map_Item__7 *it = std_map_Iterator__7_cur(&_i155);
    {
      std_buffer_Buffer_write_str_f(&this->out, std_format("/* Embed: %s */\n", it->key));
      std_buffer_Buffer_write_str(&this->out, it->value);
      std_buffer_Buffer_write_str(&this->out, "\n\n");
    }
  }
  std_buffer_Buffer_write_str(&this->out, "/* Constants */\n");
  compiler_passes_code_generator_CodeGenerator_gen_constants(this, this->o->program->global);
  std_buffer_Buffer_write_str(&this->out, "/* Typedefs */\n");
  for (std_vector_Iterator__10 _i156 = std_vector_Vector__10_iter(this->o->program->ordered_symbols); std_vector_Iterator__10_has_value(&_i156); std_vector_Iterator__10_next(&_i156)) {
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__10_cur(&_i156);
    {
      compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(this, sym);
    }
  }
  std_buffer_Buffer_write_str(&this->out, "\n");
  std_buffer_Buffer_write_str(&this->out, "/* Structs */\n");
  for (std_vector_Iterator__10 _i157 = std_vector_Vector__10_iter(this->o->program->ordered_symbols); std_vector_Iterator__10_has_value(&_i157); std_vector_Iterator__10_next(&_i157)) {
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__10_cur(&_i157);
    {
      compiler_passes_code_generator_CodeGenerator_gen_sym_def(this, sym);
    }
  }
  std_buffer_Buffer_write_str(&this->out, "/* function declarations */\n");
  compiler_passes_code_generator_CodeGenerator_gen_function_decls(this, this->o->program->global);
  for (std_vector_Iterator__8 _i158 = std_vector_Vector__8_iter(this->o->program->closures); std_vector_Iterator__8_has_value(&_i158); std_vector_Iterator__8_next(&_i158)) {
    compiler_ast_nodes_Function *clos = std_vector_Iterator__8_cur(&_i158);
    {
      compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(this, clos);
    }
  }
  compiler_passes_code_generator_CodeGenerator_gen_global_variables(this, this->o->program->global);
  std_buffer_Buffer_write_str(&this->out, "/* function implementations */\n");
  compiler_passes_code_generator_CodeGenerator_gen_functions(this, this->o->program->global);
  for (std_vector_Iterator__8 _i159 = std_vector_Vector__8_iter(this->o->program->closures); std_vector_Iterator__8_has_value(&_i159); std_vector_Iterator__8_next(&_i159)) {
    compiler_ast_nodes_Function *clos = std_vector_Iterator__8_cur(&_i159);
    {
      compiler_passes_code_generator_CodeGenerator_gen_closure_func(this, clos);
    }
  }
  if (this->o->program->is_test_mode) {
    compiler_passes_code_generator_CodeGenerator_gen_test_mode_main(this);
  }
  return std_buffer_Buffer_str(this->out);
}

compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator_make(compiler_ast_program_Program *program) {
  return (compiler_passes_code_generator_CodeGenerator){.o=compiler_passes_generic_pass_GenericPass_new(program), .out=std_buffer_Buffer_make(16), .yield_vars=std_vector_Vector__1_new(16), .indent=0};
}

char *compiler_passes_code_generator_CodeGenerator_run(compiler_ast_program_Program *program) {
  compiler_passes_code_generator_CodeGenerator pass = compiler_passes_code_generator_CodeGenerator_make(program);
  return compiler_passes_code_generator_CodeGenerator_generate(&pass);
}

char *compiler_passes_code_generator_cls_ctx_type(compiler_ast_nodes_Function *func) {
  return std_format("%sCtx", compiler_ast_scopes_Symbol_out_name(func->sym));}

compiler_passes_reorder_symbols_ReorderSymbols *compiler_passes_reorder_symbols_ReorderSymbols_new(compiler_ast_program_Program *program) {
  compiler_passes_reorder_symbols_ReorderSymbols *pass = std_mem_alloc__2(1);
  (*pass)=(compiler_passes_reorder_symbols_ReorderSymbols){.o=compiler_passes_generic_pass_GenericPass_new(program), .all_syms=std_vector_Vector__10_new(16), .done=std_set_Set__1_new()};
  return pass;
}

void compiler_passes_reorder_symbols_ReorderSymbols_free(compiler_passes_reorder_symbols_ReorderSymbols *this) {
  std_vector_Vector__10_free(this->all_syms);
  std_set_Set__1_free(this->done);
  std_mem_free(this->o);
  std_mem_free(this);
}

void compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym) {
  if (((bool)sym) && !(sym->is_dead)) {
    std_vector_Vector__10_push(this->all_syms, sym);
  }
}

void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_program_Namespace *ns) {
  for (std_vector_Iterator__13 _i160 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i160); std_vector_Iterator__13_next(&_i160)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i160);
    {
      if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {
        for (std_vector_Iterator__5 _i161 = std_vector_Vector__5_iter(struc->sym->template->instances); std_vector_Iterator__5_has_value(&_i161); std_vector_Iterator__5_next(&_i161)) {
          compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i161);
          {
            compiler_ast_scopes_Symbol *sym = instance->resolved;
            if(!(sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc:49:24: Assertion failed: `sym.type == Structure`", NULL); }
            compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, sym);
          }
        }
      } else {
        compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, struc->sym);
      }
    }
  }
  for (std_vector_Iterator__14 _i162 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i162); std_vector_Iterator__14_next(&_i162)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i162);
    {
      if (compiler_ast_scopes_Symbol_is_templated(enom->sym)) {
        for (std_vector_Iterator__5 _i163 = std_vector_Vector__5_iter(enom->sym->template->instances); std_vector_Iterator__5_has_value(&_i163); std_vector_Iterator__5_next(&_i163)) {
          compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__5_cur(&_i163);
          {
            compiler_ast_scopes_Symbol *sym = instance->resolved;
            if(!(sym->type==compiler_ast_scopes_SymbolType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc:61:24: Assertion failed: `sym.type == Enum`", NULL); }
            compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, sym);
          }
        }
      } else {
        compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, enom->sym);
      }
    }
  }
  for (std_map_ValueIterator__4 _i164 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i164); std_map_ValueIterator__4_next(&_i164)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i164);
    {
      compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(this, child);
    }
  }
}

void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(compiler_passes_reorder_symbols_ReorderSymbols *this) {
  compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(this, this->o->program->global);
  for (std_vector_Iterator__0 _i165 = std_vector_Vector__0_iter(this->o->program->closure_types); std_vector_Iterator__0_has_value(&_i165); std_vector_Iterator__0_next(&_i165)) {
    compiler_types_Type *cty = std_vector_Iterator__0_cur(&_i165);
    {
      compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, cty->sym);
    }
  }
  for (std_vector_Iterator__8 _i166 = std_vector_Vector__8_iter(this->o->program->closures); std_vector_Iterator__8_has_value(&_i166); std_vector_Iterator__8_next(&_i166)) {
    compiler_ast_nodes_Function *closure = std_vector_Iterator__8_cur(&_i166);
    {
      compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, closure->sym);
    }
  }
}

void compiler_passes_reorder_symbols_ReorderSymbols_dfs(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym) {
  if (!(((bool)sym)) || std_set_Set__1_contains(this->done, sym)) {
    return;
  }
  std_set_Set__1_add(this->done, sym);
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_465_0:
      {
        for (std_vector_Iterator__4 _i167 = std_vector_Vector__4_iter(sym->u.struc->fields); std_vector_Iterator__4_has_value(&_i167); std_vector_Iterator__4_next(&_i167)) {
          compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i167);
          {
            if (((bool)field->type)) {
              compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
            }
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_465_1:
      {
        for (std_vector_Iterator__4 _i168 = std_vector_Vector__4_iter(sym->u.enom->shared_fields); std_vector_Iterator__4_has_value(&_i168); std_vector_Iterator__4_next(&_i168)) {
          compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i168);
          {
            if (((bool)field->type)) {
              compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
            }
          }
        }
        for (std_vector_Iterator__20 _i169 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i169); std_vector_Iterator__20_next(&_i169)) {
          compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i169);
          {
            for (std_vector_Iterator__4 _i170 = std_vector_Vector__4_iter(variant->specific_fields); std_vector_Iterator__4_has_value(&_i170); std_vector_Iterator__4_next(&_i170)) {
              compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i170);
              {
                if (((bool)field->type)) {
                  compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
                }
              }
            }
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_465_2:
      {
        compiler_ast_nodes_Function *func = sym->u.func;
        for (std_vector_Iterator__4 _i171 = std_vector_Vector__4_iter(func->params); std_vector_Iterator__4_has_value(&_i171); std_vector_Iterator__4_next(&_i171)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i171);
          {
            compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, param->type->sym);
          }
        }
        compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, func->return_type->sym);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_465_3:
      {
        compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, sym->u.type_def->sym);
      } break;
    default:
      {
        return;
      } break;
  }  std_vector_Vector__10_push(this->o->program->ordered_symbols, sym);
}

void compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(compiler_passes_reorder_symbols_ReorderSymbols *this) {
  for (std_vector_Iterator__10 _i172 = std_vector_Vector__10_iter(this->all_syms); std_vector_Iterator__10_has_value(&_i172); std_vector_Iterator__10_next(&_i172)) {
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__10_cur(&_i172);
    {
      compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, sym);
    }
  }
}

void compiler_passes_reorder_symbols_ReorderSymbols_run(compiler_ast_program_Program *program) {
  compiler_passes_reorder_symbols_ReorderSymbols *pass = compiler_passes_reorder_symbols_ReorderSymbols_new(program);
  compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(pass);
  compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(pass);
  compiler_passes_reorder_symbols_ReorderSymbols_free(pass);
}

compiler_parser_Parser compiler_parser_Parser_make(compiler_ast_program_Program *program, compiler_ast_program_Namespace *ns) {
  return (compiler_parser_Parser){.tokens=NULL, .curr=0, .curr_func=NULL, .program=program, .ns=ns, .attrs=std_vector_Vector__12_new(16), .attrs_span=std_span_Span_default(), .attrs_start_tok=NULL, .prev_expr_error_span=std_span_Span_default()};
}

void compiler_parser_Parser_free(compiler_parser_Parser *this) {
  std_vector_Vector__12_free(this->attrs);
}

compiler_tokens_Token *compiler_parser_Parser_peek(compiler_parser_Parser *this, i32 off) {
  i32 idx = (((i32)this->curr) + off);
  if(!((0 <= idx) && (idx < ((i32)this->tokens->size)))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:63:12: Assertion failed: `0i32 <= idx < (.tokens.size as i32)`", NULL); }
  return std_vector_Vector__11_at(this->tokens, ((u32)idx));
}

compiler_errors_Error *compiler_parser_Parser_error_msg(compiler_parser_Parser *this, char *msg) {
  compiler_errors_Error *err = compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, msg);
  std_vector_Vector__16_push(this->program->errors, err);
  return err;
}

compiler_errors_Error *compiler_parser_Parser_error(compiler_parser_Parser *this, compiler_errors_Error *err) {
  std_vector_Vector__16_push(this->program->errors, err);
  return err;
}

void compiler_parser_Parser_unhandled_type(compiler_parser_Parser *this, char *func) {
  compiler_parser_Parser_error_msg(this, std_format("Unexpected token in %s: %s", func, compiler_tokens_TokenType_str(compiler_parser_Parser_token(this)->type)));
}

compiler_tokens_Token *compiler_parser_Parser_token(compiler_parser_Parser *this) {
  if (this->curr >= this->tokens->size) {
    this->curr=(this->tokens->size - 1);
    compiler_parser_Parser_error_msg(this, "Unexpected end of file");
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }
  return std_vector_Vector__11_unchecked_at(this->tokens, ((u32)this->curr));
}

bool compiler_parser_Parser_token_is(compiler_parser_Parser *this, compiler_tokens_TokenType type) {
  if (type==compiler_tokens_TokenType_Newline) {
    return compiler_parser_Parser_token(this)->seen_newline;
  }
  return compiler_parser_Parser_token(this)->type==type;
}

bool compiler_parser_Parser_token_is_eof_or(compiler_parser_Parser *this, compiler_tokens_TokenType type) {
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)) {
    return true;
  }
  return compiler_parser_Parser_token_is(this, type);
}

bool compiler_parser_Parser_token_is_identifier(compiler_parser_Parser *this, char *name) {
  return compiler_tokens_Token_is_identifier((*compiler_parser_Parser_token(this)), name);}

bool compiler_parser_Parser_peek_token_is(compiler_parser_Parser *this, u32 off, compiler_tokens_TokenType type) {
  if ((this->curr + off) >= this->tokens->size) {
    return false;
  }
  compiler_tokens_Token *tok = std_vector_Vector__11_at(this->tokens, (this->curr + off));
  return tok->type==type;
}

bool compiler_parser_Parser_consume_if(compiler_parser_Parser *this, compiler_tokens_TokenType type) {
  if (compiler_parser_Parser_token_is(this, type)) {
    if (type != compiler_tokens_TokenType_Newline) {
      if (this->curr < (this->tokens->size - 1)) {
        this->curr+=1;
      }
    }
    return true;
  }
  return false;
}

void compiler_parser_Parser_consume_newline_or(compiler_parser_Parser *this, compiler_tokens_TokenType type) {
  if (compiler_parser_Parser_token_is(this, type)) {
    if (this->curr < (this->tokens->size - 1)) {
      this->curr+=1;
    }
  } else if (!(compiler_parser_Parser_token(this)->seen_newline)) {
    compiler_parser_Parser_error_msg(this, std_format("Expected %s or newline", compiler_tokens_TokenType_str(type)));
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }
}

void compiler_parser_Parser_consume_tokens_until_newline(compiler_parser_Parser *this) {
  while (!(compiler_parser_Parser_token(this)->seen_newline)) {
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)) {
      break;
    }
    this->curr+=1;
  }
}

compiler_tokens_Token *compiler_parser_Parser_consume(compiler_parser_Parser *this, compiler_tokens_TokenType type) {
  compiler_tokens_Token *tok = compiler_parser_Parser_token(this);
  if (!(compiler_parser_Parser_consume_if(this, type))) {
    compiler_parser_Parser_error_msg(this, std_format("Expected TokenType::%s", compiler_tokens_TokenType_str(type)));
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }
  return tok;
}

bool compiler_parser_Parser_is_end_of_statement(compiler_parser_Parser *this) {
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly)) {
    return true;
  }
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Semicolon)) {
    return true;
  }
  if (compiler_parser_Parser_token(this)->seen_newline) {
    return true;
  }
  return false;
}

void compiler_parser_Parser_consume_end_of_statement(compiler_parser_Parser *this) {
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly)) {
    return;
  }
  compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Semicolon);
}

void compiler_parser_Parser_clear_attributes(compiler_parser_Parser *this) {
  for (std_vector_Iterator__12 _i223 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i223); std_vector_Iterator__12_next(&_i223)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i223);
    {
      std_mem_free(attr);
    }
  }
  std_vector_Vector__12_clear(this->attrs);
  this->attrs_start_tok=NULL;
}

bool compiler_parser_Parser_is_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op) {
  return ({bool __yv_466;
switch ((op)) {
      case compiler_ast_operators_Operator_LeftShift:
      m_467_0:
        {
          __yv_466 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_LessThan));
          goto _l___yv_466;
        } break;
      case compiler_ast_operators_Operator_RightShift:
      m_467_1:
        {
          __yv_466 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_GreaterThan));
          goto _l___yv_466;
        } break;
      case compiler_ast_operators_Operator_LeftShiftEquals:
      m_467_2:
        {
          __yv_466 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_LessThanEquals));
          goto _l___yv_466;
        } break;
      case compiler_ast_operators_Operator_RightShiftEquals:
      m_467_3:
        {
          __yv_466 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_GreaterThanEquals));
          goto _l___yv_466;
        } break;
      default:
        {
          __yv_466 = false;
          goto _l___yv_466;
        } break;
    }
_l___yv_466:
  __yv_466;});}

std_span_Span compiler_parser_Parser_consume_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op) {
  std_span_Span span = compiler_parser_Parser_token(this)->span;
switch ((op)) {
    case compiler_ast_operators_Operator_LeftShift:
    m_468_0:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);
      } break;
    case compiler_ast_operators_Operator_RightShift:
    m_468_1:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);
      } break;
    case compiler_ast_operators_Operator_LeftShiftEquals:
    m_468_2:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThanEquals);
      } break;
    case compiler_ast_operators_Operator_RightShiftEquals:
    m_468_3:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThanEquals);
      } break;
    default:
      {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(span, std_format("Unknown operator %s in Parser::consume_compound_operator", compiler_ast_operators_Operator_dbg(op))));
      } break;
  }  compiler_tokens_Token *prev_token = std_vector_Vector__11_at(this->tokens, (this->curr - 1));
  return std_span_Span_join(span, prev_token->span);
}

compiler_types_Type *compiler_parser_Parser_parse_type(compiler_parser_Parser *this) {
  return ({compiler_types_Type *__yv_469;
switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_Identifier:
      m_470_0:
        {
          compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(this, true);
          char *name = (ident->type==compiler_ast_nodes_ASTType_Identifier ? ident->u.ident.name : "<unresolved>");
          compiler_types_Type *typ = compiler_types_Type_new_unresolved(name, ident->span);
          typ->u.unresolved=ident;
          __yv_469 = typ;
          goto _l___yv_469;
        } break;
      case compiler_tokens_TokenType_Ampersand:
      m_470_1:
        {
          compiler_tokens_Token *amp = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ampersand);
          compiler_types_Type *base = compiler_parser_Parser_parse_type(this);
          compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_join(amp->span, base->span));
          typ->u.ptr=base;
          __yv_469 = typ;
          goto _l___yv_469;
        } break;
      case compiler_tokens_TokenType_AtSign:
      case compiler_tokens_TokenType_Fn:
      m_470_2:
        {
          std_span_Span start_span = compiler_parser_Parser_token(this)->span;
          compiler_types_BaseType base_type = ({compiler_types_BaseType __yv_471;
switch ((compiler_parser_Parser_token(this)->type)) {
              case compiler_tokens_TokenType_AtSign:
              m_472_0:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Fn);
                  __yv_471 = compiler_types_BaseType_Closure;
                  goto _l___yv_471;
                } break;
              case compiler_tokens_TokenType_Fn:
              m_472_1:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Fn);
                  __yv_471 = compiler_types_BaseType_FunctionPtr;
                  goto _l___yv_471;
                } break;
              default:
                {
                  std_panic("unreachable");
                  goto _l___yv_471;
                } break;
            }
_l___yv_471:
          __yv_471;});
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
          std_vector_Vector__4 *params = std_vector_Vector__4_new(16);
          bool is_variadic = false;
          while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {
            if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ellipsis)) {
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);
              is_variadic=true;
              break;
            }
            compiler_types_Type *param_type = compiler_parser_Parser_parse_type(this);
            compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(param_type);
            var->sym=compiler_ast_scopes_Symbol_from_local_variable("", var, param_type->span);
            std_vector_Vector__4_push(params, var);
            if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseParen))) {
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
            }
          }
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
          compiler_types_Type *return_type;
          if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
            return_type=compiler_parser_Parser_parse_type(this);
          } else {
            return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Void, start_span);
          }
          compiler_types_Type *type = compiler_types_Type_new_resolved(base_type, std_span_Span_join(start_span, close->span));
          type->u.func=(compiler_types_FunctionType){.orig=NULL, .params=params, .return_type=return_type, .is_variadic=is_variadic};
          __yv_469 = type;
          goto _l___yv_469;
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_470_3:
        {
          std_span_Span start_span = compiler_parser_Parser_token(this)->span;
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
          compiler_types_Type *elem_type = compiler_parser_Parser_parse_type(this);
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);
          compiler_ast_nodes_AST *size_expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseSquare);
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
          compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Array, std_span_Span_join(start_span, close->span));
          typ->u.arr=(compiler_types_ArrayType){.elem_type=elem_type, .size_expr=size_expr, .size_known=false, .size=0};
          __yv_469 = typ;
          goto _l___yv_469;
        } break;
      case compiler_tokens_TokenType_Dollar:
      m_470_4:
        {
          compiler_tokens_Token *dollar = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dollar);
          __yv_469 = ({compiler_types_Type *__yv_473;
switch ((compiler_parser_Parser_token(this)->type)) {
              case compiler_tokens_TokenType_OpenSquare:
              m_474_0:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
                  compiler_types_Type *elem_type = compiler_parser_Parser_parse_type(this);
                  compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
                  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_VectorShorthand, std_span_Span_join(dollar->span, close->span));
                  typ->u.ptr=elem_type;
                  compiler_parser_Parser_import_from_stdlib(this, "vector", typ->span);
                  __yv_473 = typ;
                  goto _l___yv_473;
                } break;
              case compiler_tokens_TokenType_OpenCurly:
              m_474_1:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
                  compiler_types_Type *key_type = compiler_parser_Parser_parse_type(this);
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
                  compiler_types_Type *value_type = compiler_parser_Parser_parse_type(this);
                  compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
                  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_MapShorthand, std_span_Span_join(dollar->span, close->span));
                  typ->u.map_types=(compiler_types_MapShorthandType){.key=key_type, .value=value_type};
                  compiler_parser_Parser_import_from_stdlib(this, "compact_map", typ->span);
                  __yv_473 = typ;
                  goto _l___yv_473;
                } break;
              default:
                {
                  compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Unexpected token after `$`"));
                  __yv_473 = NULL;
                  goto _l___yv_473;
                } break;
            }
_l___yv_473:
          __yv_473;});
          goto _l___yv_469;
        } break;
      default:
        {
          compiler_parser_Parser_unhandled_type(this, "parse_type");
          __yv_469 = compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Error, compiler_parser_Parser_token(this)->span);
          goto _l___yv_469;
        } break;
    }
_l___yv_469:
  __yv_469;});}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_identifier(compiler_parser_Parser *this) {
  compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, tok->span);
  node->u.ident.name=tok->text;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_scoped_identifier(compiler_parser_Parser *this, bool consume_template) {
  compiler_ast_nodes_AST *node = compiler_parser_Parser_parse_identifier(this);
  while (true) {
switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_ColonColon:
      m_475_0:
        {
          compiler_tokens_Token *colons = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_ColonColon);
          compiler_ast_nodes_AST *lookup = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_NSLookup, node->span);
          lookup->u.lookup.lhs=node;
          node=lookup;
          if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Newline) || !(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {
            std_span_Span span = (std_span_Span){.start=colons->span.end, .end=colons->span.end};
            compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Expected identifier after `::`"));
            node->span.end=compiler_parser_Parser_token(this)->span.start;
          } else {
            compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
            node->span=std_span_Span_join(node->span, name->span);
            node->u.lookup.rhs_name=name->text;
            node->u.lookup.rhs_span=name->span;
          }
        } break;
      case compiler_tokens_TokenType_LessThan:
      m_475_1:
        {
          if (!(consume_template)) {
            return node;
          }
          compiler_tokens_Token *prev_token = std_vector_Vector__11_at(this->tokens, (((u32)this->curr) - 1));
          if (!(std_span_Span_starts_right_after(compiler_parser_Parser_token(this)->span, prev_token->span))) {
            return node;
          }
          compiler_tokens_Token *next_next_token = std_vector_Vector__11_at(this->tokens, (((u32)this->curr) + 2));
          if (next_next_token->type==compiler_tokens_TokenType_Dot) {
            return node;
          }
          compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);
          std_vector_Vector__0 *args = std_vector_Vector__0_new(16);
          while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_GreaterThan))) {
            std_vector_Vector__0_push(args, compiler_parser_Parser_parse_type(this));
            if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan))) {
              if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {
                compiler_parser_Parser_error(this, compiler_errors_Error_new_note(compiler_parser_Parser_token(this)->span, "Parsing template specialization: expected `,` or `>`", "If you're comparing values, put a space before the `<` earlier"));
                return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, node->span);
              }
            }
          }
          compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);
          compiler_ast_nodes_AST *spec = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Specialization, std_span_Span_join(node->span, end->span));
          spec->u.spec=(compiler_ast_nodes_Specialization){.base=node, .parsed_template_args=args, .template_args=args};
          node=spec;
        } break;
      default:
        {
          return node;
        } break;
    }  }
  return NULL;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_format_string(compiler_parser_Parser *this) {
  compiler_tokens_Token *fstr = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FormatStringLiteral);
  u32 fstr_len = strlen(fstr->text);
  std_vector_Vector__1 *expr_parts = std_vector_Vector__1_new(16);
  std_vector_Vector__31 *expr_start = std_vector_Vector__31_new(16);
  std_vector_Vector__1 *format_parts = std_vector_Vector__1_new(16);
  std_vector_Vector__1 *specifiers = std_vector_Vector__1_new(16);
  u32 specifier_loc = 0;
  bool specifier_found = false;
  u32 count = 0;
  u32 cur_start = 0;
  for (u32 i = 0; i < fstr_len; i+=1) {
    switch (fstr->text[i]) {
      case '\\': {
        i+=1;
      } break;
      case '{': {
        if (count==0) {
          char *part = str_substring(fstr->text, cur_start, (i - cur_start));
          std_vector_Vector__1_push(format_parts, part);
          cur_start=(i + 1);
        }
        count+=1;
      } break;
      case '}': {
        count-=1;
        if (count==0) {
          if (specifier_loc > 0) {
            u32 len = (specifier_loc - cur_start);
            char *part = str_substring(fstr->text, cur_start, len);
            std_vector_Vector__1_push(expr_parts, part);
            std_vector_Vector__31_push(expr_start, cur_start);
            specifier_loc+=1;
            while ((specifier_loc < i) && fstr->text[specifier_loc]==' ') {
              specifier_loc+=1;
            }
            if (specifier_loc==i) {
              std_span_Location loc = fstr->span.start;
              loc.col+=(specifier_loc + 1);
              std_span_Span span = (std_span_Span){.start=loc, .end=loc};
              compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Expected format specifier"));
              return NULL;
            }
            char *spec = str_substring(fstr->text, specifier_loc, (i - specifier_loc));
            std_vector_Vector__1_push(specifiers, spec);
          } else {
            char *part = str_substring(fstr->text, cur_start, (i - cur_start));
            std_vector_Vector__1_push(expr_parts, part);
            std_vector_Vector__31_push(expr_start, cur_start);
            std_vector_Vector__1_push(specifiers, NULL);
          }
          cur_start=(i + 1);
          specifier_loc=0;
          specifier_found=false;
        } else if (count < 0) {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(fstr->span, "Unmatched '}' in format string"));
          return NULL;
        }
      } break;
      case ':': {
        if ((count==1 && (fstr->text[(i - 1)] != ':')) && (fstr->text[(i + 1)] != ':')) {
          specifier_loc=i;
          specifier_found=true;
        }
      } break;
      default: {
      } break;
    }
  }
  if (count != 0) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(fstr->span, "Unmatched '{' in format string"));
    return NULL;
  }
  char *part = str_substring(fstr->text, cur_start, (fstr_len - cur_start));
  std_vector_Vector__1_push(format_parts, part);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_FormatStringLiteral, fstr->span);
  node->u.fmt_str.parts=format_parts;
  std_span_Location fstr_start = fstr->span.start;
  std_vector_Vector__15 *expr_nodes = std_vector_Vector__15_new(16);
  for (u32 i = 0; i < expr_parts->size; i+=1) {
    char *part = std_vector_Vector__1_at(expr_parts, i);
    u32 start = std_vector_Vector__31_at(expr_start, i);
    compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(part, fstr_start.filename, this->program->errors);
    lexer.loc=fstr_start;
    lexer.loc.col+=(start + 1);
    std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
    compiler_parser_Parser sub_parser = compiler_parser_Parser_make(this->program, this->ns);
    sub_parser.tokens=tokens;
    sub_parser.curr=0;
    sub_parser.curr_func=this->curr_func;
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(&sub_parser, compiler_tokens_TokenType_CloseCurly);
    if (!(compiler_parser_Parser_token_is(&sub_parser, compiler_tokens_TokenType_EOF))) {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(expr->span, "Invalid expression in format string"));
    }
    std_vector_Vector__15_push(expr_nodes, expr);
  }
  node->u.fmt_str.exprs=expr_nodes;
  node->u.fmt_str.specs=specifiers;
  std_vector_Vector__1_free(expr_parts);
  std_vector_Vector__31_free(expr_start);
  return node;
}

std_vector_Vector__6 *compiler_parser_Parser_parse_match_case_conds(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  std_vector_Vector__6 *conds = std_vector_Vector__6_new(16);
  while (!(compiler_parser_Parser_token_is_eof_or(this, end_type))) {
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_atom(this, compiler_tokens_TokenType_Line);
    std_vector_Vector__19 *args = NULL;
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_OpenParen)) {
      args=std_vector_Vector__19_new(16);
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {
        compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
        compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);
        var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);
        std_vector_Vector__19_push(args, ({compiler_ast_nodes_MatchCondArg *_new_476 = std_mem_state_alloc_fn(std_mem_state_allocator, sizeof(compiler_ast_nodes_MatchCondArg)); *_new_476 = (compiler_ast_nodes_MatchCondArg){.var=var, .is_shared=false}; _new_476; }));
        if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {
          break;
        }
      }
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
    }
    std_vector_Vector__6_push(conds, compiler_ast_nodes_MatchCond_new(expr, args, NULL));
    if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Line))) {
      break;
    }
  }
  return conds;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_match(compiler_parser_Parser *this) {
  compiler_tokens_Token *op = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Match);
  compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Match, std_span_Span_join(op->span, expr->span));
  node->u.match_stmt.expr=expr;
  node->u.match_stmt.match_span=op->span;
  std_vector_Vector__24 *cases = std_vector_Vector__24_new(16);
  node->u.match_stmt.cases=cases;
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '{' after match expression"));
    return node;
  }
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {
      node->u.match_stmt.defolt_span=compiler_parser_Parser_token(this)->span;
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected => after match case"));
      }
      node->u.match_stmt.defolt=compiler_parser_Parser_parse_statement(this);
    } else {
      std_vector_Vector__6 *conds = compiler_parser_Parser_parse_match_case_conds(this, compiler_tokens_TokenType_FatArrow);
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected => after match case"));
      }
      compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {
        compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Comma);
      }
      compiler_ast_nodes_MatchCase _case = (compiler_ast_nodes_MatchCase){.conds=conds, .body=body};
      std_vector_Vector__24_push(cases, _case);
    }
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }
  node->span=std_span_Span_join(op->span, compiler_parser_Parser_token(this)->span);
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
  node->u.match_stmt.cases=cases;
  return node;
}

void compiler_parser_Parser_sync_toplevel(compiler_parser_Parser *this) {
  while (!((((((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Import)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Def)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Let)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Const)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Struct)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Enum)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_AtSign)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)))) {
    this->curr+=1;
  }
}

compiler_types_Type *compiler_parser_Parser_parse_literal_suffix_type(compiler_parser_Parser *this, compiler_tokens_Token *suffix) {
  if (!(((bool)suffix))) {
    return NULL;
  }
  compiler_ast_nodes_AST *ident = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, suffix->span);
  ident->u.ident.name=suffix->text;
  compiler_types_Type *typ = compiler_types_Type_new_unresolved(suffix->text, suffix->span);
  typ->u.unresolved=ident;
  return typ;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_call(compiler_parser_Parser *this, compiler_ast_nodes_AST *callee) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
  std_vector_Vector__9 *args = std_vector_Vector__9_new(16);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {
    compiler_tokens_Token *label_tok = NULL;
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_Colon)) {
      label_tok=compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
    }
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
    std_vector_Vector__9_push(args, compiler_ast_nodes_Argument_new(expr, label_tok));
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseParen))) {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
  compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
  compiler_ast_nodes_ASTType call_type = compiler_ast_nodes_ASTType_Call;
  compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(call_type, std_span_Span_join(callee->span, end->span));
  call->u.call.callee=callee;
  call->u.call.args=args;
  call->u.call.open_paren_span=start->span;
  call->u.call.close_paren_span=end->span;
  return call;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_initializer(compiler_parser_Parser *this) {
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) {
    compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
    std_vector_Vector__15 *elements = std_vector_Vector__15_new(16);
    while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseSquare))) {
      std_vector_Vector__15_push(elements, compiler_parser_Parser_parse_var_initializer(this));
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseSquare))) {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
      }
    }
    compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_ArrayLiteral, std_span_Span_join(start->span, close->span));
    node->u.array_literal.elements=elements;
    return node;
  }
  return compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_declaration(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Let);
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  std_span_Span end_span = name->span;
  compiler_types_Type *type = NULL;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
    type=compiler_parser_Parser_parse_type(this);
    end_span=type->span;
  }
  compiler_ast_nodes_AST *init = NULL;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
    init=compiler_parser_Parser_parse_var_initializer(this);
    end_span=init->span;
  }
  compiler_parser_Parser_consume_end_of_statement(this);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, std_span_Span_join(start->span, end_span));
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);
  var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);
  var->default_value=init;
  node->u.var_decl=var;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_global_value(compiler_parser_Parser *this, bool is_const) {
  compiler_tokens_Token *start_token = ({compiler_tokens_Token *__yv_477;
    if (is_const) {
      __yv_477 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Const);
      goto _l___yv_477;
    } else {
      __yv_477 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Let);
      goto _l___yv_477;
    }

_l___yv_477:
  __yv_477;});
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, compiler_parser_Parser_token(this)->span);
  compiler_tokens_Token *name = ({compiler_tokens_Token *__yv_478;
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier)) {
      __yv_478 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
      goto _l___yv_478;
    } else {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier"));
      return node;
    }

_l___yv_478:
  __yv_478;});
  compiler_types_Type *type = NULL;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
    type=compiler_parser_Parser_parse_type(this);
  }
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);
  var->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Variable, this->ns, this->ns->sym, name->text, name->span);
  var->sym->u.var=var;
  if (is_const) {
    var->sym->type=compiler_ast_scopes_SymbolType_Constant;
  }
  compiler_parser_Parser_parse_extern_into_symbol(this, var->sym);
  for (std_vector_Iterator__12 _i224 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i224); std_vector_Iterator__12_next(&_i224)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i224);
    {
switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_479_0:
          {
            compiler_parser_Parser_get_extern_from_attr(this, var->sym, attr);
          } break;
        case compiler_attributes_AttributeType_Atomic:
        m_479_1:
          {
            var->is_atomic=true;
          } break;
        default:
          {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Unexpected attribute for variable"));
          } break;
      }    }
  }
  node->u.var_decl=var;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
    if (is_const) {
      var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
    } else {
      var->default_value=compiler_parser_Parser_parse_var_initializer(this);
    }
  }
  compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Semicolon);
  return node;
}

u64 compiler_parser_Parser_parse_num_literal_int(compiler_parser_Parser *this, char *text) {
  u32 offset = 2;
  u64 base = ({u64 __yv_480;
    if (str_starts_with(text, "0x")) {
      __yv_480 = ((u64)16);
      goto _l___yv_480;
    } else if (str_starts_with(text, "0o")) {
      __yv_480 = ((u64)8);
      goto _l___yv_480;
    } else if (str_starts_with(text, "0b")) {
      __yv_480 = ((u64)2);
      goto _l___yv_480;
    } else {
      offset=0;
      __yv_480 = ((u64)10);
      goto _l___yv_480;
    }

_l___yv_480:
  __yv_480;});
  u32 len = strlen(text);
  u64 value = ((u64)0);
  for (u32 i = offset; i < len; i+=1) {
    char c = text[i];
    if (c=='_') {
      continue;
    }
    value=((value * base) + ((u64)char_get_hex_digit(c)));
  }
  return value;
}

f64 compiler_parser_Parser_parse_num_literal_float(compiler_parser_Parser *this, char *text) {
  u32 len = strlen(text);
  char buf[32] = {0};
  if(!(len < 32)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:759:12: Assertion failed: `len < 32`", NULL); }
  u32 j = 0;
  for (u32 i = 0; i < len; i+=1) {
    char c = text[i];
    if (c=='_') {
      continue;
    }
    buf[j++]=c;
  }
  buf[j]='\0';
  char *endptr;
  return strtod(buf, &endptr);
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_atom(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *node = NULL;
switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_If:
    m_481_0:
      {
        node=compiler_parser_Parser_parse_if(this);
      } break;
    case compiler_tokens_TokenType_Match:
    m_481_1:
      {
        node=compiler_parser_Parser_parse_match(this);
      } break;
    case compiler_tokens_TokenType_OpenCurly:
    m_481_2:
      {
        node=compiler_parser_Parser_parse_block(this);
      } break;
    case compiler_tokens_TokenType_FormatStringLiteral:
    m_481_3:
      {
        node=compiler_parser_Parser_parse_format_string(this);
      } break;
    case compiler_tokens_TokenType_Null:
    m_481_4:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Null);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Null, tok->span);
      } break;
    case compiler_tokens_TokenType_IntLiteral:
    m_481_5:
      {
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_IntLiteral, compiler_parser_Parser_token(this)->span);
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_IntLiteral);
        node->u.num_literal=(compiler_ast_nodes_NumLiteral){.text=tok->text, .suffix=compiler_parser_Parser_parse_literal_suffix_type(this, tok->suffix), .as_float=0.000000, .as_int=compiler_parser_Parser_parse_num_literal_int(this, tok->text)};
      } break;
    case compiler_tokens_TokenType_FloatLiteral:
    m_481_6:
      {
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_FloatLiteral, compiler_parser_Parser_token(this)->span);
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FloatLiteral);
        node->u.num_literal=(compiler_ast_nodes_NumLiteral){.text=tok->text, .suffix=compiler_parser_Parser_parse_literal_suffix_type(this, tok->suffix), .as_float=compiler_parser_Parser_parse_num_literal_float(this, tok->text), .as_int=((u64)0)};
      } break;
    case compiler_tokens_TokenType_StringLiteral:
    m_481_7:
      {
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_StringLiteral, compiler_parser_Parser_token(this)->span);
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
        node->u.string_literal=tok->text;
      } break;
    case compiler_tokens_TokenType_CharLiteral:
    m_481_8:
      {
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CharLiteral, compiler_parser_Parser_token(this)->span);
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CharLiteral);
        node->u.char_literal=tok->text;
      } break;
    case compiler_tokens_TokenType_Identifier:
    m_481_9:
      {
        node=compiler_parser_Parser_parse_scoped_identifier(this, true);
      } break;
    case compiler_tokens_TokenType_True:
    case compiler_tokens_TokenType_False:
    m_481_10:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BoolLiteral, tok->span);
        node->u.bool_literal=tok->type==compiler_tokens_TokenType_True;
      } break;
    case compiler_tokens_TokenType_OpenParen:
    m_481_11:
      {
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
        node=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseParen);
        compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
        node->span=std_span_Span_join(start->span, end->span);
      } break;
    case compiler_tokens_TokenType_Dot:
    m_481_12:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dot);
        if ((!(((bool)this->curr_func)) || !(this->curr_func->kind==compiler_ast_nodes_FunctionKind_Method)) || this->curr_func->is_static) {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(tok->span, "Cannot use dot shorthand outside of a method"));
          return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, tok->span);
        }
        compiler_ast_nodes_AST *lhs = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, tok->span);
        lhs->u.ident.name="this";
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, tok->span);
        node->u.member.lhs=lhs;
        node->u.member.dot_shorthand=true;
        if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier after `.`"));
          node->span.end=compiler_parser_Parser_token(this)->span.start;
        } else {
          compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
          node->span=std_span_Span_join(tok->span, ident->span);
          node->u.member.rhs_name=ident->text;
          node->u.member.rhs_span=ident->span;
        }
      } break;
    case compiler_tokens_TokenType_EOF:
    m_481_13:
      {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Unexpected end of file"));
        return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
      } break;
    case compiler_tokens_TokenType_Line:
    m_481_14:
      {
        std_span_Location start_loc = compiler_parser_Parser_token(this)->span.start;
        compiler_ast_nodes_Function *closure_func = compiler_parser_Parser_parse_closure(this);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CreateClosure, closure_func->span);
        node->u.closure=closure_func;
        char *closure_name = std_format("_Closure_%u", this->program->closures->size);
        std_vector_Vector__8_push(this->program->closures, closure_func);
        compiler_ast_scopes_Symbol *parent_sym = (((bool)this->curr_func) ? this->curr_func->sym : this->ns->sym);
        compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Closure, this->ns, parent_sym, closure_name, (std_span_Span){.start=start_loc, .end=start_loc});
        sym->u.func=closure_func;
        closure_func->sym=sym;
        return node;
      } break;
    case compiler_tokens_TokenType_Dollar:
    m_481_15:
      {
        compiler_tokens_Token *dollar = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dollar);
switch ((compiler_parser_Parser_token(this)->type)) {
          case compiler_tokens_TokenType_OpenSquare:
          m_482_0:
            {
              compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
              std_vector_Vector__15 *elements = std_vector_Vector__15_new(16);
              while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseSquare))) {
                std_vector_Vector__15_push(elements, compiler_parser_Parser_parse_var_initializer(this));
                if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseSquare))) {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
                }
              }
              compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
              compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VectorLiteral, std_span_Span_join(dollar->span, close->span));
              node->u.vec_literal.elements=elements;
              node->u.vec_literal.start_span=std_span_Span_join(dollar->span, start->span);
              compiler_parser_Parser_import_from_stdlib(this, "vector", node->span);
              return node;
            } break;
          case compiler_tokens_TokenType_OpenCurly:
          m_482_1:
            {
              compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
              std_vector_Vector__25 *elements = ({
                std_vector_Vector__25 *_vc483 = std_vector_Vector__25_new(8);
                _vc483;});
              while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
                compiler_ast_nodes_AST *key = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Colon);
                compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
                compiler_ast_nodes_AST *value = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
                if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
                }
                std_vector_Vector__25_push(elements, (compiler_ast_nodes_MapLiteralPair){.key=key, .value=value});
              }
              compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
              compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_MapLiteral, std_span_Span_join(dollar->span, close->span));
              node->u.map_literal.elements=elements;
              node->u.map_literal.start_span=std_span_Span_join(dollar->span, start->span);
              compiler_parser_Parser_import_from_stdlib(this, "compact_map", node->span);
              return node;
            } break;
          default:
            {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, std_format("Unexpected token: %s", compiler_tokens_TokenType_dbg(compiler_parser_Parser_token(this)->type))));
            } break;
        }      } break;
    default:
      {
        std_span_Span prev_span = std_vector_Vector__11_at(this->tokens, (this->curr - 1))->span;
        std_span_Span cur_span = compiler_parser_Parser_token(this)->span;
        std_span_Span err_span = (std_span_Span){.start=prev_span.end, .end=cur_span.start};
        if (!(compiler_parser_Parser_token_is(this, end_type))) {
          this->curr+=1;
          err_span=cur_span;
          compiler_parser_Parser_unhandled_type(this, "parse_expression");
        } else if (std_span_Span_eq(this->prev_expr_error_span, err_span)) {
          this->curr+=1;
        } else {
          this->prev_expr_error_span=err_span;
          compiler_parser_Parser_unhandled_type(this, "parse_expression");
        }
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, err_span);
      } break;
  }  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_postfix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *node = compiler_parser_Parser_parse_atom(this, end_type);
  bool running = true;
  while (running) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      goto _While_break_484;
    }
switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_OpenParen:
      m_485_0:
        {
          node=compiler_parser_Parser_parse_call(this, node);
        } break;
      case compiler_tokens_TokenType_Dot:
      case compiler_tokens_TokenType_QuestionDot:
      m_485_1:
        {
          if (compiler_parser_Parser_token_is(this, end_type)) {
            goto _While_break_484;
          }
          compiler_tokens_Token *op = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
          compiler_ast_nodes_AST *member = ({compiler_ast_nodes_AST *__yv_486;
switch ((op->type)) {
              case compiler_tokens_TokenType_QuestionDot:
              m_487_0:
                {
                  __yv_486 = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_TryMember, node->span);
                  goto _l___yv_486;
                } break;
              case compiler_tokens_TokenType_Dot:
              m_487_1:
                {
                  __yv_486 = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, node->span);
                  goto _l___yv_486;
                } break;
              default:
                {
                  std_panic("Unreachable");
                  goto _l___yv_486;
                } break;
            }
_l___yv_486:
          __yv_486;});
          member->u.member.lhs=node;
          node=member;
          if (compiler_parser_Parser_token_is(this, end_type) || !(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier after `.`"));
            node->span.end=compiler_parser_Parser_token(this)->span.start;
          } else {
            compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
            node->span=std_span_Span_join(node->span, ident->span);
            node->u.member.rhs_name=ident->text;
            node->u.member.rhs_span=ident->span;
          }
        } break;
      case compiler_tokens_TokenType_Question:
      m_485_2:
        {
          compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Question);
          node=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_IsNotNull, std_span_Span_join(node->span, tok->span), node);
        } break;
      case compiler_tokens_TokenType_Exclamation:
      m_485_3:
        {
          compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Exclamation);
          node=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_ErrorProp, std_span_Span_join(node->span, tok->span), node);
          compiler_parser_Parser_import_from_stdlib(this, "result", node->span);
        } break;
      case compiler_tokens_TokenType_ExclamationExclamation:
      m_485_4:
        {
          compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_ExclamationExclamation);
          node=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_ErrorUnwrap, std_span_Span_join(node->span, tok->span), node);
          compiler_parser_Parser_import_from_stdlib(this, "result", node->span);
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_485_5:
        {
          compiler_tokens_Token *open = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
          compiler_ast_nodes_AST *index = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseSquare);
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
          compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BinaryOp, std_span_Span_join(node->span, close->span));
          op->u.binary.op=compiler_ast_operators_Operator_Index;
          op->u.binary.lhs=node;
          op->u.binary.rhs=index;
          op->u.binary.op_span=open->span;
          node=op;
        } break;
      case compiler_tokens_TokenType_MinusMinus:
      case compiler_tokens_TokenType_PlusPlus:
      m_485_6:
        {
          std_span_Span span = std_span_Span_join(node->span, compiler_parser_Parser_token(this)->span);
          compiler_ast_operators_Operator op = ({compiler_ast_operators_Operator __yv_488;
            if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusMinus)) {
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_MinusMinus);
              __yv_488 = compiler_ast_operators_Operator_PostDecrement;
              goto _l___yv_488;
            } else {
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_PlusPlus);
              __yv_488 = compiler_ast_operators_Operator_PostIncrement;
              goto _l___yv_488;
            }

_l___yv_488:
          __yv_488;});
          node=compiler_ast_nodes_AST_new_unop(op, span, node);
        } break;
      default:
        {
          running=false;
        } break;
    }  }
  _While_break_484:;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_prefix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_Ampersand:
    m_489_0:
      {
        compiler_tokens_Token *amp = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ampersand);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, std_span_Span_join(amp->span, expr->span), expr);
        return node;
      } break;
    case compiler_tokens_TokenType_MinusMinus:
    case compiler_tokens_TokenType_PlusPlus:
    m_489_1:
      {
        std_span_Span start_span = compiler_parser_Parser_token(this)->span;
        compiler_ast_operators_Operator op = ({compiler_ast_operators_Operator __yv_490;
          if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusMinus)) {
            compiler_parser_Parser_consume(this, compiler_tokens_TokenType_MinusMinus);
            __yv_490 = compiler_ast_operators_Operator_PreDecrement;
            goto _l___yv_490;
          } else {
            compiler_parser_Parser_consume(this, compiler_tokens_TokenType_PlusPlus);
            __yv_490 = compiler_ast_operators_Operator_PreIncrement;
            goto _l___yv_490;
          }

_l___yv_490:
        __yv_490;});
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
        return compiler_ast_nodes_AST_new_unop(op, std_span_Span_join(start_span, expr->span), expr);
      } break;
    case compiler_tokens_TokenType_SizeOf:
    m_489_2:
      {
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_SizeOf);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
        compiler_types_Type *type = compiler_parser_Parser_parse_type(this);
        compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_SizeOf, std_span_Span_join(start->span, close->span));
        node->u.size_of_type=type;
        return node;
      } break;
    case compiler_tokens_TokenType_AtSign:
    m_489_3:
      {
        compiler_tokens_Token *atsign = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);
        if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected compiler operation after @"));
          return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, atsign->span);
        }
        compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
        {
          char *__match_var_491 = ident->text;
          if (str_eq(__match_var_491, "new")) {
            compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
            compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CreateNew, std_span_Span_join(atsign->span, expr->span));
            node->u.child=expr;
            return node;
          } else  {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(ident->span, "Unknown compiler operation"));
            return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, atsign->span);
          }
        }
      } break;
    case compiler_tokens_TokenType_Star:
    m_489_4:
      {
        compiler_tokens_Token *star = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Star);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Dereference, std_span_Span_join(star->span, expr->span), expr);
        return node;
      } break;
    case compiler_tokens_TokenType_Minus:
    m_489_5:
      {
        compiler_tokens_Token *minus = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Minus);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Negate, std_span_Span_join(minus->span, expr->span), expr);
        return node;
      } break;
    case compiler_tokens_TokenType_Tilde:
    m_489_6:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Tilde);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_BitwiseNot, std_span_Span_join(tok->span, expr->span), expr);
        return node;
      } break;
    default:
      {
        return compiler_parser_Parser_parse_postfix(this, end_type);
      } break;
  }}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_cast(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_prefix(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_As)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_As);
    compiler_types_Type *type_node = compiler_parser_Parser_parse_type(this);
    compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Cast, std_span_Span_join(lhs->span, type_node->span));
    op->u.cast.lhs=lhs;
    op->u.cast.to=type_node;
    op->u.cast.parsed_to=type_node;
    lhs=op;
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_term(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_cast(this, end_type);
  while ((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Star) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Slash)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Percent)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_cast(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_additive(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_term(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Plus) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Minus)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_term(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_shift(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_additive(this, end_type);
  while (compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShift) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShift)) {
    compiler_ast_operators_Operator op = ({compiler_ast_operators_Operator __yv_492;
      if (compiler_parser_Parser_token(this)->type==compiler_tokens_TokenType_LessThan) {
        __yv_492 = compiler_ast_operators_Operator_LeftShift;
        goto _l___yv_492;
      } else {
        __yv_492 = compiler_ast_operators_Operator_RightShift;
        goto _l___yv_492;
      }

_l___yv_492:
    __yv_492;});
    std_span_Span op_span = compiler_parser_Parser_consume_compound_operator(this, op);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_additive(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_shift(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ampersand)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_shift(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_xor(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_and(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Caret)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_bw_and(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_xor(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Line)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_bw_xor(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_relational(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_or(this, end_type);
  std_vector_Vector__15 *operands = NULL;
  std_vector_Vector__11 *operators = NULL;
  while ((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThanEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThanEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EqualEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_NotEquals)) || compiler_parser_Parser_token_is_identifier(this, "in")) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    bool done = ({bool __yv_493;
switch ((compiler_parser_Parser_token(this)->type)) {
        case compiler_tokens_TokenType_LessThan:
        m_494_0:
          {
            __yv_493 = compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals);
            goto _l___yv_493;
          } break;
        case compiler_tokens_TokenType_GreaterThan:
        m_494_1:
          {
            __yv_493 = compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals);
            goto _l___yv_493;
          } break;
        default:
          {
            __yv_493 = false;
            goto _l___yv_493;
          } break;
      }
_l___yv_493:
    __yv_493;});
    if (done) {
      break;
    }
    if (!(((bool)operators))) {
      operators=std_vector_Vector__11_new(2);
      operands=std_vector_Vector__15_new(3);
      std_vector_Vector__15_push(operands, lhs);
    }
    compiler_tokens_Token *token = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    std_vector_Vector__11_push(operators, token);
    compiler_ast_nodes_AST *term = compiler_parser_Parser_parse_bw_or(this, end_type);
    std_vector_Vector__15_push(operands, term);
  }
  if (!(((bool)operators))) {
    return lhs;
  }
  compiler_ast_nodes_AST *root = NULL;
  for (u32 i = 0; i < operators->size; i+=1) {
    compiler_tokens_Token *tok = std_vector_Vector__11_at(operators, i);
    compiler_ast_nodes_AST *lhs = std_vector_Vector__15_at(operands, i);
    compiler_ast_nodes_AST *rhs = std_vector_Vector__15_at(operands, (i + 1));
    compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator_from_token(tok), lhs, rhs, tok->span);
    if (((bool)root)) {
      root=compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator_And, root, op, tok->span);
    } else {
      root=op;
    }
  }
  std_vector_Vector__15_free(operands);
  std_vector_Vector__11_free(operators);
  return root;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_is(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_relational(this, end_type);
  if (!(compiler_parser_Parser_token_is_identifier(this, "is"))) {
    return lhs;
  }
  if(!(str_eq(compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier)->text, "is"))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:1245:12: Assertion failed: `.consume(Identifier).text.eq(\"is\")`", NULL); }
  std_vector_Vector__6 *conds = compiler_parser_Parser_parse_match_case_conds(this, end_type);
  std_span_Span prev_tok_span = std_vector_Vector__11_at(this->tokens, (this->curr - 1))->span;
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Is, std_span_Span_join(lhs->span, prev_tok_span));
  node->u.is_expr.lhs=lhs;
  node->u.is_expr.conds=conds;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_not(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Not)) {
    compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Not);
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_logical_not(this, end_type);
    return compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Not, std_span_Span_join(tok->span, expr->span), expr);
  }
  return compiler_parser_Parser_parse_is(this, end_type);
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_not(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_And)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_logical_not(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_and(this, end_type);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Or)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_logical_and(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_expression(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_or(this, end_type);
  while ((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Equals) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_PlusEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_StarEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_SlashEquals)) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals)) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals)) {
    if (compiler_parser_Parser_token_is(this, end_type)) {
      break;
    }
    std_span_Span op_span = {0};
    compiler_ast_operators_Operator op = ({compiler_ast_operators_Operator __yv_495;
switch ((compiler_parser_Parser_token(this)->type)) {
        case compiler_tokens_TokenType_LessThan:
        m_496_0:
          {
            op_span=compiler_parser_Parser_consume_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals);
            __yv_495 = compiler_ast_operators_Operator_LeftShiftEquals;
            goto _l___yv_495;
          } break;
        case compiler_tokens_TokenType_GreaterThan:
        m_496_1:
          {
            op_span=compiler_parser_Parser_consume_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals);
            __yv_495 = compiler_ast_operators_Operator_RightShiftEquals;
            goto _l___yv_495;
          } break;
        default:
          {
            compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
            op_span=tok->span;
            __yv_495 = compiler_ast_operators_Operator_from_token(tok);
            goto _l___yv_495;
          } break;
      }
_l___yv_495:
    __yv_495;});
    if ((op==compiler_ast_operators_Operator_Assignment && lhs->type==compiler_ast_nodes_ASTType_BinaryOp) && lhs->u.binary.op==compiler_ast_operators_Operator_Index) {
      op=compiler_ast_operators_Operator_IndexAssign;
    }
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_expression(this, end_type);
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_span);
  }
  return lhs;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_multi_if(compiler_parser_Parser *this, compiler_tokens_Token *start_tok) {
  std_span_Span start_span = start_tok->span;
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_If, start_span);
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
  std_vector_Vector__23 *branches = std_vector_Vector__23_new(16);
  node->u.if_stmt.branches=branches;
  node->u.if_stmt.if_span=start_span;
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {
      node->u.if_stmt.els_span=compiler_parser_Parser_token(this)->span;
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FatArrow);
      node->u.if_stmt.els=compiler_parser_Parser_parse_statement(this);
    } else {
      compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_FatArrow);
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected `=>` after condition"));
      }
      compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);
      std_vector_Vector__23_push(branches, (compiler_ast_nodes_IfBranch){.cond=cond, .body=body});
    }
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly)->span;
  node->span=std_span_Span_join(start_span, end_span);
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_if(compiler_parser_Parser *this) {
  compiler_tokens_Token *start_tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_If);
  std_span_Span start_span = start_tok->span;
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
    return compiler_parser_Parser_parse_multi_if(this, start_tok);
  }
  std_vector_Vector__23 *cases = std_vector_Vector__23_new(16);
  std_span_Span end_span = start_span;
  while (true) {
    compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Then);
    compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);
    std_vector_Vector__23_push(cases, (compiler_ast_nodes_IfBranch){.cond=cond, .body=body});
    end_span=body->span;
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_If)) {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_If);
    } else {
      break;
    }
  }
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_If, std_span_Span_join(start_span, end_span));
  node->u.if_stmt.branches=cases;
  node->u.if_stmt.if_span=start_span;
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {
    compiler_tokens_Token *els_tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);
    node->u.if_stmt.els=compiler_parser_Parser_parse_statement(this);
    node->u.if_stmt.els_span=els_tok->span;
  }
  node->span=std_span_Span_join(start_span, end_span);
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_for_each(compiler_parser_Parser *this, std_span_Span start_span) {
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  if (!(compiler_parser_Parser_token_is_identifier(this, "in"))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected `in` after for-each loop variable"));
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, start_span);
  }
  compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
  compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
  char *iter_var_name = std_format("_i%u", this->program->uid++);
  compiler_ast_nodes_AST *init = ({compiler_ast_nodes_AST *__yv_497;
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, start_span);
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(iter_var_name, var, start_span);
    var->default_value=expr;
    node->u.var_decl=var;
    __yv_497 = node;
    goto _l___yv_497;
  
_l___yv_497:
  __yv_497;});
  compiler_ast_nodes_AST *cond = ({compiler_ast_nodes_AST *__yv_498;
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);
    iter_name->u.ident.name=iter_var_name;
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);
    member->u.member.lhs=iter_name;
    member->u.member.rhs_name="has_value";
    member->u.member.rhs_span=expr->span;
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);
    node->u.call.callee=member;
    node->u.call.args=std_vector_Vector__9_new(16);
    node->u.call.open_paren_span=name->span;
    node->u.call.close_paren_span=name->span;
    __yv_498 = node;
    goto _l___yv_498;
  
_l___yv_498:
  __yv_498;});
  compiler_ast_nodes_AST *step = ({compiler_ast_nodes_AST *__yv_499;
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);
    iter_name->u.ident.name=iter_var_name;
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);
    member->u.member.lhs=iter_name;
    member->u.member.rhs_name="next";
    member->u.member.rhs_span=expr->span;
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);
    node->u.call.callee=member;
    node->u.call.args=std_vector_Vector__9_new(16);
    node->u.call.open_paren_span=name->span;
    node->u.call.close_paren_span=name->span;
    __yv_499 = node;
    goto _l___yv_499;
  
_l___yv_499:
  __yv_499;});
  compiler_ast_nodes_AST *loop_var_decl = ({compiler_ast_nodes_AST *__yv_500;
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);
    iter_name->u.ident.name=iter_var_name;
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);
    member->u.member.lhs=iter_name;
    member->u.member.rhs_name="cur";
    member->u.member.rhs_span=expr->span;
    compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);
    call->u.call.callee=member;
    call->u.call.args=std_vector_Vector__9_new(16);
    call->u.call.open_paren_span=name->span;
    call->u.call.close_paren_span=name->span;
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, start_span);
    var->default_value=call;
    node->u.var_decl=var;
    __yv_500 = node;
    goto _l___yv_500;
  
_l___yv_500:
  __yv_500;});
  compiler_ast_nodes_AST *inner_body = compiler_parser_Parser_parse_block(this);
  std_vector_Vector__15 *statements = std_vector_Vector__15_new(16);
  std_vector_Vector__15_push(statements, loop_var_decl);
  std_vector_Vector__15_push(statements, inner_body);
  compiler_ast_nodes_AST *body = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Block, inner_body->span);
  body->u.block.statements=statements;
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_For, std_span_Span_join(start_span, body->span));
  node->u.loop.init=init;
  node->u.loop.cond=cond;
  node->u.loop.step=step;
  node->u.loop.body=body;
  node->u.loop.needs_goto_break=false;
  node->u.loop.break_label=NULL;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_for(compiler_parser_Parser *this) {
  compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_For);
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && compiler_tokens_Token_is_identifier((*compiler_parser_Parser_peek(this, 1)), "in")) {
    return compiler_parser_Parser_parse_for_each(this, tok->span);
  }
  compiler_ast_nodes_AST *init = NULL;
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Let)) {
    init=compiler_parser_Parser_parse_statement(this);
  } else if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon))) {
    init=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Semicolon);
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);
  }
  void *cond = ({void *__yv_501;
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon)) {
      __yv_501 = NULL;
      goto _l___yv_501;
    } else {
      compiler_ast_nodes_AST *res = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Semicolon);
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);
      __yv_501 = res;
      goto _l___yv_501;
    }

_l___yv_501:
  __yv_501;});
  void *step = ({void *__yv_502;
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
      __yv_502 = NULL;
      goto _l___yv_502;
    } else {
      compiler_ast_nodes_AST *res = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);
      __yv_502 = res;
      goto _l___yv_502;
    }

_l___yv_502:
  __yv_502;});
  compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_block(this);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_For, std_span_Span_join(tok->span, body->span));
  node->u.loop.init=init;
  node->u.loop.cond=cond;
  node->u.loop.step=step;
  node->u.loop.body=body;
  node->u.loop.needs_goto_break=false;
  node->u.loop.break_label=NULL;
  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_statement(compiler_parser_Parser *this) {
  compiler_ast_nodes_AST *node = NULL;
  std_span_Span start_span = compiler_parser_Parser_token(this)->span;
switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_OpenCurly:
    m_503_0:
      {
        node=compiler_parser_Parser_parse_block(this);
      } break;
    case compiler_tokens_TokenType_Return:
    m_503_1:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Return);
        compiler_ast_nodes_AST *expr = NULL;
        if (!(compiler_parser_Parser_is_end_of_statement(this))) {
          expr=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        }
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Return, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));
        node->u.ret.expr=expr;
        node->u.ret.return_span=tok->span;
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Yield:
    m_503_2:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Yield);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Yield, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));
        node->u.child=expr;
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Break:
    m_503_3:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Break);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Break, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Continue:
    m_503_4:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Continue);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Continue, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_While:
    m_503_5:
      {
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_While);
        compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);
        compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_block(this);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_While, std_span_Span_join(tok->span, body->span));
        node->u.loop.cond=cond;
        node->u.loop.body=body;
        node->u.loop.needs_goto_break=false;
        node->u.loop.break_label=NULL;
      } break;
    case compiler_tokens_TokenType_Assert:
    m_503_6:
      {
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Assert);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        compiler_ast_nodes_AST *msg = NULL;
        std_span_Span end_span = expr->span;
        if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma)) {
          msg=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
          end_span=msg->span;
        }
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Assert, std_span_Span_join(start->span, end_span));
        node->u.assertion.expr=expr;
        node->u.assertion.msg=msg;
        return node;
      } break;
    case compiler_tokens_TokenType_Defer:
    m_503_7:
      {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Defer);
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Defer, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));
        node->u.child=expr;
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Import:
    m_503_8:
      {
        node=compiler_parser_Parser_parse_import(this);
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_For:
    m_503_9:
      {
        node=compiler_parser_Parser_parse_for(this);
      } break;
    case compiler_tokens_TokenType_Let:
    m_503_10:
      {
        node=compiler_parser_Parser_parse_var_declaration(this);
      } break;
    case compiler_tokens_TokenType_TypeDef:
    m_503_11:
      {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "TypeDefs are only allowed in the global scope"));
        this->curr+=1;
        compiler_parser_Parser_consume_tokens_until_newline(this);
      } break;
    case compiler_tokens_TokenType_Const:
    m_503_12:
      {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Constants are only allowed in the global scope"));
        this->curr+=1;
        compiler_parser_Parser_consume_tokens_until_newline(this);
      } break;
    default:
      {
        node=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon);
      } break;
  }  return node;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_block(compiler_parser_Parser *this) {
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '{'"));
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
  }
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
  std_vector_Vector__15 *statements = std_vector_Vector__15_new(16);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
    compiler_ast_nodes_AST *statement = compiler_parser_Parser_parse_statement(this);
    if (((bool)statement)) {
      std_vector_Vector__15_push(statements, statement);
    }
  }
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '}' at end of block"));
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
  }
  compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Block, std_span_Span_join(start->span, end->span));
  node->u.block.statements=statements;
  return node;
}

void compiler_parser_Parser_parse_template_params(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, std_span_Span *out_span) {
  std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan)->span;
  std_vector_Vector__10 *params = std_vector_Vector__10_new(16);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_GreaterThan))) {
    compiler_tokens_Token *type = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
    char *name = type->text;
    compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, this->ns, name, name, name, type->span);
    sym->u.type_def=compiler_types_Type_new_unresolved(name, type->span);
    sym->u.type_def->sym=sym;
    std_vector_Vector__10_push(params, sym);
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan))) {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
  std_span_Span end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan)->span;
  if (((bool)out_span)) {
    (*out_span)=std_span_Span_join(start, end);
  }
  sym->template=compiler_ast_scopes_Template_new(params);
}

void compiler_parser_Parser_add_doc_comment(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_tokens_Token *token) {
  if (((bool)token->comment)) {
    sym->comment=token->comment;
    sym->comment_loc=token->comment_loc;
  }
  if ((this->attrs->size > 0) && ((bool)this->attrs_start_tok->comment)) {
    if (!(((bool)sym->comment))) {
      sym->comment=this->attrs_start_tok->comment;
      sym->comment_loc=this->attrs_start_tok->comment_loc;
    }
  }
}

void compiler_parser_Parser_parse_function_args(compiler_parser_Parser *this, compiler_ast_nodes_Function *func, compiler_tokens_TokenType end, bool need_types) {
  bool seen_default = false;
  while (!(compiler_parser_Parser_token_is_eof_or(this, end))) {
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ellipsis)) {
      if (seen_default) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Cannot have variadic parameters and default parameters"));
      }
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);
      func->is_variadic=true;
      break;
    }
    bool found_amp = compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Ampersand);
    compiler_tokens_Token *var_name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
    compiler_types_Type *type = NULL;
    if (std_vector_Vector__4_is_empty(func->params) && func->kind==compiler_ast_nodes_FunctionKind_Method) {
      if (str_eq(var_name->text, "this")) {
        type=func->parent_type;
        if (found_amp) {
          type=compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, func->parent_type->span);
          type->u.ptr=func->parent_type;
        }
        func->is_static=false;
      } else if (found_amp) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(var_name->span, "Expected 'this' over here"));
      }
    }
    if (!(((bool)type))) {
      if (need_types || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Colon)) {
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
        type=compiler_parser_Parser_parse_type(this);
      }
    }
    compiler_ast_nodes_AST *default_value = NULL;
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
      default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
      seen_default=true;
    } else if (seen_default) {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(var_name->span, "Cannot have non-default parameters after default parameters"));
    }
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(var_name->text, var, var_name->span);
    var->default_value=default_value;
    std_vector_Vector__4_push(func->params, var);
    compiler_parser_Parser_add_doc_comment(this, var->sym, var_name);
    if (!(compiler_parser_Parser_token_is(this, end))) {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_function_body(compiler_parser_Parser *this, compiler_ast_nodes_Function *func) {
  if (compiler_parser_Parser_token(this)->type != compiler_tokens_TokenType_FatArrow) {
    func->is_arrow=false;
    return compiler_parser_Parser_parse_block(this);
  }
  func->is_arrow=true;
  compiler_tokens_Token *arrow = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FatArrow);
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected an expression for an arrow function"));
    return NULL;
  }
  compiler_ast_nodes_AST *stmt = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
  return stmt;
}

compiler_ast_nodes_Function *compiler_parser_Parser_parse_closure(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Line);
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();
  func->name_ast=NULL;
  func->kind=compiler_ast_nodes_FunctionKind_Closure;
  compiler_parser_Parser_parse_function_args(this, func, compiler_tokens_TokenType_Line, false);
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Line)->span;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
    func->return_type=compiler_parser_Parser_parse_type(this);
    end_span=func->return_type->span;
  } else {
    func->return_type=NULL;
  }
  func->parsed_return_type=func->return_type;
  func->body=compiler_parser_Parser_parse_function_body(this, func);
  func->span=std_span_Span_join(start->span, func->body->span);
  return func;
}

compiler_ast_nodes_Function *compiler_parser_Parser_parse_function(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Def);
  compiler_types_Type *parent_type = NULL;
  compiler_ast_nodes_FunctionKind kind = compiler_ast_nodes_FunctionKind_Normal;
  compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(this, false);
  if (!(((bool)ident))) {
    return NULL;
  }
  std_span_Span name_span = ident->span;
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();
  func->name_ast=ident;
  func->is_static=true;
  func->kind=compiler_ast_nodes_FunctionKind_Normal;
  char *name = ({char *__yv_504;
switch ((ident->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_505_0:
        {
          __yv_504 = ident->u.ident.name;
          goto _l___yv_504;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_505_1:
        {
          parent_type=compiler_types_Type_new_unresolved("<unresolved>", ident->span);
          parent_type->u.unresolved=ident->u.lookup.lhs;
          kind=compiler_ast_nodes_FunctionKind_Method;
          name_span=ident->u.lookup.rhs_span;
          func->parent_type=parent_type;
          func->kind=compiler_ast_nodes_FunctionKind_Method;
          __yv_504 = ident->u.lookup.rhs_name;
          goto _l___yv_504;
        } break;
      default:
        {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(ident->span, "Expected identifier"));
          __yv_504 = "<error>";
          goto _l___yv_504;
        } break;
    }
_l___yv_504:
  __yv_504;});
  func->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Function, this->ns, this->ns->sym, name, name_span);
  func->sym->u.func=func;
  compiler_parser_Parser_add_doc_comment(this, func->sym, start);
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan)) {
    compiler_parser_Parser_parse_template_params(this, func->sym, NULL);
  }
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
  compiler_parser_Parser_parse_function_args(this, func, compiler_tokens_TokenType_CloseParen, true);
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen)->span;
  bool returns = false;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
    func->return_type=compiler_parser_Parser_parse_type(this);
    end_span=func->return_type->span;
    returns=true;
  } else if (str_eq(func->sym->full_name, "main")) {
    func->return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_I32, name_span);
    returns=true;
  } else {
    func->return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Void, name_span);
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && str_eq(compiler_parser_Parser_token(this)->text, "exits")) {
      end_span=compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier)->span;
      func->exits=true;
    }
  }
  func->parsed_return_type=func->return_type;
  compiler_parser_Parser_parse_extern_into_symbol(this, func->sym);
  for (std_vector_Iterator__12 _i225 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i225); std_vector_Iterator__12_next(&_i225)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i225);
    {
switch ((attr->type)) {
        case compiler_attributes_AttributeType_Exits:
        m_506_0:
          {
            func->exits=true;
          } break;
        case compiler_attributes_AttributeType_Extern:
        m_506_1:
          {
            compiler_parser_Parser_get_extern_from_attr(this, func->sym, attr);
          } break;
        case compiler_attributes_AttributeType_VariadicFormat:
        m_506_2:
          {
            if (!(func->is_variadic)) {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Variadic format attribute can only be used on variadic functions"));
            }
            func->is_variadic_format=true;
          } break;
        case compiler_attributes_AttributeType_Operator:
        m_506_3:
          {
            compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_operator_overload(std_vector_Vector__1_at(attr->args, 0), func->params);
            if (op==compiler_ast_operators_Operator_Error) {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid operator"));
              continue;
            }
            if (!(((bool)func->operator_overloads))) {
              func->operator_overloads=std_vector_Vector__21_new(16);
            }
            std_vector_Vector__21_push(func->operator_overloads, op);
          } break;
        case compiler_attributes_AttributeType_Alive:
        m_506_4:
          {
            std_vector_Vector__10_push(this->program->explicit_alive_symbols, func->sym);
          } break;
        case compiler_attributes_AttributeType_Test:
        m_506_5:
          {
            func->is_test_function=true;
          } break;
        default:
          {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, std_format("Invalid attribute for function: %s", compiler_attributes_AttributeType_dbg(attr->type))));
          } break;
      }    }
  }
  compiler_parser_Parser_clear_attributes(this);
  if (func->sym->is_extern) {
    func->span=std_span_Span_join(start->span, end_span);
    return func;
  }
  this->curr_func=func;
  func->body=compiler_parser_Parser_parse_function_body(this, func);
  this->curr_func=NULL;
  func->span=std_span_Span_join(start->span, func->body->span);
  return func;
}

void compiler_parser_Parser_parse_extern_into_symbol(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym) {
  if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Extern))) {
    return;
  }
  sym->is_extern=true;
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenParen)) {
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
    sym->extern_name=name->text;
  } else {
    sym->extern_name=sym->name;
  }
}

void compiler_parser_Parser_get_extern_from_attr(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_attributes_Attribute *attr) {
  if(!(attr->type==compiler_attributes_AttributeType_Extern)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:1935:12: Assertion failed: `attr.type == Extern`", NULL); }
  sym->is_extern=true;
  if (attr->args->size > 0) {
    sym->extern_name=std_vector_Vector__1_at(attr->args, 0);
  } else {
    sym->extern_name=sym->name;
  }
}

std_vector_Vector__7 *compiler_parser_Parser_parse_import_path(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  std_vector_Vector__7 *parts = std_vector_Vector__7_new(16);
  while (true) {
    bool done = false;
    if (!(compiler_parser_Parser_token_is(this, end_type)) && compiler_tokens_Token_is_word((*compiler_parser_Parser_token(this)))) {
      compiler_tokens_Token *word = compiler_parser_Parser_token(this);
      this->curr+=1;
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Single, word->span);
      part->u.single.name=word->text;
      part->u.single.name_span=word->span;
      if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_As)) {
        compiler_tokens_Token *alias = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
        part->u.single.alias=alias->text;
        part->u.single.alias_span=alias->span;
        done=true;
      }
      std_vector_Vector__7_push(parts, part);
    } else if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Star)) {
      compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Star);
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Wildcard, tok->span);
      std_vector_Vector__7_push(parts, part);
      done=true;
    } else if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
      compiler_tokens_Token *open = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
      std_vector_Vector__22 *sub_paths = std_vector_Vector__22_new(16);
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
        std_vector_Vector__7 *sub_path = compiler_parser_Parser_parse_import_path(this, compiler_tokens_TokenType_CloseCurly);
        if (!(((bool)sub_path))) {
          return NULL;
        }
        std_vector_Vector__22_push(sub_paths, sub_path);
        if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {
          break;
        }
      }
      compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Multiple, std_span_Span_join(open->span, close->span));
      part->u.multiple.paths=sub_paths;
      part->u.multiple.open_curly_span=open->span;
      part->u.multiple.close_curly_span=close->span;
      std_vector_Vector__7_push(parts, part);
      done=true;
    } else {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier"));
      std_span_Span prev_tok = std_vector_Vector__11_at(this->tokens, (this->curr - 1))->span;
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Single, (std_span_Span){.start=prev_tok.end, .end=prev_tok.end});
      part->u.single.name=NULL;
      part->u.single.name_span=part->span;
      std_vector_Vector__7_push(parts, part);
      done=true;
    }
    if (done) {
      break;
    }
    if (!((compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_ColonColon) || compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Slash)))) {
      break;
    }
  }
  return parts;
}

compiler_ast_nodes_AST *compiler_parser_Parser_parse_import(compiler_parser_Parser *this) {
  std_span_Span span = compiler_parser_Parser_token(this)->span;
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Import);
  u32 parent_count = 0;
  compiler_ast_nodes_ImportType type = ({compiler_ast_nodes_ImportType __yv_507;
switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_AtSign:
      m_508_0:
        {
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);
          __yv_507 = compiler_ast_nodes_ImportType_ProjectNamespace;
          goto _l___yv_507;
        } break;
      case compiler_tokens_TokenType_ColonColon:
      case compiler_tokens_TokenType_Slash:
      m_508_1:
        {
          compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
          __yv_507 = compiler_ast_nodes_ImportType_CurrentScope;
          goto _l___yv_507;
        } break;
      case compiler_tokens_TokenType_Dot:
      case compiler_tokens_TokenType_Ellipsis:
      m_508_2:
        {
          bool done = false;
          while (!(done)) {
switch ((compiler_parser_Parser_token(this)->type)) {
              case compiler_tokens_TokenType_Dot:
              m_509_0:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dot);
                  parent_count+=1;
                } break;
              case compiler_tokens_TokenType_Ellipsis:
              m_509_1:
                {
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);
                  parent_count+=3;
                } break;
              default:
                {
                  done=true;
                } break;
            }          }
          __yv_507 = compiler_ast_nodes_ImportType_ParentNamespace;
          goto _l___yv_507;
        } break;
      default:
        {
          __yv_507 = compiler_ast_nodes_ImportType_GlobalNamespace;
          goto _l___yv_507;
        } break;
    }
_l___yv_507:
  __yv_507;});
  if (this->ns->is_dir_with_mod) {
    parent_count-=1;
  }
  std_vector_Vector__7 *parts = compiler_parser_Parser_parse_import_path(this, compiler_tokens_TokenType_Newline);
  if (!(((bool)parts))) {
    return NULL;
  }
  if (parts->size==0) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Invalid import statement"));
    return NULL;
  }
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Import, span);
  node->u.import_path=(compiler_ast_nodes_Import){.parts=parts, .type=type, .parent_count=parent_count, .export=false, .root_sym=NULL};
  for (std_vector_Iterator__12 _i226 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i226); std_vector_Iterator__12_next(&_i226)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i226);
    {
switch ((attr->type)) {
        case compiler_attributes_AttributeType_Export:
        m_510_0:
          {
            node->u.import_path.export=true;
          } break;
        default:
          {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for import"));
          } break;
      }    }
  }
  std_vector_Vector__15_push(this->ns->unhandled_imports, node);
  return node;
}

bool compiler_parser_Parser_parse_struct_field(compiler_parser_Parser *this, compiler_ast_nodes_Structure *struc) {
  std_vector_Vector__4 *fields = std_vector_Vector__4_new(1);
  compiler_parser_Parser_parse_attributes_if_any(this);
  while (true) {
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier for field name"));
      return false;
    }
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);
    compiler_parser_Parser_add_doc_comment(this, var->sym, name);
    std_vector_Vector__4_push(fields, var);
    if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {
      break;
    }
  }
  if (fields->size==1) {
    compiler_ast_nodes_Variable *field = std_vector_Vector__4_at(fields, 0);
    for (std_vector_Iterator__12 _i227 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i227); std_vector_Iterator__12_next(&_i227)) {
      compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i227);
      {
switch ((attr->type)) {
          case compiler_attributes_AttributeType_Extern:
          m_511_0:
            {
              compiler_parser_Parser_get_extern_from_attr(this, field->sym, attr);
            } break;
          case compiler_attributes_AttributeType_Atomic:
          m_511_1:
            {
              field->is_atomic=true;
            } break;
          default:
            {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for field"));
            } break;
        }      }
    }
  } else if ((fields->size > 1) && (this->attrs->size > 0)) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new_note(std_vector_Vector__4_at(fields, 0)->sym->span, "Can't use attributes on multi-field declaration", "Split this into separate field declarations"));
  }
  if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected ':' after struct field names for type"));
    return false;
  }
  compiler_types_Type *type = compiler_parser_Parser_parse_type(this);
  compiler_ast_nodes_AST *default_value = NULL;
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
    default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
  }
  for (std_vector_Iterator__4 _i228 = std_vector_Vector__4_iter(fields); std_vector_Iterator__4_has_value(&_i228); std_vector_Iterator__4_next(&_i228)) {
    compiler_ast_nodes_Variable *var = std_vector_Iterator__4_cur(&_i228);
    {
      var->type=type;
      var->parsed_type=type;
      var->default_value=default_value;
      std_vector_Vector__4_push(struc->fields, var);
    }
  }
  std_vector_Vector__4_free(fields);
  return true;
}

compiler_ast_nodes_Structure *compiler_parser_Parser_parse_struct(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_token(this);
  bool is_union = ({bool __yv_512;
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Union)) {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Union);
      __yv_512 = true;
      goto _l___yv_512;
    } else {
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Struct);
      __yv_512 = false;
      goto _l___yv_512;
    }

_l___yv_512:
  __yv_512;});
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  compiler_ast_nodes_Structure *struc = compiler_ast_nodes_Structure_new();
  struc->is_union=is_union;
  struc->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Structure, this->ns, this->ns->sym, name->text, name->span);
  struc->sym->u.struc=struc;
  compiler_parser_Parser_add_doc_comment(this, struc->sym, start);
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan)) {
    compiler_parser_Parser_parse_template_params(this, struc->sym, NULL);
  }
  compiler_parser_Parser_parse_extern_into_symbol(this, struc->sym);
  for (std_vector_Iterator__12 _i229 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i229); std_vector_Iterator__12_next(&_i229)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i229);
    {
switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_513_0:
          {
            compiler_parser_Parser_get_extern_from_attr(this, struc->sym, attr);
          } break;
        case compiler_attributes_AttributeType_Formatting:
        m_513_1:
          {
            struc->format_spec=std_vector_Vector__1_at(attr->args, 0);
            struc->format_args=std_vector_Vector__1_at(attr->args, 1);
          } break;
        default:
          {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for struct"));
          } break;
      }    }
  }
  if (!(struc->sym->is_extern) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
    while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
      if (!(compiler_parser_Parser_parse_struct_field(this, struc))) {
        break;
      }
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {
        compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Comma);
      }
    }
    compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
    struc->span=std_span_Span_join(start->span, end->span);
  }
  return struc;
}

compiler_ast_nodes_Enum *compiler_parser_Parser_parse_enum(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Enum);
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  compiler_ast_nodes_Enum *enom = compiler_ast_nodes_Enum_new(start->span);
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Enum, this->ns, this->ns->sym, name->text, name->span);
  sym->u.enom=enom;
  enom->sym=sym;
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan)) {
    compiler_parser_Parser_parse_template_params(this, enom->sym, NULL);
  }
  compiler_parser_Parser_add_doc_comment(this, sym, start);
  enom->has_values=false;
  bool is_extern = false;
  for (std_vector_Iterator__12 _i230 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i230); std_vector_Iterator__12_next(&_i230)) {
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i230);
    {
switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_514_0:
          {
            compiler_parser_Parser_get_extern_from_attr(this, enom->sym, attr);
            is_extern=true;
          } break;
        default:
          {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for value enum"));
          } break;
      }    }
  }
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Extern)) {
    compiler_parser_Parser_parse_extern_into_symbol(this, enom->sym);
  }
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {
    compiler_parser_Parser_parse_attributes_if_any(this);
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {
      compiler_types_Type *type = compiler_parser_Parser_parse_type(this);
      compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);
      var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);
      compiler_parser_Parser_add_doc_comment(this, var->sym, name);
      std_vector_Vector__4_push(enom->shared_fields, var);
      if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
        var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
      }
      compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
      enom->has_values=true;
      continue;
    }
    compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_EnumVariant_new(name->span);
    compiler_ast_scopes_Symbol *vsym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_EnumVariant, this->ns, sym, name->text, name->span);
    vsym->u.enum_var=variant;
    variant->sym=vsym;
    variant->parent=enom;
    compiler_parser_Parser_add_doc_comment(this, vsym, name);
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenParen)) {
      compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {
        compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
        compiler_types_Type *type = compiler_parser_Parser_parse_type(this);
        compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);
        var->sym=compiler_ast_scopes_Symbol_from_local_variable(ident->text, var, ident->span);
        if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
          var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
        }
        enom->has_values=true;
        std_vector_Vector__4_push(variant->specific_fields, var);
        compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
      }
      compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
      if (is_extern && (compiler_ast_nodes_EnumVariant_num_fields(variant) > 0)) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(std_span_Span_join(start->span, end->span), "Extern value enum variants cannot have fields"));
      }
    }
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {
      compiler_parser_Parser_parse_extern_into_symbol(this, variant->sym);
      if (enom->has_values) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(variant->sym->span, "Non-trivial value enums can't be extern"));
      }
    }
    for (std_vector_Iterator__12 _i231 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i231); std_vector_Iterator__12_next(&_i231)) {
      compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i231);
      {
switch ((attr->type)) {
          case compiler_attributes_AttributeType_Extern:
          m_515_0:
            {
              compiler_parser_Parser_get_extern_from_attr(this, variant->sym, attr);
              if (enom->has_values) {
                compiler_parser_Parser_error(this, compiler_errors_Error_new(variant->sym->span, "Non-trivial value enums can't be extern"));
              }
            } break;
          default:
            {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for value enum variant"));
            } break;
        }      }
    }
    std_vector_Vector__20_push(enom->variants, variant);
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }
  compiler_tokens_Token *end_tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
  enom->span=std_span_Span_join(start->span, end_tok->span);
  return enom;
}

void compiler_parser_Parser_parse_attribute(compiler_parser_Parser *this) {
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
  if (this->attrs->size==0) {
    this->attrs_span=start->span;
    this->attrs_start_tok=start;
  }
  if (!((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Extern)))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected attribute name here"));
    return;
  }
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);
  compiler_attributes_AttributeType attr_type = compiler_attributes_AttributeType_from_str(name->text);
  if (attr_type==compiler_attributes_AttributeType_Invalid) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(name->span, "Unknown attribute type"));
    return;
  }
  compiler_attributes_Attribute *attr = compiler_attributes_Attribute_new(attr_type, name->span);
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseSquare))) {
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_StringLiteral))) {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Only string literals supported in attribute arguments"));
      this->curr+=1;
      continue;
    }
    compiler_tokens_Token *arg = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
    std_vector_Vector__1_push(attr->args, arg->text);
  }
  compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
  this->attrs_span=std_span_Span_join(this->attrs_span, close->span);
  if (!(compiler_attributes_Attribute_validate(attr, this))) {
    return;
  }
  std_vector_Vector__12_push(this->attrs, attr);
}

void compiler_parser_Parser_parse_attributes_if_any(compiler_parser_Parser *this) {
  compiler_parser_Parser_clear_attributes(this);
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) {
    compiler_parser_Parser_parse_attribute(this);
  }
}

void compiler_parser_Parser_parse_namespace_until(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {
  compiler_parser_Parser_add_doc_comment(this, this->ns->sym, compiler_parser_Parser_token(this));
  jmp_buf *ctx = compiler_ast_program_Program_add_error_context(this->program);
  if (setjmp((*ctx)) > 0) {
    compiler_parser_Parser_sync_toplevel(this);
  }
  while (!(compiler_parser_Parser_token_is_eof_or(this, end_type))) {
    compiler_parser_Parser_parse_attributes_if_any(this);
switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_Def:
      m_516_0:
        {
          compiler_ast_nodes_Function *func = compiler_parser_Parser_parse_function(this);
          if (((bool)func)) {
            std_vector_Vector__8_push(this->ns->functions, func);
          }
        } break;
      case compiler_tokens_TokenType_Import:
      m_516_1:
        {
          compiler_ast_nodes_AST *import_ = compiler_parser_Parser_parse_import(this);
          if (((bool)import_)) {
            std_vector_Vector__15_push(this->ns->imports, import_);
          }
        } break;
      case compiler_tokens_TokenType_Namespace:
      m_516_2:
        {
          if (this->attrs->size > 0) {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on namespaces"));
          }
          std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Namespace)->span;
          compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
          compiler_ast_program_Namespace *old_ns = this->ns;
          compiler_ast_program_Namespace *new_ns = compiler_ast_program_Namespace_new(this->ns, this->ns->path);
          new_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, old_ns, old_ns->sym, name->text, name->span);
          new_ns->sym->u.ns=new_ns;
          new_ns->always_add_to_scope=true;
          std_map_Map__4_insert(old_ns->namespaces, name->text, new_ns);
          this->ns=new_ns;
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
          compiler_parser_Parser_parse_namespace_until(this, compiler_tokens_TokenType_CloseCurly);
          std_span_Span end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly)->span;
          new_ns->span=std_span_Span_join(start, end);
          this->ns=old_ns;
        } break;
      case compiler_tokens_TokenType_Struct:
      case compiler_tokens_TokenType_Union:
      m_516_3:
        {
          compiler_ast_nodes_Structure *struc = compiler_parser_Parser_parse_struct(this);
          if (((bool)struc)) {
            std_vector_Vector__13_push(this->ns->structs, struc);
          }
        } break;
      case compiler_tokens_TokenType_TypeDef:
      m_516_4:
        {
          if (this->attrs->size > 0) {
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on typedefs"));
          }
          std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_TypeDef)->span;
          compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Equals);
          compiler_types_Type *type = compiler_parser_Parser_parse_type(this);
          compiler_parser_Parser_consume_end_of_statement(this);
          compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, this->ns, name->text, name->text, name->text, name->span);
          sym->u.type_def=type;
          type->sym=sym;
          if (((bool)type)) {
            std_map_Map__2_insert(this->ns->typedefs, name->text, type);
          }
        } break;
      case compiler_tokens_TokenType_Enum:
      m_516_5:
        {
          compiler_ast_nodes_Enum *enom = compiler_parser_Parser_parse_enum(this);
          if (((bool)enom)) {
            std_vector_Vector__14_push(this->ns->enums, enom);
          }
        } break;
      case compiler_tokens_TokenType_Let:
      m_516_6:
        {
          compiler_ast_nodes_AST *var = compiler_parser_Parser_parse_global_value(this, false);
          if (((bool)var)) {
            std_vector_Vector__15_push(this->ns->variables, var);
          }
        } break;
      case compiler_tokens_TokenType_Const:
      m_516_7:
        {
          compiler_ast_nodes_AST *con = compiler_parser_Parser_parse_global_value(this, true);
          if (((bool)con)) {
            std_vector_Vector__15_push(this->ns->constants, con);
          }
        } break;
      case compiler_tokens_TokenType_AtSign:
      m_516_8:
        {
          compiler_parser_Parser_parse_compiler_option(this);
        } break;
      default:
        {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, std_format("Unexpected token in Parser: %s", compiler_tokens_TokenType_dbg(compiler_parser_Parser_token(this)->type))));
          this->curr+=1;
        } break;
    }  }
  compiler_ast_program_Program_pop_error_context(this->program);
  while (this->ns->unhandled_imports->size > 0) {
    compiler_ast_nodes_AST *imp = std_vector_Vector__15_pop(this->ns->unhandled_imports);
    compiler_parser_Parser_load_import_path(this, imp);
  }
}

void compiler_parser_Parser_parse_compiler_option(compiler_parser_Parser *this) {
  if (this->attrs->size > 0) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on compiler options"));
  }
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);
  compiler_tokens_Token *compiler = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  if (!(str_eq(compiler->text, "compiler"))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler->span, "Expected 'compiler'"));
  }
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
  {
    char *__match_var_517 = name->text;
    if (str_eq(__match_var_517, "c_include")) {
      compiler_tokens_Token *filename = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
      std_vector_Vector__1_push(this->program->c_includes, filename->text);
    } else if (str_eq(__match_var_517, "c_flag")) {
      compiler_tokens_Token *flag = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
      std_vector_Vector__1_push(this->program->c_flags, flag->text);
    } else if (str_eq(__match_var_517, "c_embed")) {
      compiler_tokens_Token *path = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
      char *cur_dir = ({char *__yv_518;
        if (this->ns->is_dir_with_mod) {
          __yv_518 = this->ns->path;
          goto _l___yv_518;
        } else {
          __yv_518 = this->ns->parent->path;
          goto _l___yv_518;
        }

_l___yv_518:
      __yv_518;});
      char *full_path = std_format("%s/%s", cur_dir, path->text);
      if (!(std_fs_file_exists(full_path))) {
        compiler_parser_Parser_error(this, compiler_errors_Error_new(path->span, std_format("File '%s' does not exist", full_path)));
        return;
      }
      std_buffer_Buffer contents = std_fs_read_file(full_path);
      std_map_Map__7_insert(this->program->c_embeds, full_path, std_buffer_Buffer_str(contents));
    } else  {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(name->span, "Unknown compiler option"));
    }
  }
}

void compiler_parser_Parser_try_load_mod_for_namespace(compiler_parser_Parser *this, compiler_ast_program_Namespace *ns) {
  if (ns->is_dir_with_mod) {
    return;
  }
  char *mod_path = std_format("%s/mod.oc", ns->path);
  if (std_fs_file_exists(mod_path)) {
    ns->is_dir_with_mod=true;
    compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, ns);
    compiler_parser_Parser_load_file(&parser, mod_path, NULL);
  } else {
    std_mem_free(mod_path);
  }
}

compiler_ast_program_Namespace *compiler_parser_Parser_load_single_import_part(compiler_parser_Parser *this, compiler_ast_program_Namespace *base, char *name, std_span_Span span) {
  compiler_parser_Parser_try_load_mod_for_namespace(this, base);
  if (!(((bool)name))) {
    return NULL;
  }
  compiler_ast_scopes_Symbol *sym = compiler_ast_program_Namespace_find_importable_symbol(base, name);
  if (str_eq(name, "this")) {
    return base;
  }
  if (((bool)sym) && (sym->type != compiler_ast_scopes_SymbolType_Namespace)) {
    return base;
  }
  compiler_ast_program_Namespace *next = (((bool)sym) ? sym->u.ns : NULL);
  char *part_path = std_format("%s/%s", base->path, name);
  if (!(((bool)next))) {
    bool dir_exists = compiler_utils_directory_exists(part_path);
    char *path = std_format("%s/%s.oc", base->path, name);
    bool file_exists = std_fs_file_exists(path);
    if (!(dir_exists) && !(file_exists)) {
      compiler_parser_Parser_error(this, compiler_errors_Error_new(span, std_format("Could not find import path %s(.oc)", part_path)));
      return NULL;
    }
    next=compiler_ast_program_Namespace_new(base, part_path);
    next->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, base, base->sym, name, span);
    next->sym->u.ns=next;
    std_map_Map__4_insert(base->namespaces, name, next);
    if (file_exists) {
      compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, next);
      compiler_parser_Parser_load_file(&parser, strdup(path), NULL);
    } else {
      compiler_parser_Parser_try_load_mod_for_namespace(this, next);
    }
    std_mem_free(path);
  }
  return next;
}

bool compiler_parser_Parser_load_import_path_from_base(compiler_parser_Parser *this, std_vector_Vector__7 *parts, compiler_ast_program_Namespace *base) {
  for (u32 i = 0; (i < parts->size) && (!(base->is_a_file) || base->is_dir_with_mod); i+=1) {
    compiler_ast_nodes_ImportPart *part = std_vector_Vector__7_at(parts, i);
switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_519_0:
        {
          compiler_parser_Parser_error(this, compiler_errors_Error_new(part->span, std_format("Wildcard import is not allowed from non-module")));
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_519_1:
        {
          std_vector_Vector__22 *paths = part->u.multiple.paths;
          bool success = true;
          for (std_vector_Iterator__22 _i232 = std_vector_Vector__22_iter(paths); std_vector_Iterator__22_has_value(&_i232); std_vector_Iterator__22_next(&_i232)) {
            std_vector_Vector__7 *path = std_vector_Iterator__22_cur(&_i232);
            {
              success=(compiler_parser_Parser_load_import_path_from_base(this, path, base) && success);
            }
          }
          return success;
        } break;
      case compiler_ast_nodes_ImportPartType_Single:
      m_519_2:
        {
          base=compiler_parser_Parser_load_single_import_part(this, base, part->u.single.name, part->span);
          if (!(((bool)base))) {
            return false;
          }
        } break;
    }  }
  return true;
}

compiler_parser_LibraryInfo compiler_parser_Parser_find_external_library(compiler_parser_Parser *this, char *name) {
  for (std_vector_Iterator__1 _i233 = std_vector_Vector__1_iter(this->program->library_paths); std_vector_Iterator__1_has_value(&_i233); std_vector_Iterator__1_next(&_i233)) {
    char *lib_path = std_vector_Iterator__1_cur(&_i233);
    {
      char *dir_path = ((strlen(lib_path) > 0) ? std_format("%s/%s", lib_path, name) : strdup(name));
      if (compiler_utils_directory_exists(dir_path)) {
        return (compiler_parser_LibraryInfo){.parent_dir=std_fs_realpath(lib_path), .path=std_fs_realpath(dir_path)};
      }
      std_mem_free(dir_path);
      char *file_path = ((strlen(lib_path) > 0) ? std_format("%s/%s.oc", lib_path, name) : std_format("%s.oc", name));
      if (std_fs_file_exists(file_path)) {
        return (compiler_parser_LibraryInfo){.parent_dir=std_fs_realpath(lib_path), .path=std_fs_realpath(file_path)};
      }
      std_mem_free(file_path);
    }
  }
  return (compiler_parser_LibraryInfo){.parent_dir=NULL, .path=NULL};
}

compiler_ast_program_Namespace *compiler_parser_Parser_import_from_stdlib(compiler_parser_Parser *this, char *name, std_span_Span span) {
  compiler_ast_program_Namespace *std_ns = compiler_parser_Parser_find_or_import_stdlib(this);
  compiler_ast_program_Namespace *ns = std_map_Map__4_get(std_ns->namespaces, name, NULL);
  if (!(((bool)ns))) {
    ns=compiler_parser_Parser_load_single_import_part(this, std_ns, name, span);
  }
  return ns;
}

compiler_ast_program_Namespace *compiler_parser_Parser_import_external_lib(compiler_parser_Parser *this, char *name) {
  compiler_parser_LibraryInfo lib = compiler_parser_Parser_find_external_library(this, name);
  if (!(((bool)lib.path))) {
    return NULL;
  }
  compiler_ast_program_Namespace *ns = compiler_ast_program_Namespace_new(this->program->global, lib.path);
  ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, this->program->global, this->program->global->sym, name, std_span_Span_default());
  ns->sym->u.ns=ns;
  ns->always_add_to_scope=true;
  ns->internal_project_root=ns;
  if (std_fs_directory_exists(lib.path)) {
    compiler_parser_Parser_try_load_mod_for_namespace(this, ns);
  } else {
    compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, ns);
    compiler_parser_Parser_load_file(&parser, lib.path, NULL);
    compiler_parser_Parser_free(&parser);
  }
  return ns;
}

bool compiler_parser_Parser_load_import_path(compiler_parser_Parser *this, compiler_ast_nodes_AST *import_stmt) {
  compiler_ast_nodes_Import *path = &import_stmt->u.import_path;
  compiler_ast_program_Namespace *base = ({compiler_ast_program_Namespace *__yv_520;
switch ((path->type)) {
      case compiler_ast_nodes_ImportType_GlobalNamespace:
      m_521_0:
        {
          std_vector_Vector__7 *parts = path->parts;
          if(!(parts->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:2659:20: Assertion failed: `parts.size > 0`", "Expected at least one part in import path"); }
          if(!(std_vector_Vector__7_at(parts, 0)->type==compiler_ast_nodes_ImportPartType_Single)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:2660:20: Assertion failed: `parts.at(0).type == Single`", "Expected first part to be a single import"); }
          compiler_ast_nodes_ImportPartSingle first_part = std_vector_Vector__7_at(parts, 0)->u.single;
          char *lib_name = first_part.name;
          if (!(std_map_Map__4_contains(this->program->global->namespaces, lib_name))) {
            compiler_ast_program_Namespace *lib = compiler_parser_Parser_import_external_lib(this, lib_name);
            if (!(((bool)lib))) {
              compiler_parser_Parser_error(this, compiler_errors_Error_new(import_stmt->span, std_format("Could not find library '%s'", lib_name)));
              return false;
            }
            std_map_Map__4_insert(this->program->global->namespaces, lib_name, lib);
          }
          __yv_520 = this->program->global;
          goto _l___yv_520;
        } break;
      case compiler_ast_nodes_ImportType_ProjectNamespace:
      m_521_1:
        {
          __yv_520 = compiler_ast_program_Namespace_get_project_root(this->ns, import_stmt->span, this->program);
          goto _l___yv_520;
        } break;
      case compiler_ast_nodes_ImportType_ParentNamespace:
      m_521_2:
        {
          compiler_ast_program_Namespace *cur = this->ns;
          for (u32 i = 0; i < path->parent_count; i+=1) {
            if (!(((bool)cur->parent))) {
              compiler_ast_nodes_ImportPart *first_part = std_vector_Vector__7_at(path->parts, 0);
              compiler_parser_Parser_error(this, compiler_errors_Error_new(first_part->span, "Cannot import from parent of root namespace"));
              longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
            }
            cur=cur->parent;
          }
          __yv_520 = cur;
          goto _l___yv_520;
        } break;
      case compiler_ast_nodes_ImportType_CurrentScope:
      m_521_3:
        {
          return true;
        } break;
    }
_l___yv_520:
  __yv_520;});
  if (!(((bool)base))) {
    return false;
  }
  compiler_parser_Parser_load_import_path_from_base(this, path->parts, base);
  return true;
}

void compiler_parser_Parser_load_file(compiler_parser_Parser *this, char *filename, char *contents) {
  if (std_map_Map__7_contains(this->program->sources, filename)) {
    return;
  }
  std_span_Location loc = (std_span_Location){.filename=strdup(filename), .line=0, .col=0, .index=0};
  std_span_Span span = (std_span_Span){.start=loc, .end=loc};
  this->ns->span=span;
  this->ns->sym->span=span;
  if (!(((bool)contents))) {
    contents=std_buffer_Buffer_str(std_fs_read_file(filename));
  }
  std_map_Map__7_insert(this->program->sources, filename, contents);
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(contents, filename, this->program->errors);
  this->tokens=compiler_lexer_Lexer_lex(&lexer);
  this->curr=0;
  this->ns->is_a_file=true;
  std_span_Span start = compiler_parser_Parser_token(this)->span;
  compiler_parser_Parser_parse_namespace_until(this, compiler_tokens_TokenType_EOF);
  std_span_Span end = compiler_parser_Parser_token(this)->span;
  this->ns->span=std_span_Span_join(start, end);
}

void compiler_parser_Parser_couldnt_find_stdlib(compiler_parser_Parser *this) {
  printf("--------------------------------------------------------------------------------""\n");
  printf("    Could not find standard library. Set OCEN_ROOT environment variable.""\n");
  printf("      Alternatively, compile from the root of `ocen` repository.""\n");
  printf("--------------------------------------------------------------------------------""\n");
  longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
}

compiler_ast_program_Namespace *compiler_parser_Parser_find_or_import_stdlib(compiler_parser_Parser *this) {
  compiler_ast_program_Namespace *std_ns = std_map_Map__4_get(this->program->global->namespaces, "std", NULL);
  if (!(((bool)std_ns))) {
    compiler_ast_program_Namespace *std_ns = compiler_parser_Parser_import_external_lib(this, "std");
    std_map_Map__4_insert(this->program->global->namespaces, "std", std_ns);
  }
  return std_ns;
}

void compiler_parser_Parser_include_prelude_only(compiler_parser_Parser *this) {
  compiler_parser_LibraryInfo stdlib = compiler_parser_Parser_find_external_library(this, "std");
  if (!(((bool)stdlib.path))) {
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }
  char *prelude_path = std_format("%s/prelude.h", stdlib.path);
  if (!(std_fs_file_exists(prelude_path))) {
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }
  std_buffer_Buffer content = std_fs_read_file(prelude_path);
  std_map_Map__7_insert(this->program->c_embeds, prelude_path, std_buffer_Buffer_str(content));
}

void compiler_parser_Parser_create_namespaces_for_initial_file(compiler_parser_Parser *this, char *filename, bool single_file) {
  if (!(this->program->include_stdlib)) {
    compiler_parser_Parser_include_prelude_only(this);
    return;
  }
  compiler_ast_program_Namespace *std_lib_ns = compiler_parser_Parser_import_external_lib(this, "std");
  if (!(((bool)std_lib_ns))) {
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }
  char *std_lib_ns_path = std_fs_realpath(std_lib_ns->path);
  char *cur = std_fs_realpath(filename);
  if (!(((bool)cur))) {
    compiler_parser_Parser_error(this, compiler_errors_Error_new(std_span_Span_default(), std_format("Could not find file: %s", filename)));
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }
  std_vector_Vector__1 *namespace_paths = std_vector_Vector__1_new(16);
  bool found_root = false;
  while (true) {
    char *base = strdup(dirname(strdup(cur)));
    std_vector_Vector__1_push(namespace_paths, base);
    if (str_eq(base, "/")) {
      break;
    }
    if (single_file) {
      break;
    }
    char *potential_main_path = std_format("%s/main.oc", base);
    bool main_exists = std_fs_file_exists(potential_main_path);
    str_free(&potential_main_path);
    if (str_eq(base, std_lib_ns_path) || main_exists) {
      found_root=true;
      break;
    }
    cur=base;
  }
  i32 start = (found_root ? ((i32)namespace_paths->size) : 0);
  compiler_ast_program_Namespace *cur_ns = this->program->global;
  for (i32 i = (start - 1); i >= 0; i-=1) {
    char *path = namespace_paths->data[i];
    char *t1 = strdup(path);
    char *base = strdup(basename(t1));
    str_free(&t1);
    if (std_map_Map__4_contains(cur_ns->namespaces, base)) {
      cur_ns=std_map_Map__4_at(cur_ns->namespaces, base);
      continue;
    }
    compiler_ast_program_Namespace *new_ns = compiler_ast_program_Namespace_new(cur_ns, path);
    std_span_Location loc = (std_span_Location){.filename=path, .line=0, .col=0, .index=0};
    new_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, cur_ns, cur_ns->sym, base, (std_span_Span){.start=loc, .end=loc});
    new_ns->sym->u.ns=new_ns;
    if (i==(start - 1)) {
      new_ns->internal_project_root=new_ns;
    }
    std_map_Map__4_insert(cur_ns->namespaces, base, new_ns);
    cur_ns=new_ns;
  }
  char *file_base = strdup(basename(filename));
  if (str_ends_with(file_base, ".oc")) {
    file_base[(strlen(file_base) - 3)]='\0';
  }
  if (str_eq(file_base, "mod")) {
    cur_ns->is_dir_with_mod=true;
    this->ns=cur_ns;
    return;
  }
  if (std_map_Map__4_contains(cur_ns->namespaces, file_base)) {
    this->ns=std_map_Map__4_at(cur_ns->namespaces, file_base);
    return;
  }
  compiler_ast_program_Namespace *child_ns = compiler_ast_program_Namespace_new(cur_ns, filename);
  child_ns->sym=compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Namespace, cur_ns, file_base, "", "", std_span_Span_default());
  child_ns->sym->u.ns=child_ns;
  std_map_Map__4_insert(cur_ns->namespaces, file_base, child_ns);
  child_ns->sym->full_name="";
  this->ns=child_ns;
}

void compiler_parser_Parser_parse_toplevel(compiler_ast_program_Program *program, char *filename, char *file_contents, bool include_workspace_main) {
  jmp_buf *ctx = compiler_ast_program_Program_add_error_context(program);
  if (setjmp((*ctx)) > 0) {
    printf("Error in parse_toplevel context""\n");
    return;
  }
  compiler_parser_Parser parser = compiler_parser_Parser_make(program, program->global);
  if (program->include_stdlib) {
    compiler_parser_Parser_find_or_import_stdlib(&parser);
  } else {
    compiler_parser_Parser_include_prelude_only(&parser);
  }
  compiler_parser_Parser_create_namespaces_for_initial_file(&parser, filename, false);
  compiler_parser_Parser_load_file(&parser, filename, file_contents);
  compiler_ast_program_Namespace *file_ns = parser.ns;
  if (include_workspace_main && ((bool)file_ns->internal_project_root)) {
    char *potential_main = std_format("%s/main.oc", file_ns->internal_project_root->path);
    if (std_fs_file_exists(potential_main)) {
      compiler_ast_program_Namespace *main_ns = std_map_Map__4_get(file_ns->internal_project_root->namespaces, "main", NULL);
      if (main_ns==file_ns) {
        return;
      }
      if (!(((bool)main_ns))) {
        compiler_ast_program_Namespace *root = file_ns->internal_project_root;
        main_ns=compiler_ast_program_Namespace_new(root, "main");
        main_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, root, root->sym, "main", std_span_Span_default());
        main_ns->sym->u.ns=main_ns;
        std_map_Map__4_insert(root->namespaces, "main", main_ns);
      }
      parser.ns=main_ns;
      compiler_parser_Parser_load_file(&parser, potential_main, NULL);
    } else {
      str_free(&potential_main);
    }
  }
  if (program->is_test_mode) {
    compiler_parser_Parser_import_from_stdlib(&parser, "testing", std_span_Span_default());
  }
}

compiler_ast_program_Namespace *compiler_ast_program_Namespace_new(compiler_ast_program_Namespace *parent, char *path) {
  compiler_ast_program_Namespace *ns = std_mem_alloc__3(1);
  ns->parent=parent;
  compiler_ast_scopes_Scope *parent_scope = (((bool)parent) ? parent->scope : NULL);
  compiler_ast_program_Namespace *parent_root = (((bool)parent) ? parent->internal_project_root : NULL);
  ns->scope=NULL;
  ns->functions=std_vector_Vector__8_new(16);
  ns->structs=std_vector_Vector__13_new(16);
  ns->enums=std_vector_Vector__14_new(16);
  ns->constants=std_vector_Vector__15_new(16);
  ns->variables=std_vector_Vector__15_new(16);
  ns->typedefs=std_map_Map__2_new(8);
  ns->namespaces=std_map_Map__4_new(8);
  ns->imports=std_vector_Vector__15_new(16);
  ns->exported_symbols=std_map_Map__5_new(8);
  ns->unhandled_imports=std_vector_Vector__15_new(16);
  ns->path=path;
  ns->is_a_file=false;
  ns->internal_project_root=parent_root;
  return ns;
}

compiler_ast_scopes_Symbol *compiler_ast_program_Namespace_find_importable_symbol(compiler_ast_program_Namespace *this, char *name) {
  compiler_ast_program_Namespace *item = std_map_Map__4_get(this->namespaces, name, NULL);
  if (((bool)item)) {
    return item->sym;
  }
  for (std_vector_Iterator__15 _i68 = std_vector_Vector__15_iter(this->constants); std_vector_Iterator__15_has_value(&_i68); std_vector_Iterator__15_next(&_i68)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i68);
    {
      compiler_ast_nodes_Variable *var = node->u.var_decl;
      if (str_eq(var->sym->name, name)) {
        return var->sym;
      }
    }
  }
  for (std_vector_Iterator__15 _i69 = std_vector_Vector__15_iter(this->variables); std_vector_Iterator__15_has_value(&_i69); std_vector_Iterator__15_next(&_i69)) {
    compiler_ast_nodes_AST *node = std_vector_Iterator__15_cur(&_i69);
    {
      compiler_ast_nodes_Variable *var = node->u.var_decl;
      if (str_eq(var->sym->name, name)) {
        return var->sym;
      }
    }
  }
  for (std_vector_Iterator__8 _i70 = std_vector_Vector__8_iter(this->functions); std_vector_Iterator__8_has_value(&_i70); std_vector_Iterator__8_next(&_i70)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i70);
    {
      if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
        continue;
      }
      if (str_eq(func->sym->name, name)) {
        return func->sym;
      }
    }
  }
  for (std_vector_Iterator__13 _i71 = std_vector_Vector__13_iter(this->structs); std_vector_Iterator__13_has_value(&_i71); std_vector_Iterator__13_next(&_i71)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i71);
    {
      if (str_eq(struc->sym->name, name)) {
        return struc->sym;
      }
    }
  }
  for (std_vector_Iterator__14 _i72 = std_vector_Vector__14_iter(this->enums); std_vector_Iterator__14_has_value(&_i72); std_vector_Iterator__14_next(&_i72)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i72);
    {
      if (str_eq(enom->sym->name, name)) {
        return enom->sym;
      }
    }
  }
  if (std_map_Map__5_contains(this->exported_symbols, name)) {
    return std_map_Map__5_at(this->exported_symbols, name);
  }
  compiler_types_Type *td = std_map_Map__2_get(this->typedefs, name, NULL);
  if (((bool)td)) {
    return td->sym;
  }
  return NULL;
}

compiler_ast_program_Namespace *compiler_ast_program_Namespace_get_project_root(compiler_ast_program_Namespace *this, std_span_Span span, compiler_ast_program_Program *program_for_errors) {
  if (!(((bool)this->internal_project_root))) {
    compiler_ast_program_Program_error(program_for_errors, compiler_errors_Error_new_note(span, "No project root found, can't use a Project Namespace import", "A project root is a top-level directory containing a `main.oc` file."));
  }
  return this->internal_project_root;
}

compiler_ast_program_Program *compiler_ast_program_Program_new(void) {
  compiler_ast_program_Program *prog = std_mem_alloc__4(1);
  prog->global=compiler_ast_program_Namespace_new(NULL, "");
  prog->ordered_symbols=std_vector_Vector__10_new(16);
  prog->global->sym=compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Namespace, prog->global, "", "", "", std_span_Span_default());
  prog->global->sym->u.ns=prog->global;
  prog->error_level=1;
  prog->errors=std_vector_Vector__16_new(16);
  prog->c_includes=std_vector_Vector__1_new(16);
  prog->c_flags=std_vector_Vector__1_new(16);
  prog->c_embeds=std_map_Map__7_new(8);
  prog->sources=std_map_Map__7_new(8);
  prog->library_paths=std_vector_Vector__1_new(16);
  prog->operator_overloads=std_map_Map__6_new(8);
  prog->err_jmp_stack=std_vector_Vector__17_new(16);
  prog->explicit_alive_symbols=std_vector_Vector__10_new(16);
  prog->closure_types=std_vector_Vector__0_new(16);
  prog->closures=std_vector_Vector__8_new(16);
  prog->uid=0;
  return prog;
}

jmp_buf *compiler_ast_program_Program_add_error_context(compiler_ast_program_Program *this) {
  std_vector_Vector__17_resize(this->err_jmp_stack, (this->err_jmp_stack->size + 1));
  this->err_jmp_stack->size+=1;
  return std_vector_Vector__17_back_ptr(this->err_jmp_stack, 0);
}

jmp_buf *compiler_ast_program_Program_get_error_context(compiler_ast_program_Program *this) {
  return std_vector_Vector__17_back_ptr(this->err_jmp_stack, 0);
}

void compiler_ast_program_Program_pop_error_context(compiler_ast_program_Program *this) {
  this->err_jmp_stack->size-=1;
}

void compiler_ast_program_Program_setup_library_paths(compiler_ast_program_Program *this) {
  std_vector_Vector__1_push(this->library_paths, "");
  char *ocen_root = getenv("OCEN_ROOT");
  if (((bool)ocen_root) && (strlen(ocen_root) > 0)) {
    std_vector_Vector__1_push(this->library_paths, ocen_root);
  }
  char *ocen_lib = getenv("OCEN_LIB");
  if (((bool)ocen_lib)) {
    std_sv_SV oc_sv = std_sv_SV_from_str(ocen_lib);
    for (std_sv_SVSplitIterator _i73 = std_sv_SV_split_str(oc_sv, ":"); std_sv_SVSplitIterator_has_value(&_i73); std_sv_SVSplitIterator_next(&_i73)) {
      std_sv_SV part = std_sv_SVSplitIterator_cur(&_i73);
      {
        std_vector_Vector__1_push(this->library_paths, std_sv_SV_copy_data_to_cstr(part));
      }
    }
  }
}

void compiler_ast_program_Program_exit_with_errors_if_any(compiler_ast_program_Program *this) {
  if (!(std_vector_Vector__16_is_empty(this->errors))) {
    compiler_errors_display_error_messages(this->errors, this->error_level);
    exit(1);
  }
}

char *compiler_ast_program_Program_get_source_text(compiler_ast_program_Program *this, std_span_Span span) {
  std_span_Location start = span.start;
  std_span_Location end = span.end;
  char *contents = ((char *)std_map_Map__7_get(this->sources, start.filename, NULL));
  if (!(((bool)contents))) {
    return NULL;
  }
  u32 len = (end.index - start.index);
  return str_substring(contents, start.index, len);
}

compiler_errors_Error *compiler_ast_program_Program_error(compiler_ast_program_Program *this, compiler_errors_Error *err) {
  std_vector_Vector__16_push(this->errors, err);
  return err;
}

compiler_types_Type *compiler_ast_program_Program_find_closure_type(compiler_ast_program_Program *this, std_vector_Vector__4 *params, compiler_types_Type *ret) {
  for (std_vector_Iterator__0 _i74 = std_vector_Vector__0_iter(this->closure_types); std_vector_Iterator__0_has_value(&_i74); std_vector_Iterator__0_next(&_i74)) {
    compiler_types_Type *c = std_vector_Iterator__0_cur(&_i74);
    {
      compiler_types_FunctionType clos = c->u.func;
      if (clos.params->size != params->size) {
        continue;
      }
      if (!(compiler_types_Type_eq(clos.return_type, ret, false))) {
        continue;
      }
      bool all_match = true;
      for (u32 i = 0; i < params->size; i+=1) {
        if (!(compiler_types_Type_eq(std_vector_Vector__4_at(clos.params, i)->type, std_vector_Vector__4_at(params, i)->type, false))) {
          all_match=false;
          break;
        }
      }
      if (!(all_match)) {
        continue;
      }
      return c;
    }
  }
  return NULL;
}

compiler_ast_nodes_Function *compiler_ast_program_get_deep_copy__0(compiler_ast_program_Program *program, compiler_ast_nodes_Function *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *(*parse_fn)(compiler_parser_Parser *)) {
  char *obj_text = compiler_ast_program_Program_get_source_text(program, old->span);
  if (!(((bool)obj_text))) {
    return NULL;
  }
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(obj_text, old->span.start.filename, NULL);
  lexer.loc=old->span.start;
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  compiler_parser_Parser parser = compiler_parser_Parser_make(program, ns);
  parser.tokens=tokens;
  parser.curr=0;
  return parse_fn(&parser);
}

compiler_ast_nodes_Structure *compiler_ast_program_get_deep_copy__1(compiler_ast_program_Program *program, compiler_ast_nodes_Structure *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *(*parse_fn)(compiler_parser_Parser *)) {
  char *obj_text = compiler_ast_program_Program_get_source_text(program, old->span);
  if (!(((bool)obj_text))) {
    return NULL;
  }
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(obj_text, old->span.start.filename, NULL);
  lexer.loc=old->span.start;
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  compiler_parser_Parser parser = compiler_parser_Parser_make(program, ns);
  parser.tokens=tokens;
  parser.curr=0;
  return parse_fn(&parser);
}

compiler_ast_nodes_Enum *compiler_ast_program_get_deep_copy__2(compiler_ast_program_Program *program, compiler_ast_nodes_Enum *old, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *(*parse_fn)(compiler_parser_Parser *)) {
  char *obj_text = compiler_ast_program_Program_get_source_text(program, old->span);
  if (!(((bool)obj_text))) {
    return NULL;
  }
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(obj_text, old->span.start.filename, NULL);
  lexer.loc=old->span.start;
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  compiler_parser_Parser parser = compiler_parser_Parser_make(program, ns);
  parser.tokens=tokens;
  parser.curr=0;
  return parse_fn(&parser);
}

compiler_types_Type *compiler_ast_program_Program_get_base_type(compiler_ast_program_Program *this, compiler_types_BaseType base, std_span_Span span) {
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_local(this->global->scope, compiler_types_BaseType_str(base));
  if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_TypeDef) {
    return sym->u.type_def;
  } else {
    compiler_ast_program_Program_error(this, compiler_errors_Error_new(span, std_format("Internal compiler error, couldn't find base type %s", compiler_types_BaseType_dbg(base))));
    return NULL;
  }
}

compiler_types_Type *compiler_ast_program_Program_get_type_by_name(compiler_ast_program_Program *this, char *name, std_span_Span span) {
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_local(this->global->scope, name);
  if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_TypeDef) {
    return sym->u.type_def;
  } else {
    compiler_ast_program_Program_error(this, compiler_errors_Error_new(span, std_format("Internal compiler error, couldn't find type %s", name)));
    return NULL;
  }
}

compiler_ast_program_NSIterator compiler_ast_program_Program_iter_namespaces(compiler_ast_program_Program *this) {
  return (compiler_ast_program_NSIterator){.stack=std_vector_Vector__3_new(16), .curr=this->global};
}

bool compiler_ast_program_NSIterator_has_value(compiler_ast_program_NSIterator *this) {
  return ((bool)this->curr);}

void compiler_ast_program_NSIterator_next(compiler_ast_program_NSIterator *this) {
  for (std_map_ValueIterator__4 _i75 = std_map_Map__4_iter_values(this->curr->namespaces); std_map_ValueIterator__4_has_value(&_i75); std_map_ValueIterator__4_next(&_i75)) {
    compiler_ast_program_Namespace *ns = std_map_ValueIterator__4_cur(&_i75);
    {
      std_vector_Vector__3_push(this->stack, ns);
    }
  }
  if (std_vector_Vector__3_is_empty(this->stack)) {
    this->curr=NULL;
    std_vector_Vector__3_free(this->stack);
  } else {
    this->curr=std_vector_Vector__3_pop(this->stack);
  }
}

compiler_ast_program_Namespace *compiler_ast_program_NSIterator_cur(compiler_ast_program_NSIterator *this) {
  return this->curr;}

compiler_ast_scopes_TemplateInstance *compiler_ast_scopes_TemplateInstance_new(std_vector_Vector__0 *args, compiler_ast_scopes_Symbol *parent, compiler_ast_scopes_Symbol *resolved) {
  compiler_ast_scopes_TemplateInstance *instance = std_mem_alloc__5(1);
  instance->args=args;
  instance->parent=parent;
  instance->resolved=resolved;
  return instance;
}

bool compiler_ast_scopes_TemplateInstance_matches(compiler_ast_scopes_TemplateInstance *this, std_vector_Vector__0 *other) {
  if(!(other->size==this->args->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc:47:12: Assertion failed: `other.size == .args.size`", NULL); }
  for (u32 i = 0; i < other->size; i++) {
    compiler_types_Type *a = std_vector_Vector__0_at(this->args, i);
    compiler_types_Type *b = std_vector_Vector__0_at(other, i);
    if (!(compiler_types_Type_eq(a, b, true))) {
      return false;
    }
  }
  return true;
}

compiler_ast_scopes_Template *compiler_ast_scopes_Template_new(std_vector_Vector__10 *params) {
  compiler_ast_scopes_Template *templ = std_mem_alloc__6(1);
  templ->params=params;
  templ->instances=std_vector_Vector__5_new(16);
  return templ;
}

char *compiler_ast_scopes_Symbol_out_name(compiler_ast_scopes_Symbol *this) {
  if (this->is_extern) {
    return this->extern_name;
  }
  return this->full_name;
}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, char *name, char *display, char *full_name, std_span_Span span) {
  compiler_ast_scopes_Symbol *item = std_mem_alloc__7(1);
  item->name=name;
  item->display=display;
  item->references=std_vector_Vector__18_new(4);
  u32 full_name_len = strlen(full_name);
  full_name=strdup(full_name);
  for (u32 i = 0; i < full_name_len; ) {
    char c = full_name[i];
    u32 ln = 1;
    if(!(compiler_lexer_is_valid_utf8_start(c, &ln))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc:152:16: Assertion failed: `is_valid_utf8_start(c, &ln)`", NULL); }
    switch (ln) {
      case 1: {
        if ((i==0 && char_is_digit(c)) || (!(char_is_alnum(c)) && (c != '_'))) {
          full_name[i]='_';
        }
      } break;
      default: {
        for (u32 j = 0; j < ln; j++) {
          full_name[(i + j)]=((char)(((u8)'a') + (((u8)full_name[(i + j)]) % ((u8)26))));
        }
      } break;
    }
    i+=ln;
  }
  item->full_name=full_name;
  item->span=span;
  item->type=type;
  item->ns=ns;
  return item;
}

char *compiler_ast_scopes_Symbol_join_display(char *a, char *b) {
  return (strlen(a)==0 ? b : std_format("%s::%s", a, b));}

char *compiler_ast_scopes_Symbol_join_full_name(char *a, char *b) {
  return (strlen(a)==0 ? b : std_format("%s_%s", a, b));}

bool compiler_ast_scopes_Symbol_is_templated(compiler_ast_scopes_Symbol *this) {
  return (((bool)this) && ((bool)this->template));}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, compiler_ast_scopes_Symbol *parent, char *name, std_span_Span span) {
  char *display = compiler_ast_scopes_Symbol_join_display(parent->display, name);
  char *full_name = compiler_ast_scopes_Symbol_join_full_name(parent->full_name, name);
  return compiler_ast_scopes_Symbol_new(type, ns, name, display, full_name, span);
}

void compiler_ast_scopes_Symbol_update_parent(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_Symbol *parent) {
  this->display=compiler_ast_scopes_Symbol_join_display(parent->display, this->name);
  if (!(this->is_extern)) {
    this->full_name=compiler_ast_scopes_Symbol_join_full_name(parent->full_name, this->name);
  }
}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_from_local_variable(char *name, compiler_ast_nodes_Variable *var, std_span_Span span) {
  compiler_ast_scopes_Symbol *item = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Variable, NULL, name, name, name, span);
  item->u.var=var;
  return item;
}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_remove_alias(compiler_ast_scopes_Symbol *this) {
  return ({compiler_ast_scopes_Symbol *__yv_522;
switch ((this->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_523_0:
        {
          if (this->u.type_def->sym != this) {
            return compiler_ast_scopes_Symbol_remove_alias(this->u.type_def->sym);
          }
          return this;
        } break;
      default:
        {
          __yv_522 = this;
          goto _l___yv_522;
        } break;
    }
_l___yv_522:
  __yv_522;});}

void compiler_ast_scopes_Symbol_add_reference(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_ReferenceType type, std_span_Span span) {
  if (!(((bool)this))) {
    return;
  }
  std_vector_Vector__18_push(this->references, (compiler_ast_scopes_Reference){.type=type, .span=span});
  if (this->type==compiler_ast_scopes_SymbolType_TypeDef && (this->u.type_def->sym != this)) {
    compiler_ast_scopes_Symbol_add_reference(this->u.type_def->sym, type, span);
    return;
  }
  compiler_types_Type *parent_type = ({compiler_types_Type *__yv_524;
switch ((this->type)) {
      case compiler_ast_scopes_SymbolType_Structure:
      m_525_0:
        {
          __yv_524 = this->u.struc->type;
          goto _l___yv_524;
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_525_1:
        {
          __yv_524 = this->u.func->type;
          goto _l___yv_524;
        } break;
      default:
        {
          __yv_524 = NULL;
          goto _l___yv_524;
        } break;
    }
_l___yv_524:
  __yv_524;});
  if (!(((bool)parent_type))) {
    return;
  }
  if (!(((bool)parent_type->template_instance))) {
    return;
  }
  compiler_ast_scopes_Symbol *child_sym = parent_type->template_instance->parent;
  compiler_ast_scopes_Symbol_add_reference(child_sym, type, span);
}

compiler_ast_scopes_Scope *compiler_ast_scopes_Scope_new(compiler_ast_scopes_Scope *parent) {
  compiler_ast_scopes_Scope *scope = std_mem_alloc__8(1);
  scope->items=std_map_Map__5_new(8);
  scope->defers=std_vector_Vector__15_new(16);
  scope->is_for_match=false;
  if (((bool)parent)) {
    scope->loop_count=parent->loop_count;
    scope->can_yield=parent->can_yield;
    scope->cur_func=parent->cur_func;
    scope->parent=parent;
  }
  return scope;
}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_recursive(compiler_ast_scopes_Scope *this, char *name) {
  compiler_ast_scopes_Symbol *item = std_map_Map__5_get(this->items, name, NULL);
  if (((bool)item)) {
    return item;
  }
  if (((bool)this->parent)) {
    return compiler_ast_scopes_Scope_lookup_recursive(this->parent, name);
  }
  return NULL;
}

compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_local(compiler_ast_scopes_Scope *this, char *name) {
  return std_map_Map__5_get(this->items, name, NULL);
}

void compiler_ast_scopes_Scope_insert(compiler_ast_scopes_Scope *this, char *name, compiler_ast_scopes_Symbol *symbol) {
  std_map_Map__5_insert(this->items, name, symbol);
}

compiler_ast_operators_Operator compiler_ast_operators_Operator_from_operator_overload(char *s, std_vector_Vector__4 *params) {
  return ({compiler_ast_operators_Operator __yv_526;
    {
      char *__match_var_527 = s;
      if (str_eq(__match_var_527, "+")) {
        __yv_526 = compiler_ast_operators_Operator_Plus;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "-")) {
        __yv_526 = ({compiler_ast_operators_Operator __yv_528;
          switch (params->size) {
            case 1: {
              __yv_528 = compiler_ast_operators_Operator_Negate;
              goto _l___yv_528;
            } break;
            default: {
              __yv_528 = compiler_ast_operators_Operator_Minus;
              goto _l___yv_528;
            } break;
          }

_l___yv_528:
        __yv_528;});
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "*")) {
        __yv_526 = compiler_ast_operators_Operator_Multiply;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "/")) {
        __yv_526 = compiler_ast_operators_Operator_Divide;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "==")) {
        __yv_526 = compiler_ast_operators_Operator_Equals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "!=")) {
        __yv_526 = compiler_ast_operators_Operator_NotEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "[]")) {
        __yv_526 = compiler_ast_operators_Operator_Index;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "<<")) {
        __yv_526 = compiler_ast_operators_Operator_LeftShift;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, ">>")) {
        __yv_526 = compiler_ast_operators_Operator_RightShift;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "&")) {
        __yv_526 = ({compiler_ast_operators_Operator __yv_529;
          switch (params->size) {
            case 1: {
              __yv_529 = compiler_ast_operators_Operator_Address;
              goto _l___yv_529;
            } break;
            default: {
              __yv_529 = compiler_ast_operators_Operator_BitwiseAnd;
              goto _l___yv_529;
            } break;
          }

_l___yv_529:
        __yv_529;});
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "|")) {
        __yv_526 = compiler_ast_operators_Operator_BitwiseOr;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "+=")) {
        __yv_526 = compiler_ast_operators_Operator_PlusEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "-=")) {
        __yv_526 = compiler_ast_operators_Operator_MinusEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "*=")) {
        __yv_526 = compiler_ast_operators_Operator_MultiplyEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "/=")) {
        __yv_526 = compiler_ast_operators_Operator_DivideEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "[]=")) {
        __yv_526 = compiler_ast_operators_Operator_IndexAssign;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "<<=")) {
        __yv_526 = compiler_ast_operators_Operator_LeftShiftEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, ">>=")) {
        __yv_526 = compiler_ast_operators_Operator_RightShiftEquals;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "%")) {
        __yv_526 = compiler_ast_operators_Operator_Modulus;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "in")) {
        __yv_526 = compiler_ast_operators_Operator_In;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "not")) {
        __yv_526 = compiler_ast_operators_Operator_Not;
        goto _l___yv_526;
      } else if (str_eq(__match_var_527, "?")) {
        __yv_526 = compiler_ast_operators_Operator_IsNotNull;
        goto _l___yv_526;
      } else  {
        __yv_526 = compiler_ast_operators_Operator_Error;
        goto _l___yv_526;
      }
    }

_l___yv_526:
  __yv_526;});}

compiler_ast_operators_Operator compiler_ast_operators_Operator_from_token(compiler_tokens_Token *tok) {
  return ({compiler_ast_operators_Operator __yv_530;
switch ((tok->type)) {
      case compiler_tokens_TokenType_Ampersand:
      m_531_0:
        {
          __yv_530 = compiler_ast_operators_Operator_BitwiseAnd;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_And:
      m_531_1:
        {
          __yv_530 = compiler_ast_operators_Operator_And;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Caret:
      m_531_2:
        {
          __yv_530 = compiler_ast_operators_Operator_BitwiseXor;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_EqualEquals:
      m_531_3:
        {
          __yv_530 = compiler_ast_operators_Operator_Equals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Equals:
      m_531_4:
        {
          __yv_530 = compiler_ast_operators_Operator_Assignment;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_GreaterThan:
      m_531_5:
        {
          __yv_530 = compiler_ast_operators_Operator_GreaterThan;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_GreaterThanEquals:
      m_531_6:
        {
          __yv_530 = compiler_ast_operators_Operator_GreaterThanEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_LessThan:
      m_531_7:
        {
          __yv_530 = compiler_ast_operators_Operator_LessThan;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_LessThanEquals:
      m_531_8:
        {
          __yv_530 = compiler_ast_operators_Operator_LessThanEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Line:
      m_531_9:
        {
          __yv_530 = compiler_ast_operators_Operator_BitwiseOr;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Minus:
      m_531_10:
        {
          __yv_530 = compiler_ast_operators_Operator_Minus;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_MinusEquals:
      m_531_11:
        {
          __yv_530 = compiler_ast_operators_Operator_MinusEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_NotEquals:
      m_531_12:
        {
          __yv_530 = compiler_ast_operators_Operator_NotEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Or:
      m_531_13:
        {
          __yv_530 = compiler_ast_operators_Operator_Or;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Percent:
      m_531_14:
        {
          __yv_530 = compiler_ast_operators_Operator_Modulus;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Plus:
      m_531_15:
        {
          __yv_530 = compiler_ast_operators_Operator_Plus;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_PlusEquals:
      m_531_16:
        {
          __yv_530 = compiler_ast_operators_Operator_PlusEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Slash:
      m_531_17:
        {
          __yv_530 = compiler_ast_operators_Operator_Divide;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_SlashEquals:
      m_531_18:
        {
          __yv_530 = compiler_ast_operators_Operator_DivideEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Star:
      m_531_19:
        {
          __yv_530 = compiler_ast_operators_Operator_Multiply;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_StarEquals:
      m_531_20:
        {
          __yv_530 = compiler_ast_operators_Operator_MultiplyEquals;
          goto _l___yv_530;
        } break;
      case compiler_tokens_TokenType_Identifier:
      m_531_21:
        {
          __yv_530 = ({compiler_ast_operators_Operator __yv_532;
            {
              char *__match_var_533 = tok->text;
              if (str_eq(__match_var_533, "in")) {
                __yv_532 = compiler_ast_operators_Operator_In;
                goto _l___yv_532;
              } else  std_panic(std_format("Unhandled identifier in Operator::from_token: %s", tok->text));
            }

_l___yv_532:
          __yv_532;});
          goto _l___yv_530;
        } break;
      default:
        {
          std_panic(std_format("Unhandled token type in Operator::from_token: %s", compiler_tokens_TokenType_str(tok->type)));
          goto _l___yv_530;
        } break;
    }
_l___yv_530:
  __yv_530;});}

u32 compiler_ast_operators_Operator_num_overload_params(compiler_ast_operators_Operator this) {
  return ({u32 __yv_534;
switch ((this)) {
      case compiler_ast_operators_Operator_Address:
      case compiler_ast_operators_Operator_Dereference:
      case compiler_ast_operators_Operator_Negate:
      case compiler_ast_operators_Operator_Not:
      case compiler_ast_operators_Operator_BitwiseNot:
      case compiler_ast_operators_Operator_IsNotNull:
      case compiler_ast_operators_Operator_PreIncrement:
      case compiler_ast_operators_Operator_PreDecrement:
      case compiler_ast_operators_Operator_PostIncrement:
      case compiler_ast_operators_Operator_PostDecrement:
      case compiler_ast_operators_Operator_ErrorProp:
      case compiler_ast_operators_Operator_ErrorUnwrap:
      m_535_0:
        {
          __yv_534 = 1;
          goto _l___yv_534;
        } break;
      case compiler_ast_operators_Operator_And:
      case compiler_ast_operators_Operator_Assignment:
      case compiler_ast_operators_Operator_BitwiseAnd:
      case compiler_ast_operators_Operator_BitwiseOr:
      case compiler_ast_operators_Operator_LeftShiftEquals:
      case compiler_ast_operators_Operator_Divide:
      case compiler_ast_operators_Operator_RightShiftEquals:
      case compiler_ast_operators_Operator_BitwiseXor:
      case compiler_ast_operators_Operator_DivideEquals:
      case compiler_ast_operators_Operator_Equals:
      case compiler_ast_operators_Operator_GreaterThan:
      case compiler_ast_operators_Operator_GreaterThanEquals:
      case compiler_ast_operators_Operator_Index:
      case compiler_ast_operators_Operator_LeftShift:
      case compiler_ast_operators_Operator_LessThan:
      case compiler_ast_operators_Operator_LessThanEquals:
      case compiler_ast_operators_Operator_Minus:
      case compiler_ast_operators_Operator_MinusEquals:
      case compiler_ast_operators_Operator_Modulus:
      case compiler_ast_operators_Operator_Multiply:
      case compiler_ast_operators_Operator_MultiplyEquals:
      case compiler_ast_operators_Operator_Or:
      case compiler_ast_operators_Operator_Plus:
      case compiler_ast_operators_Operator_NotEquals:
      case compiler_ast_operators_Operator_PlusEquals:
      case compiler_ast_operators_Operator_RightShift:
      case compiler_ast_operators_Operator_In:
      case compiler_ast_operators_Operator_EqualsValueEnumVariant:
      m_535_1:
        {
          __yv_534 = 2;
          goto _l___yv_534;
        } break;
      case compiler_ast_operators_Operator_IndexAssign:
      m_535_2:
        {
          __yv_534 = 3;
          goto _l___yv_534;
        } break;
      case compiler_ast_operators_Operator_Error:
      m_535_3:
        {
          __yv_534 = 0;
          goto _l___yv_534;
        } break;
    }
_l___yv_534:
  __yv_534;});}

bool compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(compiler_ast_operators_Operator this) {
  return ({bool __yv_536;
switch ((this)) {
      case compiler_ast_operators_Operator_MultiplyEquals:
      m_537_0:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_DivideEquals:
      m_537_1:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_PlusEquals:
      m_537_2:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_MinusEquals:
      m_537_3:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_IndexAssign:
      m_537_4:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_LeftShiftEquals:
      m_537_5:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      case compiler_ast_operators_Operator_RightShiftEquals:
      m_537_6:
        {
          __yv_536 = true;
          goto _l___yv_536;
        } break;
      default:
        {
          __yv_536 = false;
          goto _l___yv_536;
        } break;
    }
_l___yv_536:
  __yv_536;});}

u32 compiler_ast_operators_OperatorOverload_hash(compiler_ast_operators_OperatorOverload this) {
  u32 hash = u32_hash(((u32)this.op));
  if (((bool)this.type1)) {
    std_traits_hash_pair_hash(hash, ((u32)this.type1->base));
  }
  if (((bool)this.type2)) {
    std_traits_hash_pair_hash(hash, ((u32)this.type2->base));
  }
  if (((bool)this.type3)) {
    std_traits_hash_pair_hash(hash, ((u32)this.type3->base));
  }
  return hash;
}

bool compiler_ast_operators_OperatorOverload_eq(compiler_ast_operators_OperatorOverload this, compiler_ast_operators_OperatorOverload other) {
  return ((this.op==other.op && compiler_types_Type_eq(this.type1, other.type1, true)) && compiler_types_Type_eq(this.type2, other.type2, true)) && compiler_types_Type_eq(this.type3, other.type3, true);
}

compiler_ast_nodes_Variable *compiler_ast_nodes_Variable_new(compiler_types_Type *type) {
  compiler_ast_nodes_Variable *var = std_mem_alloc__9(1);
  var->type=type;
  var->parsed_type=type;
  return var;
}

compiler_ast_nodes_Structure *compiler_ast_nodes_Structure_new(void) {
  compiler_ast_nodes_Structure *struc = std_mem_alloc__10(1);
  struc->fields=std_vector_Vector__4_new(16);
  return struc;
}

compiler_ast_nodes_Variable *compiler_ast_nodes_Structure_get_field(compiler_ast_nodes_Structure *this, char *name) {
  for (std_vector_Iterator__4 _i109 = std_vector_Vector__4_iter(this->fields); std_vector_Iterator__4_has_value(&_i109); std_vector_Iterator__4_next(&_i109)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i109);
    {
      if (str_eq(field->sym->name, name)) {
        return field;
      }
    }
  }
  return NULL;
}

compiler_ast_nodes_EnumVariant *compiler_ast_nodes_Enum_get_variant(compiler_ast_nodes_Enum *this, char *name) {
  for (std_vector_Iterator__20 _i110 = std_vector_Vector__20_iter(this->variants); std_vector_Iterator__20_has_value(&_i110); std_vector_Iterator__20_next(&_i110)) {
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i110);
    {
      if (str_eq(variant->sym->name, name)) {
        return variant;
      }
    }
  }
  return NULL;
}

compiler_ast_nodes_Variable *compiler_ast_nodes_Enum_get_shared_field(compiler_ast_nodes_Enum *this, char *name) {
  for (std_vector_Iterator__4 _i111 = std_vector_Vector__4_iter(this->shared_fields); std_vector_Iterator__4_has_value(&_i111); std_vector_Iterator__4_next(&_i111)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i111);
    {
      if (str_eq(field->sym->name, name)) {
        return field;
      }
    }
  }
  return NULL;
}

compiler_ast_nodes_Enum *compiler_ast_nodes_Enum_new(std_span_Span span) {
  compiler_ast_nodes_Enum *enom = std_mem_alloc__11(1);
  enom->variants=std_vector_Vector__20_new(16);
  enom->shared_fields=std_vector_Vector__4_new(16);
  enom->span=span;
  return enom;
}

u32 compiler_ast_nodes_EnumVariant_num_fields(compiler_ast_nodes_EnumVariant *this) {
  return (this->parent->shared_fields->size + this->specific_fields->size);}

compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_field_by_idx(compiler_ast_nodes_EnumVariant *this, u32 idx) {
  if (idx < this->parent->shared_fields->size) {
    return std_vector_Vector__4_at(this->parent->shared_fields, idx);
  } else {
    return std_vector_Vector__4_at(this->specific_fields, (idx - this->parent->shared_fields->size));
  }
}

compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_specific_field(compiler_ast_nodes_EnumVariant *this, char *name) {
  for (std_vector_Iterator__4 _i112 = std_vector_Vector__4_iter(this->specific_fields); std_vector_Iterator__4_has_value(&_i112); std_vector_Iterator__4_next(&_i112)) {
    compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i112);
    {
      if (str_eq(field->sym->name, name)) {
        return field;
      }
    }
  }
  return NULL;
}

compiler_ast_nodes_EnumVariant *compiler_ast_nodes_EnumVariant_new(std_span_Span span) {
  compiler_ast_nodes_EnumVariant *variant = std_mem_alloc__12(1);
  variant->specific_fields=std_vector_Vector__4_new(16);
  return variant;
}

compiler_ast_nodes_Function *compiler_ast_nodes_Function_new(void) {
  compiler_ast_nodes_Function *func = std_mem_alloc__13(1);
  func->params=std_vector_Vector__4_new(16);
  return func;
}

bool compiler_ast_nodes_Function_is_template_instance(compiler_ast_nodes_Function *this) {
  if (((bool)this->type) && ((bool)this->type->template_instance)) {
    return true;
  }
  if (((bool)this->parent_type) && ((bool)this->parent_type->template_instance)) {
    return true;
  }
  return false;
}

compiler_ast_nodes_Argument *compiler_ast_nodes_Argument_new(compiler_ast_nodes_AST *expr, compiler_tokens_Token *label_token) {
  compiler_ast_nodes_Argument *arg = std_mem_alloc__14(1);
  arg->expr=expr;
  if (((bool)label_token)) {
    arg->label=label_token->text;
  }
  if (((bool)label_token)) {
    arg->label_span=label_token->span;
  }
  return arg;
}

compiler_ast_nodes_ImportPart *compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType type, std_span_Span span) {
  compiler_ast_nodes_ImportPart *part = std_mem_alloc__15(1);
  part->type=type;
  part->span=span;
  return part;
}

compiler_ast_nodes_MatchCond *compiler_ast_nodes_MatchCond_new(compiler_ast_nodes_AST *cond, std_vector_Vector__19 *args, compiler_ast_nodes_Function *cmp_fn) {
  compiler_ast_nodes_MatchCond *mcond = std_mem_alloc__16(1);
  mcond->expr=cond;
  mcond->args=args;
  mcond->cmp_fn=cmp_fn;
  return mcond;
}

compiler_ast_nodes_AST *compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType type, std_span_Span span) {
  compiler_ast_nodes_AST *ast = std_mem_alloc__17(1);
  ast->type=type;
  ast->span=span;
  return ast;
}

compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator op, std_span_Span span, compiler_ast_nodes_AST *expr) {
  compiler_ast_nodes_AST *ast = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_UnaryOp, span);
  ast->u.unary.op=op;
  ast->u.unary.expr=expr;
  return ast;
}

compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator op, compiler_ast_nodes_AST *lhs, compiler_ast_nodes_AST *rhs, std_span_Span op_span) {
  std_span_Span span = std_span_Span_join(lhs->span, rhs->span);
  compiler_ast_nodes_AST *ast = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BinaryOp, span);
  ast->u.binary.op=op;
  ast->u.binary.lhs=lhs;
  ast->u.binary.rhs=rhs;
  ast->u.binary.op_span=op_span;
  return ast;
}

std_span_Span compiler_ast_nodes_AST_display_span(compiler_ast_nodes_AST *this) {
  return ({std_span_Span __yv_538;
switch ((this->type)) {
      case compiler_ast_nodes_ASTType_Match:
      m_539_0:
        {
          __yv_538 = this->u.match_stmt.match_span;
          goto _l___yv_538;
        } break;
      case compiler_ast_nodes_ASTType_If:
      m_539_1:
        {
          __yv_538 = this->u.if_stmt.if_span;
          goto _l___yv_538;
        } break;
      default:
        {
          __yv_538 = this->span;
          goto _l___yv_538;
        } break;
    }
_l___yv_538:
  __yv_538;});}

compiler_ast_scopes_Symbol *compiler_ast_nodes_AST_symbol(compiler_ast_nodes_AST *this) {
  return this->resolved_symbol;}

bool compiler_ast_nodes_AST_is_lvalue(compiler_ast_nodes_AST *this) {
  return ({bool __yv_540;
switch ((this->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_541_0:
        {
          __yv_540 = !(this->u.ident.is_function);
          goto _l___yv_540;
        } break;
      case compiler_ast_nodes_ASTType_Member:
      m_541_1:
        {
          __yv_540 = true;
          goto _l___yv_540;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_541_2:
        {
          __yv_540 = this->u.unary.op==compiler_ast_operators_Operator_Dereference;
          goto _l___yv_540;
        } break;
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_541_3:
        {
          __yv_540 = this->u.binary.op==compiler_ast_operators_Operator_Index;
          goto _l___yv_540;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_541_4:
        {
          compiler_ast_scopes_Symbol *sym = this->resolved_symbol;
          return ((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Variable;
        } break;
      default:
        {
          __yv_540 = false;
          goto _l___yv_540;
        } break;
    }
_l___yv_540:
  __yv_540;});}

compiler_lexer_Lexer compiler_lexer_Lexer_make_sv(std_sv_SV source, char *filename, std_vector_Vector__16 *errors) {
  std_span_Location start_loc = (std_span_Location){.filename=filename, .line=1, .col=1, .index=0};
  if (!(((bool)errors))) {
    errors=std_vector_Vector__16_new(16);
  }
  return (compiler_lexer_Lexer){.source=source.data, .source_len=source.len, .i=0, .loc=start_loc, .seen_newline=false, .tokens=std_vector_Vector__11_new(16), .errors=errors, .in_comment=false, .comment=std_buffer_Buffer_make(16), .comment_start=start_loc};
}

compiler_lexer_Lexer compiler_lexer_Lexer_make(char *source, char *filename, std_vector_Vector__16 *errors) {
  return compiler_lexer_Lexer_make_sv(std_sv_SV_from_str(source), filename, errors);
}

void compiler_lexer_Lexer_push(compiler_lexer_Lexer *this, compiler_tokens_Token *token) {
  token->seen_newline=this->seen_newline;
  if (this->comment.size > 0) {
    token->comment=std_buffer_Buffer_new_str(this->comment);
    token->comment_loc=this->comment_start;
  }
  std_buffer_Buffer_clear(&this->comment);
  std_vector_Vector__11_push(this->tokens, token);
  this->seen_newline=false;
  this->in_comment=false;
}

void compiler_lexer_Lexer_push_type(compiler_lexer_Lexer *this, compiler_tokens_TokenType type, u32 len) {
  std_span_Location start_loc = this->loc;
  for (u32 i = 0; i < len; i+=1) {
    compiler_lexer_Lexer_inc(this);
  }
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_from_type(type, (std_span_Span){.start=start_loc, .end=this->loc}));
}

char compiler_lexer_Lexer_cur(compiler_lexer_Lexer *this) {
  return this->source[this->i];}

bool compiler_lexer_is_valid_ident_char(char c) {
  return (char_is_alnum(c) || c=='_') || ((((u8)c) >> ((u8)7)) & ((u8)1))==((u8)1);
}

bool compiler_lexer_is_valid_utf8_start(char c, u32 *out_sz) {
  u8 cu8 = ((u8)c);
  u32 sz = ({u32 __yv_542;
    if ((cu8 & ((u8)128))==((u8)0)) {
      __yv_542 = 1;
      goto _l___yv_542;
    } else if ((cu8 & ((u8)224))==((u8)192)) {
      __yv_542 = 2;
      goto _l___yv_542;
    } else if ((cu8 & ((u8)240))==((u8)224)) {
      __yv_542 = 3;
      goto _l___yv_542;
    } else if ((cu8 & ((u8)248))==((u8)240)) {
      __yv_542 = 4;
      goto _l___yv_542;
    } else {
      __yv_542 = 1;
      goto _l___yv_542;
    }

_l___yv_542:
  __yv_542;});
  if (((bool)out_sz)) {
    (*out_sz)=sz;
  }
  return true;
}

void compiler_lexer_Lexer_inc(compiler_lexer_Lexer *this) {
  char c = compiler_lexer_Lexer_cur(this);
  u8 cu8 = ((u8)c);
  if (c=='\n') {
    this->loc.line+=1;
    this->loc.col=1;
    this->seen_newline=true;
    this->loc.index+=1;
    this->i+=1;
  } else {
    u32 ln = 1;
    if(!(compiler_lexer_is_valid_utf8_start(c, &ln))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc:101:20: Assertion failed: `is_valid_utf8_start(c, out_sz: &ln)`", "Invalid UTF-8 character"); }
    this->loc.col+=1;
    this->loc.index+=ln;
    this->i+=ln;
  }
}

char compiler_lexer_Lexer_peek(compiler_lexer_Lexer *this, u32 offset) {
  if ((this->i + offset) >= this->source_len) {
    return '\0';
  }
  return this->source[(this->i + offset)];
}

void compiler_lexer_Lexer_lex_char_literal(compiler_lexer_Lexer *this) {
  std_span_Location start_loc = this->loc;
  u32 start = (this->i + 1);
  compiler_lexer_Lexer_inc(this);
  if (compiler_lexer_Lexer_cur(this)=='\\') {
    compiler_lexer_Lexer_inc(this);
  }
  compiler_lexer_Lexer_inc(this);
  if (compiler_lexer_Lexer_cur(this) != '\'') {
    std_vector_Vector__16_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Expected ' after character literal"));
  }
  u32 len = (this->i - start);
  char *text = str_substring(this->source, start, len);
  compiler_lexer_Lexer_inc(this);
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_CharLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
}

void compiler_lexer_Lexer_lex_string_literal(compiler_lexer_Lexer *this, bool has_seen_f) {
  std_span_Location start_loc = this->loc;
  char end_char = compiler_lexer_Lexer_cur(this);
  bool is_multi_line = false;
  if (compiler_lexer_Lexer_peek(this, 1)==end_char && compiler_lexer_Lexer_peek(this, 2)==end_char) {
    compiler_lexer_Lexer_inc(this);
    compiler_lexer_Lexer_inc(this);
    is_multi_line=true;
  }
  compiler_lexer_Lexer_inc(this);
  u32 start = this->i;
  u32 end = start;
  while (this->i < this->source_len) {
    if (compiler_lexer_Lexer_cur(this)==end_char) {
      if (!(is_multi_line)) {
        end=this->i;
        compiler_lexer_Lexer_inc(this);
        break;
      }
      if (compiler_lexer_Lexer_peek(this, 1)==end_char && compiler_lexer_Lexer_peek(this, 2)==end_char) {
        end=this->i;
        compiler_lexer_Lexer_inc(this);
        compiler_lexer_Lexer_inc(this);
        compiler_lexer_Lexer_inc(this);
        break;
      }
    }
    if (compiler_lexer_Lexer_cur(this)=='\\') {
      compiler_lexer_Lexer_inc(this);
    }
    compiler_lexer_Lexer_inc(this);
  }
  u32 len = (end - start);
  char *text = str_substring(this->source, start, len);
  if (this->i >= this->source_len) {
    std_vector_Vector__16_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Unterminated string literal"));
  }
  std_span_Span span = (std_span_Span){.start=start_loc, .end=this->loc};
  if ((end_char=='`' || has_seen_f)) {
    compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_FormatStringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
  } else {
    compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_StringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
  }}

void compiler_lexer_Lexer_lex_raw_string_literal(compiler_lexer_Lexer *this) {
  std_span_Location start_loc = this->loc;
  char end_char = compiler_lexer_Lexer_cur(this);
  u32 start = (this->i + 1);
  std_buffer_Buffer buffer = std_buffer_Buffer_make(16);
  compiler_lexer_Lexer_inc(this);
  while ((this->i < this->source_len) && (compiler_lexer_Lexer_cur(this) != end_char)) {
    if (compiler_lexer_Lexer_cur(this)=='\\') {
      std_buffer_Buffer_write_char(&buffer, '\\');
    }
    std_buffer_Buffer_write_char(&buffer, compiler_lexer_Lexer_cur(this));
    compiler_lexer_Lexer_inc(this);
  }
  compiler_lexer_Lexer_inc(this);
  if (this->i >= this->source_len) {
    std_vector_Vector__16_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Unterminated string literal"));
  }
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_StringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, std_buffer_Buffer_str(buffer)));
}

compiler_tokens_Token *compiler_lexer_Lexer_lex_int_literal_different_base(compiler_lexer_Lexer *this) {
  std_span_Location start_loc = this->loc;
  u32 start = this->i;
  compiler_lexer_Lexer_inc(this);
  switch (compiler_lexer_Lexer_cur(this)) {
    case 'x': {
      compiler_lexer_Lexer_inc(this);
      while ((this->i < this->source_len) && (char_is_hex_digit(compiler_lexer_Lexer_cur(this)) || compiler_lexer_Lexer_cur(this)=='_')) {
        compiler_lexer_Lexer_inc(this);
      }
    } break;
    case 'b': {
      compiler_lexer_Lexer_inc(this);
      while ((this->i < this->source_len) && ((compiler_lexer_Lexer_cur(this)=='0' || compiler_lexer_Lexer_cur(this)=='1') || compiler_lexer_Lexer_cur(this)=='_')) {
        compiler_lexer_Lexer_inc(this);
      }
    } break;
    case 'o': {
      compiler_lexer_Lexer_inc(this);
      while ((this->i < this->source_len) && (char_is_digit(compiler_lexer_Lexer_cur(this)) || compiler_lexer_Lexer_cur(this)=='_')) {
        compiler_lexer_Lexer_inc(this);
      }
    } break;
    default: {
      if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc:244:24: Assertion failed: `false`", "Invalid base for int literal"); exit(1); }
    } break;
  }
  u32 len = (this->i - start);
  char *text = str_substring(this->source, start, len);
  return compiler_tokens_Token_new(compiler_tokens_TokenType_IntLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text);
}

compiler_tokens_Token *compiler_lexer_Lexer_lex_numeric_literal_helper(compiler_lexer_Lexer *this) {
  std_span_Location start_loc = this->loc;
  if (compiler_lexer_Lexer_cur(this)=='0') {
    switch (compiler_lexer_Lexer_peek(this, 1)) {
      case 'x':      case 'b':      case 'o': {
        return compiler_lexer_Lexer_lex_int_literal_different_base(this);
      } break;
      default: {
      } break;
    }
  }
  u32 start = this->i;
  compiler_tokens_TokenType token_type;
  while (char_is_digit(compiler_lexer_Lexer_cur(this)) || compiler_lexer_Lexer_cur(this)=='_') {
    compiler_lexer_Lexer_inc(this);
  }
  if (compiler_lexer_Lexer_cur(this)=='.') {
    compiler_lexer_Lexer_inc(this);
    while (char_is_digit(compiler_lexer_Lexer_cur(this)) || compiler_lexer_Lexer_cur(this)=='_') {
      compiler_lexer_Lexer_inc(this);
    }
    token_type=compiler_tokens_TokenType_FloatLiteral;
  } else {
    token_type=compiler_tokens_TokenType_IntLiteral;
  }
  u32 len = (this->i - start);
  char *text = str_substring(this->source, start, len);
  return compiler_tokens_Token_new(token_type, (std_span_Span){.start=start_loc, .end=this->loc}, text);
}

void compiler_lexer_Lexer_lex_numeric_literal(compiler_lexer_Lexer *this) {
  compiler_tokens_Token *token = compiler_lexer_Lexer_lex_numeric_literal_helper(this);
  if ((compiler_lexer_Lexer_cur(this)=='u' || compiler_lexer_Lexer_cur(this)=='i') || compiler_lexer_Lexer_cur(this)=='f') {
    char initial_char = compiler_lexer_Lexer_cur(this);
    std_span_Location start_loc = this->loc;
    u32 start = this->i;
    compiler_lexer_Lexer_inc(this);
    while ((this->i < this->source_len) && char_is_digit(compiler_lexer_Lexer_cur(this))) {
      compiler_lexer_Lexer_inc(this);
    }
    u32 len = (this->i - start);
    char *suffix = ({char *__yv_543;
      if (len > 1) {
        __yv_543 = str_substring(this->source, start, len);
        goto _l___yv_543;
      } else if (initial_char=='i') {
        __yv_543 = "i32";
        goto _l___yv_543;
      } else if (initial_char=='u') {
        __yv_543 = "u32";
        goto _l___yv_543;
      } else {
        std_vector_Vector__16_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=start_loc, .end=this->loc}, "Invalid numeric literal suffix"));
        __yv_543 = str_substring(this->source, start, len);
        goto _l___yv_543;
      }

_l___yv_543:
    __yv_543;});
    token->suffix=compiler_tokens_Token_from_ident(suffix, (std_span_Span){.start=start_loc, .end=this->loc});
  }
  compiler_lexer_Lexer_push(this, token);
}

void compiler_lexer_Lexer_lex_comment(compiler_lexer_Lexer *this) {
  while (compiler_lexer_Lexer_cur(this)=='/') {
    compiler_lexer_Lexer_inc(this);
  }
  bool save_comment = false;
  if ((compiler_lexer_Lexer_cur(this)=='*' || compiler_lexer_Lexer_cur(this)=='.') || compiler_lexer_Lexer_cur(this)=='!') {
    compiler_lexer_Lexer_inc(this);
    save_comment=true;
    if (this->comment.size==0) {
      this->comment_start=this->loc;
    }
  }
  if (compiler_lexer_Lexer_cur(this)==' ' || compiler_lexer_Lexer_cur(this)=='\t') {
    compiler_lexer_Lexer_inc(this);
  }
  while ((this->i < this->source_len) && (compiler_lexer_Lexer_cur(this) != '\n')) {
    if (save_comment) {
      std_buffer_Buffer_write_char(&this->comment, compiler_lexer_Lexer_cur(this));
    }
    compiler_lexer_Lexer_inc(this);
  }
  if (save_comment) {
    std_buffer_Buffer_write_char(&this->comment, '\n');
  }
}

std_vector_Vector__11 *compiler_lexer_Lexer_lex(compiler_lexer_Lexer *this) {
  while (this->i < this->source_len) {
    char c = compiler_lexer_Lexer_cur(this);
    switch (c) {
      case ' ':      case '\t':      case '\v':      case '\r':      case '\b':      case '\n': {
        compiler_lexer_Lexer_inc(this);
      } break;
      case ';': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Semicolon, 1);
      } break;
      case ',': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Comma, 1);
      } break;
      case '(': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenParen, 1);
      } break;
      case ')': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseParen, 1);
      } break;
      case '[': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenSquare, 1);
      } break;
      case ']': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseSquare, 1);
      } break;
      case '{': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenCurly, 1);
      } break;
      case '}': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseCurly, 1);
      } break;
      case '@': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_AtSign, 1);
      } break;
      case '%': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Percent, 1);
      } break;
      case '^': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Caret, 1);
      } break;
      case '&': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Ampersand, 1);
      } break;
      case '|': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Line, 1);
      } break;
      case '~': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Tilde, 1);
      } break;
      case '$': {
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Dollar, 1);
      } break;
      case '.': {
        if ((compiler_lexer_Lexer_peek(this, 1)=='.' && compiler_lexer_Lexer_peek(this, 2)=='.')) {
          compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Ellipsis, 3);
        } else {
          compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Dot, 1);
        }      } break;
      case '?': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '.': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_QuestionDot, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Question, 1);
          } break;
        }
      } break;
      case '!': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_NotEquals, 2);
          } break;
          case '!': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_ExclamationExclamation, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Exclamation, 1);
          } break;
        }
      } break;
      case ':': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case ':': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_ColonColon, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Colon, 1);
          } break;
        }
      } break;
      case '=': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_EqualEquals, 2);
          } break;
          case '>': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_FatArrow, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Equals, 1);
          } break;
        }
      } break;
      case '*': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_StarEquals, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Star, 1);
          } break;
        }
      } break;
      case '+': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_PlusEquals, 2);
          } break;
          case '+': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_PlusPlus, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Plus, 1);
          } break;
        }
      } break;
      case '-': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_MinusEquals, 2);
          } break;
          case '-': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_MinusMinus, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Minus, 1);
          } break;
        }
      } break;
      case '<': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_LessThanEquals, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_LessThan, 1);
          } break;
        }
      } break;
      case '>': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_GreaterThanEquals, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_GreaterThan, 1);
          } break;
        }
      } break;
      case '/': {
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '/': {
            compiler_lexer_Lexer_lex_comment(this);
          } break;
          case '=': {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_SlashEquals, 2);
          } break;
          default: {
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Slash, 1);
          } break;
        }
      } break;
      case '\'': {
        compiler_lexer_Lexer_lex_char_literal(this);
      } break;
      case '"':      case '`': {
        compiler_lexer_Lexer_lex_string_literal(this, false);
      } break;
      default: {
        std_span_Location start_loc = this->loc;
        if (c=='f' && compiler_lexer_Lexer_peek(this, 1)=='"') {
          compiler_lexer_Lexer_inc(this);
          compiler_lexer_Lexer_lex_string_literal(this, true);
        } else if (c=='r' && compiler_lexer_Lexer_peek(this, 1)=='"') {
          compiler_lexer_Lexer_inc(this);
          compiler_lexer_Lexer_lex_raw_string_literal(this);
        } else if (char_is_digit(c)) {
          compiler_lexer_Lexer_lex_numeric_literal(this);
        } else if (compiler_lexer_is_valid_ident_char(c) && !(char_is_digit(c))) {
          u32 start = this->i;
          while (compiler_lexer_is_valid_ident_char(compiler_lexer_Lexer_cur(this))) {
            compiler_lexer_Lexer_inc(this);
          }
          u32 len = (this->i - start);
          char *text = str_substring(this->source, start, len);
          compiler_lexer_Lexer_push(this, compiler_tokens_Token_from_ident(text, (std_span_Span){.start=start_loc, .end=this->loc}));
        } else {
          printf("\n");
          std_span_Location start = this->loc;
          compiler_lexer_Lexer_inc(this);
          std_vector_Vector__16_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=start, .end=this->loc}, std_format("Unrecognized char in lexer: '%c'", c)));
        }
      } break;
    }
  }
  this->seen_newline=true;
  compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_EOF, 0);
  return this->tokens;
}

compiler_attributes_AttributeType compiler_attributes_AttributeType_from_str(char *s) {
  return ({compiler_attributes_AttributeType __yv_544;
    {
      char *__match_var_545 = s;
      if (str_eq(__match_var_545, "extern")) {
        __yv_544 = compiler_attributes_AttributeType_Extern;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "exits")) {
        __yv_544 = compiler_attributes_AttributeType_Exits;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "variadic_format")) {
        __yv_544 = compiler_attributes_AttributeType_VariadicFormat;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "export")) {
        __yv_544 = compiler_attributes_AttributeType_Export;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "formatting")) {
        __yv_544 = compiler_attributes_AttributeType_Formatting;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "operator")) {
        __yv_544 = compiler_attributes_AttributeType_Operator;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "atomic")) {
        __yv_544 = compiler_attributes_AttributeType_Atomic;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "alive")) {
        __yv_544 = compiler_attributes_AttributeType_Alive;
        goto _l___yv_544;
      } else if (str_eq(__match_var_545, "test")) {
        __yv_544 = compiler_attributes_AttributeType_Test;
        goto _l___yv_544;
      } else  {
        __yv_544 = compiler_attributes_AttributeType_Invalid;
        goto _l___yv_544;
      }
    }

_l___yv_544:
  __yv_544;});}

compiler_attributes_Attribute *compiler_attributes_Attribute_new(compiler_attributes_AttributeType type, std_span_Span span) {
  compiler_attributes_Attribute *attr = std_mem_alloc__18(1);
  attr->type=type;
  attr->args=std_vector_Vector__1_new(2);
  attr->span=span;
  return attr;
}

bool compiler_attributes_Attribute_validate(compiler_attributes_Attribute *this, compiler_parser_Parser *parser_for_errors) {
switch ((this->type)) {
    case compiler_attributes_AttributeType_Extern:
    m_546_0:
      {
        if (this->args->size > 1) {
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Extern attribute takes at most one argument"));
          return false;
        }
      } break;
    case compiler_attributes_AttributeType_Formatting:
    m_546_1:
      {
        if ((this->args->size < 1) || (this->args->size > 2)) {
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new_note(this->span, "Incorrect number of arguments for formatting attribute", "Only one or two arguments are allowed"));
          return false;
        }
        if (this->args->size==2) {
          bool found_dollar = false;
          for (std_CharIterator _i235 = str_chars(std_vector_Vector__1_at(this->args, 1), 0); std_CharIterator_has_value(&_i235); std_CharIterator_next(&_i235)) {
            char c = std_CharIterator_cur(&_i235);
            {
              if (c=='$') {
                found_dollar=true;
              }
            }
          }
          if (!(found_dollar)) {
            compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Second argument of formatting attribute must contain '$'"));
            return false;
          }
        } else {
          std_vector_Vector__1_push(this->args, "$");
        }
      } break;
    case compiler_attributes_AttributeType_Exits:
    case compiler_attributes_AttributeType_VariadicFormat:
    case compiler_attributes_AttributeType_Export:
    case compiler_attributes_AttributeType_Atomic:
    case compiler_attributes_AttributeType_Alive:
    case compiler_attributes_AttributeType_Test:
    m_546_2:
      {
        if (this->args->size > 0) {
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, std_format("%s attribute takes no arguments", compiler_attributes_AttributeType_dbg(this->type))));
          return false;
        }
      } break;
    case compiler_attributes_AttributeType_Invalid:
    m_546_3:
      {
        compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Invalid attribute"));
        return false;
      } break;
    case compiler_attributes_AttributeType_Operator:
    m_546_4:
      {
        if (this->args->size != 1) {
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Operator attribute takes exactly one argument"));
          return false;
        }
      } break;
  }  return true;
}

char *compiler_lsp_server_read_message(void) {
  char header[1024] = {0};
  u32 content_length = 0;
  while (((bool)fgets(header, 1024, stdin))) {
    std_sv_SV sv = std_sv_SV_from_str(header);
    if (std_sv_SV_starts_with_str(sv, "Content-Length: ")) {
      std_sv_SV_chop_by_delim(&sv, ' ');
      content_length=std_sv_SV_chop_u32(&sv);
    }
    if (header[0]=='\n' || header[0]=='\r') {
      break;
    }
  }
  if (content_length==0) {
    return NULL;
  }
  char *msg = std_mem_alloc__19((content_length + 1));
  std_fs_File_read(stdin, msg, content_length);
  msg[content_length]='\0';
  return msg;
}

void compiler_lsp_server_send_message(std_value_Value *content) {
  std_buffer_Buffer content_str = std_json_serialize(content);
  char *header = std_format("Content-Length: %u\r\n\r\n", content_str.size);
  std_fs_File_write(stdout, header, strlen(header));
  std_fs_File_write(stdout, std_buffer_Buffer_str(content_str), content_str.size);
}

void compiler_lsp_server_send_response(std_value_Value *req, std_value_Value *result) {
  std_value_Value *response = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc547 = std_compact_map_Map__1_new(2);
    std_compact_map_Map__1_insert(_mc547, "jsonrpc", std_value_Value_new_str("2.0"));
    std_compact_map_Map__1_insert(_mc547, "id", std_value_Value_at_key(req, "id"));
    _mc547;}));
  if (((bool)result)) {
    std_value_Value_insert(response, "result", result);
  } else {
    std_value_Value_insert(response, "result", std_value_Value_new(std_value_ValueType_Null));
  }
  compiler_lsp_server_send_message(response);
}

void compiler_lsp_server_lsp_log(char *msg) {
  compiler_lsp_server_send_message(std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc548 = std_compact_map_Map__1_new(3);
    std_compact_map_Map__1_insert(_mc548, "jsonrpc", std_value_Value_new_str("2.0"));
    std_compact_map_Map__1_insert(_mc548, "method", std_value_Value_new_str("window/logMessage"));
    std_compact_map_Map__1_insert(_mc548, "params", std_value_Value_new_dict(({
      std_compact_map_Map__1 *_mc549 = std_compact_map_Map__1_new(2);
      std_compact_map_Map__1_insert(_mc549, "type", std_value_Value_new_int(((i64)4)));
      std_compact_map_Map__1_insert(_mc549, "message", std_value_Value_new_str(msg));
      _mc549;})));
    _mc548;})));
}

compiler_lsp_server_Loc compiler_lsp_server_get_location(std_value_Value *req) {
  std_value_Value *params = std_value_Value_at_key(req, "params");
  if(!(std_value_Value_is((*params), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:87:12: Assertion failed: `params.is(Dictionary)`", NULL); }
  i32 row = 0;
  i32 col = 0;
  if (std_value_Value_contains(params, "position")) {
    std_value_Value *location = std_value_Value_at_key(params, "position");
    if(!(std_value_Value_is((*location), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:93:16: Assertion failed: `location.is(Dictionary)`", NULL); }
    row=((i32)std_value_Value_as_int(std_value_Value_at_key(location, "line")));
    col=((i32)std_value_Value_as_int(std_value_Value_at_key(location, "character")));
  }
  std_sv_SV uri = std_buffer_Buffer_sv(std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at_key(params, "textDocument"), "uri")));
  std_sv_SV path = uri;
  std_sv_SV_chop_by_str(&path, "file://");
  return (compiler_lsp_server_Loc){.row=row, .col=col, .uri=uri, .path=path};
}

std_process_Output compiler_lsp_server_LSPServer_run_lsp_backend_raw(compiler_lsp_server_LSPServer *this, compiler_lsp_server_Loc loc, char *lsp_cmd, bool include_pos) {
  std_sv_SV uri = loc.uri;
  std_sv_SV path = loc.path;
  std_vector_Vector__1 *args = ({
    std_vector_Vector__1 *_vc550 = std_vector_Vector__1_new(2);
    std_vector_Vector__1_push(_vc550, "lsp");
    std_vector_Vector__1_push(_vc550, lsp_cmd);
    _vc550;});
  if (include_pos) {
    std_vector_Vector__1_push(args, std_format("%d", (loc.row + 1)));
    std_vector_Vector__1_push(args, std_format("%d", (loc.col + 1)));
  }
  _ClosureTy_32 callback = ((_ClosureTy_32){0});
  if (std_compact_map_Map__0_contains(this->documents, uri)) {
    char *contents = std_buffer_Buffer_str(std_compact_map_Map__0_at(this->documents, uri).text);
    std_vector_Vector__1_push(args, "--show-path");
    std_vector_Vector__1_push(args, std_format("%.*s", (path).len, (path).data));
    callback=({compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx *_C551 = alloca(sizeof(compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx));_C551->args = &args;_C551->contents = &contents;_ClosureTy_32 _ci552 = {._C=_C551, .fn=&compiler_lsp_server_run_lsp_backend_raw__Closure_5};_ci552;});
  } else {
    std_vector_Vector__1_push(args, std_format("%.*s", (path).len, (path).data));
    callback=({compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx *_C553 = alloca(sizeof(compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx));_C553->args = &args;_ClosureTy_32 _ci554 = {._C=_C553, .fn=&compiler_lsp_server_run_lsp_backend_raw__Closure_6};_ci554;});
  }
  std_process_Output proc_out = std_process_get_output(NULL, callback, true, "/bin/bash");
  if (proc_out.error) {
    compiler_lsp_server_lsp_log(std_format("Failed to run LSP CLI: %d", proc_out.error_code));
    if (proc_out.output.size > 0) {
      compiler_lsp_server_lsp_log(std_format("Output: %.*s", (proc_out.output).size, (proc_out.output).data));
    }
  }
  return proc_out;
}

std_value_Value *compiler_lsp_server_LSPServer_run_lsp_backend(compiler_lsp_server_LSPServer *this, compiler_lsp_server_Loc loc, char *lsp_cmd, bool include_pos) {
  std_process_Output out = compiler_lsp_server_LSPServer_run_lsp_backend_raw(this, loc, lsp_cmd, include_pos);
  if (out.error || out.output.size==0) {
    return NULL;
  }
  return std_json_parse_sv(std_buffer_Buffer_sv(out.output), "<anonymous>");
}

std_value_Value *compiler_lsp_server_get_range(std_value_Value *val) {
  i64 start_line = (std_value_Value_as_int(std_value_Value_at_key(val, "start_line")) - ((i64)1));
  i64 start_col = (std_value_Value_as_int(std_value_Value_at_key(val, "start_col")) - ((i64)1));
  i64 end_line = (std_value_Value_as_int(std_value_Value_at_key(val, "end_line")) - ((i64)1));
  i64 end_col = (std_value_Value_as_int(std_value_Value_at_key(val, "end_col")) - ((i64)1));
  std_value_Value *range = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc555 = std_compact_map_Map__1_new(2);
    std_compact_map_Map__1_insert(_mc555, "start", std_value_Value_new_dict(({
      std_compact_map_Map__1 *_mc556 = std_compact_map_Map__1_new(2);
      std_compact_map_Map__1_insert(_mc556, "line", std_value_Value_new_int(start_line));
      std_compact_map_Map__1_insert(_mc556, "character", std_value_Value_new_int(start_col));
      _mc556;})));
    std_compact_map_Map__1_insert(_mc555, "end", std_value_Value_new_dict(({
      std_compact_map_Map__1 *_mc557 = std_compact_map_Map__1_new(2);
      std_compact_map_Map__1_insert(_mc557, "line", std_value_Value_new_int(end_line));
      std_compact_map_Map__1_insert(_mc557, "character", std_value_Value_new_int(end_col));
      _mc557;})));
    _mc555;}));
  return range;
}

std_value_Value *compiler_lsp_server_get_uri(std_value_Value *orig_uri, std_value_Value *val) {
  if (!(std_value_Value_contains(val, "file"))) {
    return orig_uri;
  }
  std_buffer_Buffer file = std_value_Value_as_str(std_value_Value_at_key(val, "file"));
  return std_value_Value_new_str(std_format("file://%.*s", (file).size, (file).data));
}

void compiler_lsp_server_unescape_buf(std_buffer_Buffer *buf) {
  u32 i = 0;
  u32 j = 0;
  char *s = std_buffer_Buffer_str((*buf));
  while (i < buf->size) {
    if (s[i]=='\\') {
      i++;
      switch (s[i]) {
        case 'n': {
          s[j++]='\n';
        } break;
        case 'r': {
          s[j++]='\r';
        } break;
        case 't': {
          s[j++]='\t';
        } break;
        case 'b': {
          s[j++]='\b';
        } break;
        case 'f': {
          s[j++]='\f';
        } break;
        case '\\': {
          s[j++]='\\';
        } break;
        case '"': {
          s[j++]='"';
        } break;
        default: {
          s[j++]=s[i];
        } break;
      }
      i++;
    } else {
      s[j++]=s[i++];
    }
  }
  buf->size=j;
  s[j]='\0';
}

void compiler_lsp_server_LSPServer_handle_initialize(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  std_value_Value *params = std_value_Value_at_key(req, "params");
  if(!(std_value_Value_is((*params), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:232:12: Assertion failed: `params.is(Dictionary)`", NULL); }
  std_value_Value *result = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc558 = std_compact_map_Map__1_new(1);
    std_compact_map_Map__1_insert(_mc558, "capabilities", std_value_Value_new_dict(({
      std_compact_map_Map__1 *_mc559 = std_compact_map_Map__1_new(9);
      std_compact_map_Map__1_insert(_mc559, "textDocumentSync", std_value_Value_new_int(((i64)1)));
      std_compact_map_Map__1_insert(_mc559, "completionProvider", std_value_Value_new_dict(({
        std_compact_map_Map__1 *_mc560 = std_compact_map_Map__1_new(2);
        std_compact_map_Map__1_insert(_mc560, "resolveProvider", std_value_Value_new_bool(false));
        std_compact_map_Map__1_insert(_mc560, "triggerCharacters", std_value_Value_new_list(({
          std_vector_Vector__28 *_vc561 = std_vector_Vector__28_new(4);
          std_vector_Vector__28_push(_vc561, std_value_Value_new_str("."));
          std_vector_Vector__28_push(_vc561, std_value_Value_new_str(":"));
          std_vector_Vector__28_push(_vc561, std_value_Value_new_str("@"));
          std_vector_Vector__28_push(_vc561, std_value_Value_new_str(" "));
          _vc561;})));
        _mc560;})));
      std_compact_map_Map__1_insert(_mc559, "referencesProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "definitionProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "typeDefinitionProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "documentSymbolProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "hoverProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "renameProvider", std_value_Value_new_bool(true));
      std_compact_map_Map__1_insert(_mc559, "signatureHelpProvider", std_value_Value_new_dict(({
        std_compact_map_Map__1 *_mc562 = std_compact_map_Map__1_new(1);
        std_compact_map_Map__1_insert(_mc562, "triggerCharacters", std_value_Value_new_list(({
          std_vector_Vector__28 *_vc563 = std_vector_Vector__28_new(2);
          std_vector_Vector__28_push(_vc563, std_value_Value_new_str("("));
          std_vector_Vector__28_push(_vc563, std_value_Value_new_str(","));
          _vc563;})));
        _mc562;})));
      _mc559;})));
    _mc558;}));
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_validate_document(compiler_lsp_server_LSPServer *this) {
  if (!(((bool)this->to_validate_req))) {
    return;
  }
  std_value_Value *req = this->to_validate_req;
  f64 cur_time = std_time_get_time_monotonic_ms();
  if ((cur_time - this->last_validated) < this->validate_throttle_ms) {
    return;
  }
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_process_Output out = compiler_lsp_server_LSPServer_run_lsp_backend_raw(this, loc, "--validate", false);
  if (out.error) {
    return;
  }
  std_value_Value *diagnostics = std_value_Value_new(std_value_ValueType_List);
  for (std_sv_SVLineIterator _i266 = std_sv_SV_lines(std_buffer_Buffer_sv(out.output)); std_sv_SVLineIterator_has_value(&_i266); std_sv_SVLineIterator_next(&_i266)) {
    std_sv_SV line = std_sv_SVLineIterator_cur(&_i266);
    {
      std_value_Value *out = std_json_parse_sv(line, "<anonymous>");
      i64 severity = 1;
      std_value_Value *res = std_value_Value_new_dict(({
        std_compact_map_Map__1 *_mc564 = std_compact_map_Map__1_new(3);
        std_compact_map_Map__1_insert(_mc564, "message", std_value_Value_at_key(out, "message"));
        std_compact_map_Map__1_insert(_mc564, "range", compiler_lsp_server_get_range(std_value_Value_at_key(out, "span")));
        std_compact_map_Map__1_insert(_mc564, "severity", std_value_Value_new_int(((i64)severity)));
        _mc564;}));
      if (std_value_Value_contains(out, "extra_info")) {
        std_value_Value *extra_info = std_value_Value_at_key(out, "extra_info");
        std_value_Value *orig_uri = std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri");
        std_value_Value_insert(res, "relatedInformation", std_value_Value_new_dict(({
          std_compact_map_Map__1 *_mc565 = std_compact_map_Map__1_new(2);
          std_compact_map_Map__1_insert(_mc565, "location", std_value_Value_new_dict(({
            std_compact_map_Map__1 *_mc566 = std_compact_map_Map__1_new(2);
            std_compact_map_Map__1_insert(_mc566, "uri", compiler_lsp_server_get_uri(orig_uri, extra_info));
            std_compact_map_Map__1_insert(_mc566, "range", compiler_lsp_server_get_range(std_value_Value_at_key(extra_info, "span")));
            _mc566;})));
          std_compact_map_Map__1_insert(_mc565, "message", std_value_Value_at_key(std_value_Value_at_key(out, "extra_info"), "message"));
          _mc565;})));
      }
      std_value_Value_push(diagnostics, res);
    }
  }
  std_value_Value *message = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc567 = std_compact_map_Map__1_new(3);
    std_compact_map_Map__1_insert(_mc567, "jsonrpc", std_value_Value_new_str("2.0"));
    std_compact_map_Map__1_insert(_mc567, "method", std_value_Value_new_str("textDocument/publishDiagnostics"));
    std_compact_map_Map__1_insert(_mc567, "params", std_value_Value_new_dict(({
      std_compact_map_Map__1 *_mc568 = std_compact_map_Map__1_new(2);
      std_compact_map_Map__1_insert(_mc568, "uri", std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri"));
      std_compact_map_Map__1_insert(_mc568, "diagnostics", diagnostics);
      _mc568;})));
    _mc567;}));
  compiler_lsp_server_send_message(message);
  this->to_validate_req=NULL;
  this->last_validated=std_time_get_time_monotonic_ms();
}

void compiler_lsp_server_LSPServer_handle_hover(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling hover request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-h", true);
  if (!(((bool)cli_out))) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  std_value_Value *result = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc569 = std_compact_map_Map__1_new(1);
    std_compact_map_Map__1_insert(_mc569, "contents", std_value_Value_new_list(({
      std_vector_Vector__28 *_vc570 = std_vector_Vector__28_new(1);
      std_vector_Vector__28_push(_vc570, std_value_Value_new_dict(({
        std_compact_map_Map__1 *_mc571 = std_compact_map_Map__1_new(2);
        std_compact_map_Map__1_insert(_mc571, "language", std_value_Value_new_str("ocen"));
        std_compact_map_Map__1_insert(_mc571, "value", std_value_Value_at_key(cli_out, "hover"));
        _mc571;})));
      _vc570;})));
    _mc569;}));
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_definition(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling definition request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-d", true);
  if (!(((bool)cli_out))) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  std_value_Value *result = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc572 = std_compact_map_Map__1_new(2);
    std_compact_map_Map__1_insert(_mc572, "uri", compiler_lsp_server_get_uri(std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri"), cli_out));
    std_compact_map_Map__1_insert(_mc572, "range", compiler_lsp_server_get_range(cli_out));
    _mc572;}));
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_type_definition(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling type_definition request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-t", true);
  if (!(((bool)cli_out))) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  std_value_Value *result = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc573 = std_compact_map_Map__1_new(2);
    std_compact_map_Map__1_insert(_mc573, "uri", compiler_lsp_server_get_uri(std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri"), cli_out));
    std_compact_map_Map__1_insert(_mc573, "range", compiler_lsp_server_get_range(cli_out));
    _mc573;}));
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_references(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling references request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-r", true);
  std_value_Value *result = std_value_Value_new(std_value_ValueType_List);
  if (((bool)cli_out)) {
    for (std_vector_Iterator__28 _i267 = std_vector_Vector__28_iter(std_value_Value_as_list(cli_out)); std_vector_Iterator__28_has_value(&_i267); std_vector_Iterator__28_next(&_i267)) {
      std_value_Value *ref = std_vector_Iterator__28_cur(&_i267);
      {
        std_value_Value_push(result, std_value_Value_new_dict(({
          std_compact_map_Map__1 *_mc574 = std_compact_map_Map__1_new(2);
          std_compact_map_Map__1_insert(_mc574, "uri", compiler_lsp_server_get_uri(std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri"), ref));
          std_compact_map_Map__1_insert(_mc574, "range", compiler_lsp_server_get_range(ref));
          _mc574;})));
      }
    }
  }
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_rename(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling rename request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "--renames", true);
  if (!(((bool)cli_out))) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  std_value_Value *changes = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value *newText = std_value_Value_at_key(std_value_Value_at_key(req, "params"), "newName");
  for (std_vector_Iterator__28 _i268 = std_vector_Vector__28_iter(std_value_Value_as_list(cli_out)); std_vector_Iterator__28_has_value(&_i268); std_vector_Iterator__28_next(&_i268)) {
    std_value_Value *obj = std_vector_Iterator__28_cur(&_i268);
    {
      std_value_Value *uri = compiler_lsp_server_get_uri(std_value_Value_at_key(std_value_Value_at_key(std_value_Value_at_key(req, "params"), "textDocument"), "uri"), obj);
      char *uri_str = std_buffer_Buffer_str(std_value_Value_as_str(uri));
      if (!(std_value_Value_contains(changes, uri_str))) {
        std_value_Value_insert(changes, uri_str, std_value_Value_new(std_value_ValueType_List));
      }
      std_value_Value_push(std_value_Value_at_key(changes, uri_str), std_value_Value_new_dict(({
        std_compact_map_Map__1 *_mc575 = std_compact_map_Map__1_new(2);
        std_compact_map_Map__1_insert(_mc575, "range", compiler_lsp_server_get_range(obj));
        std_compact_map_Map__1_insert(_mc575, "newText", newText);
        _mc575;})));
    }
  }
  std_value_Value *result = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc576 = std_compact_map_Map__1_new(1);
    std_compact_map_Map__1_insert(_mc576, "changes", changes);
    _mc576;}));
  compiler_lsp_server_send_response(req, result);
}

void compiler_lsp_server_LSPServer_handle_signature_help(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling signature_help request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-s", true);
  if (!(((bool)cli_out)) || std_compact_map_Map__1_size(std_value_Value_as_dict(cli_out))==0) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  compiler_lsp_server_send_response(req, cli_out);
}

std_value_Value *compiler_lsp_server_LSPServer_symbol_def_obj(compiler_lsp_server_LSPServer *this, std_value_Value *obj) {
  i32 kind = ({i32 __yv_577;
    {
      std_value_Value *__match_var_578 = std_value_Value_at_key(obj, "kind");
      if (std_value_Value_eq_str(__match_var_578, "namespace")) {
        __yv_577 = 3;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "function")) {
        __yv_577 = 12;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "method")) {
        __yv_577 = 6;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "struct")) {
        __yv_577 = 23;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "class")) {
        __yv_577 = 5;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "enum")) {
        __yv_577 = 10;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "variable")) {
        __yv_577 = 13;
        goto _l___yv_577;
      } else if (std_value_Value_eq_str(__match_var_578, "enum-member")) {
        __yv_577 = 22;
        goto _l___yv_577;
      } else  {
        __yv_577 = 13;
        goto _l___yv_577;
      }
    }

_l___yv_577:
  __yv_577;});
  std_value_Value *children = std_value_Value_new(std_value_ValueType_List);
  if (std_value_Value_contains(obj, "children")) {
    for (std_vector_Iterator__28 _i269 = std_vector_Vector__28_iter(std_value_Value_as_list(std_value_Value_at_key(obj, "children"))); std_vector_Iterator__28_has_value(&_i269); std_vector_Iterator__28_next(&_i269)) {
      std_value_Value *child = std_vector_Iterator__28_cur(&_i269);
      {
        std_value_Value_push(children, compiler_lsp_server_LSPServer_symbol_def_obj(this, child));
      }
    }
  }
  return std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc579 = std_compact_map_Map__1_new(6);
    std_compact_map_Map__1_insert(_mc579, "name", std_value_Value_at_key(obj, "name"));
    std_compact_map_Map__1_insert(_mc579, "detail", std_value_Value_at_key(obj, "detail"));
    std_compact_map_Map__1_insert(_mc579, "kind", std_value_Value_new_int(((i64)kind)));
    std_compact_map_Map__1_insert(_mc579, "range", compiler_lsp_server_get_range(std_value_Value_at_key(obj, "range")));
    std_compact_map_Map__1_insert(_mc579, "selectionRange", compiler_lsp_server_get_range(std_value_Value_at_key(obj, "selection_range")));
    std_compact_map_Map__1_insert(_mc579, "children", children);
    _mc579;}));
}

void compiler_lsp_server_LSPServer_handle_on_document_symbols(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling document_symbols request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "--doc-symbols", false);
  if (!(((bool)cli_out))) {
    compiler_lsp_server_send_response(req, NULL);
    return;
  }
  std_value_Value *results = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__28 _i270 = std_vector_Vector__28_iter(std_value_Value_as_list(cli_out)); std_vector_Iterator__28_has_value(&_i270); std_vector_Iterator__28_next(&_i270)) {
    std_value_Value *obj = std_vector_Iterator__28_cur(&_i270);
    {
      std_value_Value_push(results, compiler_lsp_server_LSPServer_symbol_def_obj(this, obj));
    }
  }
  compiler_lsp_server_send_response(req, results);
}

void compiler_lsp_server_LSPServer_handle_did_open(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling textDocument/didOpen request\n");
  std_value_Value *params = std_value_Value_at_key(req, "params");
  std_buffer_Buffer uri = std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at_key(params, "textDocument"), "uri"));
  compiler_lsp_server_lsp_log(std_format("[SERVER] Opening document: %.*s\n", (uri).size, (uri).data));
  if(!(std_value_Value_is((*params), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:538:12: Assertion failed: `params.is(Dictionary)`", NULL); }
  std_buffer_Buffer text = std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at_key(params, "textDocument"), "text"));
  compiler_lsp_server_TextDocument document = (compiler_lsp_server_TextDocument){.text=text};
  compiler_lsp_server_unescape_buf(&text);
  std_compact_map_Map__0_insert(this->documents, std_buffer_Buffer_sv(uri), document);
  this->to_validate_req=req;
}

void compiler_lsp_server_LSPServer_handle_did_change(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling textDocument/didChange request\n");
  std_value_Value *params = std_value_Value_at_key(req, "params");
  std_buffer_Buffer uri = std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at_key(params, "textDocument"), "uri"));
  compiler_lsp_server_lsp_log(std_format("[SERVER] Changing document: %.*s\n", (uri).size, (uri).data));
  if(!(std_value_Value_is((*params), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:553:12: Assertion failed: `params.is(Dictionary)`", NULL); }
  std_vector_Vector__28 *changes = std_value_Value_as_list(std_value_Value_at_key(params, "contentChanges"));
  if(!(changes->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:556:12: Assertion failed: `changes.size == 1`", NULL); }
  std_buffer_Buffer text = std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at(std_value_Value_at_key(params, "contentChanges"), 0), "text"));
  compiler_lsp_server_unescape_buf(&text);
  std_compact_map_Map__0_insert(this->documents, std_buffer_Buffer_sv(uri), (compiler_lsp_server_TextDocument){.text=text});
  this->to_validate_req=req;
}

void compiler_lsp_server_LSPServer_handle_did_close(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling textDocument/didClose request\n");
  std_value_Value *params = std_value_Value_at_key(req, "params");
  std_buffer_Buffer uri = std_value_Value_as_str(std_value_Value_at_key(std_value_Value_at_key(params, "textDocument"), "uri"));
  compiler_lsp_server_lsp_log(std_format("[SERVER] Closing document: %.*s\n", (uri).size, (uri).data));
  if(!(std_value_Value_is((*params), std_value_ValueType_Dictionary))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/server/mod.oc:569:12: Assertion failed: `params.is(Dictionary)`", NULL); }
  std_compact_map_Map__0_remove(this->documents, std_buffer_Buffer_sv(uri));
}

void compiler_lsp_server_LSPServer_handle_completion(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling completion request\n");
  compiler_lsp_server_Loc loc = compiler_lsp_server_get_location(req);
  std_value_Value *cli_out = compiler_lsp_server_LSPServer_run_lsp_backend(this, loc, "-c", true);
  std_value_Value *completions = std_value_Value_new(std_value_ValueType_List);
  if (((bool)cli_out)) {
    i64 index = ((i64)1);
    std_vector_Vector__28 *cli_list = std_value_Value_as_list(std_value_Value_at_key(cli_out, "completions"));
    for (std_vector_Iterator__28 _i271 = std_vector_Vector__28_iter(cli_list); std_vector_Iterator__28_has_value(&_i271); std_vector_Iterator__28_next(&_i271)) {
      std_value_Value *comp = std_vector_Iterator__28_cur(&_i271);
      {
        std_value_Value_push(completions, std_value_Value_new_dict(({
          std_compact_map_Map__1 *_mc580 = std_compact_map_Map__1_new(8);
          std_compact_map_Map__1_insert(_mc580, "label", std_value_Value_at_key(comp, "label"));
          std_compact_map_Map__1_insert(_mc580, "insertText", std_value_Value_at_key(comp, "insertText"));
          std_compact_map_Map__1_insert(_mc580, "detail", std_value_Value_at_key(comp, "detail"));
          std_compact_map_Map__1_insert(_mc580, "insertTextFormat", std_value_Value_new_int(((i64)2)));
          std_compact_map_Map__1_insert(_mc580, "kind", ({std_value_Value *__yv_581;
            {
              std_value_Value *__match_var_582 = std_value_Value_at_key(comp, "kind");
              if (std_value_Value_eq_str(__match_var_582, "function")) {
                __yv_581 = std_value_Value_new_int(((i64)3));
                goto _l___yv_581;
              } else if (std_value_Value_eq_str(__match_var_582, "field")) {
                __yv_581 = std_value_Value_new_int(((i64)5));
                goto _l___yv_581;
              } else  {
                __yv_581 = std_value_Value_new_int(((i64)1));
                goto _l___yv_581;
              }
            }

_l___yv_581:
          __yv_581;}));
          std_compact_map_Map__1_insert(_mc580, "data", std_value_Value_new_int(index++));
          std_compact_map_Map__1_insert(_mc580, "labelDetails", (std_value_Value_contains(comp, "labelDetails") ? std_value_Value_new_dict(({
            std_compact_map_Map__1 *_mc583 = std_compact_map_Map__1_new(1);
            std_compact_map_Map__1_insert(_mc583, "detail", std_value_Value_at_key(comp, "labelDetails"));
            _mc583;})) : std_value_Value_new(std_value_ValueType_Null)));
          std_compact_map_Map__1_insert(_mc580, "documentation", (std_value_Value_contains(comp, "documentation") ? std_value_Value_at_key(comp, "documentation") : std_value_Value_new(std_value_ValueType_Null)));
          _mc580;})));
      }
    }
  }
  compiler_lsp_server_send_response(req, completions);
}

void compiler_lsp_server_LSPServer_handle_shutdown(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling shutdown request\n");
  std_value_Value *response = std_value_Value_new_dict(({
    std_compact_map_Map__1 *_mc584 = std_compact_map_Map__1_new(3);
    std_compact_map_Map__1_insert(_mc584, "jsonrpc", std_value_Value_new_str("2.0"));
    std_compact_map_Map__1_insert(_mc584, "id", std_value_Value_at_key(req, "id"));
    std_compact_map_Map__1_insert(_mc584, "result", std_value_Value_new(std_value_ValueType_Null));
    _mc584;}));
  compiler_lsp_server_send_message(response);
}

void compiler_lsp_server_LSPServer_handle_initialized(compiler_lsp_server_LSPServer *this, std_value_Value *req) {
  compiler_lsp_server_lsp_log("Handling initialzed request\n");
}

bool compiler_lsp_server_LSPServer_handle_request(compiler_lsp_server_LSPServer *this) {
  char *message = compiler_lsp_server_read_message();
  if (!(((bool)message))) {
    compiler_lsp_server_lsp_log("Failed to read message\n");
    /* defers */
    std_mem_free(message);
    return false;
  }
  std_value_Value *data = std_json_parse(message, "<anonymous>");
  if (!(((std_value_Value_is((*data), std_value_ValueType_Dictionary) && std_compact_map_Map__1_contains(std_value_Value_as_dict(data), "method")) && std_value_Value_is((*std_value_Value_at_key(data, "method")), std_value_ValueType_String)))) {
    compiler_lsp_server_lsp_log("Invalid message format");
    /* defers */
    std_mem_free(message);
    return false;
  }
  std_sv_SV method = std_buffer_Buffer_sv(std_value_Value_as_str(std_value_Value_at_key(data, "method")));
  {
    std_sv_SV __match_var_585 = method;
    if (std_sv_SV_eq_str(__match_var_585, "initialize")) {
      compiler_lsp_server_LSPServer_handle_initialize(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "initialized")) {
      compiler_lsp_server_LSPServer_handle_initialized(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/hover")) {
      compiler_lsp_server_LSPServer_handle_hover(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/didOpen")) {
      compiler_lsp_server_LSPServer_handle_did_open(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/didChange")) {
      compiler_lsp_server_LSPServer_handle_did_change(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/didClose")) {
      compiler_lsp_server_LSPServer_handle_did_close(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/completion")) {
      compiler_lsp_server_LSPServer_handle_completion(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/definition")) {
      compiler_lsp_server_LSPServer_handle_definition(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/typeDefinition")) {
      compiler_lsp_server_LSPServer_handle_type_definition(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/references")) {
      compiler_lsp_server_LSPServer_handle_references(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/signatureHelp")) {
      compiler_lsp_server_LSPServer_handle_signature_help(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/documentSymbol")) {
      compiler_lsp_server_LSPServer_handle_on_document_symbols(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "textDocument/rename")) {
      compiler_lsp_server_LSPServer_handle_rename(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "shutdown")) {
      compiler_lsp_server_LSPServer_handle_shutdown(this, data);
    } else if (std_sv_SV_eq_str(__match_var_585, "exit")) {
      /* defers */
      std_mem_free(message);
      return false;
    } else  {
      compiler_lsp_server_lsp_log(std_format("-----------------------------------------"));
      compiler_lsp_server_lsp_log(std_format("[SERVER] Unknown method: %.*s", (method).len, (method).data));
      compiler_lsp_server_lsp_log(std_format("-----------------------------------------"));
    }
  }
  /* defers */
  std_mem_free(message);
  return true;
}

void compiler_lsp_server_main_loop(void) {
  compiler_lsp_server_LSPServer *lsp = ({compiler_lsp_server_LSPServer *_new_586 = std_mem_state_alloc_fn(std_mem_state_allocator, sizeof(compiler_lsp_server_LSPServer)); *_new_586 = (compiler_lsp_server_LSPServer){.documents=({
    std_compact_map_Map__0 *_mc587 = std_compact_map_Map__0_new(8);
    _mc587;}), .validate_throttle_ms=500.000000, .last_validated=0.000000, .to_validate_req=NULL}; _new_586; });
  while (true) {
    if (!(compiler_lsp_server_LSPServer_handle_request(lsp))) {
      /* defers */
      {
        std_gc_collect();
        std_gc_print_stats();
      }
      break;
    }
    compiler_lsp_server_LSPServer_handle_validate_document(lsp);
    /* defers */
    {
      std_gc_collect();
      std_gc_print_stats();
    }
  }
}

i32 compiler_lsp_server_main(i32 argc, char **argv) {
  std_gc_init(&argv);
  setvbuf(stdin, NULL, _IONBF, ((u64)0));
  setvbuf(stdout, NULL, _IONBF, ((u64)0));
  compiler_lsp_server_main_loop();
  std_gc_shutdown();
  return 0;
}

void compiler_lsp_cli_typecheck_and_log_errors(compiler_ast_program_Program *program, char *path) {
  compiler_passes_run_typecheck_passes(program);
  if (program->errors->size==0) {
    if (compiler_lsp_cli_utils_verbose) {
      printf("type-checked program successfully""\n");
    }
    return;
  }
  for (std_vector_Iterator__16 _i2 = std_vector_Vector__16_iter(program->errors); std_vector_Iterator__16_has_value(&_i2); std_vector_Iterator__16_next(&_i2)) {
    compiler_errors_Error *err = std_vector_Iterator__16_cur(&_i2);
    {
      std_span_Location start = err->span1.start;
      std_span_Location end = err->span1.end;
      if (compiler_lsp_cli_utils_verbose) {
        printf("[-] ERROR: %s:%d:%d - %d:%d :: %s""\n", start.filename, start.line, start.col, end.line, end.col, err->msg1);
      }
    }
  }
}

void compiler_lsp_cli_handle_validate(compiler_ast_program_Program *program, char *path) {
  compiler_lsp_cli_typecheck_and_log_errors(program, path);
  for (std_vector_Iterator__16 _i3 = std_vector_Vector__16_iter(program->errors); std_vector_Iterator__16_has_value(&_i3); std_vector_Iterator__16_next(&_i3)) {
    compiler_errors_Error *err = std_vector_Iterator__16_cur(&_i3);
    {
      if (!(((bool)err->span1.start.filename))) {
        continue;
      }
      if (!(str_eq(err->span1.start.filename, path))) {
        continue;
      }
      std_value_Value *err_value = compiler_lsp_cli_utils_gen_error_json(err);
      printf("%s\n", std_value_Value_dbg(err_value));
    }
  }
  return;
  compiler_passes_visitor_Visitor visitor = (compiler_passes_visitor_Visitor){.node_fn=({compiler_lsp_cli_handle_validate__Closure_0Ctx *_C588 = alloca(sizeof(compiler_lsp_cli_handle_validate__Closure_0Ctx));_C588->path = &path;_ClosureTy_2 _ci589 = {._C=_C588, .fn=&compiler_lsp_cli_handle_validate__Closure_0};_ci589;}), .type_fn=({compiler_passes_visitor__Closure_4Ctx *_C590 = alloca(sizeof(compiler_passes_visitor__Closure_4Ctx));_ClosureTy_3 _ci591 = {._C=_C590, .fn=&compiler_passes_visitor__Closure_4};_ci591;})};
  for (compiler_ast_program_NSIterator _i5 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i5); compiler_ast_program_NSIterator_next(&_i5)) {
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i5);
    {
      if (str_eq(ns->path, path)) {
        for (std_vector_Iterator__8 _i6 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i6); std_vector_Iterator__8_next(&_i6)) {
          compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i6);
          {
            if (((bool)func->body)) {
              compiler_passes_visitor_Visitor_visit_po(&visitor, func->body);
            }
          }
        }
      }
    }
  }
}

void compiler_lsp_cli_handle_location_command(compiler_ast_program_Program *program, compiler_lsp_cli_CommandType type, std_span_Location loc) {
  compiler_lsp_cli_typecheck_and_log_errors(program, loc.filename);
  if (compiler_lsp_cli_utils_verbose) {
    printf("[+] Looking for location: %s:%u:%u\n", (loc).filename, (loc).line, (loc).col);
  }
  compiler_lsp_cli_finder_Finder finder = compiler_lsp_cli_finder_Finder_make(type, loc);
  if (!(compiler_lsp_cli_finder_Finder_find(&finder, program))) {
    if (compiler_lsp_cli_utils_verbose) {
      printf("[-] No result found""\n");
    }
    return;
  }
  std_value_Value *resp = ({std_value_Value *__yv_592;
switch ((type)) {
      case compiler_lsp_cli_CommandType_Hover:
      m_593_0:
        {
          __yv_592 = compiler_lsp_cli_utils_gen_hover_string_with_docs(finder.found_sym);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_GoToDefinition:
      m_593_1:
        {
          compiler_ast_scopes_Symbol *usage = finder.found_sym;
          std_span_Span jump_span = ({std_span_Span __yv_594;
switch ((usage->type)) {
              case compiler_ast_scopes_SymbolType_Namespace:
              m_595_0:
                {
                  __yv_594 = usage->u.ns->span;
                  goto _l___yv_594;
                } break;
              default:
                {
                  __yv_594 = usage->span;
                  goto _l___yv_594;
                } break;
            }
_l___yv_594:
          __yv_594;});
          __yv_592 = compiler_lsp_cli_utils_gen_span_json_with_filename(jump_span, loc);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_GoToType:
      m_593_2:
        {
          compiler_types_Type *typ = compiler_lsp_cli_utils_get_symbol_typedef(finder.found_sym);
          if ((((bool)typ) && !(compiler_types_Type_can_have_methods(typ))) && typ->base==compiler_types_BaseType_Pointer) {
            typ=typ->u.ptr;
          }
          if (!(((bool)typ))) {
            return;
          }
          __yv_592 = compiler_lsp_cli_utils_gen_span_json_with_filename(typ->span, loc);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_Completions:
      m_593_3:
        {
          __yv_592 = compiler_lsp_cli_utils_gen_completions_json(&finder);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_References:
      m_593_4:
        {
          __yv_592 = compiler_lsp_cli_utils_gen_references_json(finder.found_sym, loc);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_Renames:
      m_593_5:
        {
          __yv_592 = compiler_lsp_cli_utils_gen_renames_json(finder.found_sym, loc);
          goto _l___yv_592;
        } break;
      case compiler_lsp_cli_CommandType_SignatureHelp:
      m_593_6:
        {
          __yv_592 = compiler_lsp_cli_utils_gen_signature_help(finder.call, finder.active_param);
          goto _l___yv_592;
        } break;
      default:
        {
          std_panic("Unhandled command type");
          goto _l___yv_592;
        } break;
    }
_l___yv_592:
  __yv_592;});
  if (!(((bool)resp))) {
    return;
  }
  std_buffer_Buffer resp_text = std_json_serialize(resp);
  printf("%.*s\n", (resp_text).size, (resp_text).data);
}

void compiler_lsp_cli_handle_document_symbols(compiler_ast_program_Program *program, char *path) {
  compiler_lsp_cli_typecheck_and_log_errors(program, path);
  compiler_ast_program_Namespace *doc_ns = NULL;
  for (compiler_ast_program_NSIterator _i7 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i7); compiler_ast_program_NSIterator_next(&_i7)) {
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i7);
    {
      char *ns_filename = ns->span.start.filename;
      if (((bool)ns_filename) && str_eq(ns_filename, path)) {
        doc_ns=ns;
        break;
      }
    }
  }
  if (!(((bool)doc_ns))) {
    if (compiler_lsp_cli_utils_verbose) {
      printf("No namespace found for path: %s\n", path);
    }
    printf("[]""\n");
    return;
  }
  if (compiler_lsp_cli_utils_verbose) {
    printf("Got ns: %s\n", doc_ns->sym->name);
  }
  std_value_Value *resp = compiler_lsp_cli_utils_gen_namespace_json(doc_ns);
  if (!(((bool)resp))) {
    return;
  }
  std_value_Value *children = std_value_Value_get(resp, "children", NULL);
  std_buffer_Buffer resp_text = std_json_serialize(children);
  printf("%.*s\n", (resp_text).size, (resp_text).data);
}

char *compiler_lsp_cli_shift_args(i32 *argc, char ***argv) {
  if ((*argc)==0) {
    printf("Expected argument but got none\n");
    exit(1);
  }
  char *arg = (*argv)[0];
  (*argv)=((*argv) + 1);
  (*argc)=((*argc) - 1);
  return arg;
}

void compiler_lsp_cli_lsp_usage(i32 code, bool full) {
  printf("   ./ocen [--help] [compile-options] <file>""\n");
  printf("   ./ocen lsp [--help] [lsp-options] <file>""\n");
  if (!(full)) {
    exit(code);
  }
  printf("--------------------------------------------------------""\n");
  printf("LSP Options:""\n");
  printf("    --show-path path          Display this file path instead of actual one""\n");
  printf("    -h <line> <col>           Type hints for the given location""\n");
  printf("    -d <line> <col>           Find definition for the given location""\n");
  printf("    -t <line> <col>           Find type for the given location""\n");
  printf("    -c <line> <col>           Completions for the given location""\n");
  printf("    -r <line> <col>           References for the given location""\n");
  printf("    -s <line> <col>           Signature Help for the given location""\n");
  printf("    --renames <line> <col>    Find all references for the given location""\n");
  printf("    -v                        Verbose output""\n");
  printf("    --doc-symbols             List all symbols in the file""\n");
  printf("    --validate                List all errors in the file""\n");
  exit(code);
}

void compiler_lsp_cli_signal_handler(i32 sig) {
  if (compiler_lsp_cli_utils_verbose) {
    printf("Received signal %s, exiting\n", std_signal_Signal_dbg(((i32)sig)));
  }
  longjmp(compiler_lsp_cli_global_err_ctx, 1);
}

i32 compiler_lsp_cli_main(i32 argc, char **argv, char *contents) {
  compiler_lsp_cli_shift_args(&argc, &argv);
  char *show_path = NULL;
  char *file_path = NULL;
  u32 line = 0;
  u32 col = 0;
  compiler_lsp_cli_CommandType cmd_type = compiler_lsp_cli_CommandType_None;
  while (argc > 0) {
    char *arg = compiler_lsp_cli_shift_args(&argc, &argv);
    {
      char *__match_var_596 = arg;
      if (str_eq(__match_var_596, "--help")) {
        compiler_lsp_cli_lsp_usage(0, true);
      } else if (str_eq(__match_var_596, "-h") || str_eq(__match_var_596, "-d") || str_eq(__match_var_596, "-t") || str_eq(__match_var_596, "-c") || str_eq(__match_var_596, "-r") || str_eq(__match_var_596, "-s") || str_eq(__match_var_596, "--refs") || str_eq(__match_var_596, "--renames")) {
        cmd_type=({compiler_lsp_cli_CommandType __yv_597;
          {
            char *__match_var_598 = arg;
            if (str_eq(__match_var_598, "-h")) {
              __yv_597 = compiler_lsp_cli_CommandType_Hover;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "-d")) {
              __yv_597 = compiler_lsp_cli_CommandType_GoToDefinition;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "-t")) {
              __yv_597 = compiler_lsp_cli_CommandType_GoToType;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "-c")) {
              __yv_597 = compiler_lsp_cli_CommandType_Completions;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "-s")) {
              __yv_597 = compiler_lsp_cli_CommandType_SignatureHelp;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "-r") || str_eq(__match_var_598, "--refs")) {
              __yv_597 = compiler_lsp_cli_CommandType_References;
              goto _l___yv_597;
            } else if (str_eq(__match_var_598, "--renames")) {
              __yv_597 = compiler_lsp_cli_CommandType_Renames;
              goto _l___yv_597;
            } else  std_panic("Invalid command type");
          }

_l___yv_597:
        __yv_597;});
        line=str_to_u32(compiler_lsp_cli_shift_args(&argc, &argv));
        col=str_to_u32(compiler_lsp_cli_shift_args(&argc, &argv));
      } else if (str_eq(__match_var_596, "--validate")) {
        cmd_type=compiler_lsp_cli_CommandType_Validate;
      } else if (str_eq(__match_var_596, "--doc-symbols")) {
        cmd_type=compiler_lsp_cli_CommandType_DocumentSymbols;
      } else if (str_eq(__match_var_596, "-v")) {
        compiler_lsp_cli_utils_verbose=true;
      } else if (str_eq(__match_var_596, "--show-path")) {
        show_path=compiler_lsp_cli_shift_args(&argc, &argv);
      } else  {
        if (((bool)file_path)) {
          printf("Too many arguments, got: %s\n", arg);
          compiler_lsp_cli_lsp_usage(1, false);
        }
        file_path=arg;
      }
    }
  }
  if (((bool)show_path))     if (((bool)file_path)) {
      file_path=std_fs_realpath(file_path);
      contents=std_buffer_Buffer_str(std_fs_read_file(file_path));
    } else if (((bool)contents)) {
    } else {
      printf("No file path provided""\n");
      compiler_lsp_cli_lsp_usage(1, false);
    }
   else     if (!(((bool)file_path))) {
      printf("No file path provided""\n");
      compiler_lsp_cli_lsp_usage(1, false);
    }
  
  if (cmd_type==compiler_lsp_cli_CommandType_None) {
    printf("No command type provided""\n");
    compiler_lsp_cli_lsp_usage(1, false);
  }
  if (!(((bool)show_path))) {
    show_path=file_path;
  } else {
    show_path=std_fs_realpath(show_path);
  }
  std_signal_set_signal_handler(SIGSEGV, compiler_lsp_cli_signal_handler);
  std_signal_set_signal_handler(SIGILL, compiler_lsp_cli_signal_handler);
  std_signal_set_signal_handler(SIGFPE, compiler_lsp_cli_signal_handler);
  compiler_ast_program_Program *program = compiler_ast_program_Program_new();
  if (setjmp(compiler_lsp_cli_global_err_ctx) > 0) {
    exit(1);
  }
  compiler_ast_program_Program_setup_library_paths(program);
  program->include_stdlib=true;
  bool include_workspace_main = ({bool __yv_599;
switch ((cmd_type)) {
      case compiler_lsp_cli_CommandType_References:
      case compiler_lsp_cli_CommandType_Renames:
      m_600_0:
        {
          __yv_599 = true;
          goto _l___yv_599;
        } break;
      default:
        {
          __yv_599 = false;
          goto _l___yv_599;
        } break;
    }
_l___yv_599:
  __yv_599;});
  compiler_parser_Parser_parse_toplevel(program, show_path, contents, include_workspace_main);
switch ((cmd_type)) {
    case compiler_lsp_cli_CommandType_DocumentSymbols:
    m_601_0:
      {
        compiler_lsp_cli_handle_document_symbols(program, show_path);
      } break;
    case compiler_lsp_cli_CommandType_Validate:
    m_601_1:
      {
        compiler_lsp_cli_handle_validate(program, show_path);
      } break;
    default:
      {
        std_span_Location loc = (std_span_Location){.filename=show_path, .line=line, .col=col, .index=0};
        compiler_lsp_cli_handle_location_command(program, cmd_type, loc);
      } break;
  }  return 0;
}

char *compiler_lsp_cli_utils_gen_func_param_string(u32 i, compiler_ast_nodes_Variable *param, bool is_non_static_method) {
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);
  if (i==0 && is_non_static_method) {
    if (param->type->base==compiler_types_BaseType_Pointer) {
      std_buffer_Buffer_write_str(&sb, "&");
    }
    std_buffer_Buffer_write_str(&sb, "this");
  } else {
    if (!(str_eq(param->sym->name, ""))) {
      std_buffer_Buffer_write_str(&sb, param->sym->name);
      std_buffer_Buffer_write_str(&sb, ": ");
    }
    std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(param->type, false));
  }
  if (((bool)param->default_value)) {
    char *expr_str = compiler_lsp_cli_utils_try_gen_expr_string(param->default_value);
    if (((bool)expr_str)) {
      std_buffer_Buffer_write_str(&sb, " = ");
      std_buffer_Buffer_write_str(&sb, expr_str);
    }
  }
  return std_buffer_Buffer_str(sb);
}

char *compiler_lsp_cli_utils_gen_template_params(std_vector_Vector__0 *args) {
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);
  std_buffer_Buffer_write_str(&sb, "<");
  for (u32 i = 0; i < args->size; i+=1) {
    if (i > 0) {
      std_buffer_Buffer_write_str(&sb, ", ");
    }
    std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(std_vector_Vector__0_at(args, i), false));
  }
  std_buffer_Buffer_write_str(&sb, ">");
  return std_buffer_Buffer_str(sb);
}

char *compiler_lsp_cli_utils_gen_type_string(compiler_types_Type *type, bool full) {
  return ({char *__yv_602;
switch ((type->base)) {
      case compiler_types_BaseType_Char:
      case compiler_types_BaseType_Bool:
      case compiler_types_BaseType_Void:
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_603_0:
        {
          __yv_602 = compiler_types_BaseType_str(type->base);
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Pointer:
      m_603_1:
        {
          __yv_602 = ({char *__yv_604;
switch ((type->u.ptr->base)) {
              case compiler_types_BaseType_Void:
              m_605_0:
                {
                  __yv_604 = "untyped_ptr";
                  goto _l___yv_604;
                } break;
              case compiler_types_BaseType_Char:
              m_605_1:
                {
                  __yv_604 = "str";
                  goto _l___yv_604;
                } break;
              default:
                {
                  __yv_604 = std_format("&%s", compiler_lsp_cli_utils_gen_type_string(type->u.ptr, full));
                  goto _l___yv_604;
                } break;
            }
_l___yv_604:
          __yv_604;});
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Array:
      m_603_2:
        {
          __yv_602 = std_format("&%s", compiler_lsp_cli_utils_gen_type_string(type->u.arr.elem_type, full));
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_VectorShorthand:
      m_603_3:
        {
          __yv_602 = std_format("$[%s]", compiler_lsp_cli_utils_gen_type_string(type->u.arr.elem_type, full));
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_MapShorthand:
      m_603_4:
        {
          compiler_types_MapShorthandType mpt = type->u.map_types;
          __yv_602 = std_format("${%s:%s}", compiler_lsp_cli_utils_gen_type_string(mpt.key, full), compiler_lsp_cli_utils_gen_type_string(mpt.value, full));
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Structure:
      case compiler_types_BaseType_Alias:
      case compiler_types_BaseType_Enum:
      m_603_5:
        {
          if (!(((bool)type->template_instance))) {
            return ({char *__yv_606;
              if (full) {
                __yv_606 = type->sym->display;
                goto _l___yv_606;
              } else {
                __yv_606 = type->sym->name;
                goto _l___yv_606;
              }
_l___yv_606:
            __yv_606;});
          }
          compiler_ast_scopes_TemplateInstance *instance = type->template_instance;
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&sb, (full ? instance->parent->display : instance->parent->name));
          std_buffer_Buffer_write_str_f(&sb, compiler_lsp_cli_utils_gen_template_params(instance->args));
          __yv_602 = std_buffer_Buffer_str(sb);
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Closure:
      case compiler_types_BaseType_FunctionPtr:
      m_603_6:
        {
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);
          compiler_types_FunctionType func_type = type->u.func;
          bool is_non_static_method = false;
          if (((bool)func_type.orig)) {
            if (func_type.orig->kind==compiler_ast_nodes_FunctionKind_Method) {
              is_non_static_method=!(func_type.orig->is_static);
            }
            std_buffer_Buffer_write_str(&sb, "def ");
            compiler_ast_nodes_Function *orig = func_type.orig;
            if (((bool)orig->parent_type)) {
              std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(orig->parent_type, false));
              std_buffer_Buffer_write_str(&sb, "::");
              std_buffer_Buffer_write_str(&sb, orig->sym->name);
            } else {
              std_buffer_Buffer_write_str(&sb, func_type.orig->sym->display);
            }
            if (((bool)orig->sym->template)) {
              std_buffer_Buffer_write_str(&sb, "<");
              std_vector_Vector__10 *params = orig->sym->template->params;
              for (u32 i = 0; i < params->size; i+=1) {
                if (i > 0) {
                  std_buffer_Buffer_write_str(&sb, ", ");
                }
                std_buffer_Buffer_write_str(&sb, std_vector_Vector__10_at(params, i)->name);
              }
              std_buffer_Buffer_write_str(&sb, ">");
            }
          } else {
            if (type->base==compiler_types_BaseType_Closure) {
              std_buffer_Buffer_write_str(&sb, "@");
            }
            std_buffer_Buffer_write_str(&sb, "fn");
          }
          std_buffer_Buffer_write_str(&sb, "(");
          for (u32 i = 0; i < func_type.params->size; i+=1) {
            compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(func_type.params, i);
            if (i > 0) {
              std_buffer_Buffer_write_str(&sb, ", ");
            }
            std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_func_param_string(i, param, is_non_static_method));
          }
          if (func_type.is_variadic) {
            if (func_type.params->size > 0) {
              std_buffer_Buffer_write_str(&sb, ", ");
            }
            std_buffer_Buffer_write_str(&sb, "...");
          }
          std_buffer_Buffer_write_str(&sb, ")");
          if (func_type.return_type->base != compiler_types_BaseType_Void) {
            std_buffer_Buffer_write_str(&sb, ": ");
            std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(func_type.return_type, false));
          }
          __yv_602 = std_buffer_Buffer_str(sb);
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Unresolved:
      m_603_7:
        {
          compiler_ast_nodes_AST *unres = type->u.unresolved;
          __yv_602 = ({char *__yv_607;
switch ((unres->type)) {
              case compiler_ast_nodes_ASTType_Identifier:
              m_608_0:
                {
                  __yv_607 = unres->u.ident.name;
                  goto _l___yv_607;
                } break;
              default:
                {
                  __yv_607 = "<unresolved>";
                  goto _l___yv_607;
                } break;
            }
_l___yv_607:
          __yv_607;});
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_UnresolvedTemplate:
      m_603_8:
        {
          compiler_types_UnresolvedTemplate unres = type->u.unresolved_spec;
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(unres.base, full));
          std_buffer_Buffer_write_str_f(&sb, compiler_lsp_cli_utils_gen_template_params(unres.args));
          __yv_602 = std_buffer_Buffer_str(sb);
          goto _l___yv_602;
        } break;
      case compiler_types_BaseType_Error:
      case compiler_types_BaseType_NUM_BASE_TYPES:
      m_603_9:
        {
          __yv_602 = "ERROR";
          goto _l___yv_602;
        } break;
    }
_l___yv_602:
  __yv_602;});}

char *compiler_lsp_cli_utils_try_gen_expr_string(compiler_ast_nodes_AST *expr) {
  return ({char *__yv_609;
switch ((expr->type)) {
      case compiler_ast_nodes_ASTType_BoolLiteral:
      m_610_0:
                  __yv_609 = (expr->u.bool_literal ? "true" : "false");
          goto _l___yv_609;
         break;
      case compiler_ast_nodes_ASTType_IntLiteral:
      case compiler_ast_nodes_ASTType_FloatLiteral:
      m_610_1:
        {
          compiler_ast_nodes_NumLiteral *literal = &expr->u.num_literal;
          __yv_609 = ({char *__yv_611;
            if (((bool)literal->suffix)) {
              __yv_611 = std_format("%s%s", literal->text, compiler_types_Type_str(literal->suffix));
              goto _l___yv_611;
            } else {
              __yv_611 = literal->text;
              goto _l___yv_611;
            }
_l___yv_611:
          __yv_611;});
          goto _l___yv_609;
        } break;
      case compiler_ast_nodes_ASTType_StringLiteral:
      m_610_2:
        {
          __yv_609 = std_format("\"%s\"", expr->u.string_literal);
          goto _l___yv_609;
        } break;
      case compiler_ast_nodes_ASTType_CharLiteral:
      m_610_3:
        {
          __yv_609 = std_format("'%s'", expr->u.char_literal);
          goto _l___yv_609;
        } break;
      case compiler_ast_nodes_ASTType_Null:
      m_610_4:
        {
          __yv_609 = "null";
          goto _l___yv_609;
        } break;
      case compiler_ast_nodes_ASTType_Identifier:
      m_610_5:
        {
          __yv_609 = expr->u.ident.name;
          goto _l___yv_609;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_610_6:
        {
          char *lhs_str = compiler_lsp_cli_utils_try_gen_expr_string(expr->u.lookup.lhs);
          if (!(((bool)lhs_str))) {
            return NULL;
          }
          __yv_609 = std_format("%s::%s", lhs_str, expr->u.lookup.rhs_name);
          goto _l___yv_609;
        } break;
      default:
        {
          __yv_609 = NULL;
          goto _l___yv_609;
        } break;
    }
_l___yv_609:
  __yv_609;});}

char *compiler_lsp_cli_utils_gen_hover_string(compiler_ast_scopes_Symbol *sym) {
  return ({char *__yv_612;
switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_ClosureType:
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_613_0:
        {
          __yv_612 = compiler_lsp_cli_utils_gen_type_string(sym->u.type_def, true);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_613_1:
        {
          __yv_612 = compiler_lsp_cli_utils_gen_type_string(sym->u.func->type, true);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_613_2:
        {
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&sb, sym->display);
          std_buffer_Buffer_write_str(&sb, ": ");
          std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(sym->u.var->type, true));
          __yv_612 = std_buffer_Buffer_str(sb);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Constant:
      m_613_3:
        {
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&sb, "const ");
          std_buffer_Buffer_write_str(&sb, sym->display);
          std_buffer_Buffer_write_str(&sb, ": ");
          std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_type_string(sym->u.var->type, true));
          __yv_612 = std_buffer_Buffer_str(sb);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_613_4:
        {
          __yv_612 = std_format("struct %s", sym->display);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Namespace:
      m_613_5:
        {
          __yv_612 = std_format("namespace %s", sym->display);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_613_6:
        {
          __yv_612 = std_format("enum %s", sym->display);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_EnumVariant:
      m_613_7:
        {
          compiler_ast_nodes_EnumVariant *variant = sym->u.enum_var;
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str_f(&buf, std_format("enum %s", variant->sym->display));
          u32 num_fields = compiler_ast_nodes_EnumVariant_num_fields(variant);
          if (num_fields > 0) {
            std_buffer_Buffer_write_str(&buf, "(");
            for (u32 i = 0; i < num_fields; i+=1) {
              if (i > 0) {
                std_buffer_Buffer_write_str(&buf, ", ");
              }
              compiler_ast_nodes_Variable *field = compiler_ast_nodes_EnumVariant_get_field_by_idx(variant, i);
              if (((bool)field->sym) && (strlen(field->sym->name) > 0)) {
                std_buffer_Buffer_write_str(&buf, field->sym->name);
                std_buffer_Buffer_write_str(&buf, ": ");
              }
              std_buffer_Buffer_write_str(&buf, compiler_lsp_cli_utils_gen_type_string(field->type, false));
            }
            std_buffer_Buffer_write_str(&buf, ")");
          }
          __yv_612 = std_buffer_Buffer_str(buf);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_EnumField:
      m_613_8:
        {
          compiler_ast_scopes_EnumField field = sym->u.enum_field;
          __yv_612 = std_format("enum %s.%u", field.variant->sym->display, field.idx);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_Closure:
      m_613_9:
        {
          __yv_612 = compiler_lsp_cli_utils_gen_type_string(sym->u.func->type, true);
          goto _l___yv_612;
        } break;
      case compiler_ast_scopes_SymbolType_ClosedVariable:
      m_613_10:
        {
          compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&buf, var->sym->display);
          std_buffer_Buffer_write_str(&buf, ": ");
          std_buffer_Buffer_write_str(&buf, compiler_lsp_cli_utils_gen_type_string(var->type, true));
          __yv_612 = std_buffer_Buffer_str(buf);
          goto _l___yv_612;
        } break;
    }
_l___yv_612:
  __yv_612;});}

compiler_types_Type *compiler_lsp_cli_utils_get_symbol_typedef(compiler_ast_scopes_Symbol *sym) {
  return ({compiler_types_Type *__yv_614;
switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_615_0:
        {
          __yv_614 = sym->u.type_def;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_615_1:
        {
          __yv_614 = sym->u.func->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_615_2:
        {
          __yv_614 = sym->u.var->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Constant:
      m_615_3:
        {
          __yv_614 = sym->u.var->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_615_4:
        {
          __yv_614 = sym->u.struc->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Namespace:
      m_615_5:
        {
          __yv_614 = NULL;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_615_6:
        {
          __yv_614 = sym->u.enom->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_EnumVariant:
      m_615_7:
        {
          __yv_614 = sym->u.enum_var->parent->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_EnumField:
      m_615_8:
        {
          __yv_614 = sym->u.enum_field.variant->parent->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_ClosureType:
      m_615_9:
        {
          __yv_614 = sym->u.type_def;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_Closure:
      m_615_10:
        {
          __yv_614 = sym->u.func->type;
          goto _l___yv_614;
        } break;
      case compiler_ast_scopes_SymbolType_ClosedVariable:
      m_615_11:
        {
          __yv_614 = sym->u.closed_var.orig->type;
          goto _l___yv_614;
        } break;
    }
_l___yv_614:
  __yv_614;});}

std_value_Value *compiler_lsp_cli_utils_gen_error_json(compiler_errors_Error *err) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "severity", "Error");
  std_value_Value_insert(obj, "span", compiler_lsp_cli_utils_gen_span_json(err->span1));
  std_value_Value_insert_str(obj, "message", err->msg1);
switch ((err->type)) {
    case compiler_errors_ErrorType_WithHint:
    case compiler_errors_ErrorType_WithNote:
    m_616_0:
      {
        std_value_Value *extra_info = std_value_Value_new(std_value_ValueType_Dictionary);
        std_span_Span extra_span = ({std_span_Span __yv_617;
switch ((err->type)) {
            case compiler_errors_ErrorType_WithHint:
            m_618_0:
                              __yv_617 = (std_span_Span_is_valid(err->span2) ? err->span2 : err->span1);
                goto _l___yv_617;
               break;
            default:
              {
                __yv_617 = err->span1;
                goto _l___yv_617;
              } break;
          }
_l___yv_617:
        __yv_617;});
        std_value_Value_insert(extra_info, "span", compiler_lsp_cli_utils_gen_span_json(extra_span));
        std_value_Value_insert_str(extra_info, "message", err->msg2);
        std_value_Value_insert(obj, "extra_info", extra_info);
      } break;
    case compiler_errors_ErrorType_Standard:
    m_616_1:
      {
      } break;
  }  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_span_json(std_span_Span span) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert(obj, "start_line", std_value_Value_new_int(((i64)span.start.line)));
  std_value_Value_insert(obj, "start_col", std_value_Value_new_int(((i64)span.start.col)));
  std_value_Value_insert(obj, "end_line", std_value_Value_new_int(((i64)span.end.line)));
  std_value_Value_insert(obj, "end_col", std_value_Value_new_int(((i64)span.end.col)));
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_span_json_with_filename(std_span_Span span, std_span_Location search_loc) {
  std_value_Value *obj = compiler_lsp_cli_utils_gen_span_json(span);
  if (!(str_eq(span.start.filename, search_loc.filename))) {
    std_value_Value_insert_str(obj, "file", span.start.filename);
  }
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_hover_string_with_docs(compiler_ast_scopes_Symbol *sym) {
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);
  std_buffer_Buffer_write_str(&sb, compiler_lsp_cli_utils_gen_hover_string(sym));
  if (((bool)sym->comment)) {
    std_buffer_Buffer_write_str(&sb, "\n");
    std_buffer_Buffer_write_str(&sb, sym->comment);
  }
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "hover", std_buffer_Buffer_str(sb));
  return obj;
}

void compiler_lsp_cli_utils_gen_type_methods_into(std_value_Value *obj, compiler_types_Type *type) {
  if (!(((bool)type)) || !(((bool)type->methods))) {
    return;
  }
  for (std_map_Iterator__9 _i8 = std_map_Map__9_iter(type->methods); std_map_Iterator__9_has_value(&_i8); std_map_Iterator__9_next(&_i8)) {
    std_map_Item__9 *it = std_map_Iterator__9_cur(&_i8);
    {
      compiler_ast_nodes_Function *func = it->value;
      std_value_Value *func_doc = std_value_Value_new(std_value_ValueType_Dictionary);
      std_value_Value_insert_str(func_doc, "name", it->key);
      std_value_Value_insert_str(func_doc, "detail", compiler_lsp_cli_utils_gen_hover_string(func->sym));
      std_value_Value_insert_str(func_doc, "kind", "method");
      std_value_Value_insert(func_doc, "range", compiler_lsp_cli_utils_gen_span_json(func->sym->span));
      std_value_Value_insert(func_doc, "selection_range", compiler_lsp_cli_utils_gen_span_json(func->sym->span));
      std_value_Value_insert(func_doc, "children", std_value_Value_new(std_value_ValueType_List));
      std_value_Value_push(obj, func_doc);
    }
  }
}

std_value_Value *compiler_lsp_cli_utils_gen_struct_json(compiler_ast_nodes_Structure *struc) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "name", struc->sym->name);
  std_value_Value_insert_str(obj, "detail", compiler_lsp_cli_utils_gen_hover_string(struc->sym));
  std_value_Value_insert_str(obj, "kind", "struct");
  std_value_Value_insert(obj, "range", compiler_lsp_cli_utils_gen_span_json(struc->sym->span));
  std_value_Value_insert(obj, "selection_range", compiler_lsp_cli_utils_gen_span_json(struc->sym->span));
  std_value_Value *children = std_value_Value_new(std_value_ValueType_List);
  compiler_lsp_cli_utils_gen_type_methods_into(children, struc->type);
  std_value_Value_insert(obj, "children", children);
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_variable_json(compiler_ast_nodes_Variable *var) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "name", var->sym->name);
  std_value_Value_insert_str(obj, "detail", compiler_lsp_cli_utils_gen_hover_string(var->sym));
  std_value_Value_insert_str(obj, "kind", "variable");
  std_value_Value_insert(obj, "range", compiler_lsp_cli_utils_gen_span_json(var->sym->span));
  std_value_Value_insert(obj, "selection_range", compiler_lsp_cli_utils_gen_span_json(var->sym->span));
  std_value_Value_insert(obj, "children", std_value_Value_new(std_value_ValueType_List));
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_function_json(compiler_ast_nodes_Function *func) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "name", func->sym->name);
  std_value_Value_insert_str(obj, "detail", compiler_lsp_cli_utils_gen_hover_string(func->sym));
  std_value_Value_insert_str(obj, "kind", "function");
  std_value_Value_insert(obj, "range", compiler_lsp_cli_utils_gen_span_json(func->sym->span));
  std_value_Value_insert(obj, "selection_range", compiler_lsp_cli_utils_gen_span_json(func->sym->span));
  std_value_Value_insert(obj, "children", std_value_Value_new(std_value_ValueType_List));
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_namespace_json(compiler_ast_program_Namespace *ns) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(obj, "name", ns->sym->name);
  std_value_Value_insert_str(obj, "detail", compiler_lsp_cli_utils_gen_hover_string(ns->sym));
  std_value_Value_insert_str(obj, "kind", "namespace");
  std_value_Value_insert(obj, "range", compiler_lsp_cli_utils_gen_span_json(ns->span));
  std_value_Value_insert(obj, "selection_range", compiler_lsp_cli_utils_gen_span_json(ns->span));
  std_value_Value *children = std_value_Value_new(std_value_ValueType_List);
  for (std_vector_Iterator__13 _i10 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i10); std_vector_Iterator__13_next(&_i10)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i10);
    {
      std_value_Value_push(children, compiler_lsp_cli_utils_gen_struct_json(struc));
    }
  }
  for (std_vector_Iterator__15 _i11 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i11); std_vector_Iterator__15_next(&_i11)) {
    compiler_ast_nodes_AST *var = std_vector_Iterator__15_cur(&_i11);
    {
      std_value_Value_push(children, compiler_lsp_cli_utils_gen_variable_json(var->u.var_decl));
    }
  }
  for (std_vector_Iterator__15 _i12 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i12); std_vector_Iterator__15_next(&_i12)) {
    compiler_ast_nodes_AST *var = std_vector_Iterator__15_cur(&_i12);
    {
      std_value_Value_push(children, compiler_lsp_cli_utils_gen_variable_json(var->u.var_decl));
    }
  }
  for (std_vector_Iterator__8 _i13 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i13); std_vector_Iterator__8_next(&_i13)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i13);
    {
      if (func->kind==compiler_ast_nodes_FunctionKind_Method) {
        continue;
      }
      std_value_Value_push(children, compiler_lsp_cli_utils_gen_function_json(func));
    }
  }
  for (std_map_ValueIterator__4 _i14 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i14); std_map_ValueIterator__4_next(&_i14)) {
    compiler_ast_program_Namespace *it = std_map_ValueIterator__4_cur(&_i14);
    {
      if (!(it->is_a_file) && !(it->is_dir_with_mod)) {
        std_value_Value_push(children, compiler_lsp_cli_utils_gen_namespace_json(it));
      }
    }
  }
  std_value_Value_insert(obj, "children", children);
  return obj;
}

void compiler_lsp_cli_utils_insert_completion_item(std_value_Value *completions, compiler_ast_scopes_Symbol *sym, std_set_Set__2 *seen, char *name) {
  if (std_set_Set__2_contains(seen, sym->display)) {
    return;
  }
  std_set_Set__2_add(seen, sym->display);
  if (!(((bool)name))) {
    name=sym->name;
  }
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(val, "label", name);
  std_value_Value_insert_str(val, "detail", compiler_lsp_cli_utils_gen_hover_string(sym));
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Function:
    m_619_0:
      {
        std_value_Value_insert_str(val, "insertText", name);
        std_value_Value_insert_str(val, "kind", "function");
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_cli_utils_gen_hover_string(sym));
        if (((bool)sym->comment)) {
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
    case compiler_ast_scopes_SymbolType_Variable:
    m_619_1:
      {
        std_value_Value_insert_str(val, "insertText", name);
        std_value_Value_insert_str(val, "kind", "field");
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_cli_utils_gen_hover_string(sym));
        if (((bool)sym->comment)) {
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
    case compiler_ast_scopes_SymbolType_Constant:
    m_619_2:
      {
        std_value_Value_insert_str(val, "insertText", name);
        std_value_Value_insert_str(val, "kind", "constant");
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_cli_utils_gen_hover_string(sym));
        if (((bool)sym->comment)) {
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
    default:
      {
        std_value_Value_insert_str(val, "insertText", name);
        std_value_Value_insert_str(val, "kind", "field");
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_cli_utils_gen_hover_string(sym));
        if (((bool)sym->comment)) {
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
  }  std_value_Value_push(completions, val);
}

std_vector_Vector__27 *compiler_lsp_cli_utils_get_unique_reference_spans(compiler_ast_scopes_Symbol *sym, bool for_rename) {
  std_set_Set__3 *set = std_set_Set__3_new();
  for (std_vector_Iterator__18 _i15 = std_vector_Vector__18_iter(sym->references); std_vector_Iterator__18_has_value(&_i15); std_vector_Iterator__18_next(&_i15)) {
    compiler_ast_scopes_Reference ref = std_vector_Iterator__18_cur(&_i15);
    {
      if (for_rename && (ref.type != compiler_ast_scopes_ReferenceType_Normal)) {
        continue;
      }
      std_set_Set__3_add(set, ref.span);
    }
  }
  std_set_Set__3_add(set, sym->span);
  std_vector_Vector__27 *vec = std_vector_Vector__27_new(16);
  for (std_set_Iterator__3 _i16 = std_set_Set__3_iter(set); std_set_Iterator__3_has_value(&_i16); std_set_Iterator__3_next(&_i16)) {
    std_span_Span span = std_set_Iterator__3_cur(&_i16);
    {
      std_vector_Vector__27_push(vec, span);
    }
  }
  std_set_Set__3_free(set);
  return vec;
}

std_value_Value *compiler_lsp_cli_utils_gen_references_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_List);
  std_vector_Vector__27 *spans = compiler_lsp_cli_utils_get_unique_reference_spans(sym, false);
  for (std_vector_Iterator__27 _i17 = std_vector_Vector__27_iter(spans); std_vector_Iterator__27_has_value(&_i17); std_vector_Iterator__27_next(&_i17)) {
    std_span_Span ref = std_vector_Iterator__27_cur(&_i17);
    {
      std_value_Value_push(obj, compiler_lsp_cli_utils_gen_span_json_with_filename(ref, loc));
    }
  }
  std_vector_Vector__27_free(spans);
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_signature_help(compiler_ast_nodes_AST *node, u32 active_param) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  compiler_ast_scopes_Symbol *callee_sym = node->u.call.callee->resolved_symbol;
  bool is_non_static_method = false;
  std_vector_Vector__4 *params = ({std_vector_Vector__4 *__yv_620;
switch ((callee_sym->type)) {
      case compiler_ast_scopes_SymbolType_Function:
      m_621_0:
        {
          compiler_ast_nodes_Function *func = callee_sym->u.func;
          std_value_Value_insert_str(obj, "label", compiler_lsp_cli_utils_gen_type_string(func->type, true));
          is_non_static_method=(func->kind==compiler_ast_nodes_FunctionKind_Method && !(func->is_static));
          __yv_620 = func->params;
          goto _l___yv_620;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_621_1:
        {
          compiler_ast_nodes_Variable *var = callee_sym->u.var;
          if (var->type->base != compiler_types_BaseType_FunctionPtr) {
            if (compiler_lsp_cli_utils_verbose) {
              printf("gen_signature_help: variable is not a function: %p\n", var->type);
            }
            return obj;
          }
          std_value_Value_insert_str(obj, "label", compiler_lsp_cli_utils_gen_type_string(var->type, true));
          __yv_620 = var->type->u.func.params;
          goto _l___yv_620;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_621_2:
        {
          compiler_ast_nodes_Structure *struc = callee_sym->u.struc;
          std_buffer_Buffer struc_func_label = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&struc_func_label, "struct ");
          std_buffer_Buffer_write_str(&struc_func_label, compiler_lsp_cli_utils_gen_type_string(struc->type, true));
          std_buffer_Buffer_write_str(&struc_func_label, "(");
          std_vector_Vector__4 *params = struc->fields;
          for (u32 i = 0; i < params->size; i+=1) {
            compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(params, i);
            if (i != 0) {
              std_buffer_Buffer_write_str(&struc_func_label, ", ");
            }
            std_buffer_Buffer_write_str(&struc_func_label, compiler_lsp_cli_utils_gen_func_param_string(i, param, false));
          }
          std_buffer_Buffer_write_str(&struc_func_label, ")");
          std_value_Value_insert_str(obj, "label", std_buffer_Buffer_str(struc_func_label));
          __yv_620 = struc->fields;
          goto _l___yv_620;
        } break;
      default:
        {
          if (compiler_lsp_cli_utils_verbose) {
            printf("gen_signature_help: unhandled symbol type: %s\n", compiler_ast_scopes_SymbolType_dbg(callee_sym->type));
          }
          return obj;
        } break;
    }
_l___yv_620:
  __yv_620;});
  std_value_Value *params_obj = std_value_Value_new(std_value_ValueType_List);
  for (u32 i = 0; i < params->size; i+=1) {
    compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(params, i);
    std_value_Value *param_obj = std_value_Value_new(std_value_ValueType_Dictionary);
    std_value_Value_insert_str(param_obj, "label", compiler_lsp_cli_utils_gen_func_param_string(i, param, is_non_static_method));
    std_value_Value_push(params_obj, param_obj);
  }
  std_value_Value_insert(obj, "parameters", params_obj);
  std_value_Value *sig_help = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert(sig_help, "signatures", std_value_Value_new(std_value_ValueType_List));
  std_value_Value_push(std_value_Value_at_key(sig_help, "signatures"), obj);
  std_value_Value_insert_u32(sig_help, "activeSignature", 0);
  std_value_Value_insert_u32(sig_help, "activeParameter", active_param);
  return sig_help;
}

std_value_Value *compiler_lsp_cli_utils_gen_renames_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc) {
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_List);
  std_vector_Vector__27 *spans = compiler_lsp_cli_utils_get_unique_reference_spans(sym, true);
  for (std_vector_Iterator__27 _i18 = std_vector_Vector__27_iter(spans); std_vector_Iterator__27_has_value(&_i18); std_vector_Iterator__27_next(&_i18)) {
    std_span_Span ref = std_vector_Iterator__27_cur(&_i18);
    {
      u32 size = (ref.end.index - ref.start.index);
      if (str_eq(sym->name, "this") && size==1) {
        ref=(std_span_Span){.start=ref.start, .end=ref.start};
      }
      std_value_Value_push(obj, compiler_lsp_cli_utils_gen_span_json_with_filename(ref, loc));
    }
  }
  return obj;
}

void compiler_lsp_cli_utils_gen_completions_from_scope(compiler_ast_scopes_Scope *scope, std_value_Value *completions, compiler_types_Type *hint_type, std_set_Set__2 *seen) {
  if (!(((bool)scope))) {
    return;
  }
  if (((bool)hint_type) && hint_type->base==compiler_types_BaseType_Enum) {
    compiler_ast_nodes_Enum *enom = hint_type->u.enom;
    for (std_vector_Iterator__20 _i19 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i19); std_vector_Iterator__20_next(&_i19)) {
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i19);
      {
        compiler_lsp_cli_utils_insert_completion_item(completions, variant->sym, seen, NULL);
      }
    }
  }
  for (std_map_ValueIterator__5 _i20 = std_map_Map__5_iter_values(scope->items); std_map_ValueIterator__5_has_value(&_i20); std_map_ValueIterator__5_next(&_i20)) {
    compiler_ast_scopes_Symbol *item = std_map_ValueIterator__5_cur(&_i20);
    {
      compiler_types_Type *item_type = compiler_lsp_cli_utils_get_symbol_typedef(item);
      if (((bool)hint_type) && !(compiler_types_Type_eq(item_type, hint_type, false))) {
        continue;
      }
      compiler_lsp_cli_utils_insert_completion_item(completions, item, seen, NULL);
    }
  }
  compiler_lsp_cli_utils_gen_completions_from_scope(scope->parent, completions, hint_type, seen);
}

void compiler_lsp_cli_utils_gen_completion_items_from_ns(std_value_Value *completions, compiler_ast_program_Namespace *ns, std_set_Set__2 *seen) {
  for (std_map_ValueIterator__4 _i21 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i21); std_map_ValueIterator__4_next(&_i21)) {
    compiler_ast_program_Namespace *it = std_map_ValueIterator__4_cur(&_i21);
    {
      std_set_Set__2_add(seen, it->sym->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->sym, seen, NULL);
    }
  }
  for (std_vector_Iterator__13 _i22 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i22); std_vector_Iterator__13_next(&_i22)) {
    compiler_ast_nodes_Structure *it = std_vector_Iterator__13_cur(&_i22);
    {
      std_set_Set__2_add(seen, it->sym->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->sym, seen, NULL);
    }
  }
  for (std_vector_Iterator__15 _i23 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i23); std_vector_Iterator__15_next(&_i23)) {
    compiler_ast_nodes_AST *it = std_vector_Iterator__15_cur(&_i23);
    {
      std_set_Set__2_add(seen, it->resolved_symbol->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->resolved_symbol, seen, NULL);
    }
  }
  for (std_vector_Iterator__15 _i24 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i24); std_vector_Iterator__15_next(&_i24)) {
    compiler_ast_nodes_AST *it = std_vector_Iterator__15_cur(&_i24);
    {
      std_set_Set__2_add(seen, it->resolved_symbol->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->resolved_symbol, seen, NULL);
    }
  }
  for (std_vector_Iterator__14 _i25 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i25); std_vector_Iterator__14_next(&_i25)) {
    compiler_ast_nodes_Enum *it = std_vector_Iterator__14_cur(&_i25);
    {
      std_set_Set__2_add(seen, it->sym->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->sym, seen, NULL);
    }
  }
  for (std_map_Iterator__2 _i26 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i26); std_map_Iterator__2_next(&_i26)) {
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i26);
    {
      std_set_Set__2_add(seen, it->value->sym->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->value->sym, seen, it->key);
    }
  }
  for (std_map_Iterator__5 _i27 = std_map_Map__5_iter(ns->exported_symbols); std_map_Iterator__5_has_value(&_i27); std_map_Iterator__5_next(&_i27)) {
    std_map_Item__5 *it = std_map_Iterator__5_cur(&_i27);
    {
      std_set_Set__2_add(seen, it->value->name);
      compiler_lsp_cli_utils_insert_completion_item(completions, it->value, seen, it->key);
    }
  }
  for (std_vector_Iterator__8 _i28 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i28); std_vector_Iterator__8_next(&_i28)) {
    compiler_ast_nodes_Function *it = std_vector_Iterator__8_cur(&_i28);
    {
      if (it->kind != compiler_ast_nodes_FunctionKind_Method) {
        std_set_Set__2_add(seen, it->sym->name);
        compiler_lsp_cli_utils_insert_completion_item(completions, it->sym, seen, NULL);
      }
    }
  }
  if (!((ns->is_a_file && !(ns->is_dir_with_mod)))) {
    char *ns_path = ns->path;
    for (std_fs_DirectoryIterator _i29 = std_fs_iterate_directory(ns_path, true); std_fs_DirectoryIterator_has_value(&_i29); std_fs_DirectoryIterator_next(&_i29)) {
      std_fs_DirectoryEntry entry = std_fs_DirectoryIterator_cur(&_i29);
      {
        if (std_set_Set__2_contains(seen, entry.name)) {
          continue;
        }
        char *path = std_format("%s/%s", ns_path, entry.name);
        if (std_fs_file_exists(path) && str_ends_with(path, ".oc")) {
          char *name = strdup(entry.name);
          name[(strlen(name) - 3)]='\0';
          if (str_eq(name, "mod") || std_set_Set__2_contains(seen, name)) {
            /* defers */
            str_free(&path);
            continue;
          }
          std_value_Value *item = std_value_Value_new(std_value_ValueType_Dictionary);
          std_value_Value_insert_str(item, "label", name);
          std_value_Value_insert_str(item, "kind", "field");
          std_value_Value_insert_str(item, "insertText", name);
          std_value_Value_insert_str(item, "detail", "(file)");
          std_value_Value_push(completions, item);
        }
        if (std_fs_directory_exists(path)) {
          std_value_Value *item = std_value_Value_new(std_value_ValueType_Dictionary);
          std_value_Value_insert_str(item, "label", entry.name);
          std_value_Value_insert_str(item, "kind", "field");
          std_value_Value_insert_str(item, "insertText", entry.name);
          std_value_Value_insert_str(item, "detail", "(directory)");
          std_value_Value_push(completions, item);
        }
        /* defers */
        str_free(&path);
      }
    }
  }
}

void compiler_lsp_cli_utils_gen_completions_from_symbol(compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node, std_value_Value *completions, std_set_Set__2 *seen) {
switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_622_0:
      {
        if (((bool)node) && (node->type != compiler_ast_nodes_ASTType_NSLookup)) {
          for (std_vector_Iterator__4 _i30 = std_vector_Vector__4_iter(sym->u.struc->fields); std_vector_Iterator__4_has_value(&_i30); std_vector_Iterator__4_next(&_i30)) {
            compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i30);
            {
              compiler_lsp_cli_utils_insert_completion_item(completions, field->sym, seen, NULL);
            }
          }
        }
        for (std_map_ValueIterator__9 _i31 = std_map_Map__9_iter_values(sym->u.struc->type->methods); std_map_ValueIterator__9_has_value(&_i31); std_map_ValueIterator__9_next(&_i31)) {
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__9_cur(&_i31);
          {
            compiler_lsp_cli_utils_insert_completion_item(completions, mth->sym, seen, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_622_1:
      {
        for (std_map_ValueIterator__9 _i32 = std_map_Map__9_iter_values(sym->u.type_def->methods); std_map_ValueIterator__9_has_value(&_i32); std_map_ValueIterator__9_next(&_i32)) {
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__9_cur(&_i32);
          {
            compiler_lsp_cli_utils_insert_completion_item(completions, mth->sym, seen, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_622_2:
      {
        if (((bool)node) && node->type==compiler_ast_nodes_ASTType_NSLookup) {
          for (std_vector_Iterator__20 _i33 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i33); std_vector_Iterator__20_next(&_i33)) {
            compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i33);
            {
              compiler_lsp_cli_utils_insert_completion_item(completions, variant->sym, seen, NULL);
            }
          }
        }
        for (std_map_ValueIterator__9 _i34 = std_map_Map__9_iter_values(sym->u.enom->type->methods); std_map_ValueIterator__9_has_value(&_i34); std_map_ValueIterator__9_next(&_i34)) {
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__9_cur(&_i34);
          {
            compiler_lsp_cli_utils_insert_completion_item(completions, mth->sym, seen, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Variable:
    m_622_3:
      {
        compiler_types_Type *typ = compiler_lsp_cli_utils_get_symbol_typedef(sym);
        if ((((bool)typ) && !(compiler_types_Type_can_have_methods(typ))) && typ->base==compiler_types_BaseType_Pointer) {
          typ=typ->u.ptr;
        }
        if (((bool)typ) && ((bool)typ->sym)) {
          compiler_lsp_cli_utils_gen_completions_from_symbol(typ->sym, node, completions, seen);
        }
      } break;
    case compiler_ast_scopes_SymbolType_Namespace:
    m_622_4:
      {
        compiler_lsp_cli_utils_gen_completion_items_from_ns(completions, sym->u.ns, seen);
      } break;
    default:
      {
        if (compiler_lsp_cli_utils_verbose) {
          printf("gen_completions_json: unhandled symbol type: %s\n", compiler_ast_scopes_SymbolType_dbg(sym->type));
        }
      } break;
  }}

std_value_Value *compiler_lsp_cli_utils_gen_completions_json(compiler_lsp_cli_finder_Finder *finder) {
  compiler_ast_nodes_AST *node = finder->found_node;
  if (!(((bool)node))) {
    return NULL;
  }
  std_value_Value *completions = std_value_Value_new(std_value_ValueType_List);
  compiler_types_Type *hint_type = node->hint;
  compiler_ast_scopes_Symbol *sym = ({compiler_ast_scopes_Symbol *__yv_623;
switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Member:
      m_624_0:
        {
          __yv_623 = node->u.member.lhs->resolved_symbol;
          goto _l___yv_623;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_624_1:
        {
          __yv_623 = node->u.lookup.lhs->resolved_symbol;
          goto _l___yv_623;
        } break;
      case compiler_ast_nodes_ASTType_Import:
      m_624_2:
        {
          __yv_623 = finder->found_import_ns->sym;
          goto _l___yv_623;
        } break;
      default:
        {
          __yv_623 = NULL;
          goto _l___yv_623;
        } break;
    }
_l___yv_623:
  __yv_623;});
  std_set_Set__2 *seen = std_set_Set__2_new();
  if (((bool)sym)) {
    compiler_lsp_cli_utils_gen_completions_from_symbol(sym, node, completions, seen);
  } else {
    compiler_lsp_cli_utils_gen_completions_from_scope(finder->found_scope, completions, hint_type, seen);
  }  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert(obj, "completions", completions);
  /* defers */
  std_set_Set__2_free(seen);
  return obj;
}

std_value_Value *compiler_lsp_cli_utils_gen_inlay_hint(compiler_ast_nodes_Variable *var, char *path) {
  if (((bool)var->parsed_type)) {
    return NULL;
  }
  std_value_Value *msg = std_value_Value_new(std_value_ValueType_Dictionary);
  std_value_Value_insert_str(msg, "severity", "InlayType");
  if (((bool)var->type)) {
    char *hint_type = compiler_lsp_cli_utils_gen_type_string(var->type, true);
    std_value_Value_insert_str(msg, "type", hint_type);
  } else {
    std_value_Value_insert_str(msg, "type", "???");
  }
  std_span_Location loc = (std_span_Location){.filename=path, .line=0, .col=0, .index=0};
  std_value_Value_insert(msg, "span", compiler_lsp_cli_utils_gen_span_json_with_filename(var->sym->span, loc));
  return msg;
}

compiler_lsp_cli_finder_Finder compiler_lsp_cli_finder_Finder_make(compiler_lsp_cli_CommandType cmd, std_span_Location loc) {
  compiler_lsp_cli_finder_Finder finder = {0};
  finder.cmd=cmd;
  finder.loc=loc;
  finder.scopes=std_vector_Vector__2_new(16);
  return finder;
}

bool compiler_lsp_cli_finder_Finder_find_in_identifier(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node) {
  compiler_ast_nodes_Identifier *ident = &node->u.ident;
  if (std_span_Span_contains_loc(node->span, this->loc)) {
    return compiler_lsp_cli_finder_Finder_set_usage(this, node->resolved_symbol, node);
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_var(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_Variable *var, compiler_ast_nodes_AST *node) {
  if (((bool)var->sym) && std_span_Span_contains_loc(var->sym->span, this->loc)) {
    return compiler_lsp_cli_finder_Finder_set_usage(this, var->sym, node);
  }
  if (((bool)var->parsed_type) && compiler_lsp_cli_finder_Finder_find_in_type(this, var->parsed_type)) {
    return true;
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_set_usage(compiler_lsp_cli_finder_Finder *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node) {
  this->found_sym=sym;
  this->found_node=node;
  if(!(this->scopes->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/cli/finder.oc:71:12: Assertion failed: `.scopes.size > 0`", "No scopes to set"); }
  this->found_scope=std_vector_Vector__2_back(this->scopes, 0);
  if (this->cmd==compiler_lsp_cli_CommandType_Completions) {
    return true;
  }
  return ((bool)sym);
}

bool compiler_lsp_cli_finder_Finder_find_in_literal(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node) {
  if (std_span_Span_contains_loc(node->span, this->loc)) {
    if (((bool)node->etype)) {
      return compiler_lsp_cli_finder_Finder_set_usage(this, node->etype->sym, node);
    }
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_find_signature_help(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__9 *args, u32 param_idx) {
  if (this->cmd != compiler_lsp_cli_CommandType_SignatureHelp) {
    return false;
  }
  if (!(std_span_Span_contains_loc(node->span, this->loc))) {
    return false;
  }
  compiler_ast_scopes_Symbol *func = node->u.call.callee->resolved_symbol;
  if (!(((bool)func))) {
    return false;
  }
  std_vector_Vector__4 *params = ({std_vector_Vector__4 *__yv_625;
switch ((func->type)) {
      case compiler_ast_scopes_SymbolType_Function:
      m_626_0:
        {
          __yv_625 = func->u.func->params;
          goto _l___yv_625;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_626_1:
        {
          __yv_625 = func->u.struc->fields;
          goto _l___yv_625;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_626_2:
        {
          compiler_types_Type *var_type = func->u.var->type;
          if (!(((bool)var_type)) || (var_type->base != compiler_types_BaseType_FunctionPtr)) {
            return false;
          }
          __yv_625 = func->u.var->type->u.func.params;
          goto _l___yv_625;
        } break;
      default:
        {
          return false;
        } break;
    }
_l___yv_625:
  __yv_625;});
  if (param_idx > params->size) {
    return false;
  }
  if (param_idx==0) {
    std_span_Span open_paren_span = node->u.call.open_paren_span;
    open_paren_span.end.col+=1;
    if (std_span_Span_contains_loc(open_paren_span, this->loc)) {
      this->active_param=0;
      this->call=node;
      return true;
    }
  } else {
    compiler_ast_nodes_Argument *prev_arg = std_vector_Vector__9_at(args, (param_idx - 1));
    std_span_Span arg_span = (((bool)prev_arg->label) ? std_span_Span_join(prev_arg->label_span, prev_arg->expr->span) : prev_arg->expr->span);
    if (std_span_Span_contains_loc(arg_span, this->loc)) {
      this->active_param=(param_idx - 1);
      this->call=node;
      return true;
    }
    std_span_Span close_paren_span = node->u.call.close_paren_span;
    std_span_Span mid_span = (std_span_Span){.start=arg_span.end, .end=close_paren_span.start};
    if (std_span_Span_contains_loc(mid_span, this->loc)) {
      this->active_param=param_idx;
      this->call=node;
      return true;
    }
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_call_args(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__9 *args) {
  if (compiler_lsp_cli_finder_Finder_find_signature_help(this, node, args, args->size)) {
    return true;
  }
  for (u32 i = 0; i < args->size; i+=1) {
    compiler_ast_nodes_Argument *arg = std_vector_Vector__9_at(args, i);
    if (((bool)arg->label) && std_span_Span_contains_loc(arg->label_span, this->loc)) {
      compiler_types_Type *callee_type = node->u.call.callee->etype;
      if (((bool)callee_type)) {
        compiler_ast_nodes_Variable *found = NULL;
        for (std_vector_Iterator__4 _i35 = std_vector_Vector__4_iter(callee_type->sym->u.func->params); std_vector_Iterator__4_has_value(&_i35); std_vector_Iterator__4_next(&_i35)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i35);
          {
            if (str_eq(param->sym->name, arg->label)) {
              found=param;
              break;
            }
          }
        }
        compiler_lsp_cli_finder_Finder_set_usage(this, found->sym, node);
      }
      return true;
    }
    if (compiler_lsp_cli_finder_Finder_find_in_expression(this, arg->expr)) {
      return true;
    }
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_expression(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node) {
  if (!(((bool)node))) {
    return false;
  }
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    case compiler_ast_nodes_ASTType_FloatLiteral:
    case compiler_ast_nodes_ASTType_BoolLiteral:
    case compiler_ast_nodes_ASTType_StringLiteral:
    case compiler_ast_nodes_ASTType_CharLiteral:
    case compiler_ast_nodes_ASTType_Null:
    m_627_0:
      {
        return compiler_lsp_cli_finder_Finder_find_in_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_627_1:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_627_2:
      {
        compiler_ast_nodes_FormatString *fmt = &node->u.fmt_str;
        for (u32 i = 0; i < fmt->exprs->size; i+=1) {
          if (compiler_lsp_cli_finder_Finder_find_in_expression(this, std_vector_Vector__15_at(fmt->exprs, i))) {
            return true;
          }
        }
        return compiler_lsp_cli_finder_Finder_find_in_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    m_627_3:
      {
        return compiler_lsp_cli_finder_Finder_find_in_identifier(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Member:
    case compiler_ast_nodes_ASTType_TryMember:
    m_627_4:
      {
        char *rhs = node->u.member.rhs_name;
        if ((!(((bool)rhs)) && this->cmd==compiler_lsp_cli_CommandType_Completions) && std_span_Span_contains_loc(node->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, node->u.member.lhs->resolved_symbol, node);
        }
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.member.lhs)) {
          return true;
        }
        if (std_span_Span_contains_loc(node->u.member.rhs_span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_627_5:
      {
        return compiler_lsp_cli_finder_Finder_find_in_function(this, node->u.closure);
      } break;
    case compiler_ast_nodes_ASTType_NSLookup:
    m_627_6:
      {
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.lookup.lhs)) {
          return true;
        }
        char *rhs = node->u.member.rhs_name;
        if (!(((bool)rhs)) && std_span_Span_contains_loc(node->span, this->loc)) {
          bool res = compiler_lsp_cli_finder_Finder_set_usage(this, node->u.member.lhs->resolved_symbol, node);
          return res;
        }
        if (std_span_Span_contains_loc(node->u.member.rhs_span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_627_7:
      {
        compiler_ast_nodes_AST *lhs = node->u.binary.lhs;
        compiler_ast_nodes_AST *rhs = node->u.binary.rhs;
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, lhs) || compiler_lsp_cli_finder_Finder_find_in_expression(this, rhs);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_627_8:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.unary.expr);
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    case compiler_ast_nodes_ASTType_Yield:
    m_627_9:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_627_10:
      {
        compiler_ast_nodes_FuncCall *call = &node->u.call;
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, call->callee)) {
          return true;
        }
        if (compiler_lsp_cli_finder_Finder_find_in_call_args(this, node, call->args)) {
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_627_11:
      {
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.cast.lhs)) {
          return true;
        }
        return compiler_lsp_cli_finder_Finder_find_in_type(this, node->u.cast.parsed_to);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_627_12:
      {
        return compiler_lsp_cli_finder_Finder_find_in_type(this, node->u.size_of_type);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_627_13:
      {
        compiler_ast_nodes_IfStatement *stmt = &node->u.if_stmt;
        for (std_vector_Iterator__23 _i36 = std_vector_Vector__23_iter(stmt->branches); std_vector_Iterator__23_has_value(&_i36); std_vector_Iterator__23_next(&_i36)) {
          compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i36);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_expression(this, branch.cond)) {
              return true;
            }
            if (compiler_lsp_cli_finder_Finder_find_in_statement(this, branch.body)) {
              return true;
            }
          }
        }
        if (((bool)stmt->els) && compiler_lsp_cli_finder_Finder_find_in_statement(this, stmt->els)) {
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_627_14:
      {
        compiler_ast_nodes_Match *stmt = &node->u.match_stmt;
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, stmt->expr)) {
          return true;
        }
        for (std_vector_Iterator__24 _i37 = std_vector_Vector__24_iter(stmt->cases); std_vector_Iterator__24_has_value(&_i37); std_vector_Iterator__24_next(&_i37)) {
          compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i37);
          {
            for (std_vector_Iterator__6 _i38 = std_vector_Vector__6_iter(_case.conds); std_vector_Iterator__6_has_value(&_i38); std_vector_Iterator__6_next(&_i38)) {
              compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__6_cur(&_i38);
              {
                if (compiler_lsp_cli_finder_Finder_find_in_expression(this, cond->expr)) {
                  return true;
                }
                if (((bool)cond->args)) {
                  for (std_vector_Iterator__19 _i39 = std_vector_Vector__19_iter(cond->args); std_vector_Iterator__19_has_value(&_i39); std_vector_Iterator__19_next(&_i39)) {
                    compiler_ast_nodes_MatchCondArg *arg = std_vector_Iterator__19_cur(&_i39);
                    {
                      if (compiler_lsp_cli_finder_Finder_find_in_var(this, arg->var, node)) {
                        return true;
                      }
                    }
                  }
                }
              }
            }
            if (((bool)_case.body) && compiler_lsp_cli_finder_Finder_find_in_statement(this, _case.body)) {
              return true;
            }
          }
        }
        if (((bool)stmt->defolt) && compiler_lsp_cli_finder_Finder_find_in_statement(this, stmt->defolt)) {
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_627_15:
      {
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_627_16:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.assertion.expr);
      } break;
    case compiler_ast_nodes_ASTType_Specialization:
    m_627_17:
      {
        compiler_ast_nodes_Specialization *spec = &node->u.spec;
        if (compiler_lsp_cli_finder_Finder_find_in_expression(this, spec->base)) {
          return true;
        }
        for (std_vector_Iterator__0 _i40 = std_vector_Vector__0_iter(spec->parsed_template_args); std_vector_Iterator__0_has_value(&_i40); std_vector_Iterator__0_next(&_i40)) {
          compiler_types_Type *ty = std_vector_Iterator__0_cur(&_i40);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_type(this, ty)) {
              return true;
            }
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_627_18:
      {
        return compiler_lsp_cli_finder_Finder_find_in_block(this, node);
      } break;
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_627_19:
      {
        std_span_Span op_span = node->u.operator_span;
        if (std_span_Span_contains_loc(op_span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_627_20:
      {
        for (std_vector_Iterator__15 _i41 = std_vector_Vector__15_iter(node->u.array_literal.elements); std_vector_Iterator__15_has_value(&_i41); std_vector_Iterator__15_next(&_i41)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i41);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_expression(this, elem)) {
              return true;
            }
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_VectorLiteral:
    m_627_21:
      {
        for (std_vector_Iterator__15 _i42 = std_vector_Vector__15_iter(node->u.vec_literal.elements); std_vector_Iterator__15_has_value(&_i42); std_vector_Iterator__15_next(&_i42)) {
          compiler_ast_nodes_AST *elem = std_vector_Iterator__15_cur(&_i42);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_expression(this, elem)) {
              return true;
            }
          }
        }
        if (std_span_Span_contains_loc(node->u.vec_literal.start_span, this->loc)) {
          if (((bool)node->u.vec_literal.vec_struc)) {
            return compiler_lsp_cli_finder_Finder_set_usage(this, node->u.vec_literal.vec_struc->sym, node);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_MapLiteral:
    m_627_22:
      {
        for (std_vector_Iterator__25 _i43 = std_vector_Vector__25_iter(node->u.map_literal.elements); std_vector_Iterator__25_has_value(&_i43); std_vector_Iterator__25_next(&_i43)) {
          compiler_ast_nodes_MapLiteralPair elem = std_vector_Iterator__25_cur(&_i43);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_expression(this, elem.key)) {
              return true;
            }
            if (compiler_lsp_cli_finder_Finder_find_in_expression(this, elem.value)) {
              return true;
            }
          }
        }
        if (std_span_Span_contains_loc(node->u.map_literal.start_span, this->loc)) {
          if (((bool)node->u.map_literal.map_struc)) {
            return compiler_lsp_cli_finder_Finder_set_usage(this, node->u.map_literal.map_struc->sym, node);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Error:
    m_627_23:
      {
        if (std_span_Span_contains_loc(node->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    default:
      {
        if (compiler_lsp_cli_utils_verbose) {
          printf("Unhandled node type in Finder::find_in_expression: %s""\n", compiler_ast_nodes_ASTType_dbg(node->type));
        }
      } break;
  }  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_import_part(compiler_lsp_cli_finder_Finder *this, compiler_ast_scopes_Symbol *base, compiler_ast_nodes_ImportPart *part, compiler_ast_nodes_AST *node) {
  return ({bool __yv_628;
switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Single:
      m_629_0:
        {
          if (std_span_Span_contains_loc(part->span, this->loc)) {
            return compiler_lsp_cli_finder_Finder_set_usage(this, part->resolved_symbol, node);
          }
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_629_1:
        {
          compiler_ast_nodes_ImportPartMultiple *multi = &part->u.multiple;
          for (std_vector_Iterator__22 _i44 = std_vector_Vector__22_iter(multi->paths); std_vector_Iterator__22_has_value(&_i44); std_vector_Iterator__22_next(&_i44)) {
            std_vector_Vector__7 *subpath = std_vector_Iterator__22_cur(&_i44);
            {
              compiler_ast_scopes_Symbol *prev = base;
              for (std_vector_Iterator__7 _i45 = std_vector_Vector__7_iter(subpath); std_vector_Iterator__7_has_value(&_i45); std_vector_Iterator__7_next(&_i45)) {
                compiler_ast_nodes_ImportPart *subpart = std_vector_Iterator__7_cur(&_i45);
                {
                  if (compiler_lsp_cli_finder_Finder_find_in_import_part(this, prev, subpart, node)) {
                    if (((bool)prev) && prev->type==compiler_ast_scopes_SymbolType_Namespace) {
                      this->found_import_ns=prev->u.ns;
                    }
                    return true;
                  }
                  prev=subpart->resolved_symbol;
                }
              }
            }
          }
          std_span_Span multi_span = std_span_Span_join(multi->open_curly_span, multi->close_curly_span);
          if (std_span_Span_contains_loc(multi_span, this->loc)) {
            compiler_lsp_cli_finder_Finder_set_usage(this, NULL, node);
            if (((bool)base) && base->type==compiler_ast_scopes_SymbolType_Namespace) {
              this->found_import_ns=base->u.ns;
            }
            return true;
          }
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_629_2:
        {
          __yv_628 = false;
          goto _l___yv_628;
        } break;
    }
_l___yv_628:
  __yv_628;});}

bool compiler_lsp_cli_finder_Finder_find_in_statement(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node) {
switch ((node->type)) {
    case compiler_ast_nodes_ASTType_While:
    case compiler_ast_nodes_ASTType_For:
    m_630_0:
      {
        compiler_ast_nodes_Loop *loop = &node->u.loop;
        if (((bool)loop->init) && compiler_lsp_cli_finder_Finder_find_in_statement(this, loop->init)) {
          return true;
        }
        if (((bool)loop->cond) && compiler_lsp_cli_finder_Finder_find_in_expression(this, loop->cond)) {
          return true;
        }
        if (((bool)loop->step) && compiler_lsp_cli_finder_Finder_find_in_expression(this, loop->step)) {
          return true;
        }
        if (((bool)loop->body) && compiler_lsp_cli_finder_Finder_find_in_statement(this, loop->body)) {
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_630_1:
      {
        compiler_ast_nodes_Variable *decl = node->u.var_decl;
        if (((bool)decl) && compiler_lsp_cli_finder_Finder_find_in_var(this, decl, node)) {
          return true;
        }
        if (((bool)decl->default_value) && compiler_lsp_cli_finder_Finder_find_in_expression(this, decl->default_value)) {
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_630_2:
      {
        return compiler_lsp_cli_finder_Finder_find_in_block(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Return:
    m_630_3:
      {
        return ((bool)node->u.ret.expr) && compiler_lsp_cli_finder_Finder_find_in_expression(this, node->u.ret.expr);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_630_4:
      {
        compiler_ast_nodes_Import path = node->u.import_path;
        compiler_ast_scopes_Symbol *prev = path.root_sym;
        for (std_vector_Iterator__7 _i46 = std_vector_Vector__7_iter(path.parts); std_vector_Iterator__7_has_value(&_i46); std_vector_Iterator__7_next(&_i46)) {
          compiler_ast_nodes_ImportPart *part = std_vector_Iterator__7_cur(&_i46);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_import_part(this, prev, part, node)) {
              if (((bool)prev) && prev->type==compiler_ast_scopes_SymbolType_Namespace) {
                this->found_import_ns=prev->u.ns;
              }
              return true;
            }
            prev=part->resolved_symbol;
          }
        }
      } break;
    default:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, node);
      } break;
  }  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_block(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_AST *node) {
  std_vector_Vector__2_push(this->scopes, node->u.block.scope);
  std_vector_Vector__15 *stmts = node->u.block.statements;
  for (u32 i = 0; i < stmts->size; i+=1) {
    if (compiler_lsp_cli_finder_Finder_find_in_statement(this, std_vector_Vector__15_at(stmts, i))) {
      return true;
    }
  }
  if (this->cmd==compiler_lsp_cli_CommandType_Completions && std_span_Span_contains_loc(node->span, this->loc)) {
    return compiler_lsp_cli_finder_Finder_set_usage(this, NULL, node);
  }
  std_vector_Vector__2_pop(this->scopes);
  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_type(compiler_lsp_cli_finder_Finder *this, compiler_types_Type *type) {
switch ((type->base)) {
    case compiler_types_BaseType_Pointer:
    m_631_0:
      {
        return compiler_lsp_cli_finder_Finder_find_in_type(this, type->u.ptr);
      } break;
    case compiler_types_BaseType_Array:
    m_631_1:
      {
        if (((bool)type->u.arr.size_expr) && compiler_lsp_cli_finder_Finder_find_in_expression(this, type->u.arr.size_expr)) {
          return true;
        }
        return compiler_lsp_cli_finder_Finder_find_in_type(this, type->u.arr.elem_type);
      } break;
    case compiler_types_BaseType_Unresolved:
    m_631_2:
      {
        return compiler_lsp_cli_finder_Finder_find_in_expression(this, type->u.unresolved);
      } break;
    case compiler_types_BaseType_UnresolvedTemplate:
    m_631_3:
      {
        compiler_types_UnresolvedTemplate spec = type->u.unresolved_spec;
        if (compiler_lsp_cli_finder_Finder_find_in_type(this, spec.base)) {
          return true;
        }
        for (std_vector_Iterator__0 _i47 = std_vector_Vector__0_iter(spec.args); std_vector_Iterator__0_has_value(&_i47); std_vector_Iterator__0_next(&_i47)) {
          compiler_types_Type *ty = std_vector_Iterator__0_cur(&_i47);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_type(this, ty)) {
              return true;
            }
          }
        }
      } break;
    case compiler_types_BaseType_FunctionPtr:
    case compiler_types_BaseType_Closure:
    m_631_4:
      {
        compiler_types_FunctionType func = type->u.func;
        for (std_vector_Iterator__4 _i48 = std_vector_Vector__4_iter(func.params); std_vector_Iterator__4_has_value(&_i48); std_vector_Iterator__4_next(&_i48)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i48);
          {
            if (compiler_lsp_cli_finder_Finder_find_in_var(this, param, NULL)) {
              return true;
            }
          }
        }
        if (((bool)func.return_type) && compiler_lsp_cli_finder_Finder_find_in_type(this, func.return_type)) {
          return true;
        }
        if (std_span_Span_contains_loc(type->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
    case compiler_types_BaseType_VectorShorthand:
    m_631_5:
      {
        if (compiler_lsp_cli_finder_Finder_find_in_type(this, type->u.ptr)) {
          return true;
        }
        if (std_span_Span_contains_loc(type->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
    case compiler_types_BaseType_MapShorthand:
    m_631_6:
      {
        if (compiler_lsp_cli_finder_Finder_find_in_type(this, type->u.map_types.key)) {
          return true;
        }
        if (compiler_lsp_cli_finder_Finder_find_in_type(this, type->u.map_types.value)) {
          return true;
        }
        if (std_span_Span_contains_loc(type->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
    default:
      {
        if (std_span_Span_contains_loc(type->span, this->loc)) {
          return compiler_lsp_cli_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
  }  return false;
}

bool compiler_lsp_cli_finder_Finder_find_in_function(compiler_lsp_cli_finder_Finder *this, compiler_ast_nodes_Function *func) {
  if (compiler_ast_nodes_Function_is_template_instance(func)) {
    return false;
  }
  if (std_span_Span_contains_loc(func->sym->span, this->loc)) {
    return compiler_lsp_cli_finder_Finder_set_usage(this, func->sym, NULL);
  }
  if (compiler_lsp_cli_finder_Finder_find_in_expression(this, func->name_ast)) {
    return true;
  }
  std_vector_Vector__2_push(this->scopes, func->scope);
  for (std_vector_Iterator__4 _i49 = std_vector_Vector__4_iter(func->params); std_vector_Iterator__4_has_value(&_i49); std_vector_Iterator__4_next(&_i49)) {
    compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i49);
    {
      if (compiler_lsp_cli_finder_Finder_find_in_var(this, param, NULL)) {
        return true;
      }
    }
  }
  compiler_types_Type *ret_type = func->parsed_return_type;
  if (((bool)ret_type) && compiler_lsp_cli_finder_Finder_find_in_type(this, ret_type)) {
    return true;
  }
  bool res = (((bool)func->body) && compiler_lsp_cli_finder_Finder_find_in_statement(this, func->body));
  std_vector_Vector__2_pop(this->scopes);
  return res;
}

bool compiler_lsp_cli_finder_Finder_find_in_program(compiler_lsp_cli_finder_Finder *this, compiler_ast_program_Namespace *ns) {
  std_vector_Vector__2_push(this->scopes, ns->scope);
  for (std_vector_Iterator__13 _i50 = std_vector_Vector__13_iter(ns->structs); std_vector_Iterator__13_has_value(&_i50); std_vector_Iterator__13_next(&_i50)) {
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__13_cur(&_i50);
    {
      if (((bool)struc->type) && ((bool)struc->type->template_instance)) {
        continue;
      }
      if (std_span_Span_contains_loc(struc->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, struc->sym, NULL);
      }
      for (std_vector_Iterator__4 _i51 = std_vector_Vector__4_iter(struc->fields); std_vector_Iterator__4_has_value(&_i51); std_vector_Iterator__4_next(&_i51)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i51);
        {
          if (compiler_lsp_cli_finder_Finder_find_in_var(this, field, NULL)) {
            return true;
          }
        }
      }
    }
  }
  for (std_vector_Iterator__14 _i52 = std_vector_Vector__14_iter(ns->enums); std_vector_Iterator__14_has_value(&_i52); std_vector_Iterator__14_next(&_i52)) {
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__14_cur(&_i52);
    {
      if (std_span_Span_contains_loc(enom->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, enom->sym, NULL);
      }
      for (std_vector_Iterator__4 _i53 = std_vector_Vector__4_iter(enom->shared_fields); std_vector_Iterator__4_has_value(&_i53); std_vector_Iterator__4_next(&_i53)) {
        compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i53);
        {
          if (compiler_lsp_cli_finder_Finder_find_in_var(this, field, NULL)) {
            return true;
          }
        }
      }
      for (std_vector_Iterator__20 _i54 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i54); std_vector_Iterator__20_next(&_i54)) {
        compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i54);
        {
          if (std_span_Span_contains_loc(variant->sym->span, this->loc)) {
            return compiler_lsp_cli_finder_Finder_set_usage(this, variant->sym, NULL);
          }
          if (((bool)variant->specific_fields)) {
            for (std_vector_Iterator__4 _i55 = std_vector_Vector__4_iter(variant->specific_fields); std_vector_Iterator__4_has_value(&_i55); std_vector_Iterator__4_next(&_i55)) {
              compiler_ast_nodes_Variable *field = std_vector_Iterator__4_cur(&_i55);
              {
                if (compiler_lsp_cli_finder_Finder_find_in_var(this, field, NULL)) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }
  for (std_vector_Iterator__8 _i56 = std_vector_Vector__8_iter(ns->functions); std_vector_Iterator__8_has_value(&_i56); std_vector_Iterator__8_next(&_i56)) {
    compiler_ast_nodes_Function *func = std_vector_Iterator__8_cur(&_i56);
    {
      if (std_span_Span_contains_loc(func->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, func->sym, NULL);
      }
      if (compiler_lsp_cli_finder_Finder_find_in_function(this, func)) {
        return true;
      }
    }
  }
  for (std_vector_Iterator__15 _i57 = std_vector_Vector__15_iter(ns->imports); std_vector_Iterator__15_has_value(&_i57); std_vector_Iterator__15_next(&_i57)) {
    compiler_ast_nodes_AST *import_ = std_vector_Iterator__15_cur(&_i57);
    {
      if (compiler_lsp_cli_finder_Finder_find_in_statement(this, import_)) {
        return true;
      }
    }
  }
  for (std_vector_Iterator__15 _i58 = std_vector_Vector__15_iter(ns->variables); std_vector_Iterator__15_has_value(&_i58); std_vector_Iterator__15_next(&_i58)) {
    compiler_ast_nodes_AST *vardecl = std_vector_Iterator__15_cur(&_i58);
    {
      compiler_ast_nodes_Variable *var = vardecl->u.var_decl;
      if (std_span_Span_contains_loc(var->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, var->sym, NULL);
      }
      compiler_ast_nodes_AST *init = vardecl->u.var_decl->default_value;
      if (((bool)init) && compiler_lsp_cli_finder_Finder_find_in_expression(this, init)) {
        return true;
      }
    }
  }
  for (std_vector_Iterator__15 _i59 = std_vector_Vector__15_iter(ns->constants); std_vector_Iterator__15_has_value(&_i59); std_vector_Iterator__15_next(&_i59)) {
    compiler_ast_nodes_AST *vardecl = std_vector_Iterator__15_cur(&_i59);
    {
      compiler_ast_nodes_Variable *var = vardecl->u.var_decl;
      if (std_span_Span_contains_loc(var->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, var->sym, NULL);
      }
      compiler_ast_nodes_AST *init = vardecl->u.var_decl->default_value;
      if (((bool)init) && compiler_lsp_cli_finder_Finder_find_in_expression(this, init)) {
        return true;
      }
    }
  }
  std_vector_Vector__2_pop(this->scopes);
  for (std_map_ValueIterator__4 _i60 = std_map_Map__4_iter_values(ns->namespaces); std_map_ValueIterator__4_has_value(&_i60); std_map_ValueIterator__4_next(&_i60)) {
    compiler_ast_program_Namespace *child = std_map_ValueIterator__4_cur(&_i60);
    {
      if (std_span_Span_contains_loc(child->sym->span, this->loc)) {
        return compiler_lsp_cli_finder_Finder_set_usage(this, child->sym, NULL);
      }
      if (compiler_lsp_cli_finder_Finder_find_in_program(this, child)) {
        return true;
      }
    }
  }
  return false;
}

bool compiler_lsp_cli_finder_Finder_find(compiler_lsp_cli_finder_Finder *this, compiler_ast_program_Program *program) {
  std_vector_Vector__2_push(this->scopes, program->global->scope);
  return compiler_lsp_cli_finder_Finder_find_in_program(this, program->global);
}

compiler_tokens_Token *compiler_tokens_Token_new(compiler_tokens_TokenType type, std_span_Span span, char *text) {
  compiler_tokens_Token *tok = std_mem_alloc__20(1);
  (*tok)=(compiler_tokens_Token){.type=type, .span=span, .text=text, .suffix=NULL, .seen_newline=false, .comment=NULL, .comment_loc=std_span_Location_default()};
  return tok;
}

compiler_tokens_Token *compiler_tokens_Token_from_type(compiler_tokens_TokenType type, std_span_Span span) {
  return compiler_tokens_Token_new(type, span, "");}

compiler_tokens_Token *compiler_tokens_Token_from_ident(char *text, std_span_Span span) {
  compiler_tokens_TokenType type = compiler_tokens_TokenType_from_text(text);
  return compiler_tokens_Token_new(type, span, text);
}

bool compiler_tokens_Token_is_word(compiler_tokens_Token this) {
  return ({bool __yv_632;
switch ((this.type)) {
      case compiler_tokens_TokenType_Identifier:
      m_633_0:
        {
          __yv_632 = true;
          goto _l___yv_632;
        } break;
      default:
        {
          __yv_632 = (((u64)this.type) > ((u64)compiler_tokens_TokenType_BEGIN_KEYWORDS));
          goto _l___yv_632;
        } break;
    }
_l___yv_632:
  __yv_632;});}

bool compiler_tokens_Token_is_identifier(compiler_tokens_Token this, char *name) {
  return ({bool __yv_634;
switch ((this.type)) {
      case compiler_tokens_TokenType_Identifier:
      m_635_0:
        {
          __yv_634 = str_eq(name, this.text);
          goto _l___yv_634;
        } break;
      default:
        {
          __yv_634 = false;
          goto _l___yv_634;
        } break;
    }
_l___yv_634:
  __yv_634;});}

compiler_tokens_TokenType compiler_tokens_TokenType_from_text(char *text) {
  return ({compiler_tokens_TokenType __yv_636;
    {
      char *__match_var_637 = text;
      if (str_eq(__match_var_637, "and")) {
        __yv_636 = compiler_tokens_TokenType_And;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "as")) {
        __yv_636 = compiler_tokens_TokenType_As;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "assert")) {
        __yv_636 = compiler_tokens_TokenType_Assert;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "break")) {
        __yv_636 = compiler_tokens_TokenType_Break;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "const")) {
        __yv_636 = compiler_tokens_TokenType_Const;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "continue")) {
        __yv_636 = compiler_tokens_TokenType_Continue;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "def")) {
        __yv_636 = compiler_tokens_TokenType_Def;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "defer")) {
        __yv_636 = compiler_tokens_TokenType_Defer;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "else")) {
        __yv_636 = compiler_tokens_TokenType_Else;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "enum")) {
        __yv_636 = compiler_tokens_TokenType_Enum;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "extern")) {
        __yv_636 = compiler_tokens_TokenType_Extern;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "false")) {
        __yv_636 = compiler_tokens_TokenType_False;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "for")) {
        __yv_636 = compiler_tokens_TokenType_For;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "fn")) {
        __yv_636 = compiler_tokens_TokenType_Fn;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "if")) {
        __yv_636 = compiler_tokens_TokenType_If;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "let")) {
        __yv_636 = compiler_tokens_TokenType_Let;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "match")) {
        __yv_636 = compiler_tokens_TokenType_Match;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "namespace")) {
        __yv_636 = compiler_tokens_TokenType_Namespace;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "not")) {
        __yv_636 = compiler_tokens_TokenType_Not;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "null")) {
        __yv_636 = compiler_tokens_TokenType_Null;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "or")) {
        __yv_636 = compiler_tokens_TokenType_Or;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "return")) {
        __yv_636 = compiler_tokens_TokenType_Return;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "sizeof")) {
        __yv_636 = compiler_tokens_TokenType_SizeOf;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "struct")) {
        __yv_636 = compiler_tokens_TokenType_Struct;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "true")) {
        __yv_636 = compiler_tokens_TokenType_True;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "then")) {
        __yv_636 = compiler_tokens_TokenType_Then;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "typedef")) {
        __yv_636 = compiler_tokens_TokenType_TypeDef;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "union")) {
        __yv_636 = compiler_tokens_TokenType_Union;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "import")) {
        __yv_636 = compiler_tokens_TokenType_Import;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "void")) {
        __yv_636 = compiler_tokens_TokenType_Void;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "yield")) {
        __yv_636 = compiler_tokens_TokenType_Yield;
        goto _l___yv_636;
      } else if (str_eq(__match_var_637, "while")) {
        __yv_636 = compiler_tokens_TokenType_While;
        goto _l___yv_636;
      } else  {
        __yv_636 = compiler_tokens_TokenType_Identifier;
        goto _l___yv_636;
      }
    }

_l___yv_636:
  __yv_636;});}

char *compiler_tokens_TokenType_str(compiler_tokens_TokenType this) {
  return ({char *__yv_638;
switch ((this)) {
      case compiler_tokens_TokenType_And:
      m_639_0:
        {
          __yv_638 = "and";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_As:
      m_639_1:
        {
          __yv_638 = "as";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Assert:
      m_639_2:
        {
          __yv_638 = "assert";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Break:
      m_639_3:
        {
          __yv_638 = "break";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Const:
      m_639_4:
        {
          __yv_638 = "const";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Continue:
      m_639_5:
        {
          __yv_638 = "continue";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Def:
      m_639_6:
        {
          __yv_638 = "def";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Defer:
      m_639_7:
        {
          __yv_638 = "defer";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Else:
      m_639_8:
        {
          __yv_638 = "else";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Enum:
      m_639_9:
        {
          __yv_638 = "enum";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Extern:
      m_639_10:
        {
          __yv_638 = "extern";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_False:
      m_639_11:
        {
          __yv_638 = "false";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_For:
      m_639_12:
        {
          __yv_638 = "for";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Fn:
      m_639_13:
        {
          __yv_638 = "fn";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_If:
      m_639_14:
        {
          __yv_638 = "if";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Let:
      m_639_15:
        {
          __yv_638 = "let";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Match:
      m_639_16:
        {
          __yv_638 = "match";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Namespace:
      m_639_17:
        {
          __yv_638 = "namespace";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Not:
      m_639_18:
        {
          __yv_638 = "not";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Null:
      m_639_19:
        {
          __yv_638 = "null";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Or:
      m_639_20:
        {
          __yv_638 = "or";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Return:
      m_639_21:
        {
          __yv_638 = "return";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_SizeOf:
      m_639_22:
        {
          __yv_638 = "sizeof";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Struct:
      m_639_23:
        {
          __yv_638 = "struct";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_True:
      m_639_24:
        {
          __yv_638 = "true";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Then:
      m_639_25:
        {
          __yv_638 = "then";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_TypeDef:
      m_639_26:
        {
          __yv_638 = "typedef";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Union:
      m_639_27:
        {
          __yv_638 = "union";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Import:
      m_639_28:
        {
          __yv_638 = "import";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Void:
      m_639_29:
        {
          __yv_638 = "void";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_Yield:
      m_639_30:
        {
          __yv_638 = "yield";
          goto _l___yv_638;
        } break;
      case compiler_tokens_TokenType_While:
      m_639_31:
        {
          __yv_638 = "while";
          goto _l___yv_638;
        } break;
      default:
        {
          __yv_638 = compiler_tokens_TokenType_dbg(this);
          goto _l___yv_638;
        } break;
    }
_l___yv_638:
  __yv_638;});}

void usage(i32 code, bool full) {
  printf("Usage:""\n");
  printf("   ./ocen [--help] [compile-options] <file>""\n");
  printf("   ./ocen lsp [--help] [lsp-options] <file>""\n");
  printf("   ./ocen lsp-server [--help] [lsp-options] <file>""\n");
  if (!(full)) {
    exit(code);
  }
  printf("--------------------------------------------------------""\n");
  printf("Compile Options:""\n");
  printf("    -o path        Output executable (default: ./out)""\n");
  printf("    -c path        Output C code (default: {out}.c)""\n");
  printf("    --no-stdlid    Don't include the standard library""\n");
  printf("    -e0            Minimal one-line errors""\n");
  printf("    -e1            Error messages with source code (default)""\n");
  printf("    -e2            Error messages with source / hints""\n");
  printf("    -s             Silent mode (no debug output)""\n");
  printf("    -n             Don't compile C code (default: false)""\n");
  printf("    --no-dce       Don't perform dead code elimination""\n");
  printf("    -d             Emit debug information (default: false)""\n");
  printf("    -l path        Directory to search for libraries (can be used multiple times)""\n");
  printf("    --docs path    Output documentation JSON (default: none)""\n");
  printf("    --cflags flags Additional C flags (can be used multiple times)""\n");
  printf("    -h             Display this information""\n");
  printf("    -r <args>      Run executable with arguments (can only be at the end)""\n");
  printf("    --backtrace    Track all calls for generating backtraces""\n");
  printf("    --asan         Compile with address sanitizer""\n");
  exit(code);
}

void save_and_compile_code(compiler_ast_program_Program *program, char *code) {
  if (!(((bool)c_path))) {
    c_path=std_format("%s.c", exec_path);
  }
  std_fs_write_file_str(c_path, code);
  if (!(compile_c)) {
    return;
  }
  std_buffer_Buffer cmd = std_buffer_Buffer_make(16);
  char *c_compiler = getenv("CC");
  if (!(((bool)c_compiler))) {
    c_compiler="gcc";
  }
  std_buffer_Buffer_write_str_f(&cmd, std_format("%s -o %s %s", c_compiler, exec_path, c_path));
  for (std_vector_Iterator__1 _i0 = std_vector_Vector__1_iter(program->c_flags); std_vector_Iterator__1_has_value(&_i0); std_vector_Iterator__1_next(&_i0)) {
    char *flag = std_vector_Iterator__1_cur(&_i0);
    {
      std_buffer_Buffer_write_str(&cmd, " ");
      std_buffer_Buffer_write_str(&cmd, flag);
    }
  }
  for (std_vector_Iterator__1 _i1 = std_vector_Vector__1_iter(extra_c_flags); std_vector_Iterator__1_has_value(&_i1); std_vector_Iterator__1_next(&_i1)) {
    char *flag = std_vector_Iterator__1_cur(&_i1);
    {
      std_buffer_Buffer_write_str(&cmd, " ");
      std_buffer_Buffer_write_str(&cmd, flag);
    }
  }
  if (debug) {
    std_buffer_Buffer_write_str(&cmd, " -ggdb3");
  }
  std_logging_log(std_logging_LogLevel_Info, "%.*s", (cmd).size, (cmd).data);
  i32 exit_code = system(std_buffer_Buffer_str(cmd));
  if (exit_code != 0) {
    std_logging_log(std_logging_LogLevel_Error, "Failed to compile C code");
    exit(1);
  }
}

void run_executable(i32 argc, char **argv) {
  std_buffer_Buffer cmd = std_buffer_Buffer_make(16);
  std_buffer_Buffer_write_str(&cmd, exec_path);
  for (i32 i = 0; i < argc; i++) {
    std_buffer_Buffer_write_str(&cmd, " ");
    std_buffer_Buffer_write_str(&cmd, argv[i]);
  }
  std_logging_log(std_logging_LogLevel_Info, "%.*s", (cmd).size, (cmd).data);
  i32 ret = system(std_buffer_Buffer_str(cmd));
  i32 exit_code = ((ret >> 8) & 255);
  std_logging_log(std_logging_LogLevel_Info, "Exited with code: %d", exit_code);
  exit(exit_code);
}

void parse_args(i32 *argc, char ***argv, compiler_ast_program_Program *program) {
  extra_c_flags=std_vector_Vector__1_new(16);
  while ((*argc) > 0) {
    char *arg = std_shift_args(argc, argv, "here");
    {
      char *__match_var_640 = arg;
      if (str_eq(__match_var_640, "--help")) {
        usage(0, true);
      } else if (str_eq(__match_var_640, "-s")) {
        silent=true;
      } else if (str_eq(__match_var_640, "-d")) {
        debug=true;
      } else if (str_eq(__match_var_640, "-b") || str_eq(__match_var_640, "-bt") || str_eq(__match_var_640, "--backtrace")) {
        backtrace=true;
        debug=true;
      } else if (str_eq(__match_var_640, "-n")) {
        compile_c=false;
      } else if (str_eq(__match_var_640, "--no-dce")) {
        program->keep_all_code=true;
      } else if (str_eq(__match_var_640, "-o")) {
        exec_path=std_shift_args(argc, argv, "here");
      } else if (str_eq(__match_var_640, "-c")) {
        c_path=std_shift_args(argc, argv, "here");
      } else if (str_eq(__match_var_640, "-l")) {
        std_vector_Vector__1_push(program->library_paths, std_shift_args(argc, argv, "here"));
      } else if (str_eq(__match_var_640, "-e0")) {
        error_level=0;
      } else if (str_eq(__match_var_640, "-e1")) {
        error_level=1;
      } else if (str_eq(__match_var_640, "-e2")) {
        error_level=2;
      } else if (str_eq(__match_var_640, "--docs")) {
        docs_path=std_shift_args(argc, argv, "here");
        program->check_doc_links=true;
      } else if (str_eq(__match_var_640, "--no-stdlib")) {
        include_stdlib=false;
      } else if (str_eq(__match_var_640, "--cflags") || str_eq(__match_var_640, "-cf")) {
        std_vector_Vector__1_push(extra_c_flags, std_shift_args(argc, argv, "here"));
      } else if (str_eq(__match_var_640, "-r") || str_eq(__match_var_640, "--run")) {
        run_after_compile=true;
        goto _While_break_641;
      } else if (str_eq(__match_var_640, "-a") || str_eq(__match_var_640, "--asan")) {
        compile_asan=true;
      } else  {
        if (arg[0]=='-') {
          printf("Unknown option: %s""\n", arg);
          usage(1, true);
        } else if (!(((bool)filename))) {
          filename=arg;
        } else {
          printf("Unknown option/argument: '%s'""\n", arg);
          usage(1, true);
        }
      }
    }
  }
  _While_break_641:;
  if (!(((bool)filename))) {
    printf("No file specified""\n");
    usage(1, false);
  }
  if (run_after_compile && !(compile_c)) {
    printf("Cannot run without compiling""\n");
    usage(1, false);
  }
}

void signal_handler(i32 sig) {
  std_logging_log(std_logging_LogLevel_Error, "Received signal %s, exiting compilation", std_signal_Signal_dbg(((i32)sig)));
  longjmp((*global_err_ctx), 1);
}

i32 main(i32 argc, char **argv) {
  bool is_test = false;
  std_shift_args(&argc, &argv, "here");
  if (argc > 0) {
    {
      char *__match_var_642 = argv[0];
      if (str_eq(__match_var_642, "lsp")) {
        return compiler_lsp_cli_main(argc, argv, NULL);
      } else if (str_eq(__match_var_642, "lsp-server")) {
        return compiler_lsp_server_main(argc, argv);
      } else if (str_eq(__match_var_642, "test")) {
        is_test=true;
        std_shift_args(&argc, &argv, "here");
      } else  {
      }
    }
  }
  std_signal_set_signal_handler(SIGSEGV, signal_handler);
  std_signal_set_signal_handler(SIGILL, signal_handler);
  std_signal_set_signal_handler(SIGFPE, signal_handler);
  compiler_ast_program_Program *program = compiler_ast_program_Program_new();
  global_err_ctx=compiler_ast_program_Program_add_error_context(program);
  if (setjmp((*global_err_ctx)) > 0) {
    compiler_ast_program_Program_exit_with_errors_if_any(program);
    exit(1);
  }
  compiler_ast_program_Program_setup_library_paths(program);
  parse_args(&argc, &argv, program);
  std_logging_LogLevel level = ({std_logging_LogLevel __yv_643;
    if (silent) {
      __yv_643 = std_logging_LogLevel_Error;
      goto _l___yv_643;
    } else {
      __yv_643 = std_logging_LogLevel_Info;
      goto _l___yv_643;
    }
_l___yv_643:
  __yv_643;});
  std_logging_init_logging(level, NULL);
  program->error_level=error_level;
  program->gen_debug_info=debug;
  program->include_stdlib=include_stdlib;
  program->backtrace=backtrace;
  program->is_test_mode=is_test;
  compiler_parser_Parser_parse_toplevel(program, filename, NULL, true);
  compiler_passes_run_typecheck_passes(program);
  compiler_ast_program_Program_exit_with_errors_if_any(program);
  if (((bool)docs_path)) {
    compiler_docgen_generate_doc_json(program, docs_path);
  } else {
    char *code = compiler_passes_run_codegen_passes(program);
    compiler_ast_program_Program_exit_with_errors_if_any(program);
    save_and_compile_code(program, code);
    if (run_after_compile || is_test) {
      run_executable(argc, argv);
    }
  }
  return 0;
}

char *compiler_types_BaseType_str(compiler_types_BaseType this) {
  return ({char *__yv_644;
switch ((this)) {
      case compiler_types_BaseType_Char:
      m_645_0:
        {
          __yv_644 = "char";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_Bool:
      m_645_1:
        {
          __yv_644 = "bool";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_Void:
      m_645_2:
        {
          __yv_644 = "void";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_I8:
      m_645_3:
        {
          __yv_644 = "i8";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_I16:
      m_645_4:
        {
          __yv_644 = "i16";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_I32:
      m_645_5:
        {
          __yv_644 = "i32";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_I64:
      m_645_6:
        {
          __yv_644 = "i64";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_U8:
      m_645_7:
        {
          __yv_644 = "u8";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_U16:
      m_645_8:
        {
          __yv_644 = "u16";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_U32:
      m_645_9:
        {
          __yv_644 = "u32";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_U64:
      m_645_10:
        {
          __yv_644 = "u64";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_F32:
      m_645_11:
        {
          __yv_644 = "f32";
          goto _l___yv_644;
        } break;
      case compiler_types_BaseType_F64:
      m_645_12:
        {
          __yv_644 = "f64";
          goto _l___yv_644;
        } break;
      default:
        {
          __yv_644 = compiler_types_BaseType_dbg(this);
          goto _l___yv_644;
        } break;
    }
_l___yv_644:
  __yv_644;});}

bool compiler_types_BaseType_is_callable(compiler_types_BaseType this) {
  return (this==compiler_types_BaseType_FunctionPtr || this==compiler_types_BaseType_Closure);}

compiler_types_Type *compiler_types_Type_shallow_copy(compiler_types_Type *old) {
  compiler_types_Type *new = std_mem_alloc__21(1);
  (*new)=(*old);
  return new;
}

compiler_types_Type *compiler_types_Type_new_resolved(compiler_types_BaseType base, std_span_Span span) {
  compiler_types_Type *type = std_mem_alloc__21(1);
  type->base=base;
  type->span=span;
  type->name=compiler_types_BaseType_str(base);
  type->methods=std_map_Map__9_new(8);
  return type;
}

compiler_types_Type *compiler_types_Type_new_unresolved(char *name, std_span_Span span) {
  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_Unresolved, span);
  type->name=name;
  return type;
}

compiler_types_Type *compiler_types_Type_new_unresolved_base(compiler_types_BaseType base, std_span_Span span) {
  compiler_ast_nodes_AST *ident = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, span);
  ident->u.ident.name=compiler_types_BaseType_str(base);
  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_Unresolved, span);
  type->u.unresolved=ident;
  return type;
}

bool compiler_types_Type_is_integer(compiler_types_Type *this) {
  return ({bool __yv_646;
switch ((this->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      m_647_0:
        {
          __yv_646 = true;
          goto _l___yv_646;
        } break;
      default:
        {
          __yv_646 = false;
          goto _l___yv_646;
        } break;
    }
_l___yv_646:
  __yv_646;});}

bool compiler_types_Type_is_float(compiler_types_Type *this) {
  return (this->base==compiler_types_BaseType_F32 || this->base==compiler_types_BaseType_F64);}

bool compiler_types_Type_is_numeric(compiler_types_Type *this) {
  return ({bool __yv_648;
switch ((this->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_649_0:
        {
          __yv_648 = true;
          goto _l___yv_648;
        } break;
      default:
        {
          __yv_648 = false;
          goto _l___yv_648;
        } break;
    }
_l___yv_648:
  __yv_648;});}

bool compiler_types_Type_is_numeric_or_char(compiler_types_Type *this) {
  return (compiler_types_Type_is_numeric(this) || this->base==compiler_types_BaseType_Char);}

bool compiler_types_Type_can_have_methods(compiler_types_Type *this) {
  return ({bool __yv_650;
switch ((this->base)) {
      case compiler_types_BaseType_Char:
      case compiler_types_BaseType_Bool:
      case compiler_types_BaseType_Void:
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      case compiler_types_BaseType_Structure:
      case compiler_types_BaseType_Alias:
      case compiler_types_BaseType_Enum:
      m_651_0:
        {
          __yv_650 = true;
          goto _l___yv_650;
        } break;
      default:
        {
          __yv_650 = false;
          goto _l___yv_650;
        } break;
    }
_l___yv_650:
  __yv_650;});}

bool compiler_types_Type_is_resolved(compiler_types_Type *this) {
  return ({bool __yv_652;
switch ((this->base)) {
      case compiler_types_BaseType_Unresolved:
      m_653_0:
        {
          __yv_652 = false;
          goto _l___yv_652;
        } break;
      case compiler_types_BaseType_Alias:
      m_653_1:
        {
          __yv_652 = compiler_types_Type_is_resolved(this->u.ptr);
          goto _l___yv_652;
        } break;
      case compiler_types_BaseType_Pointer:
      m_653_2:
        {
          __yv_652 = compiler_types_Type_is_resolved(this->u.ptr);
          goto _l___yv_652;
        } break;
      case compiler_types_BaseType_FunctionPtr:
      m_653_3:
        {
          bool resolved = compiler_types_Type_is_resolved(this->u.func.return_type);
          for (std_vector_Iterator__4 _i61 = std_vector_Vector__4_iter(this->u.func.params); std_vector_Iterator__4_has_value(&_i61); std_vector_Iterator__4_next(&_i61)) {
            compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i61);
            {
              resolved=(resolved && compiler_types_Type_is_resolved(param->type));
            }
          }
          __yv_652 = resolved;
          goto _l___yv_652;
        } break;
      default:
        {
          __yv_652 = true;
          goto _l___yv_652;
        } break;
    }
_l___yv_652:
  __yv_652;});}

bool compiler_types_Type_eq(compiler_types_Type *this, compiler_types_Type *other, bool strict) {
  if (this==NULL && other==NULL) {
    return true;
  }
  if (this==NULL || other==NULL) {
    return false;
  }
  if (this->base==compiler_types_BaseType_Alias) {
    return compiler_types_Type_eq(this->u.ptr, other, strict);
  }
  if (other->base==compiler_types_BaseType_Alias) {
    return compiler_types_Type_eq(this, other->u.ptr, strict);
  }
  if (this->base != other->base) {
    return false;
  }
switch ((this->base)) {
    case compiler_types_BaseType_Error:
    case compiler_types_BaseType_Unresolved:
    case compiler_types_BaseType_UnresolvedTemplate:
    m_654_0:
      {
        return false;
      } break;
    case compiler_types_BaseType_Closure:
    m_654_1:
      {
        return str_eq(this->sym->full_name, other->sym->full_name);
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_654_2:
      {
        compiler_types_FunctionType af = this->u.func;
        compiler_types_FunctionType bf = other->u.func;
        if (!(compiler_types_Type_eq(af.return_type, bf.return_type, true))) {
          return false;
        }
        if (af.params->size != bf.params->size) {
          return false;
        }
        for (u32 i = 0; i < af.params->size; i+=1) {
          compiler_ast_nodes_Variable *a = std_vector_Vector__4_at(af.params, i);
          compiler_ast_nodes_Variable *b = std_vector_Vector__4_at(bf.params, i);
          if (!(compiler_types_Type_eq(a->type, b->type, true))) {
            return false;
          }
        }
        return true;
      } break;
    case compiler_types_BaseType_Pointer:
    m_654_3:
      {
        if (!(strict)) {
          if (this->u.ptr->base==compiler_types_BaseType_Void || other->u.ptr->base==compiler_types_BaseType_Void) {
            return true;
          }
        }
        return compiler_types_Type_eq(this->u.ptr, other->u.ptr, true);
      } break;
    case compiler_types_BaseType_Structure:
    m_654_4:
      {
        return this->u.struc==other->u.struc;
      } break;
    case compiler_types_BaseType_Enum:
    m_654_5:
      {
        return this->u.enom==other->u.enom;
      } break;
    case compiler_types_BaseType_Array:
    m_654_6:
      {
        if (!(compiler_types_Type_eq(this->u.arr.elem_type, other->u.arr.elem_type, true))) {
          return false;
        }
        if (this->u.arr.size_known && other->u.arr.size_known) {
          return this->u.arr.size==other->u.arr.size;
        }
        return true;
      } break;
    default:
      {
        if (((u32)this->base) < ((u32)compiler_types_BaseType_NUM_BASE_TYPES)) {
          return true;
        }
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/types.oc:242:20: Assertion failed: `false`", std_format("Unhandled case in Type::eq(), base = %s", compiler_types_BaseType_dbg(this->base))); exit(1); }
      } break;
  }}

bool compiler_types_Type_is_str(compiler_types_Type *this) {
  return this->base==compiler_types_BaseType_Alias && str_eq(this->sym->full_name, "str");
}

compiler_types_Type *compiler_types_Type_unaliased(compiler_types_Type *this) {
  if (this->base != compiler_types_BaseType_Alias) {
    return this;
  }
  return compiler_types_Type_unaliased(this->u.ptr);
}

compiler_types_Type *compiler_types_Type_decay_array(compiler_types_Type *this) {
  if (this->base != compiler_types_BaseType_Array) {
    return this;
  }
  compiler_types_Type *res = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, this->span);
  res->u.ptr=this->u.arr.elem_type;
  return res;
}

char *compiler_types_Type_str(compiler_types_Type *this) {
  return ({char *__yv_655;
switch ((this->base)) {
      case compiler_types_BaseType_Pointer:
      m_656_0:
        {
          __yv_655 = std_format("&%s", compiler_types_Type_str(this->u.ptr));
          goto _l___yv_655;
        } break;
      case compiler_types_BaseType_Closure:
      case compiler_types_BaseType_FunctionPtr:
      m_656_1:
        {
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);
          if (this->base==compiler_types_BaseType_Closure) {
            std_buffer_Buffer_write_str(&buf, "@");
          }
          std_buffer_Buffer_write_str(&buf, "fn(");
          for (u32 i = 0; i < this->u.func.params->size; i+=1) {
            compiler_ast_nodes_Variable *param = std_vector_Vector__4_at(this->u.func.params, i);
            if (((bool)param->type)) {
              std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(param->type));
            } else {
              std_buffer_Buffer_write_str(&buf, "<unknown>");
            }
            if (i < (this->u.func.params->size - 1)) {
              std_buffer_Buffer_write_str(&buf, ", ");
            }
          }
          std_buffer_Buffer_write_str(&buf, "): ");
          std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(this->u.func.return_type));
          return std_buffer_Buffer_str(buf);
        } break;
      case compiler_types_BaseType_Array:
      m_656_2:
        {
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);
          std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(this->u.arr.elem_type));
          std_buffer_Buffer_write_str(&buf, "[");
          if (this->u.arr.size_known) {
            std_buffer_Buffer_write_str(&buf, std_format("%u", this->u.arr.size));
          } else {
            std_buffer_Buffer_write_str(&buf, std_format("?%p", this));
          }
          std_buffer_Buffer_write_str(&buf, "]");
          return std_buffer_Buffer_str(buf);
        } break;
      case compiler_types_BaseType_Structure:
      m_656_3:
        {
          __yv_655 = this->u.struc->sym->display;
          goto _l___yv_655;
        } break;
      case compiler_types_BaseType_Enum:
      m_656_4:
        {
          __yv_655 = this->u.enom->sym->display;
          goto _l___yv_655;
        } break;
      case compiler_types_BaseType_Alias:
      m_656_5:
        {
          __yv_655 = this->name;
          goto _l___yv_655;
        } break;
      default:
        {
          __yv_655 = compiler_types_BaseType_str(this->base);
          goto _l___yv_655;
        } break;
    }
_l___yv_655:
  __yv_655;});}

char *compiler_errors_MessageType_to_color(compiler_errors_MessageType this) {
  return ({char *__yv_657;
switch ((this)) {
      case compiler_errors_MessageType_Error:
      m_658_0:
        {
          __yv_657 = "\x1b[31m";
          goto _l___yv_657;
        } break;
      case compiler_errors_MessageType_Warning:
      m_658_1:
        {
          __yv_657 = "\x1b[33m";
          goto _l___yv_657;
        } break;
      case compiler_errors_MessageType_Note:
      m_658_2:
        {
          __yv_657 = "\x1b[32m";
          goto _l___yv_657;
        } break;
    }
_l___yv_657:
  __yv_657;});}

char *compiler_errors_MessageType_str(compiler_errors_MessageType this) {
  return ({char *__yv_659;
switch ((this)) {
      case compiler_errors_MessageType_Error:
      m_660_0:
        {
          __yv_659 = "Error";
          goto _l___yv_659;
        } break;
      case compiler_errors_MessageType_Warning:
      m_660_1:
        {
          __yv_659 = "Warning";
          goto _l___yv_659;
        } break;
      case compiler_errors_MessageType_Note:
      m_660_2:
        {
          __yv_659 = "Note";
          goto _l___yv_659;
        } break;
    }
_l___yv_659:
  __yv_659;});}

void compiler_errors_display_line(void) {
  printf("--------------------------------------------------------------------------------""\n");
}

void compiler_errors_display_message(compiler_errors_MessageType type, std_span_Span span, char *msg) {
  compiler_errors_display_line();
  char *filename = span.start.filename;
  if (str_eq(filename, "<default>") || span.start.line==0) {
    printf("%s: %s""\n", compiler_errors_MessageType_str(type), msg);
  } else {
    printf("%s: %s: %s""\n", std_span_Location_str(&span.start), compiler_errors_MessageType_str(type), msg);
  }
  compiler_errors_display_line();
}

void compiler_errors_display_message_span(compiler_errors_MessageType type, std_span_Span span, char *msg, bool line_after) {
  char *color = compiler_errors_MessageType_to_color(type);
  char *reset = "\x1b[0m";
  compiler_errors_display_message(type, span, msg);
  char *filename = span.start.filename;
  if (!(std_fs_file_exists(filename))) {
    return;
  }
  std_buffer_Buffer contents = std_fs_read_file(filename);
  u32 around_offset = 1;
  u32 min_line = u32_max((span.start.line - around_offset), 1);
  u32 max_line = (span.end.line + around_offset);
  max_line=u32_min(max_line, (min_line + 10));
  u32 line_no = 1;
  for (std_sv_SVLineIterator _i107 = std_sv_SV_lines(std_buffer_Buffer_sv(contents)); std_sv_SVLineIterator_has_value(&_i107); std_sv_SVLineIterator_next(&_i107)) {
    std_sv_SV line = std_sv_SVLineIterator_cur(&_i107);
    {
      if (line_no > max_line) {
        break;
      }
      if (line_no >= min_line) {
        printf("%4d | ", line_no);
        if (line_no==span.start.line) {
          u32 start_col = (span.start.col - 1);
          u32 end_col = (span.end.col - 1);
          if (span.end.line != span.start.line) {
            end_col=line.len;
          }
          for (u32 i = 0; i < start_col; i+=1) {
            printf("%c", std_sv_SV_at(line, i));
          }
          printf("%s", color);
          for (u32 i = start_col; i < end_col; i+=1) {
            printf("%c", std_sv_SV_at(line, i));
          }
          std_sv_SV remaining_line = std_sv_SV_slice(line, end_col, 0);
          printf("%s%.*s\n", reset, (remaining_line).len, (remaining_line).data);
          printf("%*s%s^ %s%s""\n", (start_col + 7), "", color, msg, reset);
        } else {
          printf("%.*s\n", (line).len, (line).data);
        }
      }
      line_no+=1;
    }
  }
  if (line_after) {
    compiler_errors_display_line();
  }
  /* defers */
  std_buffer_Buffer_free(&contents);
}

void compiler_errors_Error_display(compiler_errors_Error *this) {
switch ((this->type)) {
    case compiler_errors_ErrorType_Standard:
    m_661_0:
      {
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, true);
      } break;
    case compiler_errors_ErrorType_WithNote:
    m_661_1:
      {
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, false);
        compiler_errors_display_message(compiler_errors_MessageType_Note, this->span1, this->msg2);
      } break;
    case compiler_errors_ErrorType_WithHint:
    m_661_2:
      {
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, false);
        compiler_errors_display_message_span(compiler_errors_MessageType_Note, this->span2, this->msg2, true);
      } break;
  }}

void compiler_errors_Error_panic(compiler_errors_Error *this) {
  compiler_errors_Error_display(this);
  exit(1);
}

compiler_errors_Error *compiler_errors_Error_new(std_span_Span span, char *msg) {
  compiler_errors_Error *err = std_mem_alloc__22(1);
  err->type=compiler_errors_ErrorType_Standard;
  err->msg1=msg;
  err->span1=span;
  return err;
}

compiler_errors_Error *compiler_errors_Error_new_note(std_span_Span span, char *msg, char *note) {
  compiler_errors_Error *err = std_mem_alloc__22(1);
  err->type=compiler_errors_ErrorType_WithNote;
  err->msg1=msg;
  err->span1=span;
  err->msg2=note;
  return err;
}

compiler_errors_Error *compiler_errors_Error_new_hint(std_span_Span span, char *msg, std_span_Span span2, char *hint) {
  compiler_errors_Error *err = std_mem_alloc__22(1);
  err->type=compiler_errors_ErrorType_WithHint;
  err->msg1=msg;
  err->span1=span;
  err->msg2=hint;
  err->span2=span2;
  return err;
}

void compiler_errors_display_error_messages(std_vector_Vector__16 *errors, u32 detail_level) {
  char *num_errors_env = getenv("OCEN_NUM_ERRORS");
  u32 max_num_errors = (((bool)num_errors_env) ? str_to_u32(num_errors_env) : 10);
  u32 num_errors = u32_min(errors->size, max_num_errors);
  for (u32 i = 0; i < num_errors; i+=1) {
    compiler_errors_Error *err = std_vector_Vector__16_at(errors, ((num_errors - i) - 1));
    switch (detail_level) {
      case 0: {
        printf("%s: %s""\n", std_span_Location_str(&err->span1.start), err->msg1);
      } break;
      case 1: {
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, err->span1, err->msg1, true);
      } break;
      case 2: {
        compiler_errors_Error_display(err);
      } break;
      default: std_panic("invalid detail level"); break;
    }
  }
}

void std_panic(char *msg) {
  dump_backtrace();
  fprintf(stderr, "--------------------------------------------------------------------------------""\n");
  fprintf(stderr, "%s""\n", msg);
  oc_trap();
  exit(1);
}

u32 str_to_u32(char *this) {
  return ((u32)atoi(this));}

bool str_eq(char *this, char *other) {
  void *a = ((void *)this);
  void *b = ((void *)other);
  if (a==b) {
    return true;
  }
  if (!((((bool)a) && ((bool)b)))) {
    return false;
  }
  return strcmp(this, other)==0;
}

char *std_format(char *fmt, ...) {
  va_list args = {0};
  va_start(args, fmt);
  u32 size = vsnprintf(NULL, 0, fmt, args);
  va_end(args);
  va_start(args, fmt);
  char *s = std_mem_alloc__19(((u32)(size + 1)));
  vsnprintf(s, (size + 1), fmt, args);
  s[size]='\0';
  va_end(args);
  return s;
}

char *str_substring(char *this, u32 start, u32 len) {
  char *new_str = std_mem_alloc__19(((u32)(len + 1)));
  memcpy(new_str, &this[start], len);
  return new_str;
}

bool str_ends_with(char *this, char *suffix) {
  u32 suffix_len = strlen(suffix);
  u32 len = strlen(this);
  if (suffix_len > len) {
    return false;
  }
  for (u32 i = 0; i < suffix_len; i+=1) {
    if (this[((len - suffix_len) + i)] != suffix[i]) {
      return false;
    }
  }
  return true;
}

bool str_starts_with(char *this, char *prefix) {
  u32 prefix_len = strlen(prefix);
  u32 len = strlen(this);
  if (prefix_len > len) {
    return false;
  }
  for (u32 i = 0; i < prefix_len; i+=1) {
    if (this[i] != prefix[i]) {
      return false;
    }
  }
  return true;
}

void str_strip_trailing_whitespace(char *this) {
  for (u32 i = (strlen(this) - 1); i >= 0; i-=1) {
    if (this[i] != ' ') {
      break;
    }
    this[i]='\0';
  }
}

void str_replace_with(char **this, char *other) {
  std_mem_free((*this));
  (*this)=other;
}

void str_free(char **this) {
  std_mem_free((*this));
  (*this)=NULL;
}

std_CharIterator str_chars(char *this, u32 start) {
  return (std_CharIterator){.data=this, .len=strlen(this), .pos=start};}

bool std_CharIterator_has_value(std_CharIterator *this) {
  return (this->pos < this->len);}

u32 std_CharIterator_next(std_CharIterator *this) {
  return this->pos++;}

char std_CharIterator_cur(std_CharIterator *this) {
  return this->data[this->pos];}

bool char_is_digit(char this) {
  return isdigit(this);}

bool char_is_hex_digit(char this) {
  return isxdigit(this);}

u8 char_get_hex_digit(char this) {
  if (('0' <= this) && (this <= '9')) {
    return ((u8)this) - ((u8)'0');
  }
  if (('a' <= this) && (this <= 'f')) {
    return (((u8)this) - ((u8)'a')) + ((u8)10);
  }
  if (('A' <= this) && (this <= 'F')) {
    return (((u8)this) - ((u8)'A')) + ((u8)10);
  }
  std_panic(std_format("[-] Invalid hex digit: '%c' (0x%02x)", this, this));
}

bool char_is_alnum(char this) {
  return isalnum(this);}

bool char_is_print(char this) {
  return isprint(this);}

u32 u32_min(u32 this, u32 other) {
  return ((this < other) ? this : other);}

u32 u32_max(u32 this, u32 other) {
  return ((this > other) ? this : other);}

char *std_shift_args(i32 *argc, char ***argv, char *where) {
  if ((*argc)==0) {
    printf("Expected argument but got none\n");
    exit(1);
  }
  char *arg = (*argv)[0];
  (*argv)=((*argv) + 1);
  (*argc)=((*argc) - 1);
  return arg;
}

bool std_sv_SV_is_empty(std_sv_SV *this) {
  return this->len==0;}

std_sv_SV std_sv_SV_from_str(char *s) {
  return (std_sv_SV){.data=s, .len=strlen(s)};}

std_sv_SV std_sv_SV_get(std_sv_SV this, u32 n) {
  return (std_sv_SV){.data=this.data, .len=n};}

char std_sv_SV_at(std_sv_SV this, u32 n) {
  if(!(n < this.len)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/sv.oc:30:12: Assertion failed: `n < .len`", "Index out of bounds in SV::at"); }
  return this.data[n];
}

std_sv_SV std_sv_SV_chop_by_delim(std_sv_SV *this, char delim) {
  u32 i = 0;
  while ((i < this->len) && (this->data[i] != delim)) {
    i+=1;
  }
  std_sv_SV res = std_sv_SV_get((*this), i);
  if (i==this->len) {
    this->data=(this->data + i);
    this->len-=i;
  } else {
    this->data=((this->data + i) + 1);
    this->len-=(i + 1);
  }
  return res;
}

std_sv_SV std_sv_SV_chop_by_sv(std_sv_SV *this, std_sv_SV delim) {
  for (u32 i = 0; i < ((this->len - delim.len) + 1); i++) {
    if (memcmp((this->data + i), delim.data, delim.len)==0) {
      std_sv_SV res = std_sv_SV_get((*this), i);
      this->data=((this->data + i) + delim.len);
      this->len-=(i + delim.len);
      return res;
    }
  }
  std_sv_SV res = std_sv_SV_get((*this), this->len);
  this->data=(this->data + this->len);
  this->len=0;
  return res;
}

std_sv_SV std_sv_SV_chop_by_str(std_sv_SV *this, char *delim) {
  return std_sv_SV_chop_by_sv(this, std_sv_SV_from_str(delim));}

u64 std_sv_SV_chop_unsigned(std_sv_SV *this, char *fn_name) {
  char *endptr = "";
  u64 res = strtoul(this->data, &endptr, 10);
  if(!(endptr != this->data)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/sv.oc:140:12: Assertion failed: `endptr != .data`", std_format("Failed to parse number in %s", fn_name)); }
  std_sv_SV_only_chop_left(this, ((u32)(endptr - this->data)));
  return res;
}

u32 std_sv_SV_chop_u32(std_sv_SV *this) {
  return ((u32)std_sv_SV_chop_unsigned(this, "SV::chop_u32"));}

std_sv_SV std_sv_SV_chop_line(std_sv_SV *this) {
  return std_sv_SV_chop_by_delim(this, '\n');}

bool std_sv_SV_eq(std_sv_SV this, std_sv_SV other) {
  return (this.len==other.len && memcmp(this.data, other.data, this.len)==0);}

bool std_sv_SV_eq_str(std_sv_SV this, char *other) {
  return std_sv_SV_eq(this, std_sv_SV_from_str(other));}

u32 std_sv_SV_hash(std_sv_SV this) {
  u32 hash = 5381;
  for (u32 i = 0; i < this.len; i+=1) {
    hash=((hash * 33) ^ ((u32)this.data[i]));
  }
  return hash;
}

void std_sv_SV_only_chop_left(std_sv_SV *this, u32 n) {
  this->data=(this->data + n);
  this->len-=n;
}

bool std_sv_SV_starts_with_sv(std_sv_SV this, std_sv_SV other) {
  if (this.len < other.len) {
    return false;
  }
  for (u32 i = 0; i < other.len; i+=1) {
    if (this.data[i] != other.data[i]) {
      return false;
    }
  }
  return true;
}

bool std_sv_SV_starts_with_str(std_sv_SV this, char *other) {
  return std_sv_SV_starts_with_sv(this, std_sv_SV_from_str(other));}

std_sv_SV std_sv_SV_slice(std_sv_SV this, u32 off, u32 end) {
  if (end==0) {
    end=this.len;
  }
  if (end > this.len) {
    end=this.len;
  }
  if (off >= end) {
    off=end;
  }
  return (std_sv_SV){.data=(this.data + off), .len=(end - off)};
}

std_sv_SVLineIterator std_sv_SV_lines(std_sv_SV this) {
  return (std_sv_SVLineIterator){.sv=this};}

std_sv_SVSplitIterator std_sv_SV_split_str(std_sv_SV this, char *delim) {
  return (std_sv_SVSplitIterator){.sv=this, .delim=std_sv_SV_from_str(delim)};}

char *std_sv_SV_copy_data_to_cstr(std_sv_SV this) {
  char *buf = std_mem_alloc__19((this.len + 1));
  memcpy(buf, this.data, this.len);
  buf[this.len]='\0';
  return buf;
}

bool std_sv_SVLineIterator_has_value(std_sv_SVLineIterator *this) {
  return !(std_sv_SV_is_empty(&this->sv));}

std_sv_SV std_sv_SVLineIterator_cur(std_sv_SVLineIterator *this) {
  return std_sv_SV_chop_line(&this->sv);}

void std_sv_SVLineIterator_next(std_sv_SVLineIterator *this) {
}

bool std_sv_SVSplitIterator_has_value(std_sv_SVSplitIterator *this) {
  return !(std_sv_SV_is_empty(&this->sv));}

std_sv_SV std_sv_SVSplitIterator_cur(std_sv_SVSplitIterator *this) {
  return std_sv_SV_chop_by_sv(&this->sv, this->delim);}

void std_sv_SVSplitIterator_next(std_sv_SVSplitIterator *this) {
}

void std_mem_set_allocator(void *allocator, void *(*alloc_fn)(void *, u32), void (*free_fn)(void *, void *), void *(*realloc_fn)(void *, void *, u32, u32)) {
  std_mem_state_allocator=allocator;
  std_mem_state_alloc_fn=alloc_fn;
  std_mem_state_realloc_fn=realloc_fn;
  std_mem_state_free_fn=free_fn;
}

compiler_passes_mark_dead_code_MarkDeadCode *std_mem_alloc__0(u32 count) {
  return ((compiler_passes_mark_dead_code_MarkDeadCode *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_mark_dead_code_MarkDeadCode)))));
}

compiler_passes_generic_pass_GenericPass *std_mem_alloc__1(u32 count) {
  return ((compiler_passes_generic_pass_GenericPass *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_generic_pass_GenericPass)))));
}

compiler_passes_reorder_symbols_ReorderSymbols *std_mem_alloc__2(u32 count) {
  return ((compiler_passes_reorder_symbols_ReorderSymbols *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_reorder_symbols_ReorderSymbols)))));
}

compiler_ast_program_Namespace *std_mem_alloc__3(u32 count) {
  return ((compiler_ast_program_Namespace *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Namespace)))));
}

compiler_ast_program_Program *std_mem_alloc__4(u32 count) {
  return ((compiler_ast_program_Program *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Program)))));
}

compiler_ast_scopes_TemplateInstance *std_mem_alloc__5(u32 count) {
  return ((compiler_ast_scopes_TemplateInstance *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance)))));
}

compiler_ast_scopes_Template *std_mem_alloc__6(u32 count) {
  return ((compiler_ast_scopes_Template *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Template)))));
}

compiler_ast_scopes_Symbol *std_mem_alloc__7(u32 count) {
  return ((compiler_ast_scopes_Symbol *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Symbol)))));
}

compiler_ast_scopes_Scope *std_mem_alloc__8(u32 count) {
  return ((compiler_ast_scopes_Scope *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Scope)))));
}

compiler_ast_nodes_Variable *std_mem_alloc__9(u32 count) {
  return ((compiler_ast_nodes_Variable *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Variable)))));
}

compiler_ast_nodes_Structure *std_mem_alloc__10(u32 count) {
  return ((compiler_ast_nodes_Structure *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Structure)))));
}

compiler_ast_nodes_Enum *std_mem_alloc__11(u32 count) {
  return ((compiler_ast_nodes_Enum *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Enum)))));
}

compiler_ast_nodes_EnumVariant *std_mem_alloc__12(u32 count) {
  return ((compiler_ast_nodes_EnumVariant *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_EnumVariant)))));
}

compiler_ast_nodes_Function *std_mem_alloc__13(u32 count) {
  return ((compiler_ast_nodes_Function *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Function)))));
}

compiler_ast_nodes_Argument *std_mem_alloc__14(u32 count) {
  return ((compiler_ast_nodes_Argument *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Argument)))));
}

compiler_ast_nodes_ImportPart *std_mem_alloc__15(u32 count) {
  return ((compiler_ast_nodes_ImportPart *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_ImportPart)))));
}

compiler_ast_nodes_MatchCond *std_mem_alloc__16(u32 count) {
  return ((compiler_ast_nodes_MatchCond *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCond)))));
}

compiler_ast_nodes_AST *std_mem_alloc__17(u32 count) {
  return ((compiler_ast_nodes_AST *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_AST)))));
}

compiler_attributes_Attribute *std_mem_alloc__18(u32 count) {
  return ((compiler_attributes_Attribute *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_attributes_Attribute)))));
}

char *std_mem_alloc__19(u32 count) {
  return ((char *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(char)))));
}

compiler_tokens_Token *std_mem_alloc__20(u32 count) {
  return ((compiler_tokens_Token *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_tokens_Token)))));
}

compiler_types_Type *std_mem_alloc__21(u32 count) {
  return ((compiler_types_Type *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_types_Type)))));
}

compiler_errors_Error *std_mem_alloc__22(u32 count) {
  return ((compiler_errors_Error *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_errors_Error)))));
}

i32 *std_mem_alloc__23(u32 count) {
  return ((i32 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(i32)))));
}

std_compact_map_Map__0 *std_mem_alloc__24(u32 count) {
  return ((std_compact_map_Map__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Map__0)))));
}

std_compact_map_Map__1 *std_mem_alloc__25(u32 count) {
  return ((std_compact_map_Map__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Map__1)))));
}

std_compact_map_Map__2 *std_mem_alloc__26(u32 count) {
  return ((std_compact_map_Map__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Map__2)))));
}

u8 *std_mem_alloc__27(u32 count) {
  return ((u8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(u8)))));
}

std_set_Set__0 *std_mem_alloc__28(u32 count) {
  return ((std_set_Set__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__0)))));
}

std_set_Set__1 *std_mem_alloc__29(u32 count) {
  return ((std_set_Set__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__1)))));
}

std_set_Set__2 *std_mem_alloc__30(u32 count) {
  return ((std_set_Set__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__2)))));
}

std_set_Set__3 *std_mem_alloc__31(u32 count) {
  return ((std_set_Set__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__3)))));
}

std_value_Value *std_mem_alloc__32(u32 count) {
  return ((std_value_Value *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_value_Value)))));
}

std_map_Item__0 *std_mem_alloc__33(u32 count) {
  return ((std_map_Item__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__0)))));
}

std_map_Item__0 **std_mem_alloc__34(u32 count) {
  return ((std_map_Item__0 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__0 *)))));
}

std_map_Map__0 *std_mem_alloc__35(u32 count) {
  return ((std_map_Map__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__0)))));
}

std_map_Item__1 *std_mem_alloc__36(u32 count) {
  return ((std_map_Item__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__1)))));
}

std_map_Item__1 **std_mem_alloc__37(u32 count) {
  return ((std_map_Item__1 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__1 *)))));
}

std_map_Map__1 *std_mem_alloc__38(u32 count) {
  return ((std_map_Map__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__1)))));
}

std_map_Item__2 *std_mem_alloc__39(u32 count) {
  return ((std_map_Item__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__2)))));
}

std_map_Item__2 **std_mem_alloc__40(u32 count) {
  return ((std_map_Item__2 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__2 *)))));
}

std_map_Map__2 *std_mem_alloc__41(u32 count) {
  return ((std_map_Map__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__2)))));
}

std_map_Item__3 *std_mem_alloc__42(u32 count) {
  return ((std_map_Item__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__3)))));
}

std_map_Item__3 **std_mem_alloc__43(u32 count) {
  return ((std_map_Item__3 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__3 *)))));
}

std_map_Map__3 *std_mem_alloc__44(u32 count) {
  return ((std_map_Map__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__3)))));
}

std_map_Item__4 *std_mem_alloc__45(u32 count) {
  return ((std_map_Item__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__4)))));
}

std_map_Item__4 **std_mem_alloc__46(u32 count) {
  return ((std_map_Item__4 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__4 *)))));
}

std_map_Map__4 *std_mem_alloc__47(u32 count) {
  return ((std_map_Map__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__4)))));
}

std_map_Item__5 *std_mem_alloc__48(u32 count) {
  return ((std_map_Item__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__5)))));
}

std_map_Item__5 **std_mem_alloc__49(u32 count) {
  return ((std_map_Item__5 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__5 *)))));
}

std_map_Map__5 *std_mem_alloc__50(u32 count) {
  return ((std_map_Map__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__5)))));
}

std_map_Item__6 *std_mem_alloc__51(u32 count) {
  return ((std_map_Item__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__6)))));
}

std_map_Item__6 **std_mem_alloc__52(u32 count) {
  return ((std_map_Item__6 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__6 *)))));
}

std_map_Map__6 *std_mem_alloc__53(u32 count) {
  return ((std_map_Map__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__6)))));
}

std_map_Item__7 *std_mem_alloc__54(u32 count) {
  return ((std_map_Item__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__7)))));
}

std_map_Item__7 **std_mem_alloc__55(u32 count) {
  return ((std_map_Item__7 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__7 *)))));
}

std_map_Map__7 *std_mem_alloc__56(u32 count) {
  return ((std_map_Map__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__7)))));
}

std_map_Item__8 *std_mem_alloc__57(u32 count) {
  return ((std_map_Item__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__8)))));
}

std_map_Item__8 **std_mem_alloc__58(u32 count) {
  return ((std_map_Item__8 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__8 *)))));
}

std_map_Map__8 *std_mem_alloc__59(u32 count) {
  return ((std_map_Map__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__8)))));
}

std_map_Item__9 *std_mem_alloc__60(u32 count) {
  return ((std_map_Item__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__9)))));
}

std_map_Item__9 **std_mem_alloc__61(u32 count) {
  return ((std_map_Item__9 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__9 *)))));
}

std_map_Map__9 *std_mem_alloc__62(u32 count) {
  return ((std_map_Map__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__9)))));
}

std_map_Item__10 *std_mem_alloc__63(u32 count) {
  return ((std_map_Item__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__10)))));
}

std_map_Item__10 **std_mem_alloc__64(u32 count) {
  return ((std_map_Item__10 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__10 *)))));
}

std_map_Map__10 *std_mem_alloc__65(u32 count) {
  return ((std_map_Map__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__10)))));
}

std_map_Item__11 *std_mem_alloc__66(u32 count) {
  return ((std_map_Item__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__11)))));
}

std_map_Item__11 **std_mem_alloc__67(u32 count) {
  return ((std_map_Item__11 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__11 *)))));
}

std_map_Map__11 *std_mem_alloc__68(u32 count) {
  return ((std_map_Map__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__11)))));
}

std_map_Item__12 *std_mem_alloc__69(u32 count) {
  return ((std_map_Item__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__12)))));
}

std_map_Item__12 **std_mem_alloc__70(u32 count) {
  return ((std_map_Item__12 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__12 *)))));
}

std_map_Map__12 *std_mem_alloc__71(u32 count) {
  return ((std_map_Map__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__12)))));
}

std_map_Item__13 *std_mem_alloc__72(u32 count) {
  return ((std_map_Item__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__13)))));
}

std_map_Item__13 **std_mem_alloc__73(u32 count) {
  return ((std_map_Item__13 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__13 *)))));
}

std_map_Map__13 *std_mem_alloc__74(u32 count) {
  return ((std_map_Map__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__13)))));
}

std_vector_Vector__0 *std_mem_alloc__75(u32 count) {
  return ((std_vector_Vector__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__0)))));
}

compiler_types_Type **std_mem_alloc__76(u32 count) {
  return ((compiler_types_Type **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_types_Type *)))));
}

std_vector_Vector__1 *std_mem_alloc__77(u32 count) {
  return ((std_vector_Vector__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__1)))));
}

char **std_mem_alloc__78(u32 count) {
  return ((char **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(char *)))));
}

std_vector_Vector__2 *std_mem_alloc__79(u32 count) {
  return ((std_vector_Vector__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__2)))));
}

compiler_ast_scopes_Scope **std_mem_alloc__80(u32 count) {
  return ((compiler_ast_scopes_Scope **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Scope *)))));
}

std_vector_Vector__3 *std_mem_alloc__81(u32 count) {
  return ((std_vector_Vector__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__3)))));
}

compiler_ast_program_Namespace **std_mem_alloc__82(u32 count) {
  return ((compiler_ast_program_Namespace **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Namespace *)))));
}

std_vector_Vector__4 *std_mem_alloc__83(u32 count) {
  return ((std_vector_Vector__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__4)))));
}

compiler_ast_nodes_Variable **std_mem_alloc__84(u32 count) {
  return ((compiler_ast_nodes_Variable **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Variable *)))));
}

std_vector_Vector__5 *std_mem_alloc__85(u32 count) {
  return ((std_vector_Vector__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__5)))));
}

compiler_ast_scopes_TemplateInstance **std_mem_alloc__86(u32 count) {
  return ((compiler_ast_scopes_TemplateInstance **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)))));
}

std_vector_Vector__6 *std_mem_alloc__87(u32 count) {
  return ((std_vector_Vector__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__6)))));
}

compiler_ast_nodes_MatchCond **std_mem_alloc__88(u32 count) {
  return ((compiler_ast_nodes_MatchCond **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)))));
}

std_vector_Vector__7 *std_mem_alloc__89(u32 count) {
  return ((std_vector_Vector__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__7)))));
}

compiler_ast_nodes_ImportPart **std_mem_alloc__90(u32 count) {
  return ((compiler_ast_nodes_ImportPart **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)))));
}

std_vector_Vector__8 *std_mem_alloc__91(u32 count) {
  return ((std_vector_Vector__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__8)))));
}

compiler_ast_nodes_Function **std_mem_alloc__92(u32 count) {
  return ((compiler_ast_nodes_Function **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Function *)))));
}

std_vector_Vector__9 *std_mem_alloc__93(u32 count) {
  return ((std_vector_Vector__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__9)))));
}

compiler_ast_nodes_Argument **std_mem_alloc__94(u32 count) {
  return ((compiler_ast_nodes_Argument **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Argument *)))));
}

std_vector_Vector__10 *std_mem_alloc__95(u32 count) {
  return ((std_vector_Vector__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__10)))));
}

compiler_ast_scopes_Symbol **std_mem_alloc__96(u32 count) {
  return ((compiler_ast_scopes_Symbol **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Symbol *)))));
}

std_vector_Vector__11 *std_mem_alloc__97(u32 count) {
  return ((std_vector_Vector__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__11)))));
}

compiler_tokens_Token **std_mem_alloc__98(u32 count) {
  return ((compiler_tokens_Token **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_tokens_Token *)))));
}

std_vector_Vector__12 *std_mem_alloc__99(u32 count) {
  return ((std_vector_Vector__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__12)))));
}

compiler_attributes_Attribute **std_mem_alloc__100(u32 count) {
  return ((compiler_attributes_Attribute **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_attributes_Attribute *)))));
}

std_vector_Vector__13 *std_mem_alloc__101(u32 count) {
  return ((std_vector_Vector__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__13)))));
}

compiler_ast_nodes_Structure **std_mem_alloc__102(u32 count) {
  return ((compiler_ast_nodes_Structure **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Structure *)))));
}

std_vector_Vector__14 *std_mem_alloc__103(u32 count) {
  return ((std_vector_Vector__14 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__14)))));
}

compiler_ast_nodes_Enum **std_mem_alloc__104(u32 count) {
  return ((compiler_ast_nodes_Enum **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Enum *)))));
}

std_vector_Vector__15 *std_mem_alloc__105(u32 count) {
  return ((std_vector_Vector__15 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__15)))));
}

compiler_ast_nodes_AST **std_mem_alloc__106(u32 count) {
  return ((compiler_ast_nodes_AST **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_AST *)))));
}

std_vector_Vector__16 *std_mem_alloc__107(u32 count) {
  return ((std_vector_Vector__16 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__16)))));
}

compiler_errors_Error **std_mem_alloc__108(u32 count) {
  return ((compiler_errors_Error **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_errors_Error *)))));
}

std_vector_Vector__17 *std_mem_alloc__109(u32 count) {
  return ((std_vector_Vector__17 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__17)))));
}

jmp_buf *std_mem_alloc__110(u32 count) {
  return ((jmp_buf *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(jmp_buf)))));
}

std_vector_Vector__18 *std_mem_alloc__111(u32 count) {
  return ((std_vector_Vector__18 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__18)))));
}

compiler_ast_scopes_Reference *std_mem_alloc__112(u32 count) {
  return ((compiler_ast_scopes_Reference *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Reference)))));
}

std_vector_Vector__19 *std_mem_alloc__113(u32 count) {
  return ((std_vector_Vector__19 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__19)))));
}

compiler_ast_nodes_MatchCondArg **std_mem_alloc__114(u32 count) {
  return ((compiler_ast_nodes_MatchCondArg **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)))));
}

std_vector_Vector__20 *std_mem_alloc__115(u32 count) {
  return ((std_vector_Vector__20 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__20)))));
}

compiler_ast_nodes_EnumVariant **std_mem_alloc__116(u32 count) {
  return ((compiler_ast_nodes_EnumVariant **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)))));
}

std_vector_Vector__21 *std_mem_alloc__117(u32 count) {
  return ((std_vector_Vector__21 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__21)))));
}

compiler_ast_operators_Operator *std_mem_alloc__118(u32 count) {
  return ((compiler_ast_operators_Operator *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_operators_Operator)))));
}

std_vector_Vector__22 *std_mem_alloc__119(u32 count) {
  return ((std_vector_Vector__22 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__22)))));
}

std_vector_Vector__7 **std_mem_alloc__120(u32 count) {
  return ((std_vector_Vector__7 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__7 *)))));
}

std_vector_Vector__23 *std_mem_alloc__121(u32 count) {
  return ((std_vector_Vector__23 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__23)))));
}

compiler_ast_nodes_IfBranch *std_mem_alloc__122(u32 count) {
  return ((compiler_ast_nodes_IfBranch *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_IfBranch)))));
}

std_vector_Vector__24 *std_mem_alloc__123(u32 count) {
  return ((std_vector_Vector__24 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__24)))));
}

compiler_ast_nodes_MatchCase *std_mem_alloc__124(u32 count) {
  return ((compiler_ast_nodes_MatchCase *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCase)))));
}

std_vector_Vector__25 *std_mem_alloc__125(u32 count) {
  return ((std_vector_Vector__25 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__25)))));
}

compiler_ast_nodes_MapLiteralPair *std_mem_alloc__126(u32 count) {
  return ((compiler_ast_nodes_MapLiteralPair *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MapLiteralPair)))));
}

std_vector_Vector__26 *std_mem_alloc__127(u32 count) {
  return ((std_vector_Vector__26 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__26)))));
}

std_compact_map_Item__0 *std_mem_alloc__128(u32 count) {
  return ((std_compact_map_Item__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Item__0)))));
}

std_vector_Vector__27 *std_mem_alloc__129(u32 count) {
  return ((std_vector_Vector__27 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__27)))));
}

std_span_Span *std_mem_alloc__130(u32 count) {
  return ((std_span_Span *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_span_Span)))));
}

std_vector_Vector__28 *std_mem_alloc__131(u32 count) {
  return ((std_vector_Vector__28 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__28)))));
}

std_value_Value **std_mem_alloc__132(u32 count) {
  return ((std_value_Value **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_value_Value *)))));
}

std_vector_Vector__29 *std_mem_alloc__133(u32 count) {
  return ((std_vector_Vector__29 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__29)))));
}

std_compact_map_Item__1 *std_mem_alloc__134(u32 count) {
  return ((std_compact_map_Item__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Item__1)))));
}

std_vector_Vector__30 *std_mem_alloc__135(u32 count) {
  return ((std_vector_Vector__30 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__30)))));
}

std_compact_map_Item__2 *std_mem_alloc__136(u32 count) {
  return ((std_compact_map_Item__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Item__2)))));
}

std_vector_Vector__31 *std_mem_alloc__137(u32 count) {
  return ((std_vector_Vector__31 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__31)))));
}

u32 *std_mem_alloc__138(u32 count) {
  return ((u32 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(u32)))));
}

void std_mem_free(void *ptr) {
  if (std_mem_state_free_fn != NULL) {
    std_mem_state_free_fn(std_mem_state_allocator, ptr);
    return;
  }
}

u8 *std_mem_realloc__0(u8 *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(u8)));
  u32 new_size = (new_count * ((u32)sizeof(u8)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  u8 *new_ptr = std_mem_alloc__27(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_types_Type **std_mem_realloc__1(compiler_types_Type **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_types_Type *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_types_Type *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_types_Type **new_ptr = std_mem_alloc__76(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

char **std_mem_realloc__2(char **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(char *)));
  u32 new_size = (new_count * ((u32)sizeof(char *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  char **new_ptr = std_mem_alloc__78(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_scopes_Scope **std_mem_realloc__3(compiler_ast_scopes_Scope **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Scope *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Scope *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_scopes_Scope **new_ptr = std_mem_alloc__80(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_program_Namespace **std_mem_realloc__4(compiler_ast_program_Namespace **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_program_Namespace *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_program_Namespace *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_program_Namespace **new_ptr = std_mem_alloc__82(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_Variable **std_mem_realloc__5(compiler_ast_nodes_Variable **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Variable *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Variable *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_Variable **new_ptr = std_mem_alloc__84(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_scopes_TemplateInstance **std_mem_realloc__6(compiler_ast_scopes_TemplateInstance **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_scopes_TemplateInstance **new_ptr = std_mem_alloc__86(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_MatchCond **std_mem_realloc__7(compiler_ast_nodes_MatchCond **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_MatchCond **new_ptr = std_mem_alloc__88(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_ImportPart **std_mem_realloc__8(compiler_ast_nodes_ImportPart **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_ImportPart **new_ptr = std_mem_alloc__90(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_Function **std_mem_realloc__9(compiler_ast_nodes_Function **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Function *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Function *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_Function **new_ptr = std_mem_alloc__92(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_Argument **std_mem_realloc__10(compiler_ast_nodes_Argument **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Argument *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Argument *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_Argument **new_ptr = std_mem_alloc__94(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_scopes_Symbol **std_mem_realloc__11(compiler_ast_scopes_Symbol **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Symbol *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Symbol *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_scopes_Symbol **new_ptr = std_mem_alloc__96(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_tokens_Token **std_mem_realloc__12(compiler_tokens_Token **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_tokens_Token *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_tokens_Token *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_tokens_Token **new_ptr = std_mem_alloc__98(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_attributes_Attribute **std_mem_realloc__13(compiler_attributes_Attribute **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_attributes_Attribute *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_attributes_Attribute *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_attributes_Attribute **new_ptr = std_mem_alloc__100(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_Structure **std_mem_realloc__14(compiler_ast_nodes_Structure **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Structure *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Structure *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_Structure **new_ptr = std_mem_alloc__102(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_Enum **std_mem_realloc__15(compiler_ast_nodes_Enum **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Enum *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Enum *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_Enum **new_ptr = std_mem_alloc__104(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_AST **std_mem_realloc__16(compiler_ast_nodes_AST **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_AST *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_AST *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_AST **new_ptr = std_mem_alloc__106(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_errors_Error **std_mem_realloc__17(compiler_errors_Error **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_errors_Error *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_errors_Error *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_errors_Error **new_ptr = std_mem_alloc__108(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

jmp_buf *std_mem_realloc__18(jmp_buf *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(jmp_buf)));
  u32 new_size = (new_count * ((u32)sizeof(jmp_buf)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  jmp_buf *new_ptr = std_mem_alloc__110(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_scopes_Reference *std_mem_realloc__19(compiler_ast_scopes_Reference *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Reference)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Reference)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_scopes_Reference *new_ptr = std_mem_alloc__112(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_MatchCondArg **std_mem_realloc__20(compiler_ast_nodes_MatchCondArg **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_MatchCondArg **new_ptr = std_mem_alloc__114(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_EnumVariant **std_mem_realloc__21(compiler_ast_nodes_EnumVariant **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_EnumVariant **new_ptr = std_mem_alloc__116(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_operators_Operator *std_mem_realloc__22(compiler_ast_operators_Operator *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_operators_Operator)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_operators_Operator)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_operators_Operator *new_ptr = std_mem_alloc__118(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_vector_Vector__7 **std_mem_realloc__23(std_vector_Vector__7 **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_vector_Vector__7 *)));
  u32 new_size = (new_count * ((u32)sizeof(std_vector_Vector__7 *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_vector_Vector__7 **new_ptr = std_mem_alloc__120(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_IfBranch *std_mem_realloc__24(compiler_ast_nodes_IfBranch *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_IfBranch)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_IfBranch)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_IfBranch *new_ptr = std_mem_alloc__122(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_MatchCase *std_mem_realloc__25(compiler_ast_nodes_MatchCase *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCase)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCase)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_MatchCase *new_ptr = std_mem_alloc__124(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

compiler_ast_nodes_MapLiteralPair *std_mem_realloc__26(compiler_ast_nodes_MapLiteralPair *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MapLiteralPair)));
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MapLiteralPair)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  compiler_ast_nodes_MapLiteralPair *new_ptr = std_mem_alloc__126(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_compact_map_Item__0 *std_mem_realloc__27(std_compact_map_Item__0 *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_compact_map_Item__0)));
  u32 new_size = (new_count * ((u32)sizeof(std_compact_map_Item__0)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_compact_map_Item__0 *new_ptr = std_mem_alloc__128(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_span_Span *std_mem_realloc__28(std_span_Span *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_span_Span)));
  u32 new_size = (new_count * ((u32)sizeof(std_span_Span)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_span_Span *new_ptr = std_mem_alloc__130(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_value_Value **std_mem_realloc__29(std_value_Value **ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_value_Value *)));
  u32 new_size = (new_count * ((u32)sizeof(std_value_Value *)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_value_Value **new_ptr = std_mem_alloc__132(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_compact_map_Item__1 *std_mem_realloc__30(std_compact_map_Item__1 *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_compact_map_Item__1)));
  u32 new_size = (new_count * ((u32)sizeof(std_compact_map_Item__1)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_compact_map_Item__1 *new_ptr = std_mem_alloc__134(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

std_compact_map_Item__2 *std_mem_realloc__31(std_compact_map_Item__2 *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(std_compact_map_Item__2)));
  u32 new_size = (new_count * ((u32)sizeof(std_compact_map_Item__2)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  std_compact_map_Item__2 *new_ptr = std_mem_alloc__136(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

u32 *std_mem_realloc__32(u32 *ptr, u32 old_count, u32 new_count) {
  u32 old_size = (old_count * ((u32)sizeof(u32)));
  u32 new_size = (new_count * ((u32)sizeof(u32)));
  if (std_mem_state_realloc_fn != NULL) {
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }
  u32 *new_ptr = std_mem_alloc__138(new_count);
  memcpy(new_ptr, ptr, old_size);
  std_mem_free(ptr);
  return new_ptr;
}

void *std_mem_impl_my_calloc(void *state, u32 size) {
  return calloc(size, 1);}

void *std_mem_impl_my_realloc(void *state, void *ptr, u32 old_size, u32 size) {
  return realloc(ptr, size);}

void std_mem_impl_my_free(void *state, void *ptr) {
    free(ptr);
}

void std_gc_init(void *base) {
  std_gc_impl_stack_bottom=base;
  std_mem_set_allocator(NULL, std_gc_impl__alloc_fn, std_gc_impl__free_fn, std_gc_impl__realloc_fn);
}

void *std_gc_alloc(u32 size) {
  u32 total_size = (size + ((u32)sizeof(std_gc_impl_Header)));
  std_gc_impl_Header *header = calloc(total_size, 1);
  if (!(((bool)header))) {
    return NULL;
  }
  header->size=size;
  header->marked=false;
  header->global=false;
  header->next=std_gc_impl_alloc_list;
  header->prev=NULL;
  if (((bool)std_gc_impl_alloc_list)) {
    std_gc_impl_alloc_list->prev=header;
  }
  std_gc_impl_alloc_list=header;
  std_gc_impl_total_allocations+=1;
  std_gc_impl_total_alloc_bytes+=total_size;
  std_gc_impl_live_allocations+=1;
  std_gc_impl_live_alloc_bytes+=total_size;
  return ((void *)(header + 1));
}

void std_gc_collect(void) {
  if (!(((bool)std_gc_impl_stack_bottom))) {
    std_panic("collect called before init");
  }
  for (std_gc_impl_Header *header = std_gc_impl_alloc_list; ((bool)header); header=header->next) {
    if (header->global) {
      std_gc_impl_mark_object(header);
    }
  }
  void *dummy = NULL;
  void *stack_top = &dummy;
  void *start = stack_top;
  void *end = std_gc_impl_stack_bottom;
  if (stack_top >= end) {
    start=std_gc_impl_stack_bottom;
    end=stack_top;
  }
  std_gc_impl_mark_range(start, end);
  std_gc_impl_Header *header = std_gc_impl_alloc_list;
  while (((bool)header)) {
    std_gc_impl_Header *next = header->next;
    if (!(header->marked) && !(header->global)) {
      if (((bool)header->prev)) {
        header->prev->next=header->next;
      } else {
        std_gc_impl_alloc_list=header->next;
      }
      if (((bool)header->next)) {
        header->next->prev=header->prev;
      }
      std_gc_impl_live_allocations-=1;
      std_gc_impl_live_alloc_bytes-=(header->size + ((u32)sizeof(std_gc_impl_Header)));
      std_gc_impl_freed_allocations+=1;
      std_gc_impl_freed_alloc_bytes+=(header->size + ((u32)sizeof(std_gc_impl_Header)));
      free(header);
    } else {
      header->marked=false;
    }
    header=next;
  }
}

void std_gc_human_readable_size(i64 bytes, char *output) {
  char *suffixes[5] = {"B", "K", "M", "G", "T"};
  u32 i = 0;
  f64 size = ((f64)bytes);
  while ((size >= 1000.000000) && (i < 4)) {
    size/=1024.000000;
    i++;
  }
  if (size < 10.000000) {
    snprintf(output, 7, "%.1f%s", size, suffixes[i]);
  } else {
    snprintf(output, 7, "%.0f%s", size, suffixes[i]);
  }
}

void std_gc_print_stats(void) {
  char live_bytes_str[20] = {0};
  char freed_bytes_str[20] = {0};
  std_gc_human_readable_size(((i64)std_gc_impl_live_alloc_bytes), live_bytes_str);
  std_gc_human_readable_size(((i64)std_gc_impl_freed_alloc_bytes), freed_bytes_str);
  fprintf(stderr, "┌──────────────────────────┬──────────┬────────┐""\n");
  fprintf(stderr, "│                          │ Count    │ Bytes  │""\n");
  fprintf(stderr, "├──────────────────────────┼──────────┼────────┤""\n");
  fprintf(stderr, "│ GC: Live Allocations     │ %-8d │ %-6s │""\n", std_gc_impl_live_allocations, live_bytes_str);
  fprintf(stderr, "│ GC: Freed Allocations    │ %-8d │ %-6s │""\n", std_gc_impl_freed_allocations, freed_bytes_str);
  fprintf(stderr, "└──────────────────────────┴──────────┴────────┘""\n");
}

void std_gc_shutdown(void) {
  std_gc_collect();
  std_gc_print_stats();
  std_gc_impl_Header *header = std_gc_impl_alloc_list;
  while (((bool)header)) {
    std_gc_impl_Header *next = header->next;
    free(header);
    header=next;
  }
}

void *std_gc_impl__alloc_fn(void *_, u32 size) {
  return std_gc_alloc(size);
}

void *std_gc_impl__realloc_fn(void *_, void *ptr, u32 old_size, u32 size) {
  void *new_ptr = std_gc_alloc(size);
  u32 num_copy = u32_min(old_size, size);
  memcpy(new_ptr, ptr, num_copy);
  return new_ptr;
}

void std_gc_impl__free_fn(void *_, void *ptr) {
}

void std_gc_impl_mark_range(void *start, void *end) {
  u64 align = ((u64)((u32)sizeof(void *)));
  u64 ustart = (((((u64)start) + align) - ((u64)1)) & ~(align - ((u64)1)));
  u64 uend = (((u64)end) & ~(align - ((u64)1)));
  for (u64 ptr = ustart; ptr < uend; ptr+=align) {
    void *potential_ptr = (*((void **)ptr));
    for (std_gc_impl_Header *header = std_gc_impl_alloc_list; ((bool)header); header=header->next) {
      void *obj_start = ((void *)(header + 1));
      void *obj_end = ((void *)(((char *)obj_start) + header->size));
      if ((obj_start <= potential_ptr) && (potential_ptr < obj_end)) {
        std_gc_impl_mark_object(header);
      }
    }
  }
}

void std_gc_impl_mark_object(std_gc_impl_Header *header) {
  if (header->marked) {
    return;
  }
  header->marked=true;
  void *start = ((void *)(header + 1));
  void *end = ((void *)(((char *)start) + header->size));
  std_gc_impl_mark_range(start, end);
}

char *std_libc_errno_get_err(void) {
  return ((char *)strerror(errno));}

void std_compact_map_Map__0_remove(std_compact_map_Map__0 *this, std_sv_SV key) {
  u32 hash = std_sv_SV_hash(key);
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);
  if (this->indices[index]==std_compact_map_INDEX_FREE) {
    return;
  }
  if(!(index >= 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/compact_map.oc:82:12: Assertion failed: `index >= 0`", NULL); }
  u32 item_index = ((u32)this->indices[index]);
  std_compact_map_Item__0 item = std_vector_Vector__26_at(this->items, item_index);
  std_compact_map_Item__0 last_item = std_vector_Vector__26_at(this->items, (this->items->size - 1));
  u32 last_index = std_compact_map_Map__0_get_index(this, last_item.key, last_item.hash);
  if(!(last_index >= 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/compact_map.oc:90:12: Assertion failed: `last_index >= 0`", NULL); }
  if(!(this->indices[last_index] >= 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/compact_map.oc:91:12: Assertion failed: `.indices[last_index] >= 0`", NULL); }
  u32 last_item_index = ((u32)this->indices[last_index]);
  if(!(last_item_index==(this->items->size - 1))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/compact_map.oc:94:12: Assertion failed: `last_item_index == .items.size - 1`", NULL); }
  this->indices[last_index]=((i32)item_index);
  this->indices[index]=std_compact_map_INDEX_DELETED;
  this->items->data[item_index]=last_item;
  std_vector_Vector__26_pop(this->items);
  this->num_tombstones+=1;
  std_compact_map_Map__0_resize_if_necessary(this);
  std_vector_Vector__26_zero_unused(this->items);
}

bool std_compact_map_Map__0_contains(std_compact_map_Map__0 *this, std_sv_SV key) {
  u32 hash = std_sv_SV_hash(key);
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);
  return this->indices[index] >= 0;
}

compiler_lsp_server_TextDocument std_compact_map_Map__0_at(std_compact_map_Map__0 *this, std_sv_SV key) {
  std_compact_map_Item__0 *item = std_compact_map_Map__0_get_item(this, key);
  if (!(((bool)item))) {
    if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/compact_map.oc:172:16: Assertion failed: `false`", "Key not found in Map::at()"); exit(1); }
  }
  return item->value;
}

void std_compact_map_Map__0_insert(std_compact_map_Map__0 *this, std_sv_SV key, compiler_lsp_server_TextDocument value) {
  u32 hash = std_sv_SV_hash(key);
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    this->indices[index]=((i32)this->items->size);
    std_vector_Vector__26_push(this->items, (std_compact_map_Item__0){.hash=hash, .key=key, .value=value});
    std_compact_map_Map__0_resize_if_necessary(this);
  } else {
    if (this->indices[index]==std_compact_map_INDEX_DELETED) {
      this->num_tombstones-=1;
    }
    u32 item_index = ((u32)this->indices[index]);
    this->items->data[item_index].value=value;
  }
}

u32 std_compact_map_Map__0_get_index(std_compact_map_Map__0 *this, std_sv_SV key, u32 hash) {
  u32 perturb = hash;
  u32 j = (hash % this->capacity);
  u32 i = j;
  i32 first_deleted = -1;
  while (this->indices[i] != std_compact_map_INDEX_FREE) {
    if (this->indices[i]==std_compact_map_INDEX_DELETED) {
      if (first_deleted < 0) {
        first_deleted=((i32)i);
      }
    } else {
      std_compact_map_Item__0 item = this->items->data[this->indices[i]];
      if (item.hash==hash && std_sv_SV_eq(item.key, key)) {
        return i;
      }
    }
    j=(((5 * j) + perturb) + 1);
    i=(j % this->capacity);
    perturb=(perturb >> 5);
  }
  if (first_deleted < 0) {
    return i;
  }
  return ((u32)first_deleted);
}

void std_compact_map_Map__0_resize(std_compact_map_Map__0 *this, u32 new_capacity) {
  i32 *old_indices = this->indices;
  this->indices=std_mem_alloc__23(new_capacity);
  this->capacity=new_capacity;
  for (u32 i = 0; i < new_capacity; i++) {
    this->indices[i]=std_compact_map_INDEX_FREE;
  }
  for (u32 i = 0; i < this->items->size; i++) {
    std_compact_map_Item__0 item = std_vector_Vector__26_at(this->items, i);
    u32 index = std_compact_map_Map__0_get_index(this, item.key, item.hash);
    if (this->indices[index]==std_compact_map_INDEX_FREE) {
      this->indices[index]=((i32)i);
    }
  }
  this->num_tombstones=0;
  std_mem_free(old_indices);
}

std_compact_map_Item__0 *std_compact_map_Map__0_get_item(std_compact_map_Map__0 *this, std_sv_SV key) {
  u32 hash = std_sv_SV_hash(key);
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    return NULL;
  }
  u32 idx = ((u32)this->indices[index]);
  return &this->items->data[idx];
}

std_compact_map_Map__0 *std_compact_map_Map__0_new(u32 capacity) {
  std_vector_Vector__26 *items = std_vector_Vector__26_new(capacity);
  i32 *indices = std_mem_alloc__23(capacity);
  for (u32 i = 0; i < capacity; i++) {
    indices[i]=std_compact_map_INDEX_FREE;
  }
  std_compact_map_Map__0 *map = std_mem_alloc__24(1);
  map->items=items;
  map->indices=indices;
  map->capacity=capacity;
  map->num_tombstones=0;
  return map;
}

void std_compact_map_Map__0_resize_if_necessary(std_compact_map_Map__0 *this) {
  if ((this->num_tombstones + ((u32)this->items->size)) >= ((this->capacity * 3) / 4)) {
    std_compact_map_Map__0_resize(this, (this->capacity * 2));
  }
}

u32 std_compact_map_Map__1_size(std_compact_map_Map__1 *this) {
  return this->items->size;}

bool std_compact_map_Map__1_contains(std_compact_map_Map__1 *this, char *key) {
  u32 hash = str_hash(key);
  u32 index = std_compact_map_Map__1_get_index(this, key, hash);
  return this->indices[index] >= 0;
}

std_compact_map_Iterator__1 std_compact_map_Map__1_iter(std_compact_map_Map__1 *this) {
  return (std_compact_map_Iterator__1){.iter=std_vector_Vector__29_iter(this->items)};}

std_compact_map_Item__1 std_compact_map_Iterator__1_cur(std_compact_map_Iterator__1 *this) {
  return std_vector_Iterator__29_cur(&this->iter);}

void std_compact_map_Iterator__1_next(std_compact_map_Iterator__1 *this) {
  std_vector_Iterator__29_next(&this->iter);
}

bool std_compact_map_Iterator__1_has_value(std_compact_map_Iterator__1 *this) {
  return std_vector_Iterator__29_has_value(&this->iter);}

void std_compact_map_Map__1_insert(std_compact_map_Map__1 *this, char *key, std_value_Value *value) {
  u32 hash = str_hash(key);
  u32 index = std_compact_map_Map__1_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    this->indices[index]=((i32)this->items->size);
    std_vector_Vector__29_push(this->items, (std_compact_map_Item__1){.hash=hash, .key=key, .value=value});
    std_compact_map_Map__1_resize_if_necessary(this);
  } else {
    if (this->indices[index]==std_compact_map_INDEX_DELETED) {
      this->num_tombstones-=1;
    }
    u32 item_index = ((u32)this->indices[index]);
    this->items->data[item_index].value=value;
  }
}

u32 std_compact_map_Map__1_get_index(std_compact_map_Map__1 *this, char *key, u32 hash) {
  u32 perturb = hash;
  u32 j = (hash % this->capacity);
  u32 i = j;
  i32 first_deleted = -1;
  while (this->indices[i] != std_compact_map_INDEX_FREE) {
    if (this->indices[i]==std_compact_map_INDEX_DELETED) {
      if (first_deleted < 0) {
        first_deleted=((i32)i);
      }
    } else {
      std_compact_map_Item__1 item = this->items->data[this->indices[i]];
      if (item.hash==hash && str_eq(item.key, key)) {
        return i;
      }
    }
    j=(((5 * j) + perturb) + 1);
    i=(j % this->capacity);
    perturb=(perturb >> 5);
  }
  if (first_deleted < 0) {
    return i;
  }
  return ((u32)first_deleted);
}

std_value_Value *std_compact_map_Map__1_get(std_compact_map_Map__1 *this, char *key, std_value_Value *defolt) {
  std_compact_map_Item__1 *item = std_compact_map_Map__1_get_item(this, key);
  if (!(((bool)item))) {
    return defolt;
  }
  return item->value;
}

bool std_compact_map_Map__1_is_empty(std_compact_map_Map__1 *this) {
  return this->items->size==0;}

void std_compact_map_Map__1_resize(std_compact_map_Map__1 *this, u32 new_capacity) {
  i32 *old_indices = this->indices;
  this->indices=std_mem_alloc__23(new_capacity);
  this->capacity=new_capacity;
  for (u32 i = 0; i < new_capacity; i++) {
    this->indices[i]=std_compact_map_INDEX_FREE;
  }
  for (u32 i = 0; i < this->items->size; i++) {
    std_compact_map_Item__1 item = std_vector_Vector__29_at(this->items, i);
    u32 index = std_compact_map_Map__1_get_index(this, item.key, item.hash);
    if (this->indices[index]==std_compact_map_INDEX_FREE) {
      this->indices[index]=((i32)i);
    }
  }
  this->num_tombstones=0;
  std_mem_free(old_indices);
}

std_compact_map_Item__1 *std_compact_map_Map__1_get_item(std_compact_map_Map__1 *this, char *key) {
  u32 hash = str_hash(key);
  u32 index = std_compact_map_Map__1_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    return NULL;
  }
  u32 idx = ((u32)this->indices[index]);
  return &this->items->data[idx];
}

std_compact_map_Map__1 *std_compact_map_Map__1_new(u32 capacity) {
  std_vector_Vector__29 *items = std_vector_Vector__29_new(capacity);
  i32 *indices = std_mem_alloc__23(capacity);
  for (u32 i = 0; i < capacity; i++) {
    indices[i]=std_compact_map_INDEX_FREE;
  }
  std_compact_map_Map__1 *map = std_mem_alloc__25(1);
  map->items=items;
  map->indices=indices;
  map->capacity=capacity;
  map->num_tombstones=0;
  return map;
}

void std_compact_map_Map__1_resize_if_necessary(std_compact_map_Map__1 *this) {
  if ((this->num_tombstones + ((u32)this->items->size)) >= ((this->capacity * 3) / 4)) {
    std_compact_map_Map__1_resize(this, (this->capacity * 2));
  }
}

void std_compact_map_Map__2_insert(std_compact_map_Map__2 *this, char *key, std_span_Span value) {
  u32 hash = str_hash(key);
  u32 index = std_compact_map_Map__2_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    this->indices[index]=((i32)this->items->size);
    std_vector_Vector__30_push(this->items, (std_compact_map_Item__2){.hash=hash, .key=key, .value=value});
    std_compact_map_Map__2_resize_if_necessary(this);
  } else {
    if (this->indices[index]==std_compact_map_INDEX_DELETED) {
      this->num_tombstones-=1;
    }
    u32 item_index = ((u32)this->indices[index]);
    this->items->data[item_index].value=value;
  }
}

u32 std_compact_map_Map__2_get_index(std_compact_map_Map__2 *this, char *key, u32 hash) {
  u32 perturb = hash;
  u32 j = (hash % this->capacity);
  u32 i = j;
  i32 first_deleted = -1;
  while (this->indices[i] != std_compact_map_INDEX_FREE) {
    if (this->indices[i]==std_compact_map_INDEX_DELETED) {
      if (first_deleted < 0) {
        first_deleted=((i32)i);
      }
    } else {
      std_compact_map_Item__2 item = this->items->data[this->indices[i]];
      if (item.hash==hash && str_eq(item.key, key)) {
        return i;
      }
    }
    j=(((5 * j) + perturb) + 1);
    i=(j % this->capacity);
    perturb=(perturb >> 5);
  }
  if (first_deleted < 0) {
    return i;
  }
  return ((u32)first_deleted);
}

void std_compact_map_Map__2_resize(std_compact_map_Map__2 *this, u32 new_capacity) {
  i32 *old_indices = this->indices;
  this->indices=std_mem_alloc__23(new_capacity);
  this->capacity=new_capacity;
  for (u32 i = 0; i < new_capacity; i++) {
    this->indices[i]=std_compact_map_INDEX_FREE;
  }
  for (u32 i = 0; i < this->items->size; i++) {
    std_compact_map_Item__2 item = std_vector_Vector__30_at(this->items, i);
    u32 index = std_compact_map_Map__2_get_index(this, item.key, item.hash);
    if (this->indices[index]==std_compact_map_INDEX_FREE) {
      this->indices[index]=((i32)i);
    }
  }
  this->num_tombstones=0;
  std_mem_free(old_indices);
}

std_compact_map_Item__2 *std_compact_map_Map__2_get_item(std_compact_map_Map__2 *this, char *key) {
  u32 hash = str_hash(key);
  u32 index = std_compact_map_Map__2_get_index(this, key, hash);
  if (this->indices[index] < 0) {
    return NULL;
  }
  u32 idx = ((u32)this->indices[index]);
  return &this->items->data[idx];
}

std_compact_map_Map__2 *std_compact_map_Map__2_new(u32 capacity) {
  std_vector_Vector__30 *items = std_vector_Vector__30_new(capacity);
  i32 *indices = std_mem_alloc__23(capacity);
  for (u32 i = 0; i < capacity; i++) {
    indices[i]=std_compact_map_INDEX_FREE;
  }
  std_compact_map_Map__2 *map = std_mem_alloc__26(1);
  map->items=items;
  map->indices=indices;
  map->capacity=capacity;
  map->num_tombstones=0;
  return map;
}

void std_compact_map_Map__2_resize_if_necessary(std_compact_map_Map__2 *this) {
  if ((this->num_tombstones + ((u32)this->items->size)) >= ((this->capacity * 3) / 4)) {
    std_compact_map_Map__2_resize(this, (this->capacity * 2));
  }
}

std_buffer_Buffer std_buffer_Buffer_make(u32 capacity) {
  return (std_buffer_Buffer){.data=std_mem_alloc__27(capacity), .size=0, .capacity=capacity};
}

std_buffer_Buffer std_buffer_Buffer_from_str(char *s) {
  return (std_buffer_Buffer){.data=((u8 *)s), .size=((u32)strlen(s)), .capacity=((u32)strlen(s))};
}

void std_buffer_Buffer_resize_if_necessary(std_buffer_Buffer *this, u32 new_size) {
  if ((new_size + 1) >= this->capacity) {
    u32 new_capacity = u32_max(((this->capacity * 3) / 2), (new_size + 1));
    this->data=std_mem_realloc__0(this->data, this->capacity, new_capacity);
    memset((this->data + this->capacity), ((u8)0), (new_capacity - this->capacity));
    this->capacity=((u32)new_capacity);
    if(!(((bool)this->data))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/buffer.oc:65:16: Assertion failed: `.data?`", "Out of memory!"); }
  }
}

void std_buffer_Buffer_write_str(std_buffer_Buffer *this, char *s) {
  u32 len = ((u32)strlen(s));
  std_buffer_Buffer_resize_if_necessary(this, (this->size + len));
  memcpy((this->data + this->size), s, len);
  this->size+=len;
}

void std_buffer_Buffer_write_str_f(std_buffer_Buffer *this, char *s) {
  std_buffer_Buffer_write_str(this, s);
  std_mem_free(s);
}

void std_buffer_Buffer_write_char(std_buffer_Buffer *this, char c) {
    std_buffer_Buffer_write_u8(this, ((u8)c));
}

void std_buffer_Buffer_write_bytes(std_buffer_Buffer *this, void *bytes, u32 size) {
  std_buffer_Buffer_resize_if_necessary(this, (this->size + size));
  memcpy((this->data + this->size), bytes, size);
  this->size+=size;
}

void std_buffer_Buffer_write_u8(std_buffer_Buffer *this, u8 value) {
  std_buffer_Buffer_resize_if_necessary(this, (this->size + 1));
  this->data[this->size]=value;
  this->size+=1;
}

char *std_buffer_Buffer_new_str(std_buffer_Buffer this) {
  return strdup(((char *)this.data));}

char *std_buffer_Buffer_str(std_buffer_Buffer this) {
  return ((char *)this.data);}

std_sv_SV std_buffer_Buffer_sv(std_buffer_Buffer this) {
  return (std_sv_SV){.data=((char *)this.data), .len=this.size};}

void std_buffer_Buffer_clear(std_buffer_Buffer *this) {
  this->size=0;
  memset(this->data, ((u8)0), this->capacity);
}

void std_buffer_Buffer_free(std_buffer_Buffer *this) {
  std_mem_free(this->data);
}

void std_logging_init_logging(std_logging_LogLevel level, char *time_format) {
  std_logging_log_level=level;
  std_logging_log_time_format=time_format;
  char *s = getenv("LOG");
  if (!(((bool)s))) {
    return;
  }
  {
    char *__match_var_662 = s;
    if (str_eq(__match_var_662, "debug") || str_eq(__match_var_662, "DEBUG")) {
      std_logging_log_level=std_logging_LogLevel_Debug;
    } else if (str_eq(__match_var_662, "info") || str_eq(__match_var_662, "INFO")) {
      std_logging_log_level=std_logging_LogLevel_Info;
    } else if (str_eq(__match_var_662, "warn") || str_eq(__match_var_662, "WARN")) {
      std_logging_log_level=std_logging_LogLevel_Warn;
    } else if (str_eq(__match_var_662, "error") || str_eq(__match_var_662, "ERROR")) {
      std_logging_log_level=std_logging_LogLevel_Error;
    } else  {
    }
  }
}

void std_logging_vlog(std_logging_LogLevel level, char *fmt, va_list vargs) {
  if (((u32)level) < ((u32)std_logging_log_level)) {
    return;
  }
  if (((bool)std_logging_log_time_format)) {
    char time_buf[64] = {0};
    time_t timer = time(NULL);
    struct tm *tm_info = localtime(&timer);
    strftime(time_buf, 64, std_logging_log_time_format, tm_info);
    printf("(%s) ", time_buf);
  }
switch ((level)) {
    case std_logging_LogLevel_Debug:
    m_663_0:
      {
        printf("[DEBUG] ");
      } break;
    case std_logging_LogLevel_Info:
    m_663_1:
      {
        printf("[INFO] ");
      } break;
    case std_logging_LogLevel_Warn:
    m_663_2:
      {
        printf("[WARN] ");
      } break;
    case std_logging_LogLevel_Error:
    m_663_3:
      {
        printf("[ERROR] ");
      } break;
  }  vprintf(fmt, vargs);
  printf("\n");
}

void std_logging_log(std_logging_LogLevel level, char *fmt, ...) {
  va_list args = {0};
  va_start(args, fmt);
  std_logging_vlog(level, fmt, args);
  va_end(args);
}

void std_set_Set__0_free(std_set_Set__0 *this) {
  std_map_Map__0_free(this->map);
  std_mem_free(this);
}

void std_set_Set__0_add(std_set_Set__0 *this, u64 key) {
  std_map_Map__0_insert(this->map, key, true);
  this->size=this->map->size;
}

bool std_set_Set__0_contains(std_set_Set__0 *this, u64 key) {
  return std_map_Map__0_contains(this->map, key);}

std_set_Set__0 *std_set_Set__0_new(void) {
  std_set_Set__0 *set = std_mem_alloc__28(1);
  set->map=std_map_Map__0_new(8);
  return set;
}

void std_set_Set__1_free(std_set_Set__1 *this) {
  std_map_Map__3_free(this->map);
  std_mem_free(this);
}

void std_set_Set__1_add(std_set_Set__1 *this, void *key) {
  std_map_Map__3_insert(this->map, key, true);
  this->size=this->map->size;
}

bool std_set_Set__1_contains(std_set_Set__1 *this, void *key) {
  return std_map_Map__3_contains(this->map, key);}

std_set_Set__1 *std_set_Set__1_new(void) {
  std_set_Set__1 *set = std_mem_alloc__29(1);
  set->map=std_map_Map__3_new(8);
  return set;
}

void std_set_Set__2_free(std_set_Set__2 *this) {
  std_map_Map__8_free(this->map);
  std_mem_free(this);
}

void std_set_Set__2_add(std_set_Set__2 *this, char *key) {
  std_map_Map__8_insert(this->map, key, true);
  this->size=this->map->size;
}

bool std_set_Set__2_contains(std_set_Set__2 *this, char *key) {
  return std_map_Map__8_contains(this->map, key);}

std_set_Set__2 *std_set_Set__2_new(void) {
  std_set_Set__2 *set = std_mem_alloc__30(1);
  set->map=std_map_Map__8_new(8);
  return set;
}

void std_set_Set__3_free(std_set_Set__3 *this) {
  std_map_Map__13_free(this->map);
  std_mem_free(this);
}

void std_set_Set__3_add(std_set_Set__3 *this, std_span_Span key) {
  std_map_Map__13_insert(this->map, key, true);
  this->size=this->map->size;
}

std_set_Set__3 *std_set_Set__3_new(void) {
  std_set_Set__3 *set = std_mem_alloc__31(1);
  set->map=std_map_Map__13_new(8);
  return set;
}

std_set_Iterator__3 std_set_Set__3_iter(std_set_Set__3 *this) {
  return std_set_Iterator__3_make(this);}

std_span_Span std_set_Iterator__3_cur(std_set_Iterator__3 *this) {
  return std_map_Iterator__13_cur(&this->map_iter)->key;}

void std_set_Iterator__3_next(std_set_Iterator__3 *this) {
  std_map_Iterator__13_next(&this->map_iter);
}

bool std_set_Iterator__3_has_value(std_set_Iterator__3 *this) {
  return std_map_Iterator__13_has_value(&this->map_iter);}

std_set_Iterator__3 std_set_Iterator__3_make(std_set_Set__3 *set) {
  return (std_set_Iterator__3){.map_iter=std_map_Map__13_iter(set->map)};}

std_span_Location std_span_Location_default(void) {
  std_span_Location loc = {0};
  loc.filename="<default>";
  loc.line=0;
  loc.col=0;
  loc.index=0;
  return loc;
}

u32 std_span_Location_hash(std_span_Location this) {
  return std_traits_hash_pair_hash(str_hash(this.filename), u32_hash(this.index));}

bool std_span_Location_eq(std_span_Location this, std_span_Location other) {
  return (str_eq(this.filename, other.filename) && this.index==other.index);}

char *std_span_Location_str(std_span_Location *this) {
  return std_format("%s:%u:%u", this->filename, this->line, this->col);
}

bool std_span_Location_is_valid(std_span_Location *this) {
  return ((this->line > 0) && (this->col > 0)) && (this->index >= 0);
}

bool std_span_Location_is_before(std_span_Location *this, std_span_Location other) {
  if (this->line > other.line) {
    return false;
  }
  if (this->line < other.line) {
    return true;
  }
  return this->col <= other.col;
}

std_span_Span std_span_Span_default(void) {
  std_span_Span span = {0};
  span.start=(std_span_Location){.filename="<default>", .line=0, .col=0, .index=0};
  span.end=(std_span_Location){.filename="<default>", .line=0, .col=0, .index=0};
  return span;
}

u32 std_span_Span_hash(std_span_Span this) {
  return std_traits_hash_pair_hash(std_span_Location_hash(this.start), u32_hash(this.end.index));}

bool std_span_Span_eq(std_span_Span this, std_span_Span other) {
  return (std_span_Location_eq(this.start, other.start) && std_span_Location_eq(this.end, other.end));}

bool std_span_Span_is_valid(std_span_Span this) {
  return std_span_Location_is_valid(&this.start) && std_span_Location_is_valid(&this.end);
}

std_span_Span std_span_Span_join(std_span_Span this, std_span_Span other) {
  std_span_Span span = {0};
  span.start=this.start;
  span.end=other.end;
  return span;
}

bool std_span_Span_contains_loc(std_span_Span this, std_span_Location loc) {
  if (!(std_span_Span_is_valid(this))) {
    return false;
  }
  if (!(str_eq(this.start.filename, loc.filename))) {
    return false;
  }
  return std_span_Location_is_before(&this.start, loc) && std_span_Location_is_before(&loc, this.end);
}

bool std_span_Span_starts_right_after(std_span_Span this, std_span_Span other) {
  if (!(std_span_Span_is_valid(this))) {
    return false;
  }
  if (!(str_eq(this.start.filename, other.start.filename))) {
    return false;
  }
  return this.start.index==other.end.index;
}

bool u64_eq(u64 this, u64 other) {
  return this==other;}

bool untyped_ptr_eq(void *this, void *other) {
  return this==other;}

u32 std_traits_hash_hash_bytes(u8 *data, u32 len) {
  u32 hash = 5381;
  for (u32 i = 0; i < len; i+=1) {
    hash=((hash * 33) ^ ((u32)data[i]));
  }
  return hash;
}

u32 std_traits_hash_pair_hash(u32 a, u32 b) {
  return ((a * 33) ^ b);}

u32 std_traits_hash_ptr_hash(void *ptr) {
  return u64_hash(((u64)ptr));}

u32 untyped_ptr_hash(void *this) {
  return std_traits_hash_ptr_hash(this);}

u32 str_hash(char *this) {
  return std_traits_hash_hash_bytes(((u8 *)this), strlen(this));}

u32 u32_hash(u32 this) {
  return (((u32)this) * 7817);}

u32 u64_hash(u64 this) {
  return std_traits_hash_pair_hash(u32_hash(((u32)this)), u32_hash(((u32)(this >> ((u64)32)))));}

char *std_value_ValueType_str(std_value_ValueType this) {
  return std_value_ValueType_dbg(this);}

std_value_Value *std_value_Value_new(std_value_ValueType type) {
  std_value_Value *val = std_mem_alloc__32(1);
  val->type=type;
switch ((type)) {
    case std_value_ValueType_Dictionary:
    m_664_0:
      {
        val->u.as_dict=std_compact_map_Map__1_new(16);
      } break;
    case std_value_ValueType_List:
    m_664_1:
      {
        val->u.as_list=std_vector_Vector__28_new(16);
      } break;
    default:
      {
      } break;
  }  val->span=std_span_Span_default();
  return val;
}

std_value_Value *std_value_Value_new_str(char *s) {
  std_value_Value *val = std_value_Value_new(std_value_ValueType_String);
  val->u.as_str=std_buffer_Buffer_from_str(s);
  return val;
}

std_value_Value *std_value_Value_new_bool(bool bul) {
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Bool);
  val->u.as_bool=bul;
  return val;
}

std_value_Value *std_value_Value_new_int(i64 num) {
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Integer);
  val->u.as_int=num;
  return val;
}

std_value_Value *std_value_Value_new_list(std_vector_Vector__28 *vec) {
  std_value_Value *val = std_value_Value_new(std_value_ValueType_List);
  std_mem_free(val->u.as_list);
  val->u.as_list=vec;
  return val;
}

std_value_Value *std_value_Value_new_dict(std_compact_map_Map__1 *map) {
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Dictionary);
  std_mem_free(val->u.as_dict);
  val->u.as_dict=map;
  return val;
}

void std_value_Value_ensure(std_value_Value *this, std_value_ValueType type) {
  if (this->type != type) {
    printf("%s:%u:%u: Value type mismatch, expected %s but got %s\n", (this->span.start).filename, (this->span.start).line, (this->span.start).col, std_value_ValueType_dbg(this->type), std_value_ValueType_dbg(type));
    exit(1);
  }
}

bool std_value_Value_is(std_value_Value this, std_value_ValueType type) {
  return this.type==type;}

std_value_Value *std_value_Value_at(std_value_Value *this, u32 idx) {
  std_value_Value_ensure(this, std_value_ValueType_List);
  if (idx >= this->u.as_list->size) {
    printf("%s:%u:%u: Index out of bounds: %u\n", (this->span.start).filename, (this->span.start).line, (this->span.start).col, idx);
    exit(1);
  }
  return std_vector_Vector__28_at(this->u.as_list, idx);
}

std_value_Value *std_value_Value_at_key(std_value_Value *this, char *key) {
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);
  if (!(std_compact_map_Map__1_contains(this->u.as_dict, key))) {
    printf("%s:%u:%u: Key not found: %s\n", (this->span.start).filename, (this->span.start).line, (this->span.start).col, key);
    exit(1);
  }
  return std_compact_map_Map__1_get(this->u.as_dict, key, NULL);
}

void std_value_Value_push(std_value_Value *this, std_value_Value *value) {
  std_value_Value_ensure(this, std_value_ValueType_List);
  std_vector_Vector__28_push(this->u.as_list, value);
}

bool std_value_Value_contains(std_value_Value *this, char *key) {
  if (this->type != std_value_ValueType_Dictionary) {
    return false;
  }
  return std_compact_map_Map__1_contains(this->u.as_dict, key);
}

std_value_Value *std_value_Value_get(std_value_Value *this, char *key, std_value_Value *defolt) {
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);
  return std_compact_map_Map__1_get(this->u.as_dict, key, defolt);
}

void std_value_Value_insert(std_value_Value *this, char *key, std_value_Value *value) {
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);
  std_compact_map_Map__1_insert(this->u.as_dict, key, value);
}

void std_value_Value_insert_str(std_value_Value *this, char *key, char *s) {
    std_value_Value_insert(this, key, std_value_Value_new_str(s));
}

void std_value_Value_insert_u32(std_value_Value *this, char *key, u32 i) {
    std_value_Value_insert(this, key, std_value_Value_new_int(((i64)i)));
}

i64 std_value_Value_as_int(std_value_Value *this) {
  return ({i64 __yv_665;
switch ((this->type)) {
      case std_value_ValueType_Integer:
      m_666_0:
        {
          __yv_665 = this->u.as_int;
          goto _l___yv_665;
        } break;
      case std_value_ValueType_Float:
      m_666_1:
        {
          __yv_665 = ((i64)this->u.as_float);
          goto _l___yv_665;
        } break;
      default:
        {
          std_value_Value_ensure(this, std_value_ValueType_Float);
          if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/value.oc:190:20: Assertion failed: `false`", "unreachable"); exit(1); }
        } break;
    }
_l___yv_665:
  __yv_665;});
}

std_buffer_Buffer std_value_Value_as_str(std_value_Value *this) {
  std_value_Value_ensure(this, std_value_ValueType_String);
  return this->u.as_str;
}

std_vector_Vector__28 *std_value_Value_as_list(std_value_Value *this) {
  std_value_Value_ensure(this, std_value_ValueType_List);
  return this->u.as_list;
}

std_compact_map_Map__1 *std_value_Value_as_dict(std_value_Value *this) {
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);
  return this->u.as_dict;
}

char *std_value_Value_dbg(std_value_Value *this) {
  std_buffer_Buffer buf = std_json_serialize(this);
  return std_buffer_Buffer_str(buf);
}

bool std_value_Value_eq_str(std_value_Value *this, char *other) {
  if (!(std_value_Value_is((*this), std_value_ValueType_String))) {
    return false;
  }
  return str_eq(std_buffer_Buffer_str(this->u.as_str), other);
}

std_process_Output std_process_Output_from_error(i32 error_code) {
  std_process_Output out = {0};
  out.error=true;
  out.error_code=error_code;
  return out;
}

std_process_Output std_process_get_output(char *cmd, _ClosureTy_32 callback, bool capture_stderr, char *shell) {
  if ((((bool)cmd) && ((bool)callback.fn)) || (!(((bool)cmd)) && !(((bool)callback.fn)))) {
    std_panic("Exactly one of cmd or callback must be provided");
  }
  i32 fds[2] = {0};
  if (pipe(fds)==-1) {
    return std_process_Output_from_error(-1);
  }
  i32 pid = fork();
  if (pid==-1) {
    return std_process_Output_from_error(-1);
  }
  if (pid==0) {
    close(fds[0]);
    if (fds[1] != 1) {
      dup2(fds[1], 1);
    }
    if (capture_stderr) {
      if (fds[1] != 2) {
        dup2(fds[1], 2);
      }
    }
    close(fds[1]);
    if (((bool)cmd)) {
      char *args[4] = {shell, "-c", cmd, NULL};
      execvp(args[0], args);
      exit(1);
    } else {
      callback.fn(callback._C);
      exit(0);
    }
  }
  i32 status;
  i32 exit_code = 0;
  waitpid(pid, &status, 0);
  if (WIFEXITED(status)) {
    exit_code=WEXITSTATUS(status);
  } else {
    exit_code=-1;
  }
  close(fds[1]);
  std_buffer_Buffer out = std_buffer_Buffer_make(16);
  u8 buf[4096] = {0};
  while (true) {
    i32 n = read(fds[0], buf, 4096);
    if (n==-1) {
      close(fds[0]);
      return std_process_Output_from_error(-1);
    }
    if (n==0) {
      break;
    }
    std_buffer_Buffer_write_bytes(&out, buf, ((u32)n));
  }
  close(fds[0]);
  return (std_process_Output){.error=(exit_code != 0), .error_code=exit_code, .output=out};
}

f64 std_time_get_time_monotonic_ms(void) {
  struct timespec tv = {0};
  clock_gettime(CLOCK_MONOTONIC, &tv);
  return (((f64)tv.tv_sec) * 1000.000000) + (((f64)tv.tv_nsec) / 1000000.000000);
}

char *std_fs_realpath(char *path) {
  char *res = std_mem_alloc__19((2048 + 1));
  realpath(path, res);
  return res;
}

i32 std_fs_File_read(FILE *this, void *buf, u32 size) {
  return fread(buf, 1, size, this);
}

i32 std_fs_File_write(FILE *this, void *buf, u32 size) {
  return fwrite(buf, 1, size, this);
}

bool std_fs_file_exists(char *path) {
  FILE *file = fopen(path, "r");
  if (!(((bool)file))) {
    return false;
  }
  fclose(file);
  return true;
}

void std_fs_write_file_bytes(char *path, void *data, u32 size) {
  FILE *file = fopen(path, "wb");
  if (!(((bool)file))) {
    std_panic(std_format("[-] Failed to open file: %s", path));
  }
  i32 written = fwrite(data, 1, size, file);
  if (((u32)written) != size) {
    std_panic(std_format("[-] Failed to write to file: %s", path));
  }
  fclose(file);
}

void std_fs_write_file_str(char *path, char *data) {
  std_fs_write_file_bytes(path, data, strlen(data));
}

void std_fs_write_file(char *path, std_buffer_Buffer data) {
  std_fs_write_file_bytes(path, data.data, data.size);
}

std_buffer_Buffer std_fs_read_file(char *path) {
  FILE *file = fopen(path, "r");
  if (!(((bool)file))) {
    std_panic(std_format("[-] Failed to open file: %s: %s", path, std_libc_errno_get_err()));
  }
  fseek(file, ((i64)0), SEEK_END);
  u32 size = ((u32)ftell(file));
  fseek(file, ((i64)0), SEEK_SET);
  std_buffer_Buffer data = std_buffer_Buffer_make((size + 1));
  i32 read = fread(data.data, 1, size, file);
  if (((u32)read) != size) {
    std_panic(std_format("[-] Failed to read from file: %s", path));
  }
  fclose(file);
  data.size=((u32)size);
  data.data[size]=((u8)0);
  return data;
}

bool std_fs_directory_exists(char *path) {
  DIR *dir = opendir(path);
  if (dir==NULL) {
    return false;
  }
  closedir(dir);
  return true;
}

std_fs_DirectoryIterator std_fs_iterate_directory(char *path, bool skip_self_and_parent) {
  DIR *dir = opendir(path);
  if (dir==NULL) {
    std_panic(std_format("[-] Failed to open directory: %s", path));
  }
  std_fs_DirectoryIterator iter = {0};
  iter.dir=dir;
  iter.skip_self_and_parent=skip_self_and_parent;
  std_fs_DirectoryIterator_next(&iter);
  return iter;
}

bool std_fs_DirectoryIterator_has_value(std_fs_DirectoryIterator *this) {
  return ((bool)this->dp);}

void std_fs_DirectoryIterator_next(std_fs_DirectoryIterator *this) {
  this->dp=readdir(this->dir);
  while (((bool)this->dp) && this->skip_self_and_parent) {
    {
      char *__match_var_667 = this->dp->d_name;
      if (str_eq(__match_var_667, ".") || str_eq(__match_var_667, "..")) {
        this->dp=readdir(this->dir);
      } else  {
        goto _While_break_668;
      }
    }
  }
  _While_break_668:;
}

std_fs_DirectoryEntry std_fs_DirectoryIterator_cur(std_fs_DirectoryIterator *this) {
  char *name = this->dp->d_name;
  std_fs_EntryType type = ({std_fs_EntryType __yv_669;
    switch (this->dp->d_type) {
      case DT_DIR: {
        __yv_669 = std_fs_EntryType_Directory;
        goto _l___yv_669;
      } break;
      case DT_REG: {
        __yv_669 = std_fs_EntryType_File;
        goto _l___yv_669;
      } break;
      case DT_LNK: {
        __yv_669 = std_fs_EntryType_SymbolicLink;
        goto _l___yv_669;
      } break;
      default: {
        __yv_669 = std_fs_EntryType_Unknown;
        goto _l___yv_669;
      } break;
    }

_l___yv_669:
  __yv_669;});
  return (std_fs_DirectoryEntry){.type=type, .name=name};
}

std_map_Item__0 *std_map_Item__0_new(u64 key, bool value, std_map_Item__0 *next) {
  std_map_Item__0 *node = std_mem_alloc__33(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__0_free_list(std_map_Item__0 *this) {
  std_map_Item__0 *cur = this;
  while (((bool)cur)) {
    std_map_Item__0 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__0_free(std_map_Map__0 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__0_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__0_insert(std_map_Map__0 *this, u64 key, bool value) {
  std_map_Item__0 *node = std_map_Map__0_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__0_hash(this, key);
    std_map_Item__0 *new_node = std_map_Item__0_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__0_resize(this);
    }
  }
}

bool std_map_Map__0_contains(std_map_Map__0 *this, u64 key) {
  return ((bool)std_map_Map__0_get_item(this, key));
}

void std_map_Map__0_resize(std_map_Map__0 *this) {
  std_map_Item__0 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__34(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__0 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__0_hash(this, node->key);
      std_map_Item__0 *new_node = std_map_Item__0_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__0_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__0_hash(std_map_Map__0 *this, u64 key) {
  u32 hash = u64_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__0 *std_map_Map__0_new(u32 capacity) {
  std_map_Map__0 *map = std_mem_alloc__35(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__34(map->num_buckets);
  return map;
}

std_map_Item__0 *std_map_Map__0_get_item(std_map_Map__0 *this, u64 key) {
  u32 hash = std_map_Map__0_hash(this, key);
  std_map_Item__0 *node = this->buckets[hash];
  while (((bool)node)) {
    if (u64_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__1 *std_map_Item__1_new(char *key, compiler_ast_nodes_MatchCond *value, std_map_Item__1 *next) {
  std_map_Item__1 *node = std_mem_alloc__36(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__1_free_list(std_map_Item__1 *this) {
  std_map_Item__1 *cur = this;
  while (((bool)cur)) {
    std_map_Item__1 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__1_free(std_map_Map__1 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__1_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__1_insert(std_map_Map__1 *this, char *key, compiler_ast_nodes_MatchCond *value) {
  std_map_Item__1 *node = std_map_Map__1_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__1_hash(this, key);
    std_map_Item__1 *new_node = std_map_Item__1_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__1_resize(this);
    }
  }
}

compiler_ast_nodes_MatchCond *std_map_Map__1_get(std_map_Map__1 *this, char *key, compiler_ast_nodes_MatchCond *defolt) {
  std_map_Item__1 *node = std_map_Map__1_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

bool std_map_Map__1_contains(std_map_Map__1 *this, char *key) {
  return ((bool)std_map_Map__1_get_item(this, key));
}

void std_map_Map__1_resize(std_map_Map__1 *this) {
  std_map_Item__1 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__37(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__1 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__1_hash(this, node->key);
      std_map_Item__1 *new_node = std_map_Item__1_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__1_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__1_hash(std_map_Map__1 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__1 *std_map_Map__1_new(u32 capacity) {
  std_map_Map__1 *map = std_mem_alloc__38(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__37(map->num_buckets);
  return map;
}

std_map_Item__1 *std_map_Map__1_get_item(std_map_Map__1 *this, char *key) {
  u32 hash = std_map_Map__1_hash(this, key);
  std_map_Item__1 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__2 *std_map_Item__2_new(char *key, compiler_types_Type *value, std_map_Item__2 *next) {
  std_map_Item__2 *node = std_mem_alloc__39(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__2_free_list(std_map_Item__2 *this) {
  std_map_Item__2 *cur = this;
  while (((bool)cur)) {
    std_map_Item__2 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__2_free(std_map_Map__2 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__2_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__2_insert(std_map_Map__2 *this, char *key, compiler_types_Type *value) {
  std_map_Item__2 *node = std_map_Map__2_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__2_hash(this, key);
    std_map_Item__2 *new_node = std_map_Item__2_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__2_resize(this);
    }
  }
}

compiler_types_Type *std_map_Map__2_get(std_map_Map__2 *this, char *key, compiler_types_Type *defolt) {
  std_map_Item__2 *node = std_map_Map__2_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

std_map_Item__2 *std_map_Iterator__2_cur(std_map_Iterator__2 *this) {
  return this->node;}

void std_map_Iterator__2_next(std_map_Iterator__2 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__2 *__yv_670;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_670 = this->map->buckets[this->idx];
        goto _l___yv_670;
      } else {
        __yv_670 = NULL;
        goto _l___yv_670;
      }

_l___yv_670:
    __yv_670;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__2_has_value(std_map_Iterator__2 *this) {
  return ((bool)this->node);}

std_map_Iterator__2 std_map_Iterator__2_make(std_map_Map__2 *map) {
  std_map_Iterator__2 it = (std_map_Iterator__2){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__2_next(&it);
  return it;
}

bool std_map_Map__2_is_empty(std_map_Map__2 *this) {
  return this->size==0;}

void std_map_Map__2_resize(std_map_Map__2 *this) {
  std_map_Item__2 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__40(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__2 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__2_hash(this, node->key);
      std_map_Item__2 *new_node = std_map_Item__2_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__2_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__2_hash(std_map_Map__2 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__2 *std_map_Map__2_new(u32 capacity) {
  std_map_Map__2 *map = std_mem_alloc__41(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__40(map->num_buckets);
  return map;
}

std_map_Item__2 *std_map_Map__2_get_item(std_map_Map__2 *this, char *key) {
  u32 hash = std_map_Map__2_hash(this, key);
  std_map_Item__2 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

void std_map_Map__2_clear(std_map_Map__2 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__2_free_list(this->buckets[i]);
    this->buckets[i]=NULL;
  }
  this->size=0;
  this->num_collisions=0;
}

std_map_Iterator__2 std_map_Map__2_iter(std_map_Map__2 *this) {
  return std_map_Iterator__2_make(this);
}

std_map_Item__3 *std_map_Item__3_new(void *key, bool value, std_map_Item__3 *next) {
  std_map_Item__3 *node = std_mem_alloc__42(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__3_free_list(std_map_Item__3 *this) {
  std_map_Item__3 *cur = this;
  while (((bool)cur)) {
    std_map_Item__3 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__3_free(std_map_Map__3 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__3_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__3_insert(std_map_Map__3 *this, void *key, bool value) {
  std_map_Item__3 *node = std_map_Map__3_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__3_hash(this, key);
    std_map_Item__3 *new_node = std_map_Item__3_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__3_resize(this);
    }
  }
}

bool std_map_Map__3_contains(std_map_Map__3 *this, void *key) {
  return ((bool)std_map_Map__3_get_item(this, key));
}

void std_map_Map__3_resize(std_map_Map__3 *this) {
  std_map_Item__3 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__43(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__3 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__3_hash(this, node->key);
      std_map_Item__3 *new_node = std_map_Item__3_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__3_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__3_hash(std_map_Map__3 *this, void *key) {
  u32 hash = untyped_ptr_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__3 *std_map_Map__3_new(u32 capacity) {
  std_map_Map__3 *map = std_mem_alloc__44(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__43(map->num_buckets);
  return map;
}

std_map_Item__3 *std_map_Map__3_get_item(std_map_Map__3 *this, void *key) {
  u32 hash = std_map_Map__3_hash(this, key);
  std_map_Item__3 *node = this->buckets[hash];
  while (((bool)node)) {
    if (untyped_ptr_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__4 *std_map_Item__4_new(char *key, compiler_ast_program_Namespace *value, std_map_Item__4 *next) {
  std_map_Item__4 *node = std_mem_alloc__45(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__4_free_list(std_map_Item__4 *this) {
  std_map_Item__4 *cur = this;
  while (((bool)cur)) {
    std_map_Item__4 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

compiler_ast_program_Namespace *std_map_Map__4_at(std_map_Map__4 *this, char *key) {
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }
  return node->value;
}

void std_map_Map__4_insert(std_map_Map__4 *this, char *key, compiler_ast_program_Namespace *value) {
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__4_hash(this, key);
    std_map_Item__4 *new_node = std_map_Item__4_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__4_resize(this);
    }
  }
}

compiler_ast_program_Namespace *std_map_Map__4_get(std_map_Map__4 *this, char *key, compiler_ast_program_Namespace *defolt) {
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

std_map_Item__4 *std_map_Iterator__4_cur(std_map_Iterator__4 *this) {
  return this->node;}

void std_map_Iterator__4_next(std_map_Iterator__4 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__4 *__yv_671;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_671 = this->map->buckets[this->idx];
        goto _l___yv_671;
      } else {
        __yv_671 = NULL;
        goto _l___yv_671;
      }

_l___yv_671:
    __yv_671;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__4_has_value(std_map_Iterator__4 *this) {
  return ((bool)this->node);}

std_map_Iterator__4 std_map_Iterator__4_make(std_map_Map__4 *map) {
  std_map_Iterator__4 it = (std_map_Iterator__4){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__4_next(&it);
  return it;
}

bool std_map_Map__4_is_empty(std_map_Map__4 *this) {
  return this->size==0;}

bool std_map_Map__4_contains(std_map_Map__4 *this, char *key) {
  return ((bool)std_map_Map__4_get_item(this, key));
}

void std_map_Map__4_resize(std_map_Map__4 *this) {
  std_map_Item__4 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__46(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__4 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__4_hash(this, node->key);
      std_map_Item__4 *new_node = std_map_Item__4_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__4_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__4_hash(std_map_Map__4 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_ValueIterator__4 std_map_Map__4_iter_values(std_map_Map__4 *this) {
  return (std_map_ValueIterator__4){.map_iter=std_map_Map__4_iter(this)};}

compiler_ast_program_Namespace *std_map_ValueIterator__4_cur(std_map_ValueIterator__4 *this) {
  return std_map_Iterator__4_cur(&this->map_iter)->value;}

void std_map_ValueIterator__4_next(std_map_ValueIterator__4 *this) {
  std_map_Iterator__4_next(&this->map_iter);
}

bool std_map_ValueIterator__4_has_value(std_map_ValueIterator__4 *this) {
  return std_map_Iterator__4_has_value(&this->map_iter);}

std_map_Map__4 *std_map_Map__4_new(u32 capacity) {
  std_map_Map__4 *map = std_mem_alloc__47(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__46(map->num_buckets);
  return map;
}

std_map_Item__4 *std_map_Map__4_get_item(std_map_Map__4 *this, char *key) {
  u32 hash = std_map_Map__4_hash(this, key);
  std_map_Item__4 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Iterator__4 std_map_Map__4_iter(std_map_Map__4 *this) {
  return std_map_Iterator__4_make(this);
}

std_map_Item__5 *std_map_Item__5_new(char *key, compiler_ast_scopes_Symbol *value, std_map_Item__5 *next) {
  std_map_Item__5 *node = std_mem_alloc__48(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__5_free_list(std_map_Item__5 *this) {
  std_map_Item__5 *cur = this;
  while (((bool)cur)) {
    std_map_Item__5 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

compiler_ast_scopes_Symbol *std_map_Map__5_at(std_map_Map__5 *this, char *key) {
  std_map_Item__5 *node = std_map_Map__5_get_item(this, key);
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }
  return node->value;
}

void std_map_Map__5_insert(std_map_Map__5 *this, char *key, compiler_ast_scopes_Symbol *value) {
  std_map_Item__5 *node = std_map_Map__5_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__5_hash(this, key);
    std_map_Item__5 *new_node = std_map_Item__5_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__5_resize(this);
    }
  }
}

compiler_ast_scopes_Symbol *std_map_Map__5_get(std_map_Map__5 *this, char *key, compiler_ast_scopes_Symbol *defolt) {
  std_map_Item__5 *node = std_map_Map__5_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

std_map_Item__5 *std_map_Iterator__5_cur(std_map_Iterator__5 *this) {
  return this->node;}

void std_map_Iterator__5_next(std_map_Iterator__5 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__5 *__yv_672;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_672 = this->map->buckets[this->idx];
        goto _l___yv_672;
      } else {
        __yv_672 = NULL;
        goto _l___yv_672;
      }

_l___yv_672:
    __yv_672;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__5_has_value(std_map_Iterator__5 *this) {
  return ((bool)this->node);}

std_map_Iterator__5 std_map_Iterator__5_make(std_map_Map__5 *map) {
  std_map_Iterator__5 it = (std_map_Iterator__5){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__5_next(&it);
  return it;
}

bool std_map_Map__5_contains(std_map_Map__5 *this, char *key) {
  return ((bool)std_map_Map__5_get_item(this, key));
}

void std_map_Map__5_resize(std_map_Map__5 *this) {
  std_map_Item__5 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__49(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__5 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__5_hash(this, node->key);
      std_map_Item__5 *new_node = std_map_Item__5_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__5_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__5_hash(std_map_Map__5 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_ValueIterator__5 std_map_Map__5_iter_values(std_map_Map__5 *this) {
  return (std_map_ValueIterator__5){.map_iter=std_map_Map__5_iter(this)};}

compiler_ast_scopes_Symbol *std_map_ValueIterator__5_cur(std_map_ValueIterator__5 *this) {
  return std_map_Iterator__5_cur(&this->map_iter)->value;}

void std_map_ValueIterator__5_next(std_map_ValueIterator__5 *this) {
  std_map_Iterator__5_next(&this->map_iter);
}

bool std_map_ValueIterator__5_has_value(std_map_ValueIterator__5 *this) {
  return std_map_Iterator__5_has_value(&this->map_iter);}

std_map_Map__5 *std_map_Map__5_new(u32 capacity) {
  std_map_Map__5 *map = std_mem_alloc__50(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__49(map->num_buckets);
  return map;
}

std_map_Item__5 *std_map_Map__5_get_item(std_map_Map__5 *this, char *key) {
  u32 hash = std_map_Map__5_hash(this, key);
  std_map_Item__5 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Iterator__5 std_map_Map__5_iter(std_map_Map__5 *this) {
  return std_map_Iterator__5_make(this);
}

std_map_Item__6 *std_map_Item__6_new(compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value, std_map_Item__6 *next) {
  std_map_Item__6 *node = std_mem_alloc__51(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__6_free_list(std_map_Item__6 *this) {
  std_map_Item__6 *cur = this;
  while (((bool)cur)) {
    std_map_Item__6 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__6_insert(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value) {
  std_map_Item__6 *node = std_map_Map__6_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__6_hash(this, key);
    std_map_Item__6 *new_node = std_map_Item__6_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__6_resize(this);
    }
  }
}

compiler_ast_nodes_Function *std_map_Map__6_get(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *defolt) {
  std_map_Item__6 *node = std_map_Map__6_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

void std_map_Map__6_resize(std_map_Map__6 *this) {
  std_map_Item__6 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__52(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__6 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__6_hash(this, node->key);
      std_map_Item__6 *new_node = std_map_Item__6_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__6_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__6_hash(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key) {
  u32 hash = compiler_ast_operators_OperatorOverload_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__6 *std_map_Map__6_new(u32 capacity) {
  std_map_Map__6 *map = std_mem_alloc__53(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__52(map->num_buckets);
  return map;
}

std_map_Item__6 *std_map_Map__6_get_item(std_map_Map__6 *this, compiler_ast_operators_OperatorOverload key) {
  u32 hash = std_map_Map__6_hash(this, key);
  std_map_Item__6 *node = this->buckets[hash];
  while (((bool)node)) {
    if (compiler_ast_operators_OperatorOverload_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__7 *std_map_Item__7_new(char *key, char *value, std_map_Item__7 *next) {
  std_map_Item__7 *node = std_mem_alloc__54(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__7_free_list(std_map_Item__7 *this) {
  std_map_Item__7 *cur = this;
  while (((bool)cur)) {
    std_map_Item__7 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__7_insert(std_map_Map__7 *this, char *key, char *value) {
  std_map_Item__7 *node = std_map_Map__7_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__7_hash(this, key);
    std_map_Item__7 *new_node = std_map_Item__7_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__7_resize(this);
    }
  }
}

char *std_map_Map__7_get(std_map_Map__7 *this, char *key, char *defolt) {
  std_map_Item__7 *node = std_map_Map__7_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

std_map_Item__7 *std_map_Iterator__7_cur(std_map_Iterator__7 *this) {
  return this->node;}

void std_map_Iterator__7_next(std_map_Iterator__7 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__7 *__yv_673;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_673 = this->map->buckets[this->idx];
        goto _l___yv_673;
      } else {
        __yv_673 = NULL;
        goto _l___yv_673;
      }

_l___yv_673:
    __yv_673;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__7_has_value(std_map_Iterator__7 *this) {
  return ((bool)this->node);}

std_map_Iterator__7 std_map_Iterator__7_make(std_map_Map__7 *map) {
  std_map_Iterator__7 it = (std_map_Iterator__7){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__7_next(&it);
  return it;
}

bool std_map_Map__7_contains(std_map_Map__7 *this, char *key) {
  return ((bool)std_map_Map__7_get_item(this, key));
}

void std_map_Map__7_resize(std_map_Map__7 *this) {
  std_map_Item__7 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__55(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__7 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__7_hash(this, node->key);
      std_map_Item__7 *new_node = std_map_Item__7_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__7_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__7_hash(std_map_Map__7 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__7 *std_map_Map__7_new(u32 capacity) {
  std_map_Map__7 *map = std_mem_alloc__56(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__55(map->num_buckets);
  return map;
}

std_map_Item__7 *std_map_Map__7_get_item(std_map_Map__7 *this, char *key) {
  u32 hash = std_map_Map__7_hash(this, key);
  std_map_Item__7 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Iterator__7 std_map_Map__7_iter(std_map_Map__7 *this) {
  return std_map_Iterator__7_make(this);
}

std_map_Item__8 *std_map_Item__8_new(char *key, bool value, std_map_Item__8 *next) {
  std_map_Item__8 *node = std_mem_alloc__57(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__8_free_list(std_map_Item__8 *this) {
  std_map_Item__8 *cur = this;
  while (((bool)cur)) {
    std_map_Item__8 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__8_free(std_map_Map__8 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__8_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__8_insert(std_map_Map__8 *this, char *key, bool value) {
  std_map_Item__8 *node = std_map_Map__8_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__8_hash(this, key);
    std_map_Item__8 *new_node = std_map_Item__8_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__8_resize(this);
    }
  }
}

bool std_map_Map__8_contains(std_map_Map__8 *this, char *key) {
  return ((bool)std_map_Map__8_get_item(this, key));
}

void std_map_Map__8_resize(std_map_Map__8 *this) {
  std_map_Item__8 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__58(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__8 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__8_hash(this, node->key);
      std_map_Item__8 *new_node = std_map_Item__8_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__8_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__8_hash(std_map_Map__8 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__8 *std_map_Map__8_new(u32 capacity) {
  std_map_Map__8 *map = std_mem_alloc__59(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__58(map->num_buckets);
  return map;
}

std_map_Item__8 *std_map_Map__8_get_item(std_map_Map__8 *this, char *key) {
  u32 hash = std_map_Map__8_hash(this, key);
  std_map_Item__8 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__9 *std_map_Item__9_new(char *key, compiler_ast_nodes_Function *value, std_map_Item__9 *next) {
  std_map_Item__9 *node = std_mem_alloc__60(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__9_free_list(std_map_Item__9 *this) {
  std_map_Item__9 *cur = this;
  while (((bool)cur)) {
    std_map_Item__9 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

compiler_ast_nodes_Function *std_map_Map__9_at(std_map_Map__9 *this, char *key) {
  std_map_Item__9 *node = std_map_Map__9_get_item(this, key);
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }
  return node->value;
}

void std_map_Map__9_insert(std_map_Map__9 *this, char *key, compiler_ast_nodes_Function *value) {
  std_map_Item__9 *node = std_map_Map__9_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__9_hash(this, key);
    std_map_Item__9 *new_node = std_map_Item__9_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__9_resize(this);
    }
  }
}

compiler_ast_nodes_Function *std_map_Map__9_get(std_map_Map__9 *this, char *key, compiler_ast_nodes_Function *defolt) {
  std_map_Item__9 *node = std_map_Map__9_get_item(this, key);
  if (!(((bool)node))) {
    return defolt;
  }
  return node->value;
}

std_map_Item__9 *std_map_Iterator__9_cur(std_map_Iterator__9 *this) {
  return this->node;}

void std_map_Iterator__9_next(std_map_Iterator__9 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__9 *__yv_674;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_674 = this->map->buckets[this->idx];
        goto _l___yv_674;
      } else {
        __yv_674 = NULL;
        goto _l___yv_674;
      }

_l___yv_674:
    __yv_674;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__9_has_value(std_map_Iterator__9 *this) {
  return ((bool)this->node);}

std_map_Iterator__9 std_map_Iterator__9_make(std_map_Map__9 *map) {
  std_map_Iterator__9 it = (std_map_Iterator__9){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__9_next(&it);
  return it;
}

void std_map_Map__9_resize(std_map_Map__9 *this) {
  std_map_Item__9 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__61(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__9 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__9_hash(this, node->key);
      std_map_Item__9 *new_node = std_map_Item__9_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__9_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__9_hash(std_map_Map__9 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_ValueIterator__9 std_map_Map__9_iter_values(std_map_Map__9 *this) {
  return (std_map_ValueIterator__9){.map_iter=std_map_Map__9_iter(this)};}

compiler_ast_nodes_Function *std_map_ValueIterator__9_cur(std_map_ValueIterator__9 *this) {
  return std_map_Iterator__9_cur(&this->map_iter)->value;}

void std_map_ValueIterator__9_next(std_map_ValueIterator__9 *this) {
  std_map_Iterator__9_next(&this->map_iter);
}

bool std_map_ValueIterator__9_has_value(std_map_ValueIterator__9 *this) {
  return std_map_Iterator__9_has_value(&this->map_iter);}

std_map_Map__9 *std_map_Map__9_new(u32 capacity) {
  std_map_Map__9 *map = std_mem_alloc__62(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__61(map->num_buckets);
  return map;
}

std_map_Item__9 *std_map_Map__9_get_item(std_map_Map__9 *this, char *key) {
  u32 hash = std_map_Map__9_hash(this, key);
  std_map_Item__9 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Iterator__9 std_map_Map__9_iter(std_map_Map__9 *this) {
  return std_map_Iterator__9_make(this);
}

std_map_Item__10 *std_map_Item__10_new(char *key, compiler_ast_nodes_Argument *value, std_map_Item__10 *next) {
  std_map_Item__10 *node = std_mem_alloc__63(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__10_free_list(std_map_Item__10 *this) {
  std_map_Item__10 *cur = this;
  while (((bool)cur)) {
    std_map_Item__10 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__10_free(std_map_Map__10 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__10_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__10_insert(std_map_Map__10 *this, char *key, compiler_ast_nodes_Argument *value) {
  std_map_Item__10 *node = std_map_Map__10_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__10_hash(this, key);
    std_map_Item__10 *new_node = std_map_Item__10_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__10_resize(this);
    }
  }
}

void std_map_Map__10_resize(std_map_Map__10 *this) {
  std_map_Item__10 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__64(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__10 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__10_hash(this, node->key);
      std_map_Item__10 *new_node = std_map_Item__10_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__10_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__10_hash(std_map_Map__10 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__10 *std_map_Map__10_new(u32 capacity) {
  std_map_Map__10 *map = std_mem_alloc__65(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__64(map->num_buckets);
  return map;
}

std_map_Item__10 *std_map_Map__10_get_item(std_map_Map__10 *this, char *key) {
  u32 hash = std_map_Map__10_hash(this, key);
  std_map_Item__10 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__11 *std_map_Item__11_new(char *key, compiler_ast_nodes_Variable *value, std_map_Item__11 *next) {
  std_map_Item__11 *node = std_mem_alloc__66(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__11_free_list(std_map_Item__11 *this) {
  std_map_Item__11 *cur = this;
  while (((bool)cur)) {
    std_map_Item__11 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__11_free(std_map_Map__11 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__11_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__11_insert(std_map_Map__11 *this, char *key, compiler_ast_nodes_Variable *value) {
  std_map_Item__11 *node = std_map_Map__11_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__11_hash(this, key);
    std_map_Item__11 *new_node = std_map_Item__11_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__11_resize(this);
    }
  }
}

void std_map_Map__11_resize(std_map_Map__11 *this) {
  std_map_Item__11 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__67(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__11 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__11_hash(this, node->key);
      std_map_Item__11 *new_node = std_map_Item__11_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__11_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__11_hash(std_map_Map__11 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__11 *std_map_Map__11_new(u32 capacity) {
  std_map_Map__11 *map = std_mem_alloc__68(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__67(map->num_buckets);
  return map;
}

std_map_Item__11 *std_map_Map__11_get_item(std_map_Map__11 *this, char *key) {
  u32 hash = std_map_Map__11_hash(this, key);
  std_map_Item__11 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__12 *std_map_Item__12_new(char *key, std_span_Span value, std_map_Item__12 *next) {
  std_map_Item__12 *node = std_mem_alloc__69(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__12_free_list(std_map_Item__12 *this) {
  std_map_Item__12 *cur = this;
  while (((bool)cur)) {
    std_map_Item__12 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__12_free(std_map_Map__12 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__12_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__12_insert(std_map_Map__12 *this, char *key, std_span_Span value) {
  std_map_Item__12 *node = std_map_Map__12_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__12_hash(this, key);
    std_map_Item__12 *new_node = std_map_Item__12_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__12_resize(this);
    }
  }
}

void std_map_Map__12_resize(std_map_Map__12 *this) {
  std_map_Item__12 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__70(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__12 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__12_hash(this, node->key);
      std_map_Item__12 *new_node = std_map_Item__12_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__12_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__12_hash(std_map_Map__12 *this, char *key) {
  u32 hash = str_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__12 *std_map_Map__12_new(u32 capacity) {
  std_map_Map__12 *map = std_mem_alloc__71(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__70(map->num_buckets);
  return map;
}

std_map_Item__12 *std_map_Map__12_get_item(std_map_Map__12 *this, char *key) {
  u32 hash = std_map_Map__12_hash(this, key);
  std_map_Item__12 *node = this->buckets[hash];
  while (((bool)node)) {
    if (str_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Item__13 *std_map_Item__13_new(std_span_Span key, bool value, std_map_Item__13 *next) {
  std_map_Item__13 *node = std_mem_alloc__72(1);
  node->key=key;
  node->value=value;
  node->next=next;
  return node;
}

void std_map_Item__13_free_list(std_map_Item__13 *this) {
  std_map_Item__13 *cur = this;
  while (((bool)cur)) {
    std_map_Item__13 *next = cur->next;
    std_mem_free(cur);
    cur=next;
  }
}

void std_map_Map__13_free(std_map_Map__13 *this) {
  for (u32 i = 0; i < this->num_buckets; i+=1) {
    std_map_Item__13_free_list(this->buckets[i]);
  }
  std_mem_free(this->buckets);
  std_mem_free(this);
}

void std_map_Map__13_insert(std_map_Map__13 *this, std_span_Span key, bool value) {
  std_map_Item__13 *node = std_map_Map__13_get_item(this, key);
  if (((bool)node)) {
    node->value=value;
  } else {
    u32 hash = std_map_Map__13_hash(this, key);
    std_map_Item__13 *new_node = std_map_Item__13_new(key, value, this->buckets[hash]);
    if (((bool)this->buckets[hash])) {
      this->num_collisions+=1;
    }
    this->buckets[hash]=new_node;
    this->size+=1;
    if (this->size > this->num_buckets) {
      std_map_Map__13_resize(this);
    }
  }
}

std_map_Item__13 *std_map_Iterator__13_cur(std_map_Iterator__13 *this) {
  return this->node;}

void std_map_Iterator__13_next(std_map_Iterator__13 *this) {
  while (this->idx < ((i32)this->map->num_buckets)) {
    while (((bool)this->node)) {
      this->node=this->node->next;
      if (((bool)this->node)) {
        return;
      }
    }
    this->idx+=1;
    this->node=({std_map_Item__13 *__yv_675;
      if (this->idx < ((i32)this->map->num_buckets)) {
        __yv_675 = this->map->buckets[this->idx];
        goto _l___yv_675;
      } else {
        __yv_675 = NULL;
        goto _l___yv_675;
      }

_l___yv_675:
    __yv_675;});
    if (((bool)this->node)) {
      return;
    }
  }
}

bool std_map_Iterator__13_has_value(std_map_Iterator__13 *this) {
  return ((bool)this->node);}

std_map_Iterator__13 std_map_Iterator__13_make(std_map_Map__13 *map) {
  std_map_Iterator__13 it = (std_map_Iterator__13){.idx=-1, .node=NULL, .map=map};
  std_map_Iterator__13_next(&it);
  return it;
}

void std_map_Map__13_resize(std_map_Map__13 *this) {
  std_map_Item__13 **old_buckets = this->buckets;
  u32 old_num_buckets = this->num_buckets;
  u32 old_size = this->size;
  this->num_collisions=0;
  this->num_buckets*=2;
  this->num_buckets=u32_max(this->num_buckets, 16);
  this->buckets=std_mem_alloc__73(this->num_buckets);
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__13 *node = old_buckets[i];
    while (((bool)node)) {
      u32 new_hash = std_map_Map__13_hash(this, node->key);
      std_map_Item__13 *new_node = std_map_Item__13_new(node->key, node->value, this->buckets[new_hash]);
      if (((bool)this->buckets[new_hash])) {
        this->num_collisions+=1;
      }
      this->buckets[new_hash]=new_node;
      node=node->next;
    }
  }
  for (u32 i = 0; i < old_num_buckets; i+=1) {
    std_map_Item__13_free_list(old_buckets[i]);
  }
  std_mem_free(old_buckets);
}

u32 std_map_Map__13_hash(std_map_Map__13 *this, std_span_Span key) {
  u32 hash = std_span_Span_hash(key);
  hash=(hash % this->num_buckets);
  if (hash < 0) {
    hash+=this->num_buckets;
  }
  return hash;
}

std_map_Map__13 *std_map_Map__13_new(u32 capacity) {
  std_map_Map__13 *map = std_mem_alloc__74(1);
  map->num_buckets=capacity;
  map->buckets=std_mem_alloc__73(map->num_buckets);
  return map;
}

std_map_Item__13 *std_map_Map__13_get_item(std_map_Map__13 *this, std_span_Span key) {
  u32 hash = std_map_Map__13_hash(this, key);
  std_map_Item__13 *node = this->buckets[hash];
  while (((bool)node)) {
    if (std_span_Span_eq(node->key, key)) {
      return node;
    }
    node=node->next;
  }
  return NULL;
}

std_map_Iterator__13 std_map_Map__13_iter(std_map_Map__13 *this) {
  return std_map_Iterator__13_make(this);
}

void std_signal_set_signal_handler(i32 sig, void (*callback)(i32)) {
  struct sigaction action = (struct sigaction){.sa_handler=callback, .sa_flags=SA_NODEFER};
  sigaction(sig, &action, NULL);
}

std_vector_Iterator__0 std_vector_Vector__0_iter(std_vector_Vector__0 *this) {
  return std_vector_Iterator__0_make(this);}

compiler_types_Type *std_vector_Iterator__0_cur(std_vector_Iterator__0 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__0_next(std_vector_Iterator__0 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__0_has_value(std_vector_Iterator__0 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__0 std_vector_Iterator__0_make(std_vector_Vector__0 *vec) {
  return (std_vector_Iterator__0){.vec=vec, .index=0};}

compiler_types_Type *std_vector_Vector__0_at(std_vector_Vector__0 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__0_resize(std_vector_Vector__0 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__1(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__0 *std_vector_Vector__0_new(u32 capacity) {
  std_vector_Vector__0 *list = std_mem_alloc__75(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__76(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__0_push(std_vector_Vector__0 *this, compiler_types_Type *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__0_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

char *std_vector_Vector__1_pop(std_vector_Vector__1 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

char *std_vector_Vector__1_back(std_vector_Vector__1 *this, u32 i) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:101:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:102:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }
  return this->data[((this->size - i) - 1)];
}

std_vector_Iterator__1 std_vector_Vector__1_iter(std_vector_Vector__1 *this) {
  return std_vector_Iterator__1_make(this);}

char *std_vector_Iterator__1_cur(std_vector_Iterator__1 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__1_next(std_vector_Iterator__1 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__1_has_value(std_vector_Iterator__1 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__1 std_vector_Iterator__1_make(std_vector_Vector__1 *vec) {
  return (std_vector_Iterator__1){.vec=vec, .index=0};}

char *std_vector_Vector__1_at(std_vector_Vector__1 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__1_free(std_vector_Vector__1 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

void std_vector_Vector__1_resize(std_vector_Vector__1 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__2(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__1 *std_vector_Vector__1_new(u32 capacity) {
  std_vector_Vector__1 *list = std_mem_alloc__77(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__78(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__1_push(std_vector_Vector__1 *this, char *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__1_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

compiler_ast_scopes_Scope *std_vector_Vector__2_pop(std_vector_Vector__2 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

compiler_ast_scopes_Scope *std_vector_Vector__2_back(std_vector_Vector__2 *this, u32 i) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:101:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:102:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }
  return this->data[((this->size - i) - 1)];
}

compiler_ast_scopes_Scope *std_vector_Vector__2_at(std_vector_Vector__2 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__2_resize(std_vector_Vector__2 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__3(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__2 *std_vector_Vector__2_new(u32 capacity) {
  std_vector_Vector__2 *list = std_mem_alloc__79(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__80(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__2_push(std_vector_Vector__2 *this, compiler_ast_scopes_Scope *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__2_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

compiler_ast_program_Namespace *std_vector_Vector__3_pop(std_vector_Vector__3 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

compiler_ast_program_Namespace *std_vector_Vector__3_at(std_vector_Vector__3 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__3_free(std_vector_Vector__3 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

bool std_vector_Vector__3_is_empty(std_vector_Vector__3 *this) {
  return this->size==0;}

void std_vector_Vector__3_resize(std_vector_Vector__3 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__4(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__3 *std_vector_Vector__3_new(u32 capacity) {
  std_vector_Vector__3 *list = std_mem_alloc__81(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__82(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__3_push(std_vector_Vector__3 *this, compiler_ast_program_Namespace *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__3_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__4_zero_unused(std_vector_Vector__4 *this) {
  compiler_ast_nodes_Variable **start = (this->data + this->size);
  memset(start, ((u8)0), ((this->capacity - this->size) * ((u32)sizeof(compiler_ast_nodes_Variable *))));
}

compiler_ast_nodes_Variable *std_vector_Vector__4_back(std_vector_Vector__4 *this, u32 i) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:101:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:102:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }
  return this->data[((this->size - i) - 1)];
}

std_vector_Iterator__4 std_vector_Vector__4_iter(std_vector_Vector__4 *this) {
  return std_vector_Iterator__4_make(this);}

compiler_ast_nodes_Variable *std_vector_Iterator__4_cur(std_vector_Iterator__4 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__4_next(std_vector_Iterator__4 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__4_has_value(std_vector_Iterator__4 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__4 std_vector_Iterator__4_make(std_vector_Vector__4 *vec) {
  return (std_vector_Iterator__4){.vec=vec, .index=0};}

compiler_ast_nodes_Variable *std_vector_Vector__4_at(std_vector_Vector__4 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__4_free(std_vector_Vector__4 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

bool std_vector_Vector__4_is_empty(std_vector_Vector__4 *this) {
  return this->size==0;}

void std_vector_Vector__4_resize(std_vector_Vector__4 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__5(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__4 *std_vector_Vector__4_new(u32 capacity) {
  std_vector_Vector__4 *list = std_mem_alloc__83(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__84(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__4_push(std_vector_Vector__4 *this, compiler_ast_nodes_Variable *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__4_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__4_clear(std_vector_Vector__4 *this) {
  this->size=0;
  std_vector_Vector__4_zero_unused(this);
}

std_vector_Iterator__5 std_vector_Vector__5_iter(std_vector_Vector__5 *this) {
  return std_vector_Iterator__5_make(this);}

compiler_ast_scopes_TemplateInstance *std_vector_Iterator__5_cur(std_vector_Iterator__5 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__5_next(std_vector_Iterator__5 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__5_has_value(std_vector_Iterator__5 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__5 std_vector_Iterator__5_make(std_vector_Vector__5 *vec) {
  return (std_vector_Iterator__5){.vec=vec, .index=0};}

void std_vector_Vector__5_resize(std_vector_Vector__5 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__6(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__5 *std_vector_Vector__5_new(u32 capacity) {
  std_vector_Vector__5 *list = std_mem_alloc__85(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__86(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__5_push(std_vector_Vector__5 *this, compiler_ast_scopes_TemplateInstance *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__5_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__6 std_vector_Vector__6_iter(std_vector_Vector__6 *this) {
  return std_vector_Iterator__6_make(this);}

compiler_ast_nodes_MatchCond *std_vector_Iterator__6_cur(std_vector_Iterator__6 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__6_next(std_vector_Iterator__6 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__6_has_value(std_vector_Iterator__6 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__6 std_vector_Iterator__6_make(std_vector_Vector__6 *vec) {
  return (std_vector_Iterator__6){.vec=vec, .index=0};}

compiler_ast_nodes_MatchCond *std_vector_Vector__6_at(std_vector_Vector__6 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__6_resize(std_vector_Vector__6 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__7(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__6 *std_vector_Vector__6_new(u32 capacity) {
  std_vector_Vector__6 *list = std_mem_alloc__87(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__88(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__6_push(std_vector_Vector__6 *this, compiler_ast_nodes_MatchCond *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__6_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__7 std_vector_Vector__7_iter(std_vector_Vector__7 *this) {
  return std_vector_Iterator__7_make(this);}

compiler_ast_nodes_ImportPart *std_vector_Iterator__7_cur(std_vector_Iterator__7 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__7_next(std_vector_Iterator__7 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__7_has_value(std_vector_Iterator__7 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__7 std_vector_Iterator__7_make(std_vector_Vector__7 *vec) {
  return (std_vector_Iterator__7){.vec=vec, .index=0};}

compiler_ast_nodes_ImportPart *std_vector_Vector__7_at(std_vector_Vector__7 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__7_resize(std_vector_Vector__7 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__8(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__7 *std_vector_Vector__7_new(u32 capacity) {
  std_vector_Vector__7 *list = std_mem_alloc__89(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__90(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__7_push(std_vector_Vector__7 *this, compiler_ast_nodes_ImportPart *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__7_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

compiler_ast_nodes_Function *std_vector_Vector__8_pop(std_vector_Vector__8 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

std_vector_Iterator__8 std_vector_Vector__8_iter(std_vector_Vector__8 *this) {
  return std_vector_Iterator__8_make(this);}

compiler_ast_nodes_Function *std_vector_Iterator__8_cur(std_vector_Iterator__8 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__8_next(std_vector_Iterator__8 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__8_has_value(std_vector_Iterator__8 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__8 std_vector_Iterator__8_make(std_vector_Vector__8 *vec) {
  return (std_vector_Iterator__8){.vec=vec, .index=0};}

bool std_vector_Vector__8_is_empty(std_vector_Vector__8 *this) {
  return this->size==0;}

void std_vector_Vector__8_resize(std_vector_Vector__8 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__9(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__8 *std_vector_Vector__8_new(u32 capacity) {
  std_vector_Vector__8 *list = std_mem_alloc__91(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__92(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__8_push(std_vector_Vector__8 *this, compiler_ast_nodes_Function *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__8_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__9_push_front(std_vector_Vector__9 *this, compiler_ast_nodes_Argument *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__9_resize(this, (this->capacity * 2));
  }
  for (u32 i = this->size; i > 0; i-=1) {
    this->data[i]=this->data[(i - 1)];
  }
  this->data[0]=value;
  this->size+=1;
}

std_vector_Iterator__9 std_vector_Vector__9_iter(std_vector_Vector__9 *this) {
  return std_vector_Iterator__9_make(this);}

compiler_ast_nodes_Argument *std_vector_Iterator__9_cur(std_vector_Iterator__9 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__9_next(std_vector_Iterator__9 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__9_has_value(std_vector_Iterator__9 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__9 std_vector_Iterator__9_make(std_vector_Vector__9 *vec) {
  return (std_vector_Iterator__9){.vec=vec, .index=0};}

compiler_ast_nodes_Argument *std_vector_Vector__9_at(std_vector_Vector__9 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__9_free(std_vector_Vector__9 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

void std_vector_Vector__9_resize(std_vector_Vector__9 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__10(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__9 *std_vector_Vector__9_new(u32 capacity) {
  std_vector_Vector__9 *list = std_mem_alloc__93(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__94(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__9_push(std_vector_Vector__9 *this, compiler_ast_nodes_Argument *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__9_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__10 std_vector_Vector__10_iter(std_vector_Vector__10 *this) {
  return std_vector_Iterator__10_make(this);}

compiler_ast_scopes_Symbol *std_vector_Iterator__10_cur(std_vector_Iterator__10 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__10_next(std_vector_Iterator__10 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__10_has_value(std_vector_Iterator__10 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__10 std_vector_Iterator__10_make(std_vector_Vector__10 *vec) {
  return (std_vector_Iterator__10){.vec=vec, .index=0};}

compiler_ast_scopes_Symbol *std_vector_Vector__10_at(std_vector_Vector__10 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__10_free(std_vector_Vector__10 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

bool std_vector_Vector__10_is_empty(std_vector_Vector__10 *this) {
  return this->size==0;}

void std_vector_Vector__10_resize(std_vector_Vector__10 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__11(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__10 *std_vector_Vector__10_new(u32 capacity) {
  std_vector_Vector__10 *list = std_mem_alloc__95(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__96(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__10_push(std_vector_Vector__10 *this, compiler_ast_scopes_Symbol *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__10_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

compiler_tokens_Token *std_vector_Vector__11_at(std_vector_Vector__11 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__11_free(std_vector_Vector__11 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

compiler_tokens_Token *std_vector_Vector__11_unchecked_at(std_vector_Vector__11 *this, u32 i) {
  return this->data[i];}

void std_vector_Vector__11_resize(std_vector_Vector__11 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__12(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__11 *std_vector_Vector__11_new(u32 capacity) {
  std_vector_Vector__11 *list = std_mem_alloc__97(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__98(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__11_push(std_vector_Vector__11 *this, compiler_tokens_Token *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__11_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__12_zero_unused(std_vector_Vector__12 *this) {
  compiler_attributes_Attribute **start = (this->data + this->size);
  memset(start, ((u8)0), ((this->capacity - this->size) * ((u32)sizeof(compiler_attributes_Attribute *))));
}

std_vector_Iterator__12 std_vector_Vector__12_iter(std_vector_Vector__12 *this) {
  return std_vector_Iterator__12_make(this);}

compiler_attributes_Attribute *std_vector_Iterator__12_cur(std_vector_Iterator__12 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__12_next(std_vector_Iterator__12 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__12_has_value(std_vector_Iterator__12 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__12 std_vector_Iterator__12_make(std_vector_Vector__12 *vec) {
  return (std_vector_Iterator__12){.vec=vec, .index=0};}

void std_vector_Vector__12_free(std_vector_Vector__12 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

void std_vector_Vector__12_resize(std_vector_Vector__12 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__13(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__12 *std_vector_Vector__12_new(u32 capacity) {
  std_vector_Vector__12 *list = std_mem_alloc__99(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__100(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__12_push(std_vector_Vector__12 *this, compiler_attributes_Attribute *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__12_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__12_clear(std_vector_Vector__12 *this) {
  this->size=0;
  std_vector_Vector__12_zero_unused(this);
}

std_vector_Iterator__13 std_vector_Vector__13_iter(std_vector_Vector__13 *this) {
  return std_vector_Iterator__13_make(this);}

compiler_ast_nodes_Structure *std_vector_Iterator__13_cur(std_vector_Iterator__13 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__13_next(std_vector_Iterator__13 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__13_has_value(std_vector_Iterator__13 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__13 std_vector_Iterator__13_make(std_vector_Vector__13 *vec) {
  return (std_vector_Iterator__13){.vec=vec, .index=0};}

bool std_vector_Vector__13_is_empty(std_vector_Vector__13 *this) {
  return this->size==0;}

void std_vector_Vector__13_resize(std_vector_Vector__13 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__14(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__13 *std_vector_Vector__13_new(u32 capacity) {
  std_vector_Vector__13 *list = std_mem_alloc__101(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__102(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__13_push(std_vector_Vector__13 *this, compiler_ast_nodes_Structure *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__13_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__14 std_vector_Vector__14_iter(std_vector_Vector__14 *this) {
  return std_vector_Iterator__14_make(this);}

compiler_ast_nodes_Enum *std_vector_Iterator__14_cur(std_vector_Iterator__14 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__14_next(std_vector_Iterator__14 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__14_has_value(std_vector_Iterator__14 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__14 std_vector_Iterator__14_make(std_vector_Vector__14 *vec) {
  return (std_vector_Iterator__14){.vec=vec, .index=0};}

bool std_vector_Vector__14_is_empty(std_vector_Vector__14 *this) {
  return this->size==0;}

void std_vector_Vector__14_resize(std_vector_Vector__14 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__15(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__14 *std_vector_Vector__14_new(u32 capacity) {
  std_vector_Vector__14 *list = std_mem_alloc__103(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__104(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__14_push(std_vector_Vector__14 *this, compiler_ast_nodes_Enum *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__14_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

compiler_ast_nodes_AST *std_vector_Vector__15_pop(std_vector_Vector__15 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

std_vector_Iterator__15 std_vector_Vector__15_iter(std_vector_Vector__15 *this) {
  return std_vector_Iterator__15_make(this);}

compiler_ast_nodes_AST *std_vector_Iterator__15_cur(std_vector_Iterator__15 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__15_next(std_vector_Iterator__15 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__15_has_value(std_vector_Iterator__15 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__15 std_vector_Iterator__15_make(std_vector_Vector__15 *vec) {
  return (std_vector_Iterator__15){.vec=vec, .index=0};}

compiler_ast_nodes_AST *std_vector_Vector__15_at(std_vector_Vector__15 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__15_free(std_vector_Vector__15 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

bool std_vector_Vector__15_is_empty(std_vector_Vector__15 *this) {
  return this->size==0;}

void std_vector_Vector__15_resize(std_vector_Vector__15 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__16(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__15 *std_vector_Vector__15_new(u32 capacity) {
  std_vector_Vector__15 *list = std_mem_alloc__105(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__106(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__15_push(std_vector_Vector__15 *this, compiler_ast_nodes_AST *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__15_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__16 std_vector_Vector__16_iter(std_vector_Vector__16 *this) {
  return std_vector_Iterator__16_make(this);}

compiler_errors_Error *std_vector_Iterator__16_cur(std_vector_Iterator__16 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__16_next(std_vector_Iterator__16 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__16_has_value(std_vector_Iterator__16 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__16 std_vector_Iterator__16_make(std_vector_Vector__16 *vec) {
  return (std_vector_Iterator__16){.vec=vec, .index=0};}

compiler_errors_Error *std_vector_Vector__16_at(std_vector_Vector__16 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

bool std_vector_Vector__16_is_empty(std_vector_Vector__16 *this) {
  return this->size==0;}

void std_vector_Vector__16_resize(std_vector_Vector__16 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__17(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__16 *std_vector_Vector__16_new(u32 capacity) {
  std_vector_Vector__16 *list = std_mem_alloc__107(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__108(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__16_push(std_vector_Vector__16 *this, compiler_errors_Error *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__16_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

jmp_buf *std_vector_Vector__17_back_ptr(std_vector_Vector__17 *this, u32 i) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:108:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:109:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }
  return &this->data[((this->size - i) - 1)];
}

void std_vector_Vector__17_resize(std_vector_Vector__17 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__18(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__17 *std_vector_Vector__17_new(u32 capacity) {
  std_vector_Vector__17 *list = std_mem_alloc__109(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__110(capacity);
  list->size=0;
  return list;
}

std_vector_Iterator__18 std_vector_Vector__18_iter(std_vector_Vector__18 *this) {
  return std_vector_Iterator__18_make(this);}

compiler_ast_scopes_Reference std_vector_Iterator__18_cur(std_vector_Iterator__18 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__18_next(std_vector_Iterator__18 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__18_has_value(std_vector_Iterator__18 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__18 std_vector_Iterator__18_make(std_vector_Vector__18 *vec) {
  return (std_vector_Iterator__18){.vec=vec, .index=0};}

void std_vector_Vector__18_resize(std_vector_Vector__18 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__19(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__18 *std_vector_Vector__18_new(u32 capacity) {
  std_vector_Vector__18 *list = std_mem_alloc__111(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__112(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__18_push(std_vector_Vector__18 *this, compiler_ast_scopes_Reference value) {
  if (this->size==this->capacity) {
    std_vector_Vector__18_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__19 std_vector_Vector__19_iter(std_vector_Vector__19 *this) {
  return std_vector_Iterator__19_make(this);}

compiler_ast_nodes_MatchCondArg *std_vector_Iterator__19_cur(std_vector_Iterator__19 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__19_next(std_vector_Iterator__19 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__19_has_value(std_vector_Iterator__19 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__19 std_vector_Iterator__19_make(std_vector_Vector__19 *vec) {
  return (std_vector_Iterator__19){.vec=vec, .index=0};}

compiler_ast_nodes_MatchCondArg *std_vector_Vector__19_at(std_vector_Vector__19 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__19_resize(std_vector_Vector__19 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__20(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__19 *std_vector_Vector__19_new(u32 capacity) {
  std_vector_Vector__19 *list = std_mem_alloc__113(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__114(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__19_push(std_vector_Vector__19 *this, compiler_ast_nodes_MatchCondArg *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__19_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__20 std_vector_Vector__20_iter(std_vector_Vector__20 *this) {
  return std_vector_Iterator__20_make(this);}

compiler_ast_nodes_EnumVariant *std_vector_Iterator__20_cur(std_vector_Iterator__20 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__20_next(std_vector_Iterator__20 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__20_has_value(std_vector_Iterator__20 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__20 std_vector_Iterator__20_make(std_vector_Vector__20 *vec) {
  return (std_vector_Iterator__20){.vec=vec, .index=0};}

void std_vector_Vector__20_resize(std_vector_Vector__20 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__21(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__20 *std_vector_Vector__20_new(u32 capacity) {
  std_vector_Vector__20 *list = std_mem_alloc__115(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__116(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__20_push(std_vector_Vector__20 *this, compiler_ast_nodes_EnumVariant *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__20_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__21 std_vector_Vector__21_iter(std_vector_Vector__21 *this) {
  return std_vector_Iterator__21_make(this);}

compiler_ast_operators_Operator std_vector_Iterator__21_cur(std_vector_Iterator__21 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__21_next(std_vector_Iterator__21 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__21_has_value(std_vector_Iterator__21 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__21 std_vector_Iterator__21_make(std_vector_Vector__21 *vec) {
  return (std_vector_Iterator__21){.vec=vec, .index=0};}

void std_vector_Vector__21_resize(std_vector_Vector__21 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__22(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__21 *std_vector_Vector__21_new(u32 capacity) {
  std_vector_Vector__21 *list = std_mem_alloc__117(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__118(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__21_push(std_vector_Vector__21 *this, compiler_ast_operators_Operator value) {
  if (this->size==this->capacity) {
    std_vector_Vector__21_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__22 std_vector_Vector__22_iter(std_vector_Vector__22 *this) {
  return std_vector_Iterator__22_make(this);}

std_vector_Vector__7 *std_vector_Iterator__22_cur(std_vector_Iterator__22 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__22_next(std_vector_Iterator__22 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__22_has_value(std_vector_Iterator__22 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__22 std_vector_Iterator__22_make(std_vector_Vector__22 *vec) {
  return (std_vector_Iterator__22){.vec=vec, .index=0};}

std_vector_Vector__7 *std_vector_Vector__22_at(std_vector_Vector__22 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__22_resize(std_vector_Vector__22 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__23(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__22 *std_vector_Vector__22_new(u32 capacity) {
  std_vector_Vector__22 *list = std_mem_alloc__119(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__120(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__22_push(std_vector_Vector__22 *this, std_vector_Vector__7 *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__22_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__23 std_vector_Vector__23_iter(std_vector_Vector__23 *this) {
  return std_vector_Iterator__23_make(this);}

compiler_ast_nodes_IfBranch std_vector_Iterator__23_cur(std_vector_Iterator__23 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__23_next(std_vector_Iterator__23 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__23_has_value(std_vector_Iterator__23 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__23 std_vector_Iterator__23_make(std_vector_Vector__23 *vec) {
  return (std_vector_Iterator__23){.vec=vec, .index=0};}

compiler_ast_nodes_IfBranch std_vector_Vector__23_at(std_vector_Vector__23 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__23_resize(std_vector_Vector__23 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__24(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__23 *std_vector_Vector__23_new(u32 capacity) {
  std_vector_Vector__23 *list = std_mem_alloc__121(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__122(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__23_push(std_vector_Vector__23 *this, compiler_ast_nodes_IfBranch value) {
  if (this->size==this->capacity) {
    std_vector_Vector__23_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__24 std_vector_Vector__24_iter(std_vector_Vector__24 *this) {
  return std_vector_Iterator__24_make(this);}

compiler_ast_nodes_MatchCase std_vector_Iterator__24_cur(std_vector_Iterator__24 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__24_next(std_vector_Iterator__24 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__24_has_value(std_vector_Iterator__24 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__24 std_vector_Iterator__24_make(std_vector_Vector__24 *vec) {
  return (std_vector_Iterator__24){.vec=vec, .index=0};}

compiler_ast_nodes_MatchCase std_vector_Vector__24_at(std_vector_Vector__24 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__24_resize(std_vector_Vector__24 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__25(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__24 *std_vector_Vector__24_new(u32 capacity) {
  std_vector_Vector__24 *list = std_mem_alloc__123(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__124(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__24_push(std_vector_Vector__24 *this, compiler_ast_nodes_MatchCase value) {
  if (this->size==this->capacity) {
    std_vector_Vector__24_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__25 std_vector_Vector__25_iter(std_vector_Vector__25 *this) {
  return std_vector_Iterator__25_make(this);}

compiler_ast_nodes_MapLiteralPair std_vector_Iterator__25_cur(std_vector_Iterator__25 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__25_next(std_vector_Iterator__25 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__25_has_value(std_vector_Iterator__25 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__25 std_vector_Iterator__25_make(std_vector_Vector__25 *vec) {
  return (std_vector_Iterator__25){.vec=vec, .index=0};}

void std_vector_Vector__25_resize(std_vector_Vector__25 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__26(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__25 *std_vector_Vector__25_new(u32 capacity) {
  std_vector_Vector__25 *list = std_mem_alloc__125(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__126(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__25_push(std_vector_Vector__25 *this, compiler_ast_nodes_MapLiteralPair value) {
  if (this->size==this->capacity) {
    std_vector_Vector__25_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

void std_vector_Vector__26_zero_unused(std_vector_Vector__26 *this) {
  std_compact_map_Item__0 *start = (this->data + this->size);
  memset(start, ((u8)0), ((this->capacity - this->size) * ((u32)sizeof(std_compact_map_Item__0))));
}

std_compact_map_Item__0 std_vector_Vector__26_pop(std_vector_Vector__26 *this) {
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:61:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }
  this->size-=1;
  return this->data[this->size];
}

std_compact_map_Item__0 std_vector_Vector__26_at(std_vector_Vector__26 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__26_resize(std_vector_Vector__26 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__27(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__26 *std_vector_Vector__26_new(u32 capacity) {
  std_vector_Vector__26 *list = std_mem_alloc__127(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__128(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__26_push(std_vector_Vector__26 *this, std_compact_map_Item__0 value) {
  if (this->size==this->capacity) {
    std_vector_Vector__26_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__27 std_vector_Vector__27_iter(std_vector_Vector__27 *this) {
  return std_vector_Iterator__27_make(this);}

std_span_Span std_vector_Iterator__27_cur(std_vector_Iterator__27 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__27_next(std_vector_Iterator__27 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__27_has_value(std_vector_Iterator__27 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__27 std_vector_Iterator__27_make(std_vector_Vector__27 *vec) {
  return (std_vector_Iterator__27){.vec=vec, .index=0};}

void std_vector_Vector__27_free(std_vector_Vector__27 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

void std_vector_Vector__27_resize(std_vector_Vector__27 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__28(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__27 *std_vector_Vector__27_new(u32 capacity) {
  std_vector_Vector__27 *list = std_mem_alloc__129(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__130(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__27_push(std_vector_Vector__27 *this, std_span_Span value) {
  if (this->size==this->capacity) {
    std_vector_Vector__27_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__28 std_vector_Vector__28_iter(std_vector_Vector__28 *this) {
  return std_vector_Iterator__28_make(this);}

std_value_Value *std_vector_Iterator__28_cur(std_vector_Iterator__28 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__28_next(std_vector_Iterator__28 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__28_has_value(std_vector_Iterator__28 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__28 std_vector_Iterator__28_make(std_vector_Vector__28 *vec) {
  return (std_vector_Iterator__28){.vec=vec, .index=0};}

std_value_Value *std_vector_Vector__28_at(std_vector_Vector__28 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__28_resize(std_vector_Vector__28 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__29(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__28 *std_vector_Vector__28_new(u32 capacity) {
  std_vector_Vector__28 *list = std_mem_alloc__131(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__132(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__28_push(std_vector_Vector__28 *this, std_value_Value *value) {
  if (this->size==this->capacity) {
    std_vector_Vector__28_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_vector_Iterator__29 std_vector_Vector__29_iter(std_vector_Vector__29 *this) {
  return std_vector_Iterator__29_make(this);}

std_compact_map_Item__1 std_vector_Iterator__29_cur(std_vector_Iterator__29 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:168:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }
  return this->vec->data[this->index];
}

void std_vector_Iterator__29_next(std_vector_Iterator__29 *this) {
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:163:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }
  this->index+=1;
}

bool std_vector_Iterator__29_has_value(std_vector_Iterator__29 *this) {
  return (this->index < this->vec->size);}

std_vector_Iterator__29 std_vector_Iterator__29_make(std_vector_Vector__29 *vec) {
  return (std_vector_Iterator__29){.vec=vec, .index=0};}

std_compact_map_Item__1 std_vector_Vector__29_at(std_vector_Vector__29 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__29_resize(std_vector_Vector__29 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__30(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__29 *std_vector_Vector__29_new(u32 capacity) {
  std_vector_Vector__29 *list = std_mem_alloc__133(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__134(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__29_push(std_vector_Vector__29 *this, std_compact_map_Item__1 value) {
  if (this->size==this->capacity) {
    std_vector_Vector__29_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_compact_map_Item__2 std_vector_Vector__30_at(std_vector_Vector__30 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__30_resize(std_vector_Vector__30 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__31(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__30 *std_vector_Vector__30_new(u32 capacity) {
  std_vector_Vector__30 *list = std_mem_alloc__135(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__136(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__30_push(std_vector_Vector__30 *this, std_compact_map_Item__2 value) {
  if (this->size==this->capacity) {
    std_vector_Vector__30_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

u32 std_vector_Vector__31_at(std_vector_Vector__31 *this, u32 i) {
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:122:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }
  return this->data[i];
}

void std_vector_Vector__31_free(std_vector_Vector__31 *this) {
  std_mem_free(this->data);
  std_mem_free(this);
}

void std_vector_Vector__31_resize(std_vector_Vector__31 *this, u32 new_capacity) {
  if (this->capacity >= new_capacity) {
    return;
  }
  this->data=std_mem_realloc__32(this->data, this->capacity, new_capacity);
  this->capacity=new_capacity;
}

std_vector_Vector__31 *std_vector_Vector__31_new(u32 capacity) {
  std_vector_Vector__31 *list = std_mem_alloc__137(1);
  list->capacity=capacity;
  list->data=std_mem_alloc__138(capacity);
  list->size=0;
  return list;
}

void std_vector_Vector__31_push(std_vector_Vector__31 *this, u32 value) {
  if (this->size==this->capacity) {
    std_vector_Vector__31_resize(this, (this->capacity * 2));
  }
  this->data[this->size]=value;
  this->size+=1;
}

std_json_Parser std_json_Parser_make(std_vector_Vector__11 *tokens) {
  std_json_Parser parser = {0};
  parser.tokens=tokens;
  parser.curr=0;
  return parser;
}

compiler_tokens_Token *std_json_Parser_token(std_json_Parser *this) {
  return std_vector_Vector__11_at(this->tokens, this->curr);}

compiler_tokens_Token *std_json_Parser_consume(std_json_Parser *this, compiler_tokens_TokenType type) {
  if (std_json_Parser_token(this)->type != type) {
    printf("Expected %s but got %s""\n", compiler_tokens_TokenType_str(type), compiler_tokens_TokenType_str(std_json_Parser_token(this)->type));
    exit(1);
  }
  compiler_tokens_Token *tok = std_json_Parser_token(this);
  this->curr+=1;
  return tok;
}

std_value_Value *std_json_Parser_parse_object(std_json_Parser *this) {
  compiler_tokens_Token *start = std_json_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);
  std_value_Value *json = std_value_Value_new(std_value_ValueType_Dictionary);
  while (std_json_Parser_token(this)->type != compiler_tokens_TokenType_CloseCurly) {
    compiler_tokens_Token *key = std_json_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
    std_json_Parser_consume(this, compiler_tokens_TokenType_Colon);
    std_value_Value *value = std_json_Parser_parse_value(this);
    std_compact_map_Map__1_insert(json->u.as_dict, key->text, value);
    if (std_json_Parser_token(this)->type==compiler_tokens_TokenType_Comma) {
      std_json_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
  compiler_tokens_Token *end = std_json_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);
  json->span=std_span_Span_join(start->span, end->span);
  return json;
}

std_value_Value *std_json_Parser_parse_array(std_json_Parser *this) {
  compiler_tokens_Token *start = std_json_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);
  std_value_Value *json = std_value_Value_new(std_value_ValueType_List);
  while (std_json_Parser_token(this)->type != compiler_tokens_TokenType_CloseSquare) {
    std_value_Value *value = std_json_Parser_parse_value(this);
    std_vector_Vector__28_push(json->u.as_list, value);
    if (std_json_Parser_token(this)->type==compiler_tokens_TokenType_Comma) {
      std_json_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
  compiler_tokens_Token *end = std_json_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);
  json->span=std_span_Span_join(start->span, end->span);
  return json;
}

std_value_Value *std_json_Parser_parse_value(std_json_Parser *this) {
  return ({std_value_Value *__yv_676;
switch ((std_json_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_Null:
      m_677_0:
        {
          compiler_tokens_Token *tok = std_json_Parser_consume(this, compiler_tokens_TokenType_Null);
          std_value_Value *val = std_value_Value_new(std_value_ValueType_Null);
          val->span=tok->span;
          __yv_676 = val;
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_True:
      case compiler_tokens_TokenType_False:
      m_677_1:
        {
          std_value_Value *json = std_value_Value_new(std_value_ValueType_Bool);
          compiler_tokens_Token *tok = std_json_Parser_token(this);
          json->u.as_bool=str_eq(tok->text, "true");
          json->span=tok->span;
          this->curr+=1;
          __yv_676 = json;
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_IntLiteral:
      m_677_2:
        {
          std_value_Value *json = std_value_Value_new(std_value_ValueType_Integer);
          compiler_tokens_Token *tok = std_json_Parser_consume(this, compiler_tokens_TokenType_IntLiteral);
          json->u.as_int=((i64)atoi(tok->text));
          json->span=tok->span;
          __yv_676 = json;
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_FloatLiteral:
      m_677_3:
        {
          std_value_Value *json = std_value_Value_new(std_value_ValueType_Float);
          compiler_tokens_Token *tok = std_json_Parser_consume(this, compiler_tokens_TokenType_FloatLiteral);
          json->u.as_float=strtod(tok->text, NULL);
          json->span=tok->span;
          __yv_676 = json;
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_StringLiteral:
      m_677_4:
        {
          std_value_Value *json = std_value_Value_new(std_value_ValueType_String);
          compiler_tokens_Token *tok = std_json_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);
          json->u.as_str=std_buffer_Buffer_from_str(tok->text);
          json->span=tok->span;
          __yv_676 = json;
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_OpenCurly:
      m_677_5:
        {
          __yv_676 = std_json_Parser_parse_object(this);
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_677_6:
        {
          __yv_676 = std_json_Parser_parse_array(this);
          goto _l___yv_676;
        } break;
      case compiler_tokens_TokenType_Minus:
      m_677_7:
        {
          compiler_tokens_Token *start = std_json_Parser_consume(this, compiler_tokens_TokenType_Minus);
          std_value_Value *next = std_json_Parser_parse_value(this);
switch ((next->type)) {
            case std_value_ValueType_Integer:
            m_678_0:
              {
                next->u.as_int=-next->u.as_int;
              } break;
            case std_value_ValueType_Float:
            m_678_1:
              {
                next->u.as_float=-next->u.as_float;
              } break;
            default:
              {
                printf("Unexpected token in json::Parser::parse_value: %s""\n", std_value_ValueType_str(next->type));
                exit(1);
              } break;
          }          next->span=std_span_Span_join(start->span, next->span);
          __yv_676 = next;
          goto _l___yv_676;
        } break;
      default:
        {
          printf("Unexpected token in json::Parser::parse_value: %s""\n", compiler_tokens_TokenType_str(std_json_Parser_token(this)->type));
          exit(1);
        } break;
    }
_l___yv_676:
  __yv_676;});}

std_value_Value *std_json_Parser_parse(std_json_Parser *this) {
  return ({std_value_Value *__yv_679;
switch ((std_json_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_OpenCurly:
      m_680_0:
        {
          __yv_679 = std_json_Parser_parse_object(this);
          goto _l___yv_679;
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_680_1:
        {
          __yv_679 = std_json_Parser_parse_array(this);
          goto _l___yv_679;
        } break;
      default:
        {
          printf("Expected { or [ at JSON top level""\n");
          exit(1);
        } break;
    }
_l___yv_679:
  __yv_679;});}

std_value_Value *std_json_parse(char *source, char *filename) {
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(source, filename, NULL);
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  std_json_Parser parser = std_json_Parser_make(tokens);
  return std_json_Parser_parse(&parser);
}

std_value_Value *std_json_parse_sv(std_sv_SV source, char *filename) {
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make_sv(source, filename, NULL);
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);
  std_json_Parser parser = std_json_Parser_make(tokens);
  return std_json_Parser_parse(&parser);
}

void std_json_serialize_into(std_value_Value *val, std_buffer_Buffer *sb) {
switch ((val->type)) {
    case std_value_ValueType_Null:
    m_681_0:
      {
        std_buffer_Buffer_write_str(sb, "null");
      } break;
    case std_value_ValueType_Bool:
    m_681_1:
      {
        std_buffer_Buffer_write_str(sb, (val->u.as_bool ? "true" : "false"));
      } break;
    case std_value_ValueType_Integer:
    m_681_2:
      {
        std_buffer_Buffer_write_str_f(sb, std_format("%" PRId64 "", val->u.as_int));
      } break;
    case std_value_ValueType_Float:
    m_681_3:
      {
        std_buffer_Buffer_write_str_f(sb, std_format("%f", val->u.as_float));
      } break;
    case std_value_ValueType_String:
    m_681_4:
      {
        std_buffer_Buffer_write_str(sb, "\"");
        std_buffer_Buffer buf = val->u.as_str;
        for (u32 i = 0; i < buf.size; i+=1) {
          char c = ((char)buf.data[i]);
          switch (c) {
            case '\b': {
              std_buffer_Buffer_write_str(sb, "\\b");
            } break;
            case '\f': {
              std_buffer_Buffer_write_str(sb, "\\f");
            } break;
            case '\n': {
              std_buffer_Buffer_write_str(sb, "\\n");
            } break;
            case '\r': {
              std_buffer_Buffer_write_str(sb, "\\r");
            } break;
            case '\t': {
              std_buffer_Buffer_write_str(sb, "\\t");
            } break;
            case '\\': {
              std_buffer_Buffer_write_str(sb, "\\\\");
            } break;
            case '"': {
              std_buffer_Buffer_write_str(sb, "\\\"");
            } break;
            default: {
              if (char_is_print(c)) {
                std_buffer_Buffer_write_char(sb, c);
              } else {
                std_buffer_Buffer_write_str_f(sb, std_format("\\x%02x", buf.data[i]));
              }
            } break;
          }
        }
        std_buffer_Buffer_write_str(sb, "\"");
      } break;
    case std_value_ValueType_List:
    m_681_5:
      {
        std_buffer_Buffer_write_str(sb, "[");
        std_vector_Vector__28 *lst = val->u.as_list;
        for (u32 i = 0; i < lst->size; i+=1) {
          std_value_Value *value = std_vector_Vector__28_at(lst, i);
          if (i > 0) {
            std_buffer_Buffer_write_str(sb, ",");
          }
          std_json_serialize_into(value, sb);
        }
        std_buffer_Buffer_write_str(sb, "]");
      } break;
    case std_value_ValueType_Dictionary:
    m_681_6:
      {
        std_buffer_Buffer_write_str(sb, "{");
        bool first = true;
        for (std_compact_map_Iterator__1 _i265 = std_compact_map_Map__1_iter(val->u.as_dict); std_compact_map_Iterator__1_has_value(&_i265); std_compact_map_Iterator__1_next(&_i265)) {
          std_compact_map_Item__1 iter = std_compact_map_Iterator__1_cur(&_i265);
          {
            if (!(first)) {
              std_buffer_Buffer_write_str(sb, ",");
            }
            first=false;
            std_buffer_Buffer_write_str(sb, "\"");
            std_buffer_Buffer_write_str(sb, iter.key);
            std_buffer_Buffer_write_str(sb, "\":");
            std_value_Value *value = iter.value;
            std_json_serialize_into(value, sb);
          }
        }
        std_buffer_Buffer_write_str(sb, "}");
      } break;
  }}

std_buffer_Buffer std_json_serialize(std_value_Value *val) {
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);
  std_json_serialize_into(val, &sb);
  return sb;
}

void std_json_write_to_file(std_value_Value *val, char *filename) {
  std_buffer_Buffer sb = std_json_serialize(val);
  std_fs_write_file(filename, sb);
  std_buffer_Buffer_free(&sb);
}

void compiler_lsp_cli_handle_validate__Closure_0(void *__C, compiler_ast_nodes_AST *node) {
  compiler_lsp_cli_handle_validate__Closure_0Ctx *_C = (compiler_lsp_cli_handle_validate__Closure_0Ctx *)__C;
{
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_682_0:
      {
        std_value_Value *msg = compiler_lsp_cli_utils_gen_inlay_hint(node->u.var_decl, (*_C->path));
        if (((bool)msg)) {
          printf("%s\n", std_value_Value_dbg(msg));
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_682_1:
      {
        for (std_vector_Iterator__4 _i4 = std_vector_Vector__4_iter(node->u.closure->params); std_vector_Iterator__4_has_value(&_i4); std_vector_Iterator__4_next(&_i4)) {
          compiler_ast_nodes_Variable *param = std_vector_Iterator__4_cur(&_i4);
          {
            std_value_Value *msg = compiler_lsp_cli_utils_gen_inlay_hint(param, (*_C->path));
            if (((bool)msg)) {
              printf("%s\n", std_value_Value_dbg(msg));
            }
          }
        }
      } break;
    default:
      {
      } break;
  }}
}

void compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1(void *__C, compiler_ast_nodes_AST *node) {
  compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx *_C = (compiler_passes_typechecker_create_match_for_error_unwrap__Closure_1Ctx *)__C;
{
    node->span=(*_C->op_span);
}
}

void compiler_passes_typechecker_create_match_for_error_prop__Closure_2(void *__C, compiler_ast_nodes_AST *node) {
  compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx *_C = (compiler_passes_typechecker_create_match_for_error_prop__Closure_2Ctx *)__C;
{
    node->span=(*_C->op_span);
}
}

void compiler_passes_visitor__Closure_3(void *__C, compiler_ast_nodes_AST *node) {
  compiler_passes_visitor__Closure_3Ctx *_C = (compiler_passes_visitor__Closure_3Ctx *)__C;
{
}
}

void compiler_passes_visitor__Closure_4(void *__C, compiler_types_Type *type) {
  compiler_passes_visitor__Closure_4Ctx *_C = (compiler_passes_visitor__Closure_4Ctx *)__C;
{
}
}

void compiler_lsp_server_run_lsp_backend_raw__Closure_5(void *__C) {
  compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx *_C = (compiler_lsp_server_run_lsp_backend_raw__Closure_5Ctx *)__C;
{
  compiler_lsp_cli_main(((i32)(*_C->args)->size), (*_C->args)->data, (*_C->contents));
}
}

void compiler_lsp_server_run_lsp_backend_raw__Closure_6(void *__C) {
  compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx *_C = (compiler_lsp_server_run_lsp_backend_raw__Closure_6Ctx *)__C;
{
  compiler_lsp_cli_main(((i32)(*_C->args)->size), (*_C->args)->data, NULL);
}
}

