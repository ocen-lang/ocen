#include "stdarg.h"
#include "string.h"
#include "ctype.h"
#include "dirent.h"
#include "unistd.h"
#include "sys/stat.h"
#include "sys/types.h"
#include "errno.h"
#include "libgen.h"
#include "dirent.h"
#include "setjmp.h"
#include "time.h"

/* Embed: /Users/mustafa/ocen-lang/ocen/std/./prelude.h */
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>

#ifndef OC_NO_BACKTRACE
#include <stdlib.h>
#include <execinfo.h>
#endif

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef float f32;
typedef double f64;

void dump_backtrace() {
#ifndef OC_NO_BACKTRACE
  void *array[40];
  size_t size = backtrace(array, 40);
  char **strings = backtrace_symbols(array, size);
  printf("\nBacktrace:\n");
  for (size_t i = size-1; i > 0; i--) {
    printf("%s\n", strings[i]);
  }
  free(strings);
#endif
}

#ifdef __APPLE__
  #define oc_trap __builtin_debugtrap
#else
  #define oc_trap __builtin_trap
#endif

void ae_assert_fail(char *dbg_msg, char *msg) {
  dump_backtrace();
  printf("--------------------------------------------------------------------------------\n");
  printf("%s\n", dbg_msg);
  if (msg) {
    printf("  Message: %s\n", msg);
  }
  printf("--------------------------------------------------------------------------------\n");
  fflush(stdout);
  oc_trap();
}


/* Constants */
#define compiler_passes_code_generator_cls_ctx_name ("_C")
#define compiler_passes_code_generator_cls_fn_field_name ("fn")
#define std_compact_map_INDEX_FREE (-1)
#define std_compact_map_INDEX_DELETED (-2)
/* Typedefs */
typedef struct std_sv_SV std_sv_SV;
typedef struct compiler_docgen_DocGenerator compiler_docgen_DocGenerator;
typedef struct compiler_passes_register_types_RegisterTypes compiler_passes_register_types_RegisterTypes;
typedef struct compiler_passes_register_types_Finder compiler_passes_register_types_Finder;
typedef struct compiler_passes_mark_dead_code_MarkDeadCode compiler_passes_mark_dead_code_MarkDeadCode;
typedef struct compiler_passes_generic_pass_GenericPass compiler_passes_generic_pass_GenericPass;
typedef struct compiler_passes_typechecker_TypeChecker compiler_passes_typechecker_TypeChecker;
typedef struct std_buffer_Buffer std_buffer_Buffer;
typedef struct compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator;
typedef struct compiler_passes_reorder_symbols_ReorderSymbols compiler_passes_reorder_symbols_ReorderSymbols;
typedef struct std_span_Location std_span_Location;
typedef struct std_span_Span std_span_Span;
typedef struct compiler_parser_Parser compiler_parser_Parser;
typedef struct compiler_parser_LibraryInfo compiler_parser_LibraryInfo;
typedef struct compiler_lexer_Lexer compiler_lexer_Lexer;
typedef struct compiler_ast_program_Namespace compiler_ast_program_Namespace;
typedef struct compiler_ast_program_CachedSymbols compiler_ast_program_CachedSymbols;
typedef struct compiler_ast_program_Program compiler_ast_program_Program;
typedef struct compiler_ast_program_NSIterator compiler_ast_program_NSIterator;
typedef struct compiler_ast_scopes_TemplateInstance compiler_ast_scopes_TemplateInstance;
typedef struct compiler_ast_scopes_Template compiler_ast_scopes_Template;
typedef enum compiler_ast_scopes_ReferenceType compiler_ast_scopes_ReferenceType;
typedef struct compiler_ast_scopes_Reference compiler_ast_scopes_Reference;
typedef struct compiler_ast_scopes_EnumField compiler_ast_scopes_EnumField;
typedef struct compiler_ast_scopes_ClosedVariable compiler_ast_scopes_ClosedVariable;
typedef union compiler_ast_scopes_SymbolUnion compiler_ast_scopes_SymbolUnion;
typedef enum compiler_ast_scopes_SymbolType compiler_ast_scopes_SymbolType;
typedef struct compiler_ast_scopes_Symbol compiler_ast_scopes_Symbol;
typedef struct compiler_ast_scopes_Scope compiler_ast_scopes_Scope;
typedef enum compiler_ast_operators_Operator compiler_ast_operators_Operator;
typedef struct compiler_ast_operators_OperatorOverload compiler_ast_operators_OperatorOverload;
typedef struct compiler_ast_nodes_Variable compiler_ast_nodes_Variable;
typedef struct compiler_ast_nodes_Structure compiler_ast_nodes_Structure;
typedef struct compiler_ast_nodes_Enum compiler_ast_nodes_Enum;
typedef struct compiler_ast_nodes_EnumVariant compiler_ast_nodes_EnumVariant;
typedef enum compiler_ast_nodes_FunctionKind compiler_ast_nodes_FunctionKind;
typedef struct compiler_ast_nodes_Function compiler_ast_nodes_Function;
typedef struct compiler_ast_nodes_Block compiler_ast_nodes_Block;
typedef struct compiler_ast_nodes_Identifier compiler_ast_nodes_Identifier;
typedef struct compiler_ast_nodes_Argument compiler_ast_nodes_Argument;
typedef enum compiler_ast_nodes_CallType compiler_ast_nodes_CallType;
typedef struct compiler_ast_nodes_FuncCall compiler_ast_nodes_FuncCall;
typedef struct compiler_ast_nodes_ImportPartSingle compiler_ast_nodes_ImportPartSingle;
typedef struct compiler_ast_nodes_ImportPartMultiple compiler_ast_nodes_ImportPartMultiple;
typedef union compiler_ast_nodes_ImportPartUnion compiler_ast_nodes_ImportPartUnion;
typedef enum compiler_ast_nodes_ImportPartType compiler_ast_nodes_ImportPartType;
typedef struct compiler_ast_nodes_ImportPart compiler_ast_nodes_ImportPart;
typedef enum compiler_ast_nodes_ImportType compiler_ast_nodes_ImportType;
typedef struct compiler_ast_nodes_Import compiler_ast_nodes_Import;
typedef struct compiler_ast_nodes_NumLiteral compiler_ast_nodes_NumLiteral;
typedef struct compiler_ast_nodes_Binary compiler_ast_nodes_Binary;
typedef struct compiler_ast_nodes_Unary compiler_ast_nodes_Unary;
typedef struct compiler_ast_nodes_NSLookup compiler_ast_nodes_NSLookup;
typedef struct compiler_ast_nodes_Member compiler_ast_nodes_Member;
typedef struct compiler_ast_nodes_Assertion compiler_ast_nodes_Assertion;
typedef struct compiler_ast_nodes_IfBranch compiler_ast_nodes_IfBranch;
typedef struct compiler_ast_nodes_IfStatement compiler_ast_nodes_IfStatement;
typedef struct compiler_ast_nodes_Loop compiler_ast_nodes_Loop;
typedef struct compiler_ast_nodes_Cast compiler_ast_nodes_Cast;
typedef struct compiler_ast_nodes_FormatString compiler_ast_nodes_FormatString;
typedef struct compiler_ast_nodes_MatchCondArg compiler_ast_nodes_MatchCondArg;
typedef struct compiler_ast_nodes_MatchCond compiler_ast_nodes_MatchCond;
typedef struct compiler_ast_nodes_MatchCase compiler_ast_nodes_MatchCase;
typedef struct compiler_ast_nodes_Match compiler_ast_nodes_Match;
typedef struct compiler_ast_nodes_Specialization compiler_ast_nodes_Specialization;
typedef struct compiler_ast_nodes_ArrayLiteral compiler_ast_nodes_ArrayLiteral;
typedef struct compiler_ast_nodes_Return compiler_ast_nodes_Return;
typedef union compiler_ast_nodes_ASTUnion compiler_ast_nodes_ASTUnion;
typedef enum compiler_ast_nodes_ASTType compiler_ast_nodes_ASTType;
typedef struct compiler_ast_nodes_AST compiler_ast_nodes_AST;
typedef enum compiler_attributes_AttributeType compiler_attributes_AttributeType;
typedef struct compiler_attributes_Attribute compiler_attributes_Attribute;
typedef enum compiler_lsp_CommandType compiler_lsp_CommandType;
typedef struct compiler_lsp_finder_Finder compiler_lsp_finder_Finder;
typedef enum compiler_tokens_TokenType compiler_tokens_TokenType;
typedef struct compiler_tokens_Token compiler_tokens_Token;
typedef struct compiler_types_FunctionType compiler_types_FunctionType;
typedef struct compiler_types_ArrayType compiler_types_ArrayType;
typedef struct compiler_types_UnresolvedTemplate compiler_types_UnresolvedTemplate;
typedef struct compiler_types_TypeUnion compiler_types_TypeUnion;
typedef enum compiler_types_BaseType compiler_types_BaseType;
typedef struct compiler_types_Type compiler_types_Type;
typedef enum compiler_errors_ErrorType compiler_errors_ErrorType;
typedef struct compiler_errors_Error compiler_errors_Error;
typedef enum compiler_errors_MessageType compiler_errors_MessageType;
typedef struct std_CharIterator std_CharIterator;
typedef struct std_sv_SVLineIterator std_sv_SVLineIterator;
typedef struct std_sv_SVSplitIterator std_sv_SVSplitIterator;
typedef struct std_compact_map_Item__0 std_compact_map_Item__0;
typedef struct std_compact_map_Item__1 std_compact_map_Item__1;
typedef struct std_compact_map_Map__0 std_compact_map_Map__0;
typedef struct std_compact_map_Map__1 std_compact_map_Map__1;
typedef struct std_vector_Iterator__27 std_vector_Iterator__27;
typedef struct std_compact_map_Iterator__0 std_compact_map_Iterator__0;
typedef enum std_logging_LogLevel std_logging_LogLevel;
typedef struct std_set_Set__0 std_set_Set__0;
typedef struct std_set_Set__1 std_set_Set__1;
typedef struct std_set_Set__2 std_set_Set__2;
typedef struct std_set_Set__3 std_set_Set__3;
typedef struct std_map_Iterator__13 std_map_Iterator__13;
typedef struct std_set_Iterator__3 std_set_Iterator__3;
typedef union std_value_ValueUnion std_value_ValueUnion;
typedef enum std_value_ValueType std_value_ValueType;
typedef struct std_value_Value std_value_Value;
typedef enum std_fs_EntryType std_fs_EntryType;
typedef struct std_fs_DirectoryEntry std_fs_DirectoryEntry;
typedef struct std_fs_DirectoryIterator std_fs_DirectoryIterator;
typedef struct std_map_Item__0 std_map_Item__0;
typedef struct std_map_Item__1 std_map_Item__1;
typedef struct std_map_Item__2 std_map_Item__2;
typedef struct std_map_Item__3 std_map_Item__3;
typedef struct std_map_Item__4 std_map_Item__4;
typedef struct std_map_Item__5 std_map_Item__5;
typedef struct std_map_Item__6 std_map_Item__6;
typedef struct std_map_Item__7 std_map_Item__7;
typedef struct std_map_Item__8 std_map_Item__8;
typedef struct std_map_Item__9 std_map_Item__9;
typedef struct std_map_Item__10 std_map_Item__10;
typedef struct std_map_Item__11 std_map_Item__11;
typedef struct std_map_Item__12 std_map_Item__12;
typedef struct std_map_Item__13 std_map_Item__13;
typedef struct std_map_Map__0 std_map_Map__0;
typedef struct std_map_Map__1 std_map_Map__1;
typedef struct std_map_Map__2 std_map_Map__2;
typedef struct std_map_Map__3 std_map_Map__3;
typedef struct std_map_Map__4 std_map_Map__4;
typedef struct std_map_Map__5 std_map_Map__5;
typedef struct std_map_Map__6 std_map_Map__6;
typedef struct std_map_Map__7 std_map_Map__7;
typedef struct std_map_Map__8 std_map_Map__8;
typedef struct std_map_Map__9 std_map_Map__9;
typedef struct std_map_Map__10 std_map_Map__10;
typedef struct std_map_Map__11 std_map_Map__11;
typedef struct std_map_Map__12 std_map_Map__12;
typedef struct std_map_Map__13 std_map_Map__13;
typedef struct std_map_Iterator__2 std_map_Iterator__2;
typedef struct std_map_Iterator__3 std_map_Iterator__3;
typedef struct std_map_Iterator__4 std_map_Iterator__4;
typedef struct std_map_Iterator__6 std_map_Iterator__6;
typedef struct std_map_Iterator__8 std_map_Iterator__8;
typedef struct std_map_ValueIterator__3 std_map_ValueIterator__3;
typedef struct std_map_ValueIterator__4 std_map_ValueIterator__4;
typedef struct std_map_ValueIterator__8 std_map_ValueIterator__8;
typedef struct std_vector_Vector__0 std_vector_Vector__0;
typedef struct std_vector_Vector__1 std_vector_Vector__1;
typedef struct std_vector_Vector__2 std_vector_Vector__2;
typedef struct std_vector_Vector__3 std_vector_Vector__3;
typedef struct std_vector_Vector__4 std_vector_Vector__4;
typedef struct std_vector_Vector__5 std_vector_Vector__5;
typedef struct std_vector_Vector__6 std_vector_Vector__6;
typedef struct std_vector_Vector__7 std_vector_Vector__7;
typedef struct std_vector_Vector__8 std_vector_Vector__8;
typedef struct std_vector_Vector__9 std_vector_Vector__9;
typedef struct std_vector_Vector__10 std_vector_Vector__10;
typedef struct std_vector_Vector__11 std_vector_Vector__11;
typedef struct std_vector_Vector__12 std_vector_Vector__12;
typedef struct std_vector_Vector__13 std_vector_Vector__13;
typedef struct std_vector_Vector__14 std_vector_Vector__14;
typedef struct std_vector_Vector__15 std_vector_Vector__15;
typedef struct std_vector_Vector__16 std_vector_Vector__16;
typedef struct std_vector_Vector__17 std_vector_Vector__17;
typedef struct std_vector_Vector__18 std_vector_Vector__18;
typedef struct std_vector_Vector__19 std_vector_Vector__19;
typedef struct std_vector_Vector__20 std_vector_Vector__20;
typedef struct std_vector_Vector__21 std_vector_Vector__21;
typedef struct std_vector_Vector__22 std_vector_Vector__22;
typedef struct std_vector_Vector__23 std_vector_Vector__23;
typedef struct std_vector_Vector__24 std_vector_Vector__24;
typedef struct std_vector_Vector__25 std_vector_Vector__25;
typedef struct std_vector_Vector__26 std_vector_Vector__26;
typedef struct std_vector_Vector__27 std_vector_Vector__27;
typedef struct std_vector_Vector__28 std_vector_Vector__28;
typedef struct std_vector_Vector__29 std_vector_Vector__29;
typedef struct std_vector_Iterator__0 std_vector_Iterator__0;
typedef struct std_vector_Iterator__3 std_vector_Iterator__3;
typedef struct std_vector_Iterator__4 std_vector_Iterator__4;
typedef struct std_vector_Iterator__5 std_vector_Iterator__5;
typedef struct std_vector_Iterator__6 std_vector_Iterator__6;
typedef struct std_vector_Iterator__7 std_vector_Iterator__7;
typedef struct std_vector_Iterator__8 std_vector_Iterator__8;
typedef struct std_vector_Iterator__9 std_vector_Iterator__9;
typedef struct std_vector_Iterator__10 std_vector_Iterator__10;
typedef struct std_vector_Iterator__12 std_vector_Iterator__12;
typedef struct std_vector_Iterator__13 std_vector_Iterator__13;
typedef struct std_vector_Iterator__14 std_vector_Iterator__14;
typedef struct std_vector_Iterator__15 std_vector_Iterator__15;
typedef struct std_vector_Iterator__16 std_vector_Iterator__16;
typedef struct std_vector_Iterator__18 std_vector_Iterator__18;
typedef struct std_vector_Iterator__19 std_vector_Iterator__19;
typedef struct std_vector_Iterator__20 std_vector_Iterator__20;
typedef struct std_vector_Iterator__21 std_vector_Iterator__21;
typedef struct std_vector_Iterator__22 std_vector_Iterator__22;
typedef struct std_vector_Iterator__23 std_vector_Iterator__23;
typedef struct std_vector_Iterator__24 std_vector_Iterator__24;
typedef struct std_vector_Iterator__25 std_vector_Iterator__25;

/* Structs */
struct std_sv_SV {
  char *data;
  u32 len;
};

struct compiler_docgen_DocGenerator {
  compiler_ast_program_Program *program;
  std_sv_SV ocen_root;
};

struct compiler_passes_register_types_RegisterTypes {
  compiler_passes_generic_pass_GenericPass *o;
};

struct compiler_passes_register_types_Finder {
  compiler_passes_generic_pass_GenericPass *o;
  compiler_ast_scopes_Symbol *sym;
  compiler_types_Type *type;
};

struct compiler_passes_mark_dead_code_MarkDeadCode {
  compiler_passes_generic_pass_GenericPass *o;
  std_set_Set__0 *done;
};

struct compiler_passes_generic_pass_GenericPass {
  std_vector_Vector__1 *scope_stack;
  std_vector_Vector__2 *namespace_stack;
  compiler_ast_program_Program *program;
  compiler_types_Type *error_type;
};

struct compiler_passes_typechecker_TypeChecker {
  compiler_passes_generic_pass_GenericPass *o;
  std_vector_Vector__6 *unchecked_functions;
  bool in_template_instance;
};

struct std_buffer_Buffer {
  u8 *data;
  u32 size;
  u32 capacity;
};

struct compiler_passes_code_generator_CodeGenerator {
  compiler_passes_generic_pass_GenericPass *o;
  std_buffer_Buffer out;
  std_vector_Vector__8 *yield_vars;
  u32 indent;
};

struct compiler_passes_reorder_symbols_ReorderSymbols {
  compiler_passes_generic_pass_GenericPass *o;
  std_vector_Vector__9 *all_syms;
  std_set_Set__1 *done;
};

struct std_span_Location {
  char *filename;
  u32 line;
  u32 col;
  u32 index;
};

struct std_span_Span {
  std_span_Location start;
  std_span_Location end;
};

struct compiler_parser_Parser {
  std_vector_Vector__11 *tokens;
  u32 curr;
  compiler_ast_nodes_Function *curr_func;
  compiler_ast_program_Program *program;
  compiler_ast_program_Namespace *ns;
  std_vector_Vector__12 *attrs;
  std_span_Span attrs_span;
  compiler_tokens_Token *attrs_start_tok;
  std_span_Span prev_expr_error_span;
};

struct compiler_parser_LibraryInfo {
  char *parent_dir;
  char *path;
};

struct compiler_lexer_Lexer {
  char *source;
  u32 source_len;
  u32 i;
  std_span_Location loc;
  bool seen_newline;
  std_vector_Vector__11 *tokens;
  std_vector_Vector__13 *errors;
  bool in_comment;
  std_buffer_Buffer comment;
  std_span_Location comment_start;
};

struct compiler_ast_program_Namespace {
  compiler_ast_program_Namespace *parent;
  std_vector_Vector__6 *functions;
  std_vector_Vector__14 *structs;
  std_vector_Vector__15 *enums;
  std_vector_Vector__16 *constants;
  std_vector_Vector__16 *variables;
  std_vector_Vector__16 *imports;
  std_map_Map__2 *typedefs;
  std_map_Map__3 *namespaces;
  std_map_Map__4 *exported_symbols;
  compiler_ast_scopes_Symbol *sym;
  compiler_ast_scopes_Scope *scope;
  char *path;
  std_span_Span span;
  bool is_a_file;
  bool always_add_to_scope;
  bool is_dir_with_mod;
  compiler_ast_program_Namespace *internal_project_root;
  std_vector_Vector__16 *unhandled_imports;
};

struct compiler_ast_program_CachedSymbols {
  compiler_ast_scopes_Symbol *fmt_string_fn;
  compiler_ast_scopes_Symbol *mem_alloc_fn;
  compiler_ast_scopes_Symbol *mem_allocator;
};

struct compiler_ast_program_Program {
  compiler_ast_program_Namespace *global;
  std_vector_Vector__9 *ordered_symbols;
  std_vector_Vector__8 *c_includes;
  std_vector_Vector__8 *c_flags;
  std_map_Map__5 *operator_overloads;
  std_map_Map__6 *c_embeds;
  std_map_Map__6 *sources;
  std_vector_Vector__8 *library_paths;
  std_vector_Vector__13 *errors;
  u32 error_level;
  compiler_ast_program_CachedSymbols cached_symbols;
  bool did_cache_symbols;
  std_vector_Vector__17 *err_jmp_stack;
  std_vector_Vector__9 *explicit_alive_symbols;
  std_vector_Vector__0 *closure_types;
  std_vector_Vector__6 *closures;
  bool check_doc_links;
  bool gen_debug_info;
  bool keep_all_code;
  bool include_stdlib;
  u32 uid;
};

struct compiler_ast_program_NSIterator {
  std_vector_Vector__2 *stack;
  compiler_ast_program_Namespace *curr;
};

struct compiler_ast_scopes_TemplateInstance {
  std_vector_Vector__0 *args;
  compiler_ast_scopes_Symbol *parent;
  compiler_ast_scopes_Symbol *resolved;
};

struct compiler_ast_scopes_Template {
  std_vector_Vector__9 *params;
  std_vector_Vector__4 *instances;
};

enum compiler_ast_scopes_ReferenceType {
  compiler_ast_scopes_ReferenceType_Normal,
  compiler_ast_scopes_ReferenceType_OperatorOverload,
  compiler_ast_scopes_ReferenceType_DotShorthand,
};

char *compiler_ast_scopes_ReferenceType_dbg(compiler_ast_scopes_ReferenceType this) {
  switch (this) {
    case compiler_ast_scopes_ReferenceType_Normal: return "Normal";
    case compiler_ast_scopes_ReferenceType_OperatorOverload: return "OperatorOverload";
    case compiler_ast_scopes_ReferenceType_DotShorthand: return "DotShorthand";
    default: return "<unknown>";
  }
}

struct compiler_ast_scopes_Reference {
  compiler_ast_scopes_ReferenceType type;
  std_span_Span span;
};

struct compiler_ast_scopes_EnumField {
  compiler_ast_nodes_EnumVariant *variant;
  u32 idx;
};

struct compiler_ast_scopes_ClosedVariable {
  compiler_ast_nodes_Variable *orig;
  compiler_ast_nodes_Function *closure;
};

union compiler_ast_scopes_SymbolUnion {
  compiler_ast_nodes_Function *func;
  compiler_ast_nodes_Structure *struc;
  compiler_ast_program_Namespace *ns;
  compiler_types_Type *type_def;
  compiler_ast_nodes_Variable *var;
  compiler_ast_nodes_Enum *enom;
  compiler_ast_nodes_EnumVariant *enum_var;
  compiler_ast_scopes_EnumField enum_field;
  compiler_ast_nodes_Function *closure;
  compiler_ast_scopes_ClosedVariable closed_var;
};

enum compiler_ast_scopes_SymbolType {
  compiler_ast_scopes_SymbolType_Function,
  compiler_ast_scopes_SymbolType_Structure,
  compiler_ast_scopes_SymbolType_TypeDef,
  compiler_ast_scopes_SymbolType_Namespace,
  compiler_ast_scopes_SymbolType_Variable,
  compiler_ast_scopes_SymbolType_Constant,
  compiler_ast_scopes_SymbolType_ClosureType,
  compiler_ast_scopes_SymbolType_Closure,
  compiler_ast_scopes_SymbolType_ClosedVariable,
  compiler_ast_scopes_SymbolType_Enum,
  compiler_ast_scopes_SymbolType_EnumVariant,
  compiler_ast_scopes_SymbolType_EnumField,
};

char *compiler_ast_scopes_SymbolType_dbg(compiler_ast_scopes_SymbolType this) {
  switch (this) {
    case compiler_ast_scopes_SymbolType_Function: return "Function";
    case compiler_ast_scopes_SymbolType_Structure: return "Structure";
    case compiler_ast_scopes_SymbolType_TypeDef: return "TypeDef";
    case compiler_ast_scopes_SymbolType_Namespace: return "Namespace";
    case compiler_ast_scopes_SymbolType_Variable: return "Variable";
    case compiler_ast_scopes_SymbolType_Constant: return "Constant";
    case compiler_ast_scopes_SymbolType_ClosureType: return "ClosureType";
    case compiler_ast_scopes_SymbolType_Closure: return "Closure";
    case compiler_ast_scopes_SymbolType_ClosedVariable: return "ClosedVariable";
    case compiler_ast_scopes_SymbolType_Enum: return "Enum";
    case compiler_ast_scopes_SymbolType_EnumVariant: return "EnumVariant";
    case compiler_ast_scopes_SymbolType_EnumField: return "EnumField";
    default: return "<unknown>";
  }
}

struct compiler_ast_scopes_Symbol {
  char *name;
  char *display;
  char *full_name;
  std_span_Span span;
  compiler_ast_program_Namespace *ns;
  char *comment;
  std_span_Location comment_loc;
  std_vector_Vector__18 *references;
  compiler_ast_scopes_SymbolType type;
  compiler_ast_scopes_SymbolUnion u;
  bool is_extern;
  char *extern_name;
  compiler_ast_scopes_Template *template;
  bool is_dead;
};

struct compiler_ast_scopes_Scope {
  std_map_Map__4 *items;
  std_vector_Vector__16 *defers;
  u32 loop_count;
  bool can_yield;
  compiler_ast_nodes_Function *cur_func;
  compiler_ast_scopes_Scope *parent;
};

enum compiler_ast_operators_Operator {
  compiler_ast_operators_Operator_Address,
  compiler_ast_operators_Operator_Dereference,
  compiler_ast_operators_Operator_Negate,
  compiler_ast_operators_Operator_Not,
  compiler_ast_operators_Operator_BitwiseNot,
  compiler_ast_operators_Operator_IsNotNull,
  compiler_ast_operators_Operator_PreIncrement,
  compiler_ast_operators_Operator_PreDecrement,
  compiler_ast_operators_Operator_PostIncrement,
  compiler_ast_operators_Operator_PostDecrement,
  compiler_ast_operators_Operator_And,
  compiler_ast_operators_Operator_Assignment,
  compiler_ast_operators_Operator_BitwiseAnd,
  compiler_ast_operators_Operator_BitwiseOr,
  compiler_ast_operators_Operator_BitwiseXor,
  compiler_ast_operators_Operator_Divide,
  compiler_ast_operators_Operator_DivideEquals,
  compiler_ast_operators_Operator_Equals,
  compiler_ast_operators_Operator_GreaterThan,
  compiler_ast_operators_Operator_GreaterThanEquals,
  compiler_ast_operators_Operator_In,
  compiler_ast_operators_Operator_Index,
  compiler_ast_operators_Operator_LeftShift,
  compiler_ast_operators_Operator_LessThan,
  compiler_ast_operators_Operator_LessThanEquals,
  compiler_ast_operators_Operator_Minus,
  compiler_ast_operators_Operator_MinusEquals,
  compiler_ast_operators_Operator_Modulus,
  compiler_ast_operators_Operator_Multiply,
  compiler_ast_operators_Operator_MultiplyEquals,
  compiler_ast_operators_Operator_NotEquals,
  compiler_ast_operators_Operator_Or,
  compiler_ast_operators_Operator_Plus,
  compiler_ast_operators_Operator_PlusEquals,
  compiler_ast_operators_Operator_RightShift,
  compiler_ast_operators_Operator_LeftShiftEquals,
  compiler_ast_operators_Operator_RightShiftEquals,
  compiler_ast_operators_Operator_IndexAssign,
  compiler_ast_operators_Operator_Error,
};

char *compiler_ast_operators_Operator_dbg(compiler_ast_operators_Operator this) {
  switch (this) {
    case compiler_ast_operators_Operator_Address: return "Address";
    case compiler_ast_operators_Operator_Dereference: return "Dereference";
    case compiler_ast_operators_Operator_Negate: return "Negate";
    case compiler_ast_operators_Operator_Not: return "Not";
    case compiler_ast_operators_Operator_BitwiseNot: return "BitwiseNot";
    case compiler_ast_operators_Operator_IsNotNull: return "IsNotNull";
    case compiler_ast_operators_Operator_PreIncrement: return "PreIncrement";
    case compiler_ast_operators_Operator_PreDecrement: return "PreDecrement";
    case compiler_ast_operators_Operator_PostIncrement: return "PostIncrement";
    case compiler_ast_operators_Operator_PostDecrement: return "PostDecrement";
    case compiler_ast_operators_Operator_And: return "And";
    case compiler_ast_operators_Operator_Assignment: return "Assignment";
    case compiler_ast_operators_Operator_BitwiseAnd: return "BitwiseAnd";
    case compiler_ast_operators_Operator_BitwiseOr: return "BitwiseOr";
    case compiler_ast_operators_Operator_BitwiseXor: return "BitwiseXor";
    case compiler_ast_operators_Operator_Divide: return "Divide";
    case compiler_ast_operators_Operator_DivideEquals: return "DivideEquals";
    case compiler_ast_operators_Operator_Equals: return "Equals";
    case compiler_ast_operators_Operator_GreaterThan: return "GreaterThan";
    case compiler_ast_operators_Operator_GreaterThanEquals: return "GreaterThanEquals";
    case compiler_ast_operators_Operator_In: return "In";
    case compiler_ast_operators_Operator_Index: return "Index";
    case compiler_ast_operators_Operator_LeftShift: return "LeftShift";
    case compiler_ast_operators_Operator_LessThan: return "LessThan";
    case compiler_ast_operators_Operator_LessThanEquals: return "LessThanEquals";
    case compiler_ast_operators_Operator_Minus: return "Minus";
    case compiler_ast_operators_Operator_MinusEquals: return "MinusEquals";
    case compiler_ast_operators_Operator_Modulus: return "Modulus";
    case compiler_ast_operators_Operator_Multiply: return "Multiply";
    case compiler_ast_operators_Operator_MultiplyEquals: return "MultiplyEquals";
    case compiler_ast_operators_Operator_NotEquals: return "NotEquals";
    case compiler_ast_operators_Operator_Or: return "Or";
    case compiler_ast_operators_Operator_Plus: return "Plus";
    case compiler_ast_operators_Operator_PlusEquals: return "PlusEquals";
    case compiler_ast_operators_Operator_RightShift: return "RightShift";
    case compiler_ast_operators_Operator_LeftShiftEquals: return "LeftShiftEquals";
    case compiler_ast_operators_Operator_RightShiftEquals: return "RightShiftEquals";
    case compiler_ast_operators_Operator_IndexAssign: return "IndexAssign";
    case compiler_ast_operators_Operator_Error: return "Error";
    default: return "<unknown>";
  }
}

struct compiler_ast_operators_OperatorOverload {
  compiler_ast_operators_Operator op;
  compiler_types_Type *type1;
  compiler_types_Type *type2;
  compiler_types_Type *type3;
};

struct compiler_ast_nodes_Variable {
  compiler_ast_scopes_Symbol *sym;
  compiler_types_Type *type;
  bool is_atomic;
  compiler_ast_nodes_AST *default_value;
  compiler_types_Type *parsed_type;
};

struct compiler_ast_nodes_Structure {
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__3 *fields;
  compiler_types_Type *type;
  bool is_union;
  std_span_Span span;
  char *format_spec;
  char *format_args;
};

struct compiler_ast_nodes_Enum {
  compiler_ast_scopes_Symbol *sym;
  std_span_Span span;
  std_vector_Vector__3 *shared_fields;
  std_vector_Vector__20 *variants;
  compiler_types_Type *type;
  bool has_values;
};

struct compiler_ast_nodes_EnumVariant {
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__3 *specific_fields;
  compiler_ast_nodes_Enum *parent;
  std_span_Span span;
};

enum compiler_ast_nodes_FunctionKind {
  compiler_ast_nodes_FunctionKind_Normal,
  compiler_ast_nodes_FunctionKind_Method,
  compiler_ast_nodes_FunctionKind_Closure,
};

char *compiler_ast_nodes_FunctionKind_dbg(compiler_ast_nodes_FunctionKind this) {
  switch (this) {
    case compiler_ast_nodes_FunctionKind_Normal: return "Normal";
    case compiler_ast_nodes_FunctionKind_Method: return "Method";
    case compiler_ast_nodes_FunctionKind_Closure: return "Closure";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_Function {
  compiler_ast_nodes_FunctionKind kind;
  compiler_ast_scopes_Symbol *sym;
  std_vector_Vector__3 *params;
  compiler_types_Type *return_type;
  compiler_ast_nodes_AST *body;
  bool is_arrow;
  compiler_ast_scopes_Scope *scope;
  compiler_ast_scopes_Scope *closure_scope;
  std_map_Map__4 *closed_vars;
  std_span_Span span;
  compiler_types_Type *parsed_return_type;
  compiler_ast_nodes_AST *name_ast;
  compiler_types_Type *type;
  bool checked;
  bool is_variadic;
  bool is_variadic_format;
  std_vector_Vector__21 *operator_overloads;
  bool exits;
  bool is_static;
  compiler_types_Type *parent_type;
};

struct compiler_ast_nodes_Block {
  std_vector_Vector__16 *statements;
  compiler_ast_scopes_Scope *scope;
  compiler_ast_nodes_AST *final_stmt;
};

struct compiler_ast_nodes_Identifier {
  char *name;
  compiler_ast_nodes_Variable *var;
  bool is_function;
  compiler_ast_nodes_Function *func;
};

struct compiler_ast_nodes_Argument {
  compiler_ast_nodes_AST *expr;
  char *label;
  std_span_Span label_span;
};

enum compiler_ast_nodes_CallType {
  compiler_ast_nodes_CallType_Normal,
  compiler_ast_nodes_CallType_Closure,
  compiler_ast_nodes_CallType_StructConstructor,
  compiler_ast_nodes_CallType_EnumConstructor,
};

char *compiler_ast_nodes_CallType_dbg(compiler_ast_nodes_CallType this) {
  switch (this) {
    case compiler_ast_nodes_CallType_Normal: return "Normal";
    case compiler_ast_nodes_CallType_Closure: return "Closure";
    case compiler_ast_nodes_CallType_StructConstructor: return "StructConstructor";
    case compiler_ast_nodes_CallType_EnumConstructor: return "EnumConstructor";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_FuncCall {
  compiler_ast_nodes_AST *callee;
  std_vector_Vector__7 *args;
  compiler_ast_nodes_Function *func;
  std_span_Span open_paren_span;
  std_span_Span close_paren_span;
  compiler_ast_nodes_CallType call_type;
  bool is_function_pointer;
};

struct compiler_ast_nodes_ImportPartSingle {
  char *name;
  std_span_Span name_span;
  char *alias;
  std_span_Span alias_span;
};

struct compiler_ast_nodes_ImportPartMultiple {
  std_span_Span open_curly_span;
  std_span_Span close_curly_span;
  std_vector_Vector__22 *paths;
};

union compiler_ast_nodes_ImportPartUnion {
  compiler_ast_nodes_ImportPartSingle single;
  compiler_ast_nodes_ImportPartMultiple multiple;
};

enum compiler_ast_nodes_ImportPartType {
  compiler_ast_nodes_ImportPartType_Single,
  compiler_ast_nodes_ImportPartType_Multiple,
  compiler_ast_nodes_ImportPartType_Wildcard,
};

char *compiler_ast_nodes_ImportPartType_dbg(compiler_ast_nodes_ImportPartType this) {
  switch (this) {
    case compiler_ast_nodes_ImportPartType_Single: return "Single";
    case compiler_ast_nodes_ImportPartType_Multiple: return "Multiple";
    case compiler_ast_nodes_ImportPartType_Wildcard: return "Wildcard";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_ImportPart {
  compiler_ast_nodes_ImportPartType type;
  compiler_ast_nodes_ImportPartUnion u;
  std_span_Span span;
  compiler_ast_scopes_Symbol *resolved_symbol;
};

enum compiler_ast_nodes_ImportType {
  compiler_ast_nodes_ImportType_GlobalNamespace,
  compiler_ast_nodes_ImportType_ProjectNamespace,
  compiler_ast_nodes_ImportType_ParentNamespace,
  compiler_ast_nodes_ImportType_CurrentScope,
};

char *compiler_ast_nodes_ImportType_dbg(compiler_ast_nodes_ImportType this) {
  switch (this) {
    case compiler_ast_nodes_ImportType_GlobalNamespace: return "GlobalNamespace";
    case compiler_ast_nodes_ImportType_ProjectNamespace: return "ProjectNamespace";
    case compiler_ast_nodes_ImportType_ParentNamespace: return "ParentNamespace";
    case compiler_ast_nodes_ImportType_CurrentScope: return "CurrentScope";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_Import {
  std_vector_Vector__5 *parts;
  compiler_ast_nodes_ImportType type;
  u32 parent_count;
  bool export;
  compiler_ast_scopes_Symbol *root_sym;
};

struct compiler_ast_nodes_NumLiteral {
  char *text;
  compiler_types_Type *suffix;
};

struct compiler_ast_nodes_Binary {
  compiler_ast_operators_Operator op;
  compiler_ast_nodes_AST *lhs;
  compiler_ast_nodes_AST *rhs;
  std_span_Span op_span;
};

struct compiler_ast_nodes_Unary {
  compiler_ast_operators_Operator op;
  compiler_ast_nodes_AST *expr;
  std_span_Span op_span;
};

struct compiler_ast_nodes_NSLookup {
  compiler_ast_nodes_AST *lhs;
  char *rhs_name;
  std_span_Span rhs_span;
};

struct compiler_ast_nodes_Member {
  compiler_ast_nodes_AST *lhs;
  char *rhs_name;
  std_span_Span rhs_span;
  bool dot_shorthand;
  bool is_pointer;
};

struct compiler_ast_nodes_Assertion {
  compiler_ast_nodes_AST *expr;
  compiler_ast_nodes_AST *msg;
};

struct compiler_ast_nodes_IfBranch {
  compiler_ast_nodes_AST *cond;
  compiler_ast_nodes_AST *body;
};

struct compiler_ast_nodes_IfStatement {
  std_vector_Vector__23 *branches;
  compiler_ast_nodes_AST *els;
  std_span_Span els_span;
  std_span_Span if_span;
};

struct compiler_ast_nodes_Loop {
  compiler_ast_nodes_AST *init;
  compiler_ast_nodes_AST *cond;
  compiler_ast_nodes_AST *step;
  compiler_ast_nodes_AST *body;
};

struct compiler_ast_nodes_Cast {
  compiler_ast_nodes_AST *lhs;
  compiler_types_Type *to;
  compiler_types_Type *parsed_to;
};

struct compiler_ast_nodes_FormatString {
  std_vector_Vector__8 *parts;
  std_vector_Vector__8 *specs;
  std_vector_Vector__16 *exprs;
};

struct compiler_ast_nodes_MatchCondArg {
  compiler_ast_nodes_Variable *var;
  bool is_shared;
};

struct compiler_ast_nodes_MatchCond {
  compiler_ast_nodes_AST *expr;
  compiler_ast_nodes_Function *cmp_fn;
  std_vector_Vector__19 *args;
};

struct compiler_ast_nodes_MatchCase {
  std_vector_Vector__10 *conds;
  compiler_ast_nodes_AST *body;
};

struct compiler_ast_nodes_Match {
  compiler_ast_nodes_AST *expr;
  std_vector_Vector__24 *cases;
  compiler_ast_nodes_AST *defolt;
  bool is_custom_match;
  std_span_Span defolt_span;
  std_span_Span match_span;
};

struct compiler_ast_nodes_Specialization {
  compiler_ast_nodes_AST *base;
  std_vector_Vector__0 *parsed_template_args;
  std_vector_Vector__0 *template_args;
};

struct compiler_ast_nodes_ArrayLiteral {
  std_vector_Vector__16 *elements;
};

struct compiler_ast_nodes_Return {
  compiler_ast_nodes_AST *expr;
  std_span_Span return_span;
};

union compiler_ast_nodes_ASTUnion {
  compiler_ast_nodes_Assertion assertion;
  compiler_ast_nodes_Binary binary;
  compiler_ast_nodes_Block block;
  bool bool_literal;
  compiler_ast_nodes_FuncCall call;
  compiler_ast_nodes_Cast cast;
  compiler_ast_nodes_Identifier ident;
  compiler_ast_nodes_IfStatement if_stmt;
  compiler_ast_nodes_Import import_path;
  compiler_ast_nodes_NSLookup lookup;
  compiler_ast_nodes_Loop loop;
  compiler_ast_nodes_Member member;
  compiler_ast_nodes_NumLiteral num_literal;
  char *string_literal;
  char *char_literal;
  compiler_ast_nodes_Unary unary;
  std_span_Span operator_span;
  compiler_ast_nodes_Variable *var_decl;
  compiler_ast_nodes_FormatString fmt_str;
  compiler_types_Type *size_of_type;
  compiler_ast_nodes_Match match_stmt;
  compiler_ast_nodes_Specialization spec;
  compiler_ast_nodes_ArrayLiteral array_literal;
  compiler_ast_nodes_AST *child;
  compiler_ast_nodes_Return ret;
  compiler_ast_nodes_Function *closure;
};

enum compiler_ast_nodes_ASTType {
  compiler_ast_nodes_ASTType_Assert,
  compiler_ast_nodes_ASTType_Block,
  compiler_ast_nodes_ASTType_BoolLiteral,
  compiler_ast_nodes_ASTType_Break,
  compiler_ast_nodes_ASTType_Call,
  compiler_ast_nodes_ASTType_Continue,
  compiler_ast_nodes_ASTType_Error,
  compiler_ast_nodes_ASTType_Identifier,
  compiler_ast_nodes_ASTType_If,
  compiler_ast_nodes_ASTType_Import,
  compiler_ast_nodes_ASTType_IntLiteral,
  compiler_ast_nodes_ASTType_Member,
  compiler_ast_nodes_ASTType_NSLookup,
  compiler_ast_nodes_ASTType_OverloadedOperator,
  compiler_ast_nodes_ASTType_Return,
  compiler_ast_nodes_ASTType_Yield,
  compiler_ast_nodes_ASTType_StringLiteral,
  compiler_ast_nodes_ASTType_SizeOf,
  compiler_ast_nodes_ASTType_VarDeclaration,
  compiler_ast_nodes_ASTType_While,
  compiler_ast_nodes_ASTType_For,
  compiler_ast_nodes_ASTType_CharLiteral,
  compiler_ast_nodes_ASTType_FloatLiteral,
  compiler_ast_nodes_ASTType_FormatStringLiteral,
  compiler_ast_nodes_ASTType_Cast,
  compiler_ast_nodes_ASTType_Null,
  compiler_ast_nodes_ASTType_Match,
  compiler_ast_nodes_ASTType_Defer,
  compiler_ast_nodes_ASTType_Specialization,
  compiler_ast_nodes_ASTType_ArrayLiteral,
  compiler_ast_nodes_ASTType_CreateClosure,
  compiler_ast_nodes_ASTType_CreateNew,
  compiler_ast_nodes_ASTType_UnaryOp,
  compiler_ast_nodes_ASTType_BinaryOp,
};

char *compiler_ast_nodes_ASTType_dbg(compiler_ast_nodes_ASTType this) {
  switch (this) {
    case compiler_ast_nodes_ASTType_Assert: return "Assert";
    case compiler_ast_nodes_ASTType_Block: return "Block";
    case compiler_ast_nodes_ASTType_BoolLiteral: return "BoolLiteral";
    case compiler_ast_nodes_ASTType_Break: return "Break";
    case compiler_ast_nodes_ASTType_Call: return "Call";
    case compiler_ast_nodes_ASTType_Continue: return "Continue";
    case compiler_ast_nodes_ASTType_Error: return "Error";
    case compiler_ast_nodes_ASTType_Identifier: return "Identifier";
    case compiler_ast_nodes_ASTType_If: return "If";
    case compiler_ast_nodes_ASTType_Import: return "Import";
    case compiler_ast_nodes_ASTType_IntLiteral: return "IntLiteral";
    case compiler_ast_nodes_ASTType_Member: return "Member";
    case compiler_ast_nodes_ASTType_NSLookup: return "NSLookup";
    case compiler_ast_nodes_ASTType_OverloadedOperator: return "OverloadedOperator";
    case compiler_ast_nodes_ASTType_Return: return "Return";
    case compiler_ast_nodes_ASTType_Yield: return "Yield";
    case compiler_ast_nodes_ASTType_StringLiteral: return "StringLiteral";
    case compiler_ast_nodes_ASTType_SizeOf: return "SizeOf";
    case compiler_ast_nodes_ASTType_VarDeclaration: return "VarDeclaration";
    case compiler_ast_nodes_ASTType_While: return "While";
    case compiler_ast_nodes_ASTType_For: return "For";
    case compiler_ast_nodes_ASTType_CharLiteral: return "CharLiteral";
    case compiler_ast_nodes_ASTType_FloatLiteral: return "FloatLiteral";
    case compiler_ast_nodes_ASTType_FormatStringLiteral: return "FormatStringLiteral";
    case compiler_ast_nodes_ASTType_Cast: return "Cast";
    case compiler_ast_nodes_ASTType_Null: return "Null";
    case compiler_ast_nodes_ASTType_Match: return "Match";
    case compiler_ast_nodes_ASTType_Defer: return "Defer";
    case compiler_ast_nodes_ASTType_Specialization: return "Specialization";
    case compiler_ast_nodes_ASTType_ArrayLiteral: return "ArrayLiteral";
    case compiler_ast_nodes_ASTType_CreateClosure: return "CreateClosure";
    case compiler_ast_nodes_ASTType_CreateNew: return "CreateNew";
    case compiler_ast_nodes_ASTType_UnaryOp: return "UnaryOp";
    case compiler_ast_nodes_ASTType_BinaryOp: return "BinaryOp";
    default: return "<unknown>";
  }
}

struct compiler_ast_nodes_AST {
  compiler_ast_nodes_ASTType type;
  std_span_Span span;
  compiler_ast_nodes_ASTUnion u;
  compiler_types_Type *etype;
  compiler_types_Type *hint;
  compiler_ast_scopes_Symbol *resolved_symbol;
  bool returns;
};

enum compiler_attributes_AttributeType {
  compiler_attributes_AttributeType_Extern,
  compiler_attributes_AttributeType_Exits,
  compiler_attributes_AttributeType_VariadicFormat,
  compiler_attributes_AttributeType_Export,
  compiler_attributes_AttributeType_Formatting,
  compiler_attributes_AttributeType_Operator,
  compiler_attributes_AttributeType_Atomic,
  compiler_attributes_AttributeType_Alive,
  compiler_attributes_AttributeType_Invalid,
};

char *compiler_attributes_AttributeType_dbg(compiler_attributes_AttributeType this) {
  switch (this) {
    case compiler_attributes_AttributeType_Extern: return "Extern";
    case compiler_attributes_AttributeType_Exits: return "Exits";
    case compiler_attributes_AttributeType_VariadicFormat: return "VariadicFormat";
    case compiler_attributes_AttributeType_Export: return "Export";
    case compiler_attributes_AttributeType_Formatting: return "Formatting";
    case compiler_attributes_AttributeType_Operator: return "Operator";
    case compiler_attributes_AttributeType_Atomic: return "Atomic";
    case compiler_attributes_AttributeType_Alive: return "Alive";
    case compiler_attributes_AttributeType_Invalid: return "Invalid";
    default: return "<unknown>";
  }
}

struct compiler_attributes_Attribute {
  compiler_attributes_AttributeType type;
  std_vector_Vector__8 *args;
  std_span_Span span;
};

enum compiler_lsp_CommandType {
  compiler_lsp_CommandType_Hover,
  compiler_lsp_CommandType_GoToDefinition,
  compiler_lsp_CommandType_GoToType,
  compiler_lsp_CommandType_None,
  compiler_lsp_CommandType_DocumentSymbols,
  compiler_lsp_CommandType_Completions,
  compiler_lsp_CommandType_References,
  compiler_lsp_CommandType_Renames,
  compiler_lsp_CommandType_SignatureHelp,
  compiler_lsp_CommandType_Validate,
};

char *compiler_lsp_CommandType_dbg(compiler_lsp_CommandType this) {
  switch (this) {
    case compiler_lsp_CommandType_Hover: return "Hover";
    case compiler_lsp_CommandType_GoToDefinition: return "GoToDefinition";
    case compiler_lsp_CommandType_GoToType: return "GoToType";
    case compiler_lsp_CommandType_None: return "None";
    case compiler_lsp_CommandType_DocumentSymbols: return "DocumentSymbols";
    case compiler_lsp_CommandType_Completions: return "Completions";
    case compiler_lsp_CommandType_References: return "References";
    case compiler_lsp_CommandType_Renames: return "Renames";
    case compiler_lsp_CommandType_SignatureHelp: return "SignatureHelp";
    case compiler_lsp_CommandType_Validate: return "Validate";
    default: return "<unknown>";
  }
}

struct compiler_lsp_finder_Finder {
  compiler_lsp_CommandType cmd;
  std_span_Location loc;
  compiler_ast_scopes_Symbol *found_sym;
  compiler_ast_nodes_AST *found_node;
  compiler_ast_scopes_Scope *found_scope;
  compiler_ast_program_Namespace *found_import_ns;
  u32 active_param;
  compiler_ast_nodes_AST *call;
  std_vector_Vector__1 *scopes;
};

enum compiler_tokens_TokenType {
  compiler_tokens_TokenType_AtSign,
  compiler_tokens_TokenType_Ampersand,
  compiler_tokens_TokenType_Backtick,
  compiler_tokens_TokenType_Caret,
  compiler_tokens_TokenType_CharLiteral,
  compiler_tokens_TokenType_CloseCurly,
  compiler_tokens_TokenType_CloseParen,
  compiler_tokens_TokenType_CloseSquare,
  compiler_tokens_TokenType_Colon,
  compiler_tokens_TokenType_ColonColon,
  compiler_tokens_TokenType_Comma,
  compiler_tokens_TokenType_Dot,
  compiler_tokens_TokenType_EOF,
  compiler_tokens_TokenType_Ellipsis,
  compiler_tokens_TokenType_Equals,
  compiler_tokens_TokenType_EqualEquals,
  compiler_tokens_TokenType_Exclamation,
  compiler_tokens_TokenType_FatArrow,
  compiler_tokens_TokenType_FloatLiteral,
  compiler_tokens_TokenType_FormatStringLiteral,
  compiler_tokens_TokenType_GreaterThan,
  compiler_tokens_TokenType_GreaterThanEquals,
  compiler_tokens_TokenType_Identifier,
  compiler_tokens_TokenType_IntLiteral,
  compiler_tokens_TokenType_LessThan,
  compiler_tokens_TokenType_LessThanEquals,
  compiler_tokens_TokenType_Line,
  compiler_tokens_TokenType_Minus,
  compiler_tokens_TokenType_MinusEquals,
  compiler_tokens_TokenType_MinusMinus,
  compiler_tokens_TokenType_NotEquals,
  compiler_tokens_TokenType_OpenCurly,
  compiler_tokens_TokenType_OpenParen,
  compiler_tokens_TokenType_OpenSquare,
  compiler_tokens_TokenType_Percent,
  compiler_tokens_TokenType_Plus,
  compiler_tokens_TokenType_PlusEquals,
  compiler_tokens_TokenType_PlusPlus,
  compiler_tokens_TokenType_Question,
  compiler_tokens_TokenType_Semicolon,
  compiler_tokens_TokenType_Slash,
  compiler_tokens_TokenType_SlashEquals,
  compiler_tokens_TokenType_Star,
  compiler_tokens_TokenType_StarEquals,
  compiler_tokens_TokenType_StringLiteral,
  compiler_tokens_TokenType_Tilde,
  compiler_tokens_TokenType_Newline,
  compiler_tokens_TokenType_BEGIN_KEYWORDS,
  compiler_tokens_TokenType_And,
  compiler_tokens_TokenType_As,
  compiler_tokens_TokenType_Assert,
  compiler_tokens_TokenType_Break,
  compiler_tokens_TokenType_Const,
  compiler_tokens_TokenType_Continue,
  compiler_tokens_TokenType_Def,
  compiler_tokens_TokenType_Defer,
  compiler_tokens_TokenType_Else,
  compiler_tokens_TokenType_Enum,
  compiler_tokens_TokenType_Extern,
  compiler_tokens_TokenType_False,
  compiler_tokens_TokenType_For,
  compiler_tokens_TokenType_Fn,
  compiler_tokens_TokenType_If,
  compiler_tokens_TokenType_Let,
  compiler_tokens_TokenType_Match,
  compiler_tokens_TokenType_Namespace,
  compiler_tokens_TokenType_Null,
  compiler_tokens_TokenType_Not,
  compiler_tokens_TokenType_Or,
  compiler_tokens_TokenType_Return,
  compiler_tokens_TokenType_SizeOf,
  compiler_tokens_TokenType_Struct,
  compiler_tokens_TokenType_True,
  compiler_tokens_TokenType_Then,
  compiler_tokens_TokenType_TypeDef,
  compiler_tokens_TokenType_Union,
  compiler_tokens_TokenType_Import,
  compiler_tokens_TokenType_Void,
  compiler_tokens_TokenType_Yield,
  compiler_tokens_TokenType_While,
};

char *compiler_tokens_TokenType_dbg(compiler_tokens_TokenType this) {
  switch (this) {
    case compiler_tokens_TokenType_AtSign: return "AtSign";
    case compiler_tokens_TokenType_Ampersand: return "Ampersand";
    case compiler_tokens_TokenType_Backtick: return "Backtick";
    case compiler_tokens_TokenType_Caret: return "Caret";
    case compiler_tokens_TokenType_CharLiteral: return "CharLiteral";
    case compiler_tokens_TokenType_CloseCurly: return "CloseCurly";
    case compiler_tokens_TokenType_CloseParen: return "CloseParen";
    case compiler_tokens_TokenType_CloseSquare: return "CloseSquare";
    case compiler_tokens_TokenType_Colon: return "Colon";
    case compiler_tokens_TokenType_ColonColon: return "ColonColon";
    case compiler_tokens_TokenType_Comma: return "Comma";
    case compiler_tokens_TokenType_Dot: return "Dot";
    case compiler_tokens_TokenType_EOF: return "EOF";
    case compiler_tokens_TokenType_Ellipsis: return "Ellipsis";
    case compiler_tokens_TokenType_Equals: return "Equals";
    case compiler_tokens_TokenType_EqualEquals: return "EqualEquals";
    case compiler_tokens_TokenType_Exclamation: return "Exclamation";
    case compiler_tokens_TokenType_FatArrow: return "FatArrow";
    case compiler_tokens_TokenType_FloatLiteral: return "FloatLiteral";
    case compiler_tokens_TokenType_FormatStringLiteral: return "FormatStringLiteral";
    case compiler_tokens_TokenType_GreaterThan: return "GreaterThan";
    case compiler_tokens_TokenType_GreaterThanEquals: return "GreaterThanEquals";
    case compiler_tokens_TokenType_Identifier: return "Identifier";
    case compiler_tokens_TokenType_IntLiteral: return "IntLiteral";
    case compiler_tokens_TokenType_LessThan: return "LessThan";
    case compiler_tokens_TokenType_LessThanEquals: return "LessThanEquals";
    case compiler_tokens_TokenType_Line: return "Line";
    case compiler_tokens_TokenType_Minus: return "Minus";
    case compiler_tokens_TokenType_MinusEquals: return "MinusEquals";
    case compiler_tokens_TokenType_MinusMinus: return "MinusMinus";
    case compiler_tokens_TokenType_NotEquals: return "NotEquals";
    case compiler_tokens_TokenType_OpenCurly: return "OpenCurly";
    case compiler_tokens_TokenType_OpenParen: return "OpenParen";
    case compiler_tokens_TokenType_OpenSquare: return "OpenSquare";
    case compiler_tokens_TokenType_Percent: return "Percent";
    case compiler_tokens_TokenType_Plus: return "Plus";
    case compiler_tokens_TokenType_PlusEquals: return "PlusEquals";
    case compiler_tokens_TokenType_PlusPlus: return "PlusPlus";
    case compiler_tokens_TokenType_Question: return "Question";
    case compiler_tokens_TokenType_Semicolon: return "Semicolon";
    case compiler_tokens_TokenType_Slash: return "Slash";
    case compiler_tokens_TokenType_SlashEquals: return "SlashEquals";
    case compiler_tokens_TokenType_Star: return "Star";
    case compiler_tokens_TokenType_StarEquals: return "StarEquals";
    case compiler_tokens_TokenType_StringLiteral: return "StringLiteral";
    case compiler_tokens_TokenType_Tilde: return "Tilde";
    case compiler_tokens_TokenType_Newline: return "Newline";
    case compiler_tokens_TokenType_BEGIN_KEYWORDS: return "BEGIN_KEYWORDS";
    case compiler_tokens_TokenType_And: return "And";
    case compiler_tokens_TokenType_As: return "As";
    case compiler_tokens_TokenType_Assert: return "Assert";
    case compiler_tokens_TokenType_Break: return "Break";
    case compiler_tokens_TokenType_Const: return "Const";
    case compiler_tokens_TokenType_Continue: return "Continue";
    case compiler_tokens_TokenType_Def: return "Def";
    case compiler_tokens_TokenType_Defer: return "Defer";
    case compiler_tokens_TokenType_Else: return "Else";
    case compiler_tokens_TokenType_Enum: return "Enum";
    case compiler_tokens_TokenType_Extern: return "Extern";
    case compiler_tokens_TokenType_False: return "False";
    case compiler_tokens_TokenType_For: return "For";
    case compiler_tokens_TokenType_Fn: return "Fn";
    case compiler_tokens_TokenType_If: return "If";
    case compiler_tokens_TokenType_Let: return "Let";
    case compiler_tokens_TokenType_Match: return "Match";
    case compiler_tokens_TokenType_Namespace: return "Namespace";
    case compiler_tokens_TokenType_Null: return "Null";
    case compiler_tokens_TokenType_Not: return "Not";
    case compiler_tokens_TokenType_Or: return "Or";
    case compiler_tokens_TokenType_Return: return "Return";
    case compiler_tokens_TokenType_SizeOf: return "SizeOf";
    case compiler_tokens_TokenType_Struct: return "Struct";
    case compiler_tokens_TokenType_True: return "True";
    case compiler_tokens_TokenType_Then: return "Then";
    case compiler_tokens_TokenType_TypeDef: return "TypeDef";
    case compiler_tokens_TokenType_Union: return "Union";
    case compiler_tokens_TokenType_Import: return "Import";
    case compiler_tokens_TokenType_Void: return "Void";
    case compiler_tokens_TokenType_Yield: return "Yield";
    case compiler_tokens_TokenType_While: return "While";
    default: return "<unknown>";
  }
}

struct compiler_tokens_Token {
  compiler_tokens_TokenType type;
  std_span_Span span;
  char *text;
  compiler_tokens_Token *suffix;
  bool seen_newline;
  char *comment;
  std_span_Location comment_loc;
};

struct compiler_types_FunctionType {
  compiler_ast_nodes_Function *orig;
  std_vector_Vector__3 *params;
  compiler_types_Type *return_type;
  bool is_variadic;
};

struct compiler_types_ArrayType {
  compiler_types_Type *elem_type;
  compiler_ast_nodes_AST *size_expr;
  bool size_known;
  u32 size;
};

struct compiler_types_UnresolvedTemplate {
  compiler_types_Type *base;
  std_vector_Vector__0 *args;
};

struct compiler_types_TypeUnion {
  compiler_types_Type *ptr;
  compiler_ast_nodes_Structure *struc;
  compiler_ast_nodes_Enum *enom;
  compiler_ast_nodes_AST *unresolved;
  compiler_types_FunctionType func;
  compiler_types_ArrayType arr;
  compiler_types_UnresolvedTemplate unresolved_spec;
};

enum compiler_types_BaseType {
  compiler_types_BaseType_Char,
  compiler_types_BaseType_Bool,
  compiler_types_BaseType_Void,
  compiler_types_BaseType_I8,
  compiler_types_BaseType_I16,
  compiler_types_BaseType_I32,
  compiler_types_BaseType_I64,
  compiler_types_BaseType_U8,
  compiler_types_BaseType_U16,
  compiler_types_BaseType_U32,
  compiler_types_BaseType_U64,
  compiler_types_BaseType_F32,
  compiler_types_BaseType_F64,
  compiler_types_BaseType_NUM_BASE_TYPES,
  compiler_types_BaseType_FunctionPtr,
  compiler_types_BaseType_Closure,
  compiler_types_BaseType_Pointer,
  compiler_types_BaseType_Structure,
  compiler_types_BaseType_Unresolved,
  compiler_types_BaseType_Array,
  compiler_types_BaseType_Alias,
  compiler_types_BaseType_UnresolvedTemplate,
  compiler_types_BaseType_Enum,
  compiler_types_BaseType_Error,
};

char *compiler_types_BaseType_dbg(compiler_types_BaseType this) {
  switch (this) {
    case compiler_types_BaseType_Char: return "Char";
    case compiler_types_BaseType_Bool: return "Bool";
    case compiler_types_BaseType_Void: return "Void";
    case compiler_types_BaseType_I8: return "I8";
    case compiler_types_BaseType_I16: return "I16";
    case compiler_types_BaseType_I32: return "I32";
    case compiler_types_BaseType_I64: return "I64";
    case compiler_types_BaseType_U8: return "U8";
    case compiler_types_BaseType_U16: return "U16";
    case compiler_types_BaseType_U32: return "U32";
    case compiler_types_BaseType_U64: return "U64";
    case compiler_types_BaseType_F32: return "F32";
    case compiler_types_BaseType_F64: return "F64";
    case compiler_types_BaseType_NUM_BASE_TYPES: return "NUM_BASE_TYPES";
    case compiler_types_BaseType_FunctionPtr: return "FunctionPtr";
    case compiler_types_BaseType_Closure: return "Closure";
    case compiler_types_BaseType_Pointer: return "Pointer";
    case compiler_types_BaseType_Structure: return "Structure";
    case compiler_types_BaseType_Unresolved: return "Unresolved";
    case compiler_types_BaseType_Array: return "Array";
    case compiler_types_BaseType_Alias: return "Alias";
    case compiler_types_BaseType_UnresolvedTemplate: return "UnresolvedTemplate";
    case compiler_types_BaseType_Enum: return "Enum";
    case compiler_types_BaseType_Error: return "Error";
    default: return "<unknown>";
  }
}

struct compiler_types_Type {
  char *name;
  compiler_types_BaseType base;
  std_span_Span span;
  compiler_types_TypeUnion u;
  std_map_Map__8 *methods;
  compiler_ast_scopes_Symbol *sym;
  compiler_ast_scopes_TemplateInstance *template_instance;
};

enum compiler_errors_ErrorType {
  compiler_errors_ErrorType_Standard,
  compiler_errors_ErrorType_WithNote,
  compiler_errors_ErrorType_WithHint,
};

char *compiler_errors_ErrorType_dbg(compiler_errors_ErrorType this) {
  switch (this) {
    case compiler_errors_ErrorType_Standard: return "Standard";
    case compiler_errors_ErrorType_WithNote: return "WithNote";
    case compiler_errors_ErrorType_WithHint: return "WithHint";
    default: return "<unknown>";
  }
}

struct compiler_errors_Error {
  compiler_errors_ErrorType type;
  char *msg1;
  std_span_Span span1;
  char *msg2;
  std_span_Span span2;
};

enum compiler_errors_MessageType {
  compiler_errors_MessageType_Error,
  compiler_errors_MessageType_Warning,
  compiler_errors_MessageType_Note,
};

char *compiler_errors_MessageType_dbg(compiler_errors_MessageType this) {
  switch (this) {
    case compiler_errors_MessageType_Error: return "Error";
    case compiler_errors_MessageType_Warning: return "Warning";
    case compiler_errors_MessageType_Note: return "Note";
    default: return "<unknown>";
  }
}

struct std_CharIterator {
  char *data;
  u32 len;
  u32 pos;
};

struct std_sv_SVLineIterator {
  std_sv_SV sv;
};

struct std_sv_SVSplitIterator {
  std_sv_SV sv;
  std_sv_SV delim;
};

struct std_compact_map_Item__0 {
  u32 hash;
  char *key;
  std_value_Value *value;
};

struct std_compact_map_Item__1 {
  u32 hash;
  char *key;
  std_span_Span value;
};

struct std_compact_map_Map__0 {
  std_vector_Vector__27 *items;
  i32 *indices;
  u32 capacity;
  u32 num_tombstones;
};

struct std_compact_map_Map__1 {
  std_vector_Vector__28 *items;
  i32 *indices;
  u32 capacity;
  u32 num_tombstones;
};

struct std_vector_Iterator__27 {
  std_vector_Vector__27 *vec;
  u32 index;
};

struct std_compact_map_Iterator__0 {
  std_vector_Iterator__27 iter;
};

enum std_logging_LogLevel {
  std_logging_LogLevel_Debug,
  std_logging_LogLevel_Info,
  std_logging_LogLevel_Warn,
  std_logging_LogLevel_Error,
};

char *std_logging_LogLevel_dbg(std_logging_LogLevel this) {
  switch (this) {
    case std_logging_LogLevel_Debug: return "Debug";
    case std_logging_LogLevel_Info: return "Info";
    case std_logging_LogLevel_Warn: return "Warn";
    case std_logging_LogLevel_Error: return "Error";
    default: return "<unknown>";
  }
}

struct std_set_Set__0 {
  std_map_Map__0 *map;
  u32 size;
};

struct std_set_Set__1 {
  std_map_Map__1 *map;
  u32 size;
};

struct std_set_Set__2 {
  std_map_Map__7 *map;
  u32 size;
};

struct std_set_Set__3 {
  std_map_Map__13 *map;
  u32 size;
};

struct std_map_Iterator__13 {
  i32 idx;
  std_map_Item__13 *node;
  std_map_Map__13 *map;
};

struct std_set_Iterator__3 {
  std_map_Iterator__13 map_iter;
};

union std_value_ValueUnion {
  bool as_bool;
  i64 as_int;
  f64 as_float;
  std_buffer_Buffer as_str;
  std_vector_Vector__26 *as_list;
  std_compact_map_Map__0 *as_dict;
};

enum std_value_ValueType {
  std_value_ValueType_Null,
  std_value_ValueType_Bool,
  std_value_ValueType_Integer,
  std_value_ValueType_Float,
  std_value_ValueType_String,
  std_value_ValueType_List,
  std_value_ValueType_Dictionary,
};

char *std_value_ValueType_dbg(std_value_ValueType this) {
  switch (this) {
    case std_value_ValueType_Null: return "Null";
    case std_value_ValueType_Bool: return "Bool";
    case std_value_ValueType_Integer: return "Integer";
    case std_value_ValueType_Float: return "Float";
    case std_value_ValueType_String: return "String";
    case std_value_ValueType_List: return "List";
    case std_value_ValueType_Dictionary: return "Dictionary";
    default: return "<unknown>";
  }
}

struct std_value_Value {
  std_value_ValueType type;
  std_value_ValueUnion u;
  std_span_Span span;
};

enum std_fs_EntryType {
  std_fs_EntryType_File,
  std_fs_EntryType_Directory,
  std_fs_EntryType_SymbolicLink,
  std_fs_EntryType_Unknown,
};

char *std_fs_EntryType_dbg(std_fs_EntryType this) {
  switch (this) {
    case std_fs_EntryType_File: return "File";
    case std_fs_EntryType_Directory: return "Directory";
    case std_fs_EntryType_SymbolicLink: return "SymbolicLink";
    case std_fs_EntryType_Unknown: return "Unknown";
    default: return "<unknown>";
  }
}

struct std_fs_DirectoryEntry {
  std_fs_EntryType type;
  char *name;
};

struct std_fs_DirectoryIterator {
  DIR *dir;
  struct dirent *dp;
  bool skip_self_and_parent;
};

char *std_fs_SeekMode_dbg(i32 this) {
  switch (this) {
    case SEEK_SET: return "Set";
    case SEEK_CUR: return "Cur";
    case SEEK_END: return "End";
    default: return "<unknown>";
  }
}

struct std_map_Item__0 {
  u64 key;
  bool value;
  std_map_Item__0 *next;
};

struct std_map_Item__1 {
  void *key;
  bool value;
  std_map_Item__1 *next;
};

struct std_map_Item__2 {
  char *key;
  compiler_types_Type *value;
  std_map_Item__2 *next;
};

struct std_map_Item__3 {
  char *key;
  compiler_ast_program_Namespace *value;
  std_map_Item__3 *next;
};

struct std_map_Item__4 {
  char *key;
  compiler_ast_scopes_Symbol *value;
  std_map_Item__4 *next;
};

struct std_map_Item__5 {
  compiler_ast_operators_OperatorOverload key;
  compiler_ast_nodes_Function *value;
  std_map_Item__5 *next;
};

struct std_map_Item__6 {
  char *key;
  char *value;
  std_map_Item__6 *next;
};

struct std_map_Item__7 {
  char *key;
  bool value;
  std_map_Item__7 *next;
};

struct std_map_Item__8 {
  char *key;
  compiler_ast_nodes_Function *value;
  std_map_Item__8 *next;
};

struct std_map_Item__9 {
  char *key;
  compiler_ast_nodes_Argument *value;
  std_map_Item__9 *next;
};

struct std_map_Item__10 {
  char *key;
  compiler_ast_nodes_Variable *value;
  std_map_Item__10 *next;
};

struct std_map_Item__11 {
  char *key;
  compiler_ast_nodes_MatchCond *value;
  std_map_Item__11 *next;
};

struct std_map_Item__12 {
  char *key;
  std_span_Span value;
  std_map_Item__12 *next;
};

struct std_map_Item__13 {
  std_span_Span key;
  bool value;
  std_map_Item__13 *next;
};

struct std_map_Map__0 {
  std_map_Item__0 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__1 {
  std_map_Item__1 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__2 {
  std_map_Item__2 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__3 {
  std_map_Item__3 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__4 {
  std_map_Item__4 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__5 {
  std_map_Item__5 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__6 {
  std_map_Item__6 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__7 {
  std_map_Item__7 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__8 {
  std_map_Item__8 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__9 {
  std_map_Item__9 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__10 {
  std_map_Item__10 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__11 {
  std_map_Item__11 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__12 {
  std_map_Item__12 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Map__13 {
  std_map_Item__13 **buckets;
  u32 size;
  u32 num_buckets;
  u32 num_collisions;
};

struct std_map_Iterator__2 {
  i32 idx;
  std_map_Item__2 *node;
  std_map_Map__2 *map;
};

struct std_map_Iterator__3 {
  i32 idx;
  std_map_Item__3 *node;
  std_map_Map__3 *map;
};

struct std_map_Iterator__4 {
  i32 idx;
  std_map_Item__4 *node;
  std_map_Map__4 *map;
};

struct std_map_Iterator__6 {
  i32 idx;
  std_map_Item__6 *node;
  std_map_Map__6 *map;
};

struct std_map_Iterator__8 {
  i32 idx;
  std_map_Item__8 *node;
  std_map_Map__8 *map;
};

struct std_map_ValueIterator__3 {
  std_map_Iterator__3 map_iter;
};

struct std_map_ValueIterator__4 {
  std_map_Iterator__4 map_iter;
};

struct std_map_ValueIterator__8 {
  std_map_Iterator__8 map_iter;
};

struct std_vector_Vector__0 {
  compiler_types_Type **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__1 {
  compiler_ast_scopes_Scope **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__2 {
  compiler_ast_program_Namespace **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__3 {
  compiler_ast_nodes_Variable **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__4 {
  compiler_ast_scopes_TemplateInstance **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__5 {
  compiler_ast_nodes_ImportPart **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__6 {
  compiler_ast_nodes_Function **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__7 {
  compiler_ast_nodes_Argument **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__8 {
  char **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__9 {
  compiler_ast_scopes_Symbol **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__10 {
  compiler_ast_nodes_MatchCond **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__11 {
  compiler_tokens_Token **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__12 {
  compiler_attributes_Attribute **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__13 {
  compiler_errors_Error **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__14 {
  compiler_ast_nodes_Structure **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__15 {
  compiler_ast_nodes_Enum **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__16 {
  compiler_ast_nodes_AST **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__17 {
  jmp_buf *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__18 {
  compiler_ast_scopes_Reference *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__19 {
  compiler_ast_nodes_MatchCondArg **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__20 {
  compiler_ast_nodes_EnumVariant **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__21 {
  compiler_ast_operators_Operator *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__22 {
  std_vector_Vector__5 **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__23 {
  compiler_ast_nodes_IfBranch *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__24 {
  compiler_ast_nodes_MatchCase *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__25 {
  std_span_Span *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__26 {
  std_value_Value **data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__27 {
  std_compact_map_Item__0 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__28 {
  std_compact_map_Item__1 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Vector__29 {
  u32 *data;
  u32 size;
  u32 capacity;
};

struct std_vector_Iterator__0 {
  std_vector_Vector__0 *vec;
  u32 index;
};

struct std_vector_Iterator__3 {
  std_vector_Vector__3 *vec;
  u32 index;
};

struct std_vector_Iterator__4 {
  std_vector_Vector__4 *vec;
  u32 index;
};

struct std_vector_Iterator__5 {
  std_vector_Vector__5 *vec;
  u32 index;
};

struct std_vector_Iterator__6 {
  std_vector_Vector__6 *vec;
  u32 index;
};

struct std_vector_Iterator__7 {
  std_vector_Vector__7 *vec;
  u32 index;
};

struct std_vector_Iterator__8 {
  std_vector_Vector__8 *vec;
  u32 index;
};

struct std_vector_Iterator__9 {
  std_vector_Vector__9 *vec;
  u32 index;
};

struct std_vector_Iterator__10 {
  std_vector_Vector__10 *vec;
  u32 index;
};

struct std_vector_Iterator__12 {
  std_vector_Vector__12 *vec;
  u32 index;
};

struct std_vector_Iterator__13 {
  std_vector_Vector__13 *vec;
  u32 index;
};

struct std_vector_Iterator__14 {
  std_vector_Vector__14 *vec;
  u32 index;
};

struct std_vector_Iterator__15 {
  std_vector_Vector__15 *vec;
  u32 index;
};

struct std_vector_Iterator__16 {
  std_vector_Vector__16 *vec;
  u32 index;
};

struct std_vector_Iterator__18 {
  std_vector_Vector__18 *vec;
  u32 index;
};

struct std_vector_Iterator__19 {
  std_vector_Vector__19 *vec;
  u32 index;
};

struct std_vector_Iterator__20 {
  std_vector_Vector__20 *vec;
  u32 index;
};

struct std_vector_Iterator__21 {
  std_vector_Vector__21 *vec;
  u32 index;
};

struct std_vector_Iterator__22 {
  std_vector_Vector__22 *vec;
  u32 index;
};

struct std_vector_Iterator__23 {
  std_vector_Vector__23 *vec;
  u32 index;
};

struct std_vector_Iterator__24 {
  std_vector_Vector__24 *vec;
  u32 index;
};

struct std_vector_Iterator__25 {
  std_vector_Vector__25 *vec;
  u32 index;
};

/* function declarations */
std_value_Value *compiler_docgen_DocGenerator_gen_enum(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_docgen_DocGenerator_gen_location(compiler_docgen_DocGenerator *this, std_value_Value *obj, std_span_Span span);
char *compiler_docgen_DocGenerator_gen_templated_type(compiler_docgen_DocGenerator *this, compiler_types_Type *base, std_vector_Vector__0 *args);
char *compiler_docgen_DocGenerator_gen_typename_str(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_typename(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_methods(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_function(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Function *func);
std_value_Value *compiler_docgen_DocGenerator_gen_struct(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Structure *struc);
std_value_Value *compiler_docgen_DocGenerator_gen_ns(compiler_docgen_DocGenerator *this, compiler_ast_program_Namespace *ns);
std_value_Value *compiler_docgen_DocGenerator_gen_builtin(compiler_docgen_DocGenerator *this, compiler_types_Type *type);
std_value_Value *compiler_docgen_DocGenerator_gen_builtins(compiler_docgen_DocGenerator *this, compiler_ast_program_Program *program);
void compiler_docgen_generate_doc_json(compiler_ast_program_Program *program, char *json_path);
void compiler_passes_run_typecheck_passes(compiler_ast_program_Program *program);
char *compiler_passes_run_codegen_passes(compiler_ast_program_Program *program);
void compiler_passes_register_types_RegisterTypes_register_struct(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *struc);
void compiler_passes_register_types_RegisterTypes_register_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *enum_);
void compiler_passes_register_types_RegisterTypes_register_globals(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_AST *node);
void compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_register_types_RegisterTypes_register_namespace(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns);
void compiler_passes_register_types_RegisterTypes_register_base_type(compiler_passes_register_types_RegisterTypes *this, compiler_types_BaseType base);
void compiler_passes_register_types_RegisterTypes_register_alias(compiler_passes_register_types_RegisterTypes *this, char *name, compiler_types_Type *orig);
void compiler_passes_register_types_RegisterTypes_register_print_function(compiler_passes_register_types_RegisterTypes *this, char *name);
void compiler_passes_register_types_RegisterTypes_register_builtin_types(compiler_passes_register_types_RegisterTypes *this);
compiler_passes_register_types_Finder compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder this, char *name);
void compiler_passes_register_types_RegisterTypes_register_cached_types(compiler_passes_register_types_RegisterTypes *this);
void compiler_passes_register_types_RegisterTypes_create_namespace_scopes(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_program_Namespace *parent);
void compiler_passes_register_types_RegisterTypes_run(compiler_ast_program_Program *program);
compiler_passes_mark_dead_code_MarkDeadCode *compiler_passes_mark_dead_code_MarkDeadCode_new(compiler_ast_program_Program *program);
void compiler_passes_mark_dead_code_MarkDeadCode_free(compiler_passes_mark_dead_code_MarkDeadCode *this);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Function *f);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_type(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_types_Type *typ);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Structure *s);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Enum *e);
void compiler_passes_mark_dead_code_MarkDeadCode_mark(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_AST *node);
compiler_ast_nodes_Function *compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_program_Program *program);
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_mark_dead_code_MarkDeadCode_run(compiler_ast_program_Program *program);
compiler_passes_generic_pass_GenericPass *compiler_passes_generic_pass_GenericPass_new(compiler_ast_program_Program *program);
void compiler_passes_generic_pass_GenericPass_push_scope(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Scope *scope);
void compiler_passes_generic_pass_GenericPass_push_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns);
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_pop_scope(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_pop_namespace(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_scope(compiler_passes_generic_pass_GenericPass *this);
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_ns(compiler_passes_generic_pass_GenericPass *this);
compiler_errors_Error *compiler_passes_generic_pass_GenericPass_error(compiler_passes_generic_pass_GenericPass *this, compiler_errors_Error *err);
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(compiler_passes_generic_pass_GenericPass *this, bool export, compiler_ast_scopes_Symbol *item, char *name);
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *item, char *name);
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, bool allow_templated);
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, std_span_Span span, bool error);
void compiler_passes_generic_pass_GenericPass_import_all_from_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns, bool export);
void compiler_passes_generic_pass_GenericPass_import_all_from_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, bool export);
compiler_errors_Error *compiler_passes_typechecker_TypeChecker_error(compiler_passes_typechecker_TypeChecker *this, compiler_errors_Error *err);
compiler_ast_scopes_Scope *compiler_passes_typechecker_TypeChecker_scope(compiler_passes_typechecker_TypeChecker *this);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_base_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_type_by_name(compiler_passes_typechecker_TypeChecker *this, char *name, std_span_Span span);
void compiler_passes_typechecker_TypeChecker_set_resolved_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_closure_type(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__3 *params, compiler_types_Type *return_type, compiler_types_Type *old);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_resolve_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old, bool allow_incomplete, bool error, bool resolve_templates);
void compiler_passes_typechecker_TypeChecker_try_infer_array_size(compiler_passes_typechecker_TypeChecker *this, compiler_types_ArrayType *arr_typ);
void compiler_passes_typechecker_TypeChecker_resolve_templated_struct_methods(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *old, compiler_ast_nodes_Structure *cur);
void compiler_passes_typechecker_TypeChecker_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc, compiler_ast_scopes_TemplateInstance *instance);
void compiler_passes_typechecker_TypeChecker_resolve_templated_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_scopes_TemplateInstance *instance);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_find_template_instance(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__4 *template_instances, std_vector_Vector__0 *args);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node);
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool error, compiler_types_Type *hint, bool resolve_templates);
void compiler_passes_typechecker_TypeChecker_check_block(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_method_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *method, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_union_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_enum_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_call_args_labelled(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params, u32 start);
void compiler_passes_typechecker_TypeChecker_check_call_args(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params, bool is_variadic);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_pointer_arith(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_operators_Operator op, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *arg1, compiler_ast_nodes_AST *arg2, compiler_ast_nodes_AST *arg3);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_binary_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_format_string(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_member(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_being_called, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_index(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint, bool is_being_assigned);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_assignment(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression_helper(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST **node_ptr);
void compiler_passes_typechecker_TypeChecker_check_match_for_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_match_for_bool(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
compiler_ast_nodes_Function *compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *expr, compiler_ast_nodes_MatchCond *cond);
void compiler_passes_typechecker_TypeChecker_check_match(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_if(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_expression_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body, bool is_expr, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_check_while(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_for(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_handle_imports(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool is_global);
void compiler_passes_typechecker_TypeChecker_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const);
void compiler_passes_typechecker_TypeChecker_check_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_resolve_doc_links(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_const_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint);
void compiler_passes_typechecker_TypeChecker_handle_import_path_base(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Import *imp, std_vector_Vector__5 *parts, compiler_ast_scopes_Symbol *base, bool search_in_ns_scope, char *alias);
void compiler_passes_typechecker_TypeChecker_handle_import_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node);
void compiler_passes_typechecker_TypeChecker_pre_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_typechecker_TypeChecker_resolve_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_typechecker_TypeChecker_resolve_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_typechecker_TypeChecker_check_operator_overload_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_operators_Operator op);
void compiler_passes_typechecker_TypeChecker_check_function_declaration(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func);
void compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool pre_import);
void compiler_passes_typechecker_TypeChecker_check_post_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_pre_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const);
void compiler_passes_typechecker_TypeChecker_check_pre_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns);
void compiler_passes_typechecker_TypeChecker_run(compiler_ast_program_Program *program);
void compiler_passes_code_generator_CodeGenerator_gen_indent(compiler_passes_code_generator_CodeGenerator *this);
void str_replace(char **this, char *other);
compiler_errors_Error *compiler_passes_code_generator_CodeGenerator_error(compiler_passes_code_generator_CodeGenerator *this, compiler_errors_Error *err);
compiler_ast_scopes_Scope *compiler_passes_code_generator_CodeGenerator_scope(compiler_passes_code_generator_CodeGenerator *this);
void compiler_passes_code_generator_CodeGenerator_gen_debug_info(compiler_passes_code_generator_CodeGenerator *this, std_span_Span span, bool force);
char *compiler_passes_code_generator_CodeGenerator_get_op(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
bool compiler_passes_code_generator_CodeGenerator_gen_internal_print(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after, bool is_stderr);
void compiler_passes_code_generator_CodeGenerator_gen_format_string_part(compiler_passes_code_generator_CodeGenerator *this, char *part);
void compiler_passes_code_generator_CodeGenerator_gen_string_literal(compiler_passes_code_generator_CodeGenerator *this, char *literal);
void compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after);
void compiler_passes_code_generator_CodeGenerator_gen_format_string(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_yield_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr);
void compiler_passes_code_generator_CodeGenerator_gen_constant(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_constants(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_global_variables(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_control_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body);
void compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_EnumVariant *variant, std_vector_Vector__7 *args);
void compiler_passes_code_generator_CodeGenerator_gen_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_create_new(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_call_args(compiler_passes_code_generator_CodeGenerator *this, std_vector_Vector__7 *args, bool is_variadic_format);
void compiler_passes_code_generator_CodeGenerator_gen_closure_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_top_level);
void compiler_passes_code_generator_CodeGenerator_gen_var_declaration(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match_case_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body);
void compiler_passes_code_generator_CodeGenerator_gen_custom_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match_enum(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match_bool(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_defers_upto(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Scope *end_scope);
void compiler_passes_code_generator_CodeGenerator_gen_statement(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node);
void compiler_passes_code_generator_CodeGenerator_gen_block(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool with_braces);
char *compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def, char *param_prefix, std_vector_Vector__3 *params);
char *compiler_passes_code_generator_CodeGenerator_helper_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def);
char *compiler_passes_code_generator_CodeGenerator_get_type_name_string(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name, bool is_func_def);
void compiler_passes_code_generator_CodeGenerator_gen_type_and_name(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name);
void compiler_passes_code_generator_CodeGenerator_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type);
void compiler_passes_code_generator_CodeGenerator_gen_function_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_functions(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func);
void compiler_passes_code_generator_CodeGenerator_gen_function_decls(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns);
void compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_closure_func(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos);
void compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_sym_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
void compiler_passes_code_generator_CodeGenerator_gen_struct_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc);
void compiler_passes_code_generator_CodeGenerator_gen_enum_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom);
char *compiler_passes_code_generator_CodeGenerator_generate(compiler_passes_code_generator_CodeGenerator *this);
compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator_make(compiler_ast_program_Program *program);
char *compiler_passes_code_generator_CodeGenerator_run(compiler_ast_program_Program *program);
char *compiler_passes_code_generator_cls_ctx_type(compiler_ast_nodes_Function *func);
compiler_passes_reorder_symbols_ReorderSymbols *compiler_passes_reorder_symbols_ReorderSymbols_new(compiler_ast_program_Program *program);
void compiler_passes_reorder_symbols_ReorderSymbols_free(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_program_Namespace *ns);
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_dfs(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym);
void compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(compiler_passes_reorder_symbols_ReorderSymbols *this);
void compiler_passes_reorder_symbols_ReorderSymbols_run(compiler_ast_program_Program *program);
compiler_parser_Parser compiler_parser_Parser_make(compiler_ast_program_Program *program, compiler_ast_program_Namespace *ns);
void compiler_parser_Parser_free(compiler_parser_Parser *this);
compiler_tokens_Token *compiler_parser_Parser_peek(compiler_parser_Parser *this, i32 off);
compiler_errors_Error *compiler_parser_Parser_error_msg(compiler_parser_Parser *this, char *msg);
compiler_errors_Error *compiler_parser_Parser_error(compiler_parser_Parser *this, compiler_errors_Error *err);
void compiler_parser_Parser_unhandled_type(compiler_parser_Parser *this, char *func);
compiler_tokens_Token *compiler_parser_Parser_token(compiler_parser_Parser *this);
bool compiler_parser_Parser_token_is(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_token_is_eof_or(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_token_is_identifier(compiler_parser_Parser *this, char *name);
bool compiler_parser_Parser_peek_token_is(compiler_parser_Parser *this, u32 off, compiler_tokens_TokenType type);
bool compiler_parser_Parser_consume_if(compiler_parser_Parser *this, compiler_tokens_TokenType type);
void compiler_parser_Parser_consume_newline_or(compiler_parser_Parser *this, compiler_tokens_TokenType type);
void compiler_parser_Parser_consume_tokens_until_newline(compiler_parser_Parser *this);
compiler_tokens_Token *compiler_parser_Parser_consume(compiler_parser_Parser *this, compiler_tokens_TokenType type);
bool compiler_parser_Parser_is_end_of_statement(compiler_parser_Parser *this);
void compiler_parser_Parser_consume_end_of_statement(compiler_parser_Parser *this);
void compiler_parser_Parser_clear_attributes(compiler_parser_Parser *this);
bool compiler_parser_Parser_is_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op);
std_span_Span compiler_parser_Parser_consume_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op);
compiler_types_Type *compiler_parser_Parser_parse_type(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_identifier(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_scoped_identifier(compiler_parser_Parser *this, bool consume_template);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_format_string(compiler_parser_Parser *this);
std_vector_Vector__10 *compiler_parser_Parser_parse_match_case_conds(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_match(compiler_parser_Parser *this);
void compiler_parser_Parser_sync_toplevel(compiler_parser_Parser *this);
compiler_types_Type *compiler_parser_Parser_parse_literal_suffix_type(compiler_parser_Parser *this, compiler_tokens_Token *suffix);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_call(compiler_parser_Parser *this, compiler_ast_nodes_AST *callee);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_initializer(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_declaration(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_global_value(compiler_parser_Parser *this, bool is_const);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_atom(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_postfix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_prefix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_cast(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_term(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_additive(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_shift(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_xor(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_relational(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_not(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_expression(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_multi_if(compiler_parser_Parser *this, compiler_tokens_Token *start_tok);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_if(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for_each(compiler_parser_Parser *this, std_span_Span start_span);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_statement(compiler_parser_Parser *this);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_block(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_template_params(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, std_span_Span *out_span);
void compiler_parser_Parser_add_doc_comment(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_tokens_Token *token);
void compiler_parser_Parser_parse_function_args(compiler_parser_Parser *this, compiler_ast_nodes_Function *func, compiler_tokens_TokenType end, bool need_types);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_function_body(compiler_parser_Parser *this, compiler_ast_nodes_Function *func);
compiler_ast_nodes_Function *compiler_parser_Parser_parse_closure(compiler_parser_Parser *this);
compiler_ast_nodes_Function *compiler_parser_Parser_parse_function(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_extern_into_symbol(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym);
void compiler_parser_Parser_get_extern_from_attr(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_attributes_Attribute *attr);
std_vector_Vector__5 *compiler_parser_Parser_parse_import_path(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
compiler_ast_nodes_AST *compiler_parser_Parser_parse_import(compiler_parser_Parser *this);
bool compiler_parser_Parser_parse_struct_field(compiler_parser_Parser *this, compiler_ast_nodes_Structure *struc);
compiler_ast_nodes_Structure *compiler_parser_Parser_parse_struct(compiler_parser_Parser *this);
compiler_ast_nodes_Enum *compiler_parser_Parser_parse_enum(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_attribute(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_attributes_if_any(compiler_parser_Parser *this);
void compiler_parser_Parser_parse_namespace_until(compiler_parser_Parser *this, compiler_tokens_TokenType end_type);
void compiler_parser_Parser_parse_compiler_option(compiler_parser_Parser *this);
void compiler_parser_Parser_try_load_mod_for_namespace(compiler_parser_Parser *this, compiler_ast_program_Namespace *ns);
compiler_ast_program_Namespace *compiler_parser_Parser_load_single_import_part(compiler_parser_Parser *this, compiler_ast_program_Namespace *base, char *name, std_span_Span span);
bool compiler_parser_Parser_load_import_path_from_base(compiler_parser_Parser *this, std_vector_Vector__5 *parts, compiler_ast_program_Namespace *base);
compiler_parser_LibraryInfo compiler_parser_Parser_find_external_library(compiler_parser_Parser *this, char *name);
compiler_ast_program_Namespace *compiler_parser_Parser_import_external_lib(compiler_parser_Parser *this, char *name);
bool compiler_parser_Parser_load_import_path(compiler_parser_Parser *this, compiler_ast_nodes_AST *import_stmt);
void compiler_parser_Parser_load_file(compiler_parser_Parser *this, char *filename, char *contents);
void compiler_parser_Parser_couldnt_find_stdlib(compiler_parser_Parser *this);
void compiler_parser_Parser_find_and_import_stdlib(compiler_parser_Parser *this);
void compiler_parser_Parser_include_prelude_only(compiler_parser_Parser *this);
void compiler_parser_Parser_create_namespaces_for_initial_file(compiler_parser_Parser *this, char *filename, bool single_file);
void compiler_parser_Parser_parse_toplevel(compiler_ast_program_Program *program, char *filename, char *file_contents, bool include_workspace_main);
bool compiler_utils_directory_exists(char *path);
compiler_lexer_Lexer compiler_lexer_Lexer_make(char *source, char *filename);
void compiler_lexer_Lexer_push(compiler_lexer_Lexer *this, compiler_tokens_Token *token);
void compiler_lexer_Lexer_push_type(compiler_lexer_Lexer *this, compiler_tokens_TokenType type, u32 len);
char compiler_lexer_Lexer_cur(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_inc(compiler_lexer_Lexer *this);
char compiler_lexer_Lexer_peek(compiler_lexer_Lexer *this, u32 offset);
void compiler_lexer_Lexer_lex_char_literal(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_string_literal(compiler_lexer_Lexer *this, bool has_seen_f);
void compiler_lexer_Lexer_lex_raw_string_literal(compiler_lexer_Lexer *this);
compiler_tokens_Token *compiler_lexer_Lexer_lex_int_literal_different_base(compiler_lexer_Lexer *this);
compiler_tokens_Token *compiler_lexer_Lexer_lex_numeric_literal_helper(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_numeric_literal(compiler_lexer_Lexer *this);
void compiler_lexer_Lexer_lex_comment(compiler_lexer_Lexer *this);
std_vector_Vector__11 *compiler_lexer_Lexer_lex(compiler_lexer_Lexer *this);
compiler_ast_program_Namespace *compiler_ast_program_Namespace_new(compiler_ast_program_Namespace *parent, char *path);
compiler_ast_scopes_Symbol *compiler_ast_program_Namespace_find_importable_symbol(compiler_ast_program_Namespace *this, char *name);
compiler_ast_program_Namespace *compiler_ast_program_Namespace_get_project_root(compiler_ast_program_Namespace *this, std_span_Span span, compiler_ast_program_Program *program_for_errors);
compiler_ast_program_Program *compiler_ast_program_Program_new(void);
jmp_buf *compiler_ast_program_Program_add_error_context(compiler_ast_program_Program *this);
jmp_buf *compiler_ast_program_Program_get_error_context(compiler_ast_program_Program *this);
void compiler_ast_program_Program_pop_error_context(compiler_ast_program_Program *this);
void compiler_ast_program_Program_setup_library_paths(compiler_ast_program_Program *this);
void compiler_ast_program_Program_exit_with_errors_if_any(compiler_ast_program_Program *this);
char *compiler_ast_program_Program_get_source_text(compiler_ast_program_Program *this, std_span_Span span);
compiler_errors_Error *compiler_ast_program_Program_error(compiler_ast_program_Program *this, compiler_errors_Error *err);
compiler_types_Type *compiler_ast_program_Program_find_closure_type(compiler_ast_program_Program *this, std_vector_Vector__3 *params, compiler_types_Type *ret);
compiler_ast_nodes_Function *compiler_ast_program_Program_get_function_deep_copy(compiler_ast_program_Program *this, compiler_ast_nodes_Function *old, compiler_ast_program_Namespace *ns);
compiler_ast_nodes_Structure *compiler_ast_program_Program_get_struct_deep_copy(compiler_ast_program_Program *this, compiler_ast_nodes_Structure *old, compiler_ast_program_Namespace *ns);
compiler_types_Type *compiler_ast_program_Program_get_base_type(compiler_ast_program_Program *this, compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_ast_program_Program_get_type_by_name(compiler_ast_program_Program *this, char *name, std_span_Span span);
compiler_ast_program_NSIterator compiler_ast_program_Program_iter_namespaces(compiler_ast_program_Program *this);
bool compiler_ast_program_NSIterator_has_value(compiler_ast_program_NSIterator *this);
void compiler_ast_program_NSIterator_next(compiler_ast_program_NSIterator *this);
compiler_ast_program_Namespace *compiler_ast_program_NSIterator_cur(compiler_ast_program_NSIterator *this);
compiler_ast_scopes_TemplateInstance *compiler_ast_scopes_TemplateInstance_new(std_vector_Vector__0 *args, compiler_ast_scopes_Symbol *parent, compiler_ast_scopes_Symbol *resolved);
bool compiler_ast_scopes_TemplateInstance_matches(compiler_ast_scopes_TemplateInstance *this, std_vector_Vector__0 *other);
compiler_ast_scopes_Template *compiler_ast_scopes_Template_new(std_vector_Vector__9 *params);
char *compiler_ast_scopes_Symbol_out_name(compiler_ast_scopes_Symbol *this);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, char *name, char *display, char *full_name, std_span_Span span);
char *compiler_ast_scopes_Symbol_join_display(char *a, char *b);
char *compiler_ast_scopes_Symbol_join_full_name(char *a, char *b);
bool compiler_ast_scopes_Symbol_is_templated(compiler_ast_scopes_Symbol *this);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, compiler_ast_scopes_Symbol *parent, char *name, std_span_Span span);
void compiler_ast_scopes_Symbol_update_parent(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_Symbol *parent);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_from_local_variable(char *name, compiler_ast_nodes_Variable *var, std_span_Span span);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_remove_alias(compiler_ast_scopes_Symbol *this);
void compiler_ast_scopes_Symbol_add_reference(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_ReferenceType type, std_span_Span span);
compiler_ast_scopes_Scope *compiler_ast_scopes_Scope_new(compiler_ast_scopes_Scope *parent);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_recursive(compiler_ast_scopes_Scope *this, char *name);
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_local(compiler_ast_scopes_Scope *this, char *name);
void compiler_ast_scopes_Scope_insert(compiler_ast_scopes_Scope *this, char *name, compiler_ast_scopes_Symbol *symbol);
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_operator_overload(char *s, std_vector_Vector__3 *params);
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_token(compiler_tokens_Token *tok);
u32 compiler_ast_operators_Operator_num_overload_params(compiler_ast_operators_Operator this);
bool compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(compiler_ast_operators_Operator this);
u32 compiler_ast_operators_OperatorOverload_hash(compiler_ast_operators_OperatorOverload this);
bool compiler_ast_operators_OperatorOverload_eq(compiler_ast_operators_OperatorOverload this, compiler_ast_operators_OperatorOverload other);
compiler_ast_nodes_Variable *compiler_ast_nodes_Variable_new(compiler_types_Type *type);
compiler_ast_nodes_Structure *compiler_ast_nodes_Structure_new(void);
compiler_ast_nodes_Variable *compiler_ast_nodes_Structure_get_field(compiler_ast_nodes_Structure *this, char *name);
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_Enum_get_variant(compiler_ast_nodes_Enum *this, char *name);
compiler_ast_nodes_Variable *compiler_ast_nodes_Enum_get_shared_field(compiler_ast_nodes_Enum *this, char *name);
compiler_ast_nodes_Enum *compiler_ast_nodes_Enum_new(std_span_Span span);
u32 compiler_ast_nodes_EnumVariant_num_fields(compiler_ast_nodes_EnumVariant *this);
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_field_by_idx(compiler_ast_nodes_EnumVariant *this, u32 idx);
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_specific_field(compiler_ast_nodes_EnumVariant *this, char *name);
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_EnumVariant_new(std_span_Span span);
compiler_ast_nodes_Function *compiler_ast_nodes_Function_new(void);
bool compiler_ast_nodes_Function_is_template_instance(compiler_ast_nodes_Function *this);
compiler_ast_nodes_Argument *compiler_ast_nodes_Argument_new(compiler_ast_nodes_AST *expr, compiler_tokens_Token *label_token);
compiler_ast_nodes_ImportPart *compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType type, std_span_Span span);
compiler_ast_nodes_MatchCond *compiler_ast_nodes_MatchCond_new(compiler_ast_nodes_AST *cond, std_vector_Vector__19 *args, compiler_ast_nodes_Function *cmp_fn);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType type, std_span_Span span);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator op, std_span_Span span, compiler_ast_nodes_AST *expr);
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator op, compiler_ast_nodes_AST *lhs, compiler_ast_nodes_AST *rhs, std_span_Span op_span);
std_span_Span compiler_ast_nodes_AST_display_span(compiler_ast_nodes_AST *this);
compiler_ast_scopes_Symbol *compiler_ast_nodes_AST_symbol(compiler_ast_nodes_AST *this);
bool compiler_ast_nodes_AST_is_lvalue(compiler_ast_nodes_AST *this);
compiler_attributes_AttributeType compiler_attributes_AttributeType_from_str(char *s);
compiler_attributes_Attribute *compiler_attributes_Attribute_new(compiler_attributes_AttributeType type, std_span_Span span);
bool compiler_attributes_Attribute_validate(compiler_attributes_Attribute *this, compiler_parser_Parser *parser_for_errors);
void compiler_lsp_typecheck_and_log_errors(compiler_ast_program_Program *program, char *path);
void compiler_lsp_handle_validate(compiler_ast_program_Program *program, char *path);
void compiler_lsp_handle_location_command(compiler_ast_program_Program *program, compiler_lsp_CommandType type, std_span_Location loc);
void compiler_lsp_handle_document_symbols(compiler_ast_program_Program *program, char *path);
char *compiler_lsp_shift_args(i32 *argc, char ***argv);
void compiler_lsp_lsp_usage(i32 code, bool full);
void compiler_lsp_lsp_main(i32 argc, char **argv);
char *compiler_lsp_utils_gen_func_param_string(u32 i, compiler_ast_nodes_Variable *param, bool is_non_static_method);
char *compiler_lsp_utils_gen_template_params(std_vector_Vector__0 *args);
char *compiler_lsp_utils_gen_type_string(compiler_types_Type *type, bool full);
char *compiler_lsp_utils_try_gen_expr_string(compiler_ast_nodes_AST *expr);
char *compiler_lsp_utils_gen_hover_string(compiler_ast_scopes_Symbol *sym);
compiler_types_Type *compiler_lsp_utils_get_symbol_typedef(compiler_ast_scopes_Symbol *sym);
std_value_Value *compiler_lsp_utils_gen_error_json(compiler_errors_Error *err);
std_value_Value *compiler_lsp_utils_gen_span_json(std_span_Span span);
std_value_Value *compiler_lsp_utils_gen_span_json_with_filename(std_span_Span span, std_span_Location search_loc);
std_value_Value *compiler_lsp_utils_gen_hover_string_with_docs(compiler_ast_scopes_Symbol *sym);
void compiler_lsp_utils_gen_type_methods_into(std_value_Value *obj, compiler_types_Type *type);
std_value_Value *compiler_lsp_utils_gen_struct_json(compiler_ast_nodes_Structure *struc);
std_value_Value *compiler_lsp_utils_gen_variable_json(compiler_ast_nodes_Variable *var);
std_value_Value *compiler_lsp_utils_gen_function_json(compiler_ast_nodes_Function *func);
std_value_Value *compiler_lsp_utils_gen_namespace_json(compiler_ast_program_Namespace *ns);
void compiler_lsp_utils_insert_completion_item(std_value_Value *completions, compiler_ast_scopes_Symbol *sym, std_set_Set__2 *seen);
std_vector_Vector__25 *compiler_lsp_utils_get_unique_reference_spans(compiler_ast_scopes_Symbol *sym, bool for_rename);
std_value_Value *compiler_lsp_utils_gen_references_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc);
std_value_Value *compiler_lsp_utils_gen_signature_help(compiler_ast_nodes_AST *node, u32 active_param);
std_value_Value *compiler_lsp_utils_gen_renames_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc);
void compiler_lsp_utils_gen_completions_from_scope(compiler_ast_scopes_Scope *scope, std_value_Value *completions, compiler_types_Type *hint_type, std_set_Set__2 *seen);
void compiler_lsp_utils_gen_completion_items_from_ns(std_value_Value *completions, compiler_ast_program_Namespace *ns, std_set_Set__2 *seen);
void compiler_lsp_utils_gen_completions_from_symbol(compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node, std_value_Value *completions, std_set_Set__2 *seen);
std_value_Value *compiler_lsp_utils_gen_completions_json(compiler_lsp_finder_Finder *finder);
compiler_lsp_finder_Finder compiler_lsp_finder_Finder_make(compiler_lsp_CommandType cmd, std_span_Location loc);
bool compiler_lsp_finder_Finder_find_in_identifier(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_var(compiler_lsp_finder_Finder *this, compiler_ast_nodes_Variable *var, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_set_usage(compiler_lsp_finder_Finder *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_literal(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_signature_help(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__7 *args, u32 param_idx);
bool compiler_lsp_finder_Finder_find_in_call_args(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__7 *args);
bool compiler_lsp_finder_Finder_find_in_expression(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_import_part(compiler_lsp_finder_Finder *this, compiler_ast_scopes_Symbol *base, compiler_ast_nodes_ImportPart *part, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_statement(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_block(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node);
bool compiler_lsp_finder_Finder_find_in_type(compiler_lsp_finder_Finder *this, compiler_types_Type *type);
bool compiler_lsp_finder_Finder_find_in_function(compiler_lsp_finder_Finder *this, compiler_ast_nodes_Function *func);
bool compiler_lsp_finder_Finder_find_in_program(compiler_lsp_finder_Finder *this, compiler_ast_program_Namespace *ns);
bool compiler_lsp_finder_Finder_find(compiler_lsp_finder_Finder *this, compiler_ast_program_Program *program);
compiler_tokens_Token *compiler_tokens_Token_new(compiler_tokens_TokenType type, std_span_Span span, char *text);
compiler_tokens_Token *compiler_tokens_Token_from_type(compiler_tokens_TokenType type, std_span_Span span);
compiler_tokens_Token *compiler_tokens_Token_from_ident(char *text, std_span_Span span);
bool compiler_tokens_Token_is_word(compiler_tokens_Token this);
bool compiler_tokens_Token_is_identifier(compiler_tokens_Token this, char *name);
compiler_tokens_TokenType compiler_tokens_TokenType_from_text(char *text);
char *compiler_tokens_TokenType_str(compiler_tokens_TokenType this);
void usage(i32 code, bool full);
void save_and_compile_code(compiler_ast_program_Program *program, char *code);
void run_executable(i32 argc, char **argv);
void parse_args(i32 *argc, char ***argv, compiler_ast_program_Program *program);
i32 main(i32 argc, char **argv);
char *compiler_types_BaseType_str(compiler_types_BaseType this);
bool compiler_types_BaseType_is_callable(compiler_types_BaseType this);
compiler_types_Type *compiler_types_Type_shallow_copy(compiler_types_Type *old);
compiler_types_Type *compiler_types_Type_new_resolved(compiler_types_BaseType base, std_span_Span span);
compiler_types_Type *compiler_types_Type_new_unresolved(char *name, std_span_Span span);
compiler_types_Type *compiler_types_Type_new_unresolved_base(compiler_types_BaseType base, std_span_Span span);
bool compiler_types_Type_is_integer(compiler_types_Type *this);
bool compiler_types_Type_is_float(compiler_types_Type *this);
bool compiler_types_Type_is_numeric(compiler_types_Type *this);
bool compiler_types_Type_is_numeric_or_char(compiler_types_Type *this);
bool compiler_types_Type_can_have_methods(compiler_types_Type *this);
bool compiler_types_Type_is_resolved(compiler_types_Type *this);
bool compiler_types_Type_eq(compiler_types_Type *this, compiler_types_Type *other, bool strict);
bool compiler_types_Type_is_str(compiler_types_Type *this);
compiler_types_Type *compiler_types_Type_unaliased(compiler_types_Type *this);
compiler_types_Type *compiler_types_Type_decay_array(compiler_types_Type *this);
char *compiler_types_Type_str(compiler_types_Type *this);
char *compiler_errors_MessageType_to_color(compiler_errors_MessageType this);
char *compiler_errors_MessageType_str(compiler_errors_MessageType this);
void compiler_errors_display_line(void);
void compiler_errors_display_message(compiler_errors_MessageType type, std_span_Span span, char *msg);
void compiler_errors_display_message_span(compiler_errors_MessageType type, std_span_Span span, char *msg, bool line_after);
void compiler_errors_Error_display(compiler_errors_Error *this);
void compiler_errors_Error_panic(compiler_errors_Error *this) __attribute__((noreturn));
compiler_errors_Error *compiler_errors_Error_new(std_span_Span span, char *msg);
compiler_errors_Error *compiler_errors_Error_new_note(std_span_Span span, char *msg, char *note);
compiler_errors_Error *compiler_errors_Error_new_hint(std_span_Span span, char *msg, std_span_Span span2, char *hint);
void compiler_errors_display_error_messages(std_vector_Vector__13 *errors, u32 detail_level);
void std_panic(char *msg) __attribute__((noreturn));
u32 str_to_u32(char *this);
bool str_eq(char *this, char *other);
char *std_format(char *fmt, ...);
char *str_substring(char *this, u32 start, u32 len);
bool str_ends_with(char *this, char *suffix);
bool str_starts_with(char *this, char *prefix);
void str_strip_trailing_whitespace(char *this);
void str_replace_with(char **this, char *other);
void str_free(char **this);
std_CharIterator str_chars(char *this, u32 start);
bool std_CharIterator_has_value(std_CharIterator *this);
u32 std_CharIterator_next(std_CharIterator *this);
char std_CharIterator_cur(std_CharIterator *this);
bool char_is_digit(char this);
bool char_is_hex_digit(char this);
bool char_is_alpha(char this);
bool char_is_alnum(char this);
bool char_is_print(char this);
u32 u32_min(u32 this, u32 other);
u32 u32_max(u32 this, u32 other);
char *std_shift_args(i32 *argc, char ***argv, char *where);
bool std_sv_SV_is_empty(std_sv_SV *this);
std_sv_SV std_sv_SV_from_str(char *s);
std_sv_SV std_sv_SV_get(std_sv_SV this, u32 n);
char std_sv_SV_at(std_sv_SV this, u32 n);
std_sv_SV std_sv_SV_chop_by_delim(std_sv_SV *this, char delim);
std_sv_SV std_sv_SV_chop_by_sv(std_sv_SV *this, std_sv_SV delim);
std_sv_SV std_sv_SV_chop_line(std_sv_SV *this);
std_sv_SV std_sv_SV_slice(std_sv_SV this, u32 off, u32 end);
std_sv_SVLineIterator std_sv_SV_lines(std_sv_SV this);
std_sv_SVSplitIterator std_sv_SV_split_str(std_sv_SV this, char *delim);
char *std_sv_SV_copy_data_to_cstr(std_sv_SV this);
bool std_sv_SVLineIterator_has_value(std_sv_SVLineIterator *this);
std_sv_SV std_sv_SVLineIterator_cur(std_sv_SVLineIterator *this);
void std_sv_SVLineIterator_next(std_sv_SVLineIterator *this);
bool std_sv_SVSplitIterator_has_value(std_sv_SVSplitIterator *this);
std_sv_SV std_sv_SVSplitIterator_cur(std_sv_SVSplitIterator *this);
void std_sv_SVSplitIterator_next(std_sv_SVSplitIterator *this);
compiler_passes_mark_dead_code_MarkDeadCode *std_mem_alloc__0(u32 count);
compiler_passes_generic_pass_GenericPass *std_mem_alloc__1(u32 count);
compiler_passes_reorder_symbols_ReorderSymbols *std_mem_alloc__2(u32 count);
compiler_ast_program_Namespace *std_mem_alloc__3(u32 count);
compiler_ast_program_Program *std_mem_alloc__4(u32 count);
compiler_ast_scopes_TemplateInstance *std_mem_alloc__5(u32 count);
compiler_ast_scopes_Template *std_mem_alloc__6(u32 count);
compiler_ast_scopes_Symbol *std_mem_alloc__7(u32 count);
compiler_ast_scopes_Scope *std_mem_alloc__8(u32 count);
compiler_ast_nodes_Variable *std_mem_alloc__9(u32 count);
compiler_ast_nodes_Structure *std_mem_alloc__10(u32 count);
compiler_ast_nodes_Enum *std_mem_alloc__11(u32 count);
compiler_ast_nodes_EnumVariant *std_mem_alloc__12(u32 count);
compiler_ast_nodes_Function *std_mem_alloc__13(u32 count);
compiler_ast_nodes_Argument *std_mem_alloc__14(u32 count);
compiler_ast_nodes_ImportPart *std_mem_alloc__15(u32 count);
compiler_ast_nodes_MatchCond *std_mem_alloc__16(u32 count);
compiler_ast_nodes_AST *std_mem_alloc__17(u32 count);
compiler_attributes_Attribute *std_mem_alloc__18(u32 count);
compiler_tokens_Token *std_mem_alloc__19(u32 count);
compiler_types_Type *std_mem_alloc__20(u32 count);
compiler_errors_Error *std_mem_alloc__21(u32 count);
char *std_mem_alloc__22(u32 count);
i32 *std_mem_alloc__23(u32 count);
std_compact_map_Map__0 *std_mem_alloc__24(u32 count);
std_compact_map_Map__1 *std_mem_alloc__25(u32 count);
u8 *std_mem_alloc__26(u32 count);
std_set_Set__0 *std_mem_alloc__27(u32 count);
std_set_Set__1 *std_mem_alloc__28(u32 count);
std_set_Set__2 *std_mem_alloc__29(u32 count);
std_set_Set__3 *std_mem_alloc__30(u32 count);
std_value_Value *std_mem_alloc__31(u32 count);
std_map_Item__0 *std_mem_alloc__32(u32 count);
std_map_Item__0 **std_mem_alloc__33(u32 count);
std_map_Map__0 *std_mem_alloc__34(u32 count);
std_map_Item__1 *std_mem_alloc__35(u32 count);
std_map_Item__1 **std_mem_alloc__36(u32 count);
std_map_Map__1 *std_mem_alloc__37(u32 count);
std_map_Item__2 *std_mem_alloc__38(u32 count);
std_map_Item__2 **std_mem_alloc__39(u32 count);
std_map_Map__2 *std_mem_alloc__40(u32 count);
std_map_Item__3 *std_mem_alloc__41(u32 count);
std_map_Item__3 **std_mem_alloc__42(u32 count);
std_map_Map__3 *std_mem_alloc__43(u32 count);
std_map_Item__4 *std_mem_alloc__44(u32 count);
std_map_Item__4 **std_mem_alloc__45(u32 count);
std_map_Map__4 *std_mem_alloc__46(u32 count);
std_map_Item__5 *std_mem_alloc__47(u32 count);
std_map_Item__5 **std_mem_alloc__48(u32 count);
std_map_Map__5 *std_mem_alloc__49(u32 count);
std_map_Item__6 *std_mem_alloc__50(u32 count);
std_map_Item__6 **std_mem_alloc__51(u32 count);
std_map_Map__6 *std_mem_alloc__52(u32 count);
std_map_Item__7 *std_mem_alloc__53(u32 count);
std_map_Item__7 **std_mem_alloc__54(u32 count);
std_map_Map__7 *std_mem_alloc__55(u32 count);
std_map_Item__8 *std_mem_alloc__56(u32 count);
std_map_Item__8 **std_mem_alloc__57(u32 count);
std_map_Map__8 *std_mem_alloc__58(u32 count);
std_map_Item__9 *std_mem_alloc__59(u32 count);
std_map_Item__9 **std_mem_alloc__60(u32 count);
std_map_Map__9 *std_mem_alloc__61(u32 count);
std_map_Item__10 *std_mem_alloc__62(u32 count);
std_map_Item__10 **std_mem_alloc__63(u32 count);
std_map_Map__10 *std_mem_alloc__64(u32 count);
std_map_Item__11 *std_mem_alloc__65(u32 count);
std_map_Item__11 **std_mem_alloc__66(u32 count);
std_map_Map__11 *std_mem_alloc__67(u32 count);
std_map_Item__12 *std_mem_alloc__68(u32 count);
std_map_Item__12 **std_mem_alloc__69(u32 count);
std_map_Map__12 *std_mem_alloc__70(u32 count);
std_map_Item__13 *std_mem_alloc__71(u32 count);
std_map_Item__13 **std_mem_alloc__72(u32 count);
std_map_Map__13 *std_mem_alloc__73(u32 count);
std_vector_Vector__0 *std_mem_alloc__74(u32 count);
compiler_types_Type **std_mem_alloc__75(u32 count);
std_vector_Vector__1 *std_mem_alloc__76(u32 count);
compiler_ast_scopes_Scope **std_mem_alloc__77(u32 count);
std_vector_Vector__2 *std_mem_alloc__78(u32 count);
compiler_ast_program_Namespace **std_mem_alloc__79(u32 count);
std_vector_Vector__3 *std_mem_alloc__80(u32 count);
compiler_ast_nodes_Variable **std_mem_alloc__81(u32 count);
std_vector_Vector__4 *std_mem_alloc__82(u32 count);
compiler_ast_scopes_TemplateInstance **std_mem_alloc__83(u32 count);
std_vector_Vector__5 *std_mem_alloc__84(u32 count);
compiler_ast_nodes_ImportPart **std_mem_alloc__85(u32 count);
std_vector_Vector__6 *std_mem_alloc__86(u32 count);
compiler_ast_nodes_Function **std_mem_alloc__87(u32 count);
std_vector_Vector__7 *std_mem_alloc__88(u32 count);
compiler_ast_nodes_Argument **std_mem_alloc__89(u32 count);
std_vector_Vector__8 *std_mem_alloc__90(u32 count);
char **std_mem_alloc__91(u32 count);
std_vector_Vector__9 *std_mem_alloc__92(u32 count);
compiler_ast_scopes_Symbol **std_mem_alloc__93(u32 count);
std_vector_Vector__10 *std_mem_alloc__94(u32 count);
compiler_ast_nodes_MatchCond **std_mem_alloc__95(u32 count);
std_vector_Vector__11 *std_mem_alloc__96(u32 count);
compiler_tokens_Token **std_mem_alloc__97(u32 count);
std_vector_Vector__12 *std_mem_alloc__98(u32 count);
compiler_attributes_Attribute **std_mem_alloc__99(u32 count);
std_vector_Vector__13 *std_mem_alloc__100(u32 count);
compiler_errors_Error **std_mem_alloc__101(u32 count);
std_vector_Vector__14 *std_mem_alloc__102(u32 count);
compiler_ast_nodes_Structure **std_mem_alloc__103(u32 count);
std_vector_Vector__15 *std_mem_alloc__104(u32 count);
compiler_ast_nodes_Enum **std_mem_alloc__105(u32 count);
std_vector_Vector__16 *std_mem_alloc__106(u32 count);
compiler_ast_nodes_AST **std_mem_alloc__107(u32 count);
std_vector_Vector__17 *std_mem_alloc__108(u32 count);
jmp_buf *std_mem_alloc__109(u32 count);
std_vector_Vector__18 *std_mem_alloc__110(u32 count);
compiler_ast_scopes_Reference *std_mem_alloc__111(u32 count);
std_vector_Vector__19 *std_mem_alloc__112(u32 count);
compiler_ast_nodes_MatchCondArg **std_mem_alloc__113(u32 count);
std_vector_Vector__20 *std_mem_alloc__114(u32 count);
compiler_ast_nodes_EnumVariant **std_mem_alloc__115(u32 count);
std_vector_Vector__21 *std_mem_alloc__116(u32 count);
compiler_ast_operators_Operator *std_mem_alloc__117(u32 count);
std_vector_Vector__22 *std_mem_alloc__118(u32 count);
std_vector_Vector__5 **std_mem_alloc__119(u32 count);
std_vector_Vector__23 *std_mem_alloc__120(u32 count);
compiler_ast_nodes_IfBranch *std_mem_alloc__121(u32 count);
std_vector_Vector__24 *std_mem_alloc__122(u32 count);
compiler_ast_nodes_MatchCase *std_mem_alloc__123(u32 count);
std_vector_Vector__25 *std_mem_alloc__124(u32 count);
std_span_Span *std_mem_alloc__125(u32 count);
std_vector_Vector__26 *std_mem_alloc__126(u32 count);
std_value_Value **std_mem_alloc__127(u32 count);
std_vector_Vector__27 *std_mem_alloc__128(u32 count);
std_compact_map_Item__0 *std_mem_alloc__129(u32 count);
std_vector_Vector__28 *std_mem_alloc__130(u32 count);
std_compact_map_Item__1 *std_mem_alloc__131(u32 count);
std_vector_Vector__29 *std_mem_alloc__132(u32 count);
u32 *std_mem_alloc__133(u32 count);
void std_mem_free(void *ptr);
u8 *std_mem_realloc__0(u8 *ptr, u32 old_count, u32 new_count);
compiler_types_Type **std_mem_realloc__1(compiler_types_Type **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Scope **std_mem_realloc__2(compiler_ast_scopes_Scope **ptr, u32 old_count, u32 new_count);
compiler_ast_program_Namespace **std_mem_realloc__3(compiler_ast_program_Namespace **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Variable **std_mem_realloc__4(compiler_ast_nodes_Variable **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_TemplateInstance **std_mem_realloc__5(compiler_ast_scopes_TemplateInstance **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_ImportPart **std_mem_realloc__6(compiler_ast_nodes_ImportPart **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Function **std_mem_realloc__7(compiler_ast_nodes_Function **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Argument **std_mem_realloc__8(compiler_ast_nodes_Argument **ptr, u32 old_count, u32 new_count);
char **std_mem_realloc__9(char **ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Symbol **std_mem_realloc__10(compiler_ast_scopes_Symbol **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCond **std_mem_realloc__11(compiler_ast_nodes_MatchCond **ptr, u32 old_count, u32 new_count);
compiler_tokens_Token **std_mem_realloc__12(compiler_tokens_Token **ptr, u32 old_count, u32 new_count);
compiler_attributes_Attribute **std_mem_realloc__13(compiler_attributes_Attribute **ptr, u32 old_count, u32 new_count);
compiler_errors_Error **std_mem_realloc__14(compiler_errors_Error **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Structure **std_mem_realloc__15(compiler_ast_nodes_Structure **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_Enum **std_mem_realloc__16(compiler_ast_nodes_Enum **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_AST **std_mem_realloc__17(compiler_ast_nodes_AST **ptr, u32 old_count, u32 new_count);
jmp_buf *std_mem_realloc__18(jmp_buf *ptr, u32 old_count, u32 new_count);
compiler_ast_scopes_Reference *std_mem_realloc__19(compiler_ast_scopes_Reference *ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCondArg **std_mem_realloc__20(compiler_ast_nodes_MatchCondArg **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_EnumVariant **std_mem_realloc__21(compiler_ast_nodes_EnumVariant **ptr, u32 old_count, u32 new_count);
compiler_ast_operators_Operator *std_mem_realloc__22(compiler_ast_operators_Operator *ptr, u32 old_count, u32 new_count);
std_vector_Vector__5 **std_mem_realloc__23(std_vector_Vector__5 **ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_IfBranch *std_mem_realloc__24(compiler_ast_nodes_IfBranch *ptr, u32 old_count, u32 new_count);
compiler_ast_nodes_MatchCase *std_mem_realloc__25(compiler_ast_nodes_MatchCase *ptr, u32 old_count, u32 new_count);
std_span_Span *std_mem_realloc__26(std_span_Span *ptr, u32 old_count, u32 new_count);
std_value_Value **std_mem_realloc__27(std_value_Value **ptr, u32 old_count, u32 new_count);
std_compact_map_Item__0 *std_mem_realloc__28(std_compact_map_Item__0 *ptr, u32 old_count, u32 new_count);
std_compact_map_Item__1 *std_mem_realloc__29(std_compact_map_Item__1 *ptr, u32 old_count, u32 new_count);
u32 *std_mem_realloc__30(u32 *ptr, u32 old_count, u32 new_count);
void *std_mem_impl_my_calloc(void *state, u32 size);
void *std_mem_impl_my_realloc(void *state, void *ptr, u32 old_size, u32 size);
void std_mem_impl_my_free(void *state, void *ptr);
char *std_libc_errno_get_err(void);
bool std_compact_map_Map__0_contains(std_compact_map_Map__0 *this, char *key);
std_compact_map_Iterator__0 std_compact_map_Map__0_iter(std_compact_map_Map__0 *this);
std_compact_map_Item__0 std_compact_map_Iterator__0_cur(std_compact_map_Iterator__0 *this);
void std_compact_map_Iterator__0_next(std_compact_map_Iterator__0 *this);
bool std_compact_map_Iterator__0_has_value(std_compact_map_Iterator__0 *this);
void std_compact_map_Map__0_insert(std_compact_map_Map__0 *this, char *key, std_value_Value *value);
u32 std_compact_map_Map__0_get_index(std_compact_map_Map__0 *this, char *key, u32 hash);
std_value_Value *std_compact_map_Map__0_get(std_compact_map_Map__0 *this, char *key, std_value_Value *defolt);
bool std_compact_map_Map__0_is_empty(std_compact_map_Map__0 *this);
void std_compact_map_Map__0_resize(std_compact_map_Map__0 *this, u32 new_capacity);
std_compact_map_Item__0 *std_compact_map_Map__0_get_item(std_compact_map_Map__0 *this, char *key);
std_compact_map_Map__0 *std_compact_map_Map__0_new(u32 capacity);
void std_compact_map_Map__0_resize_if_necessary(std_compact_map_Map__0 *this);
void std_compact_map_Map__1_insert(std_compact_map_Map__1 *this, char *key, std_span_Span value);
u32 std_compact_map_Map__1_get_index(std_compact_map_Map__1 *this, char *key, u32 hash);
void std_compact_map_Map__1_resize(std_compact_map_Map__1 *this, u32 new_capacity);
std_compact_map_Item__1 *std_compact_map_Map__1_get_item(std_compact_map_Map__1 *this, char *key);
std_compact_map_Map__1 *std_compact_map_Map__1_new(u32 capacity);
void std_compact_map_Map__1_resize_if_necessary(std_compact_map_Map__1 *this);
std_buffer_Buffer std_buffer_Buffer_make(u32 capacity);
std_buffer_Buffer std_buffer_Buffer_from_str(char *s);
void std_buffer_Buffer_resize_if_necessary(std_buffer_Buffer *this, u32 new_size);
void std_buffer_Buffer_write_str(std_buffer_Buffer *this, char *s);
void std_buffer_Buffer_write_str_f(std_buffer_Buffer *this, char *s);
void std_buffer_Buffer_write_char(std_buffer_Buffer *this, char c);
void std_buffer_Buffer_write_u8(std_buffer_Buffer *this, u8 value);
char *std_buffer_Buffer_new_str(std_buffer_Buffer this);
char *std_buffer_Buffer_str(std_buffer_Buffer this);
std_sv_SV std_buffer_Buffer_sv(std_buffer_Buffer this);
void std_buffer_Buffer_clear(std_buffer_Buffer *this);
void std_buffer_Buffer_free(std_buffer_Buffer *this);
void std_logging_init_logging(std_logging_LogLevel level, char *time_format);
void std_logging_vlog(std_logging_LogLevel level, char *fmt, va_list vargs);
void std_logging_log(std_logging_LogLevel level, char *fmt, ...);
void std_set_Set__0_free(std_set_Set__0 *this);
void std_set_Set__0_add(std_set_Set__0 *this, u64 key);
bool std_set_Set__0_contains(std_set_Set__0 *this, u64 key);
std_set_Set__0 *std_set_Set__0_new(void);
void std_set_Set__1_free(std_set_Set__1 *this);
void std_set_Set__1_add(std_set_Set__1 *this, void *key);
bool std_set_Set__1_contains(std_set_Set__1 *this, void *key);
std_set_Set__1 *std_set_Set__1_new(void);
void std_set_Set__2_free(std_set_Set__2 *this);
void std_set_Set__2_add(std_set_Set__2 *this, char *key);
bool std_set_Set__2_contains(std_set_Set__2 *this, char *key);
std_set_Set__2 *std_set_Set__2_new(void);
void std_set_Set__3_free(std_set_Set__3 *this);
void std_set_Set__3_add(std_set_Set__3 *this, std_span_Span key);
std_set_Set__3 *std_set_Set__3_new(void);
std_set_Iterator__3 std_set_Set__3_iter(std_set_Set__3 *this);
std_span_Span std_set_Iterator__3_cur(std_set_Iterator__3 *this);
void std_set_Iterator__3_next(std_set_Iterator__3 *this);
bool std_set_Iterator__3_has_value(std_set_Iterator__3 *this);
std_set_Iterator__3 std_set_Iterator__3_make(std_set_Set__3 *set);
std_span_Location std_span_Location_default(void);
u32 std_span_Location_hash(std_span_Location this);
bool std_span_Location_eq(std_span_Location this, std_span_Location other);
char *std_span_Location_str(std_span_Location *this);
bool std_span_Location_is_valid(std_span_Location *this);
bool std_span_Location_is_before(std_span_Location *this, std_span_Location other);
std_span_Span std_span_Span_default(void);
u32 std_span_Span_hash(std_span_Span this);
bool std_span_Span_eq(std_span_Span this, std_span_Span other);
bool std_span_Span_is_valid(std_span_Span this);
std_span_Span std_span_Span_join(std_span_Span this, std_span_Span other);
bool std_span_Span_contains_loc(std_span_Span this, std_span_Location loc);
bool std_span_Span_starts_right_after(std_span_Span this, std_span_Span other);
bool u64_eq(u64 this, u64 other);
bool untyped_ptr_eq(void *this, void *other);
u32 std_traits_hash_hash_bytes(u8 *data, u32 len);
u32 std_traits_hash_pair_hash(u32 a, u32 b);
u32 std_traits_hash_ptr_hash(void *ptr);
u32 untyped_ptr_hash(void *this);
u32 str_hash(char *this);
u32 u32_hash(u32 this);
u32 u64_hash(u64 this);
std_value_Value *std_value_Value_new(std_value_ValueType type);
std_value_Value *std_value_Value_new_str(char *s);
std_value_Value *std_value_Value_new_bool(bool bul);
std_value_Value *std_value_Value_new_int(i64 num);
void std_value_Value_ensure(std_value_Value *this, std_value_ValueType type);
std_value_Value *std_value_Value_at_key(std_value_Value *this, char *key);
void std_value_Value_push(std_value_Value *this, std_value_Value *value);
std_value_Value *std_value_Value_get(std_value_Value *this, char *key, std_value_Value *defolt);
void std_value_Value_insert(std_value_Value *this, char *key, std_value_Value *value);
void std_value_Value_insert_str(std_value_Value *this, char *key, char *s);
void std_value_Value_insert_u32(std_value_Value *this, char *key, u32 i);
std_compact_map_Map__0 *std_value_Value_as_dict(std_value_Value *this);
char *std_value_Value_dbg(std_value_Value *this);
char *std_fs_realpath(char *path);
bool std_fs_file_exists(char *path);
void std_fs_write_file_bytes(char *path, void *data, u32 size);
void std_fs_write_file_str(char *path, char *data);
void std_fs_write_file(char *path, std_buffer_Buffer data);
std_buffer_Buffer std_fs_read_file(char *path);
bool std_fs_directory_exists(char *path);
std_fs_DirectoryIterator std_fs_iterate_directory(char *path, bool skip_self_and_parent);
bool std_fs_DirectoryIterator_has_value(std_fs_DirectoryIterator *this);
void std_fs_DirectoryIterator_next(std_fs_DirectoryIterator *this);
std_fs_DirectoryEntry std_fs_DirectoryIterator_cur(std_fs_DirectoryIterator *this);
std_map_Item__0 *std_map_Item__0_new(u64 key, bool value, std_map_Item__0 *next);
void std_map_Item__0_free_list(std_map_Item__0 *this);
void std_map_Map__0_free(std_map_Map__0 *this);
void std_map_Map__0_insert(std_map_Map__0 *this, u64 key, bool value);
bool std_map_Map__0_contains(std_map_Map__0 *this, u64 key);
void std_map_Map__0_resize(std_map_Map__0 *this);
u32 std_map_Map__0_hash(std_map_Map__0 *this, u64 key);
std_map_Map__0 *std_map_Map__0_new(u32 capacity);
std_map_Item__0 *std_map_Map__0_get_item(std_map_Map__0 *this, u64 key);
std_map_Item__1 *std_map_Item__1_new(void *key, bool value, std_map_Item__1 *next);
void std_map_Item__1_free_list(std_map_Item__1 *this);
void std_map_Map__1_free(std_map_Map__1 *this);
void std_map_Map__1_insert(std_map_Map__1 *this, void *key, bool value);
bool std_map_Map__1_contains(std_map_Map__1 *this, void *key);
void std_map_Map__1_resize(std_map_Map__1 *this);
u32 std_map_Map__1_hash(std_map_Map__1 *this, void *key);
std_map_Map__1 *std_map_Map__1_new(u32 capacity);
std_map_Item__1 *std_map_Map__1_get_item(std_map_Map__1 *this, void *key);
std_map_Item__2 *std_map_Item__2_new(char *key, compiler_types_Type *value, std_map_Item__2 *next);
void std_map_Item__2_free_list(std_map_Item__2 *this);
void std_map_Map__2_insert(std_map_Map__2 *this, char *key, compiler_types_Type *value);
compiler_types_Type *std_map_Map__2_get(std_map_Map__2 *this, char *key, compiler_types_Type *defolt);
std_map_Item__2 *std_map_Iterator__2_cur(std_map_Iterator__2 *this);
void std_map_Iterator__2_next(std_map_Iterator__2 *this);
bool std_map_Iterator__2_has_value(std_map_Iterator__2 *this);
std_map_Iterator__2 std_map_Iterator__2_make(std_map_Map__2 *map);
bool std_map_Map__2_is_empty(std_map_Map__2 *this);
void std_map_Map__2_resize(std_map_Map__2 *this);
u32 std_map_Map__2_hash(std_map_Map__2 *this, char *key);
std_map_Map__2 *std_map_Map__2_new(u32 capacity);
std_map_Item__2 *std_map_Map__2_get_item(std_map_Map__2 *this, char *key);
void std_map_Map__2_clear(std_map_Map__2 *this);
std_map_Iterator__2 std_map_Map__2_iter(std_map_Map__2 *this);
std_map_Item__3 *std_map_Item__3_new(char *key, compiler_ast_program_Namespace *value, std_map_Item__3 *next);
void std_map_Item__3_free_list(std_map_Item__3 *this);
compiler_ast_program_Namespace *std_map_Map__3_at(std_map_Map__3 *this, char *key);
void std_map_Map__3_insert(std_map_Map__3 *this, char *key, compiler_ast_program_Namespace *value);
compiler_ast_program_Namespace *std_map_Map__3_get(std_map_Map__3 *this, char *key, compiler_ast_program_Namespace *defolt);
std_map_Item__3 *std_map_Iterator__3_cur(std_map_Iterator__3 *this);
void std_map_Iterator__3_next(std_map_Iterator__3 *this);
bool std_map_Iterator__3_has_value(std_map_Iterator__3 *this);
std_map_Iterator__3 std_map_Iterator__3_make(std_map_Map__3 *map);
bool std_map_Map__3_is_empty(std_map_Map__3 *this);
bool std_map_Map__3_contains(std_map_Map__3 *this, char *key);
void std_map_Map__3_resize(std_map_Map__3 *this);
u32 std_map_Map__3_hash(std_map_Map__3 *this, char *key);
std_map_ValueIterator__3 std_map_Map__3_iter_values(std_map_Map__3 *this);
compiler_ast_program_Namespace *std_map_ValueIterator__3_cur(std_map_ValueIterator__3 *this);
void std_map_ValueIterator__3_next(std_map_ValueIterator__3 *this);
bool std_map_ValueIterator__3_has_value(std_map_ValueIterator__3 *this);
std_map_Map__3 *std_map_Map__3_new(u32 capacity);
std_map_Item__3 *std_map_Map__3_get_item(std_map_Map__3 *this, char *key);
std_map_Iterator__3 std_map_Map__3_iter(std_map_Map__3 *this);
std_map_Item__4 *std_map_Item__4_new(char *key, compiler_ast_scopes_Symbol *value, std_map_Item__4 *next);
void std_map_Item__4_free_list(std_map_Item__4 *this);
compiler_ast_scopes_Symbol *std_map_Map__4_at(std_map_Map__4 *this, char *key);
void std_map_Map__4_insert(std_map_Map__4 *this, char *key, compiler_ast_scopes_Symbol *value);
compiler_ast_scopes_Symbol *std_map_Map__4_get(std_map_Map__4 *this, char *key, compiler_ast_scopes_Symbol *defolt);
std_map_Item__4 *std_map_Iterator__4_cur(std_map_Iterator__4 *this);
void std_map_Iterator__4_next(std_map_Iterator__4 *this);
bool std_map_Iterator__4_has_value(std_map_Iterator__4 *this);
std_map_Iterator__4 std_map_Iterator__4_make(std_map_Map__4 *map);
bool std_map_Map__4_contains(std_map_Map__4 *this, char *key);
void std_map_Map__4_resize(std_map_Map__4 *this);
u32 std_map_Map__4_hash(std_map_Map__4 *this, char *key);
std_map_ValueIterator__4 std_map_Map__4_iter_values(std_map_Map__4 *this);
compiler_ast_scopes_Symbol *std_map_ValueIterator__4_cur(std_map_ValueIterator__4 *this);
void std_map_ValueIterator__4_next(std_map_ValueIterator__4 *this);
bool std_map_ValueIterator__4_has_value(std_map_ValueIterator__4 *this);
std_map_Map__4 *std_map_Map__4_new(u32 capacity);
std_map_Item__4 *std_map_Map__4_get_item(std_map_Map__4 *this, char *key);
std_map_Iterator__4 std_map_Map__4_iter(std_map_Map__4 *this);
std_map_Item__5 *std_map_Item__5_new(compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value, std_map_Item__5 *next);
void std_map_Item__5_free_list(std_map_Item__5 *this);
void std_map_Map__5_insert(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value);
compiler_ast_nodes_Function *std_map_Map__5_get(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *defolt);
void std_map_Map__5_resize(std_map_Map__5 *this);
u32 std_map_Map__5_hash(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key);
std_map_Map__5 *std_map_Map__5_new(u32 capacity);
std_map_Item__5 *std_map_Map__5_get_item(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key);
std_map_Item__6 *std_map_Item__6_new(char *key, char *value, std_map_Item__6 *next);
void std_map_Item__6_free_list(std_map_Item__6 *this);
void std_map_Map__6_insert(std_map_Map__6 *this, char *key, char *value);
char *std_map_Map__6_get(std_map_Map__6 *this, char *key, char *defolt);
std_map_Item__6 *std_map_Iterator__6_cur(std_map_Iterator__6 *this);
void std_map_Iterator__6_next(std_map_Iterator__6 *this);
bool std_map_Iterator__6_has_value(std_map_Iterator__6 *this);
std_map_Iterator__6 std_map_Iterator__6_make(std_map_Map__6 *map);
bool std_map_Map__6_contains(std_map_Map__6 *this, char *key);
void std_map_Map__6_resize(std_map_Map__6 *this);
u32 std_map_Map__6_hash(std_map_Map__6 *this, char *key);
std_map_Map__6 *std_map_Map__6_new(u32 capacity);
std_map_Item__6 *std_map_Map__6_get_item(std_map_Map__6 *this, char *key);
std_map_Iterator__6 std_map_Map__6_iter(std_map_Map__6 *this);
std_map_Item__7 *std_map_Item__7_new(char *key, bool value, std_map_Item__7 *next);
void std_map_Item__7_free_list(std_map_Item__7 *this);
void std_map_Map__7_free(std_map_Map__7 *this);
void std_map_Map__7_insert(std_map_Map__7 *this, char *key, bool value);
bool std_map_Map__7_contains(std_map_Map__7 *this, char *key);
void std_map_Map__7_resize(std_map_Map__7 *this);
u32 std_map_Map__7_hash(std_map_Map__7 *this, char *key);
std_map_Map__7 *std_map_Map__7_new(u32 capacity);
std_map_Item__7 *std_map_Map__7_get_item(std_map_Map__7 *this, char *key);
std_map_Item__8 *std_map_Item__8_new(char *key, compiler_ast_nodes_Function *value, std_map_Item__8 *next);
void std_map_Item__8_free_list(std_map_Item__8 *this);
compiler_ast_nodes_Function *std_map_Map__8_at(std_map_Map__8 *this, char *key);
void std_map_Map__8_insert(std_map_Map__8 *this, char *key, compiler_ast_nodes_Function *value);
compiler_ast_nodes_Function *std_map_Map__8_get(std_map_Map__8 *this, char *key, compiler_ast_nodes_Function *defolt);
std_map_Item__8 *std_map_Iterator__8_cur(std_map_Iterator__8 *this);
void std_map_Iterator__8_next(std_map_Iterator__8 *this);
bool std_map_Iterator__8_has_value(std_map_Iterator__8 *this);
std_map_Iterator__8 std_map_Iterator__8_make(std_map_Map__8 *map);
void std_map_Map__8_resize(std_map_Map__8 *this);
u32 std_map_Map__8_hash(std_map_Map__8 *this, char *key);
std_map_ValueIterator__8 std_map_Map__8_iter_values(std_map_Map__8 *this);
compiler_ast_nodes_Function *std_map_ValueIterator__8_cur(std_map_ValueIterator__8 *this);
void std_map_ValueIterator__8_next(std_map_ValueIterator__8 *this);
bool std_map_ValueIterator__8_has_value(std_map_ValueIterator__8 *this);
std_map_Map__8 *std_map_Map__8_new(u32 capacity);
std_map_Item__8 *std_map_Map__8_get_item(std_map_Map__8 *this, char *key);
std_map_Iterator__8 std_map_Map__8_iter(std_map_Map__8 *this);
std_map_Item__9 *std_map_Item__9_new(char *key, compiler_ast_nodes_Argument *value, std_map_Item__9 *next);
void std_map_Item__9_free_list(std_map_Item__9 *this);
void std_map_Map__9_free(std_map_Map__9 *this);
void std_map_Map__9_insert(std_map_Map__9 *this, char *key, compiler_ast_nodes_Argument *value);
void std_map_Map__9_resize(std_map_Map__9 *this);
u32 std_map_Map__9_hash(std_map_Map__9 *this, char *key);
std_map_Map__9 *std_map_Map__9_new(u32 capacity);
std_map_Item__9 *std_map_Map__9_get_item(std_map_Map__9 *this, char *key);
std_map_Item__10 *std_map_Item__10_new(char *key, compiler_ast_nodes_Variable *value, std_map_Item__10 *next);
void std_map_Item__10_free_list(std_map_Item__10 *this);
void std_map_Map__10_free(std_map_Map__10 *this);
void std_map_Map__10_insert(std_map_Map__10 *this, char *key, compiler_ast_nodes_Variable *value);
void std_map_Map__10_resize(std_map_Map__10 *this);
u32 std_map_Map__10_hash(std_map_Map__10 *this, char *key);
std_map_Map__10 *std_map_Map__10_new(u32 capacity);
std_map_Item__10 *std_map_Map__10_get_item(std_map_Map__10 *this, char *key);
std_map_Item__11 *std_map_Item__11_new(char *key, compiler_ast_nodes_MatchCond *value, std_map_Item__11 *next);
void std_map_Item__11_free_list(std_map_Item__11 *this);
void std_map_Map__11_free(std_map_Map__11 *this);
void std_map_Map__11_insert(std_map_Map__11 *this, char *key, compiler_ast_nodes_MatchCond *value);
compiler_ast_nodes_MatchCond *std_map_Map__11_get(std_map_Map__11 *this, char *key, compiler_ast_nodes_MatchCond *defolt);
bool std_map_Map__11_contains(std_map_Map__11 *this, char *key);
void std_map_Map__11_resize(std_map_Map__11 *this);
u32 std_map_Map__11_hash(std_map_Map__11 *this, char *key);
std_map_Map__11 *std_map_Map__11_new(u32 capacity);
std_map_Item__11 *std_map_Map__11_get_item(std_map_Map__11 *this, char *key);
std_map_Item__12 *std_map_Item__12_new(char *key, std_span_Span value, std_map_Item__12 *next);
void std_map_Item__12_free_list(std_map_Item__12 *this);
void std_map_Map__12_free(std_map_Map__12 *this);
void std_map_Map__12_insert(std_map_Map__12 *this, char *key, std_span_Span value);
void std_map_Map__12_resize(std_map_Map__12 *this);
u32 std_map_Map__12_hash(std_map_Map__12 *this, char *key);
std_map_Map__12 *std_map_Map__12_new(u32 capacity);
std_map_Item__12 *std_map_Map__12_get_item(std_map_Map__12 *this, char *key);
std_map_Item__13 *std_map_Item__13_new(std_span_Span key, bool value, std_map_Item__13 *next);
void std_map_Item__13_free_list(std_map_Item__13 *this);
void std_map_Map__13_free(std_map_Map__13 *this);
void std_map_Map__13_insert(std_map_Map__13 *this, std_span_Span key, bool value);
std_map_Item__13 *std_map_Iterator__13_cur(std_map_Iterator__13 *this);
void std_map_Iterator__13_next(std_map_Iterator__13 *this);
bool std_map_Iterator__13_has_value(std_map_Iterator__13 *this);
std_map_Iterator__13 std_map_Iterator__13_make(std_map_Map__13 *map);
void std_map_Map__13_resize(std_map_Map__13 *this);
u32 std_map_Map__13_hash(std_map_Map__13 *this, std_span_Span key);
std_map_Map__13 *std_map_Map__13_new(u32 capacity);
std_map_Item__13 *std_map_Map__13_get_item(std_map_Map__13 *this, std_span_Span key);
std_map_Iterator__13 std_map_Map__13_iter(std_map_Map__13 *this);
std_vector_Iterator__0 std_vector_Vector__0_iter(std_vector_Vector__0 *this);
compiler_types_Type *std_vector_Iterator__0_cur(std_vector_Iterator__0 *this);
void std_vector_Iterator__0_next(std_vector_Iterator__0 *this);
bool std_vector_Iterator__0_has_value(std_vector_Iterator__0 *this);
std_vector_Iterator__0 std_vector_Iterator__0_make(std_vector_Vector__0 *vec);
compiler_types_Type *std_vector_Vector__0_at(std_vector_Vector__0 *this, u32 i);
void std_vector_Vector__0_resize(std_vector_Vector__0 *this, u32 new_capacity);
std_vector_Vector__0 *std_vector_Vector__0_new(u32 capacity);
void std_vector_Vector__0_push(std_vector_Vector__0 *this, compiler_types_Type *value);
compiler_ast_scopes_Scope *std_vector_Vector__1_pop(std_vector_Vector__1 *this);
compiler_ast_scopes_Scope *std_vector_Vector__1_back(std_vector_Vector__1 *this, u32 i);
compiler_ast_scopes_Scope *std_vector_Vector__1_at(std_vector_Vector__1 *this, u32 i);
void std_vector_Vector__1_resize(std_vector_Vector__1 *this, u32 new_capacity);
std_vector_Vector__1 *std_vector_Vector__1_new(u32 capacity);
void std_vector_Vector__1_push(std_vector_Vector__1 *this, compiler_ast_scopes_Scope *value);
compiler_ast_program_Namespace *std_vector_Vector__2_pop(std_vector_Vector__2 *this);
compiler_ast_program_Namespace *std_vector_Vector__2_at(std_vector_Vector__2 *this, u32 i);
void std_vector_Vector__2_free(std_vector_Vector__2 *this);
bool std_vector_Vector__2_is_empty(std_vector_Vector__2 *this);
void std_vector_Vector__2_resize(std_vector_Vector__2 *this, u32 new_capacity);
std_vector_Vector__2 *std_vector_Vector__2_new(u32 capacity);
void std_vector_Vector__2_push(std_vector_Vector__2 *this, compiler_ast_program_Namespace *value);
compiler_ast_nodes_Variable *std_vector_Vector__3_back(std_vector_Vector__3 *this, u32 i);
std_vector_Iterator__3 std_vector_Vector__3_iter(std_vector_Vector__3 *this);
compiler_ast_nodes_Variable *std_vector_Iterator__3_cur(std_vector_Iterator__3 *this);
void std_vector_Iterator__3_next(std_vector_Iterator__3 *this);
bool std_vector_Iterator__3_has_value(std_vector_Iterator__3 *this);
std_vector_Iterator__3 std_vector_Iterator__3_make(std_vector_Vector__3 *vec);
compiler_ast_nodes_Variable *std_vector_Vector__3_at(std_vector_Vector__3 *this, u32 i);
void std_vector_Vector__3_free(std_vector_Vector__3 *this);
bool std_vector_Vector__3_is_empty(std_vector_Vector__3 *this);
void std_vector_Vector__3_resize(std_vector_Vector__3 *this, u32 new_capacity);
std_vector_Vector__3 *std_vector_Vector__3_new(u32 capacity);
void std_vector_Vector__3_push(std_vector_Vector__3 *this, compiler_ast_nodes_Variable *value);
void std_vector_Vector__3_clear(std_vector_Vector__3 *this);
std_vector_Iterator__4 std_vector_Vector__4_iter(std_vector_Vector__4 *this);
compiler_ast_scopes_TemplateInstance *std_vector_Iterator__4_cur(std_vector_Iterator__4 *this);
void std_vector_Iterator__4_next(std_vector_Iterator__4 *this);
bool std_vector_Iterator__4_has_value(std_vector_Iterator__4 *this);
std_vector_Iterator__4 std_vector_Iterator__4_make(std_vector_Vector__4 *vec);
void std_vector_Vector__4_resize(std_vector_Vector__4 *this, u32 new_capacity);
std_vector_Vector__4 *std_vector_Vector__4_new(u32 capacity);
void std_vector_Vector__4_push(std_vector_Vector__4 *this, compiler_ast_scopes_TemplateInstance *value);
std_vector_Iterator__5 std_vector_Vector__5_iter(std_vector_Vector__5 *this);
compiler_ast_nodes_ImportPart *std_vector_Iterator__5_cur(std_vector_Iterator__5 *this);
void std_vector_Iterator__5_next(std_vector_Iterator__5 *this);
bool std_vector_Iterator__5_has_value(std_vector_Iterator__5 *this);
std_vector_Iterator__5 std_vector_Iterator__5_make(std_vector_Vector__5 *vec);
compiler_ast_nodes_ImportPart *std_vector_Vector__5_at(std_vector_Vector__5 *this, u32 i);
void std_vector_Vector__5_resize(std_vector_Vector__5 *this, u32 new_capacity);
std_vector_Vector__5 *std_vector_Vector__5_new(u32 capacity);
void std_vector_Vector__5_push(std_vector_Vector__5 *this, compiler_ast_nodes_ImportPart *value);
compiler_ast_nodes_Function *std_vector_Vector__6_pop(std_vector_Vector__6 *this);
std_vector_Iterator__6 std_vector_Vector__6_iter(std_vector_Vector__6 *this);
compiler_ast_nodes_Function *std_vector_Iterator__6_cur(std_vector_Iterator__6 *this);
void std_vector_Iterator__6_next(std_vector_Iterator__6 *this);
bool std_vector_Iterator__6_has_value(std_vector_Iterator__6 *this);
std_vector_Iterator__6 std_vector_Iterator__6_make(std_vector_Vector__6 *vec);
bool std_vector_Vector__6_is_empty(std_vector_Vector__6 *this);
void std_vector_Vector__6_resize(std_vector_Vector__6 *this, u32 new_capacity);
std_vector_Vector__6 *std_vector_Vector__6_new(u32 capacity);
void std_vector_Vector__6_push(std_vector_Vector__6 *this, compiler_ast_nodes_Function *value);
void std_vector_Vector__7_push_front(std_vector_Vector__7 *this, compiler_ast_nodes_Argument *value);
std_vector_Iterator__7 std_vector_Vector__7_iter(std_vector_Vector__7 *this);
compiler_ast_nodes_Argument *std_vector_Iterator__7_cur(std_vector_Iterator__7 *this);
void std_vector_Iterator__7_next(std_vector_Iterator__7 *this);
bool std_vector_Iterator__7_has_value(std_vector_Iterator__7 *this);
std_vector_Iterator__7 std_vector_Iterator__7_make(std_vector_Vector__7 *vec);
compiler_ast_nodes_Argument *std_vector_Vector__7_at(std_vector_Vector__7 *this, u32 i);
void std_vector_Vector__7_free(std_vector_Vector__7 *this);
void std_vector_Vector__7_resize(std_vector_Vector__7 *this, u32 new_capacity);
std_vector_Vector__7 *std_vector_Vector__7_new(u32 capacity);
void std_vector_Vector__7_push(std_vector_Vector__7 *this, compiler_ast_nodes_Argument *value);
char *std_vector_Vector__8_pop(std_vector_Vector__8 *this);
char *std_vector_Vector__8_back(std_vector_Vector__8 *this, u32 i);
std_vector_Iterator__8 std_vector_Vector__8_iter(std_vector_Vector__8 *this);
char *std_vector_Iterator__8_cur(std_vector_Iterator__8 *this);
void std_vector_Iterator__8_next(std_vector_Iterator__8 *this);
bool std_vector_Iterator__8_has_value(std_vector_Iterator__8 *this);
std_vector_Iterator__8 std_vector_Iterator__8_make(std_vector_Vector__8 *vec);
char *std_vector_Vector__8_at(std_vector_Vector__8 *this, u32 i);
void std_vector_Vector__8_free(std_vector_Vector__8 *this);
void std_vector_Vector__8_resize(std_vector_Vector__8 *this, u32 new_capacity);
std_vector_Vector__8 *std_vector_Vector__8_new(u32 capacity);
void std_vector_Vector__8_push(std_vector_Vector__8 *this, char *value);
std_vector_Iterator__9 std_vector_Vector__9_iter(std_vector_Vector__9 *this);
compiler_ast_scopes_Symbol *std_vector_Iterator__9_cur(std_vector_Iterator__9 *this);
void std_vector_Iterator__9_next(std_vector_Iterator__9 *this);
bool std_vector_Iterator__9_has_value(std_vector_Iterator__9 *this);
std_vector_Iterator__9 std_vector_Iterator__9_make(std_vector_Vector__9 *vec);
compiler_ast_scopes_Symbol *std_vector_Vector__9_at(std_vector_Vector__9 *this, u32 i);
void std_vector_Vector__9_free(std_vector_Vector__9 *this);
bool std_vector_Vector__9_is_empty(std_vector_Vector__9 *this);
void std_vector_Vector__9_resize(std_vector_Vector__9 *this, u32 new_capacity);
std_vector_Vector__9 *std_vector_Vector__9_new(u32 capacity);
void std_vector_Vector__9_push(std_vector_Vector__9 *this, compiler_ast_scopes_Symbol *value);
std_vector_Iterator__10 std_vector_Vector__10_iter(std_vector_Vector__10 *this);
compiler_ast_nodes_MatchCond *std_vector_Iterator__10_cur(std_vector_Iterator__10 *this);
void std_vector_Iterator__10_next(std_vector_Iterator__10 *this);
bool std_vector_Iterator__10_has_value(std_vector_Iterator__10 *this);
std_vector_Iterator__10 std_vector_Iterator__10_make(std_vector_Vector__10 *vec);
compiler_ast_nodes_MatchCond *std_vector_Vector__10_at(std_vector_Vector__10 *this, u32 i);
void std_vector_Vector__10_resize(std_vector_Vector__10 *this, u32 new_capacity);
std_vector_Vector__10 *std_vector_Vector__10_new(u32 capacity);
void std_vector_Vector__10_push(std_vector_Vector__10 *this, compiler_ast_nodes_MatchCond *value);
compiler_tokens_Token *std_vector_Vector__11_at(std_vector_Vector__11 *this, u32 i);
void std_vector_Vector__11_free(std_vector_Vector__11 *this);
compiler_tokens_Token *std_vector_Vector__11_unchecked_at(std_vector_Vector__11 *this, u32 i);
void std_vector_Vector__11_resize(std_vector_Vector__11 *this, u32 new_capacity);
std_vector_Vector__11 *std_vector_Vector__11_new(u32 capacity);
void std_vector_Vector__11_push(std_vector_Vector__11 *this, compiler_tokens_Token *value);
std_vector_Iterator__12 std_vector_Vector__12_iter(std_vector_Vector__12 *this);
compiler_attributes_Attribute *std_vector_Iterator__12_cur(std_vector_Iterator__12 *this);
void std_vector_Iterator__12_next(std_vector_Iterator__12 *this);
bool std_vector_Iterator__12_has_value(std_vector_Iterator__12 *this);
std_vector_Iterator__12 std_vector_Iterator__12_make(std_vector_Vector__12 *vec);
void std_vector_Vector__12_free(std_vector_Vector__12 *this);
void std_vector_Vector__12_resize(std_vector_Vector__12 *this, u32 new_capacity);
std_vector_Vector__12 *std_vector_Vector__12_new(u32 capacity);
void std_vector_Vector__12_push(std_vector_Vector__12 *this, compiler_attributes_Attribute *value);
void std_vector_Vector__12_clear(std_vector_Vector__12 *this);
std_vector_Iterator__13 std_vector_Vector__13_iter(std_vector_Vector__13 *this);
compiler_errors_Error *std_vector_Iterator__13_cur(std_vector_Iterator__13 *this);
void std_vector_Iterator__13_next(std_vector_Iterator__13 *this);
bool std_vector_Iterator__13_has_value(std_vector_Iterator__13 *this);
std_vector_Iterator__13 std_vector_Iterator__13_make(std_vector_Vector__13 *vec);
compiler_errors_Error *std_vector_Vector__13_at(std_vector_Vector__13 *this, u32 i);
void std_vector_Vector__13_free(std_vector_Vector__13 *this);
bool std_vector_Vector__13_is_empty(std_vector_Vector__13 *this);
void std_vector_Vector__13_resize(std_vector_Vector__13 *this, u32 new_capacity);
std_vector_Vector__13 *std_vector_Vector__13_new(u32 capacity);
void std_vector_Vector__13_push(std_vector_Vector__13 *this, compiler_errors_Error *value);
std_vector_Iterator__14 std_vector_Vector__14_iter(std_vector_Vector__14 *this);
compiler_ast_nodes_Structure *std_vector_Iterator__14_cur(std_vector_Iterator__14 *this);
void std_vector_Iterator__14_next(std_vector_Iterator__14 *this);
bool std_vector_Iterator__14_has_value(std_vector_Iterator__14 *this);
std_vector_Iterator__14 std_vector_Iterator__14_make(std_vector_Vector__14 *vec);
bool std_vector_Vector__14_is_empty(std_vector_Vector__14 *this);
void std_vector_Vector__14_resize(std_vector_Vector__14 *this, u32 new_capacity);
std_vector_Vector__14 *std_vector_Vector__14_new(u32 capacity);
void std_vector_Vector__14_push(std_vector_Vector__14 *this, compiler_ast_nodes_Structure *value);
std_vector_Iterator__15 std_vector_Vector__15_iter(std_vector_Vector__15 *this);
compiler_ast_nodes_Enum *std_vector_Iterator__15_cur(std_vector_Iterator__15 *this);
void std_vector_Iterator__15_next(std_vector_Iterator__15 *this);
bool std_vector_Iterator__15_has_value(std_vector_Iterator__15 *this);
std_vector_Iterator__15 std_vector_Iterator__15_make(std_vector_Vector__15 *vec);
bool std_vector_Vector__15_is_empty(std_vector_Vector__15 *this);
void std_vector_Vector__15_resize(std_vector_Vector__15 *this, u32 new_capacity);
std_vector_Vector__15 *std_vector_Vector__15_new(u32 capacity);
void std_vector_Vector__15_push(std_vector_Vector__15 *this, compiler_ast_nodes_Enum *value);
compiler_ast_nodes_AST *std_vector_Vector__16_pop(std_vector_Vector__16 *this);
std_vector_Iterator__16 std_vector_Vector__16_iter(std_vector_Vector__16 *this);
compiler_ast_nodes_AST *std_vector_Iterator__16_cur(std_vector_Iterator__16 *this);
void std_vector_Iterator__16_next(std_vector_Iterator__16 *this);
bool std_vector_Iterator__16_has_value(std_vector_Iterator__16 *this);
std_vector_Iterator__16 std_vector_Iterator__16_make(std_vector_Vector__16 *vec);
compiler_ast_nodes_AST *std_vector_Vector__16_at(std_vector_Vector__16 *this, u32 i);
void std_vector_Vector__16_free(std_vector_Vector__16 *this);
bool std_vector_Vector__16_is_empty(std_vector_Vector__16 *this);
void std_vector_Vector__16_resize(std_vector_Vector__16 *this, u32 new_capacity);
std_vector_Vector__16 *std_vector_Vector__16_new(u32 capacity);
void std_vector_Vector__16_push(std_vector_Vector__16 *this, compiler_ast_nodes_AST *value);
jmp_buf *std_vector_Vector__17_back_ptr(std_vector_Vector__17 *this, u32 i);
void std_vector_Vector__17_resize(std_vector_Vector__17 *this, u32 new_capacity);
std_vector_Vector__17 *std_vector_Vector__17_new(u32 capacity);
std_vector_Iterator__18 std_vector_Vector__18_iter(std_vector_Vector__18 *this);
compiler_ast_scopes_Reference std_vector_Iterator__18_cur(std_vector_Iterator__18 *this);
void std_vector_Iterator__18_next(std_vector_Iterator__18 *this);
bool std_vector_Iterator__18_has_value(std_vector_Iterator__18 *this);
std_vector_Iterator__18 std_vector_Iterator__18_make(std_vector_Vector__18 *vec);
void std_vector_Vector__18_resize(std_vector_Vector__18 *this, u32 new_capacity);
std_vector_Vector__18 *std_vector_Vector__18_new(u32 capacity);
void std_vector_Vector__18_push(std_vector_Vector__18 *this, compiler_ast_scopes_Reference value);
std_vector_Iterator__19 std_vector_Vector__19_iter(std_vector_Vector__19 *this);
compiler_ast_nodes_MatchCondArg *std_vector_Iterator__19_cur(std_vector_Iterator__19 *this);
void std_vector_Iterator__19_next(std_vector_Iterator__19 *this);
bool std_vector_Iterator__19_has_value(std_vector_Iterator__19 *this);
std_vector_Iterator__19 std_vector_Iterator__19_make(std_vector_Vector__19 *vec);
compiler_ast_nodes_MatchCondArg *std_vector_Vector__19_at(std_vector_Vector__19 *this, u32 i);
void std_vector_Vector__19_resize(std_vector_Vector__19 *this, u32 new_capacity);
std_vector_Vector__19 *std_vector_Vector__19_new(u32 capacity);
void std_vector_Vector__19_push(std_vector_Vector__19 *this, compiler_ast_nodes_MatchCondArg *value);
std_vector_Iterator__20 std_vector_Vector__20_iter(std_vector_Vector__20 *this);
compiler_ast_nodes_EnumVariant *std_vector_Iterator__20_cur(std_vector_Iterator__20 *this);
void std_vector_Iterator__20_next(std_vector_Iterator__20 *this);
bool std_vector_Iterator__20_has_value(std_vector_Iterator__20 *this);
std_vector_Iterator__20 std_vector_Iterator__20_make(std_vector_Vector__20 *vec);
void std_vector_Vector__20_resize(std_vector_Vector__20 *this, u32 new_capacity);
std_vector_Vector__20 *std_vector_Vector__20_new(u32 capacity);
void std_vector_Vector__20_push(std_vector_Vector__20 *this, compiler_ast_nodes_EnumVariant *value);
std_vector_Iterator__21 std_vector_Vector__21_iter(std_vector_Vector__21 *this);
compiler_ast_operators_Operator std_vector_Iterator__21_cur(std_vector_Iterator__21 *this);
void std_vector_Iterator__21_next(std_vector_Iterator__21 *this);
bool std_vector_Iterator__21_has_value(std_vector_Iterator__21 *this);
std_vector_Iterator__21 std_vector_Iterator__21_make(std_vector_Vector__21 *vec);
void std_vector_Vector__21_resize(std_vector_Vector__21 *this, u32 new_capacity);
std_vector_Vector__21 *std_vector_Vector__21_new(u32 capacity);
void std_vector_Vector__21_push(std_vector_Vector__21 *this, compiler_ast_operators_Operator value);
std_vector_Iterator__22 std_vector_Vector__22_iter(std_vector_Vector__22 *this);
std_vector_Vector__5 *std_vector_Iterator__22_cur(std_vector_Iterator__22 *this);
void std_vector_Iterator__22_next(std_vector_Iterator__22 *this);
bool std_vector_Iterator__22_has_value(std_vector_Iterator__22 *this);
std_vector_Iterator__22 std_vector_Iterator__22_make(std_vector_Vector__22 *vec);
std_vector_Vector__5 *std_vector_Vector__22_at(std_vector_Vector__22 *this, u32 i);
void std_vector_Vector__22_resize(std_vector_Vector__22 *this, u32 new_capacity);
std_vector_Vector__22 *std_vector_Vector__22_new(u32 capacity);
void std_vector_Vector__22_push(std_vector_Vector__22 *this, std_vector_Vector__5 *value);
std_vector_Iterator__23 std_vector_Vector__23_iter(std_vector_Vector__23 *this);
compiler_ast_nodes_IfBranch std_vector_Iterator__23_cur(std_vector_Iterator__23 *this);
void std_vector_Iterator__23_next(std_vector_Iterator__23 *this);
bool std_vector_Iterator__23_has_value(std_vector_Iterator__23 *this);
std_vector_Iterator__23 std_vector_Iterator__23_make(std_vector_Vector__23 *vec);
compiler_ast_nodes_IfBranch std_vector_Vector__23_at(std_vector_Vector__23 *this, u32 i);
void std_vector_Vector__23_resize(std_vector_Vector__23 *this, u32 new_capacity);
std_vector_Vector__23 *std_vector_Vector__23_new(u32 capacity);
void std_vector_Vector__23_push(std_vector_Vector__23 *this, compiler_ast_nodes_IfBranch value);
std_vector_Iterator__24 std_vector_Vector__24_iter(std_vector_Vector__24 *this);
compiler_ast_nodes_MatchCase std_vector_Iterator__24_cur(std_vector_Iterator__24 *this);
void std_vector_Iterator__24_next(std_vector_Iterator__24 *this);
bool std_vector_Iterator__24_has_value(std_vector_Iterator__24 *this);
std_vector_Iterator__24 std_vector_Iterator__24_make(std_vector_Vector__24 *vec);
compiler_ast_nodes_MatchCase std_vector_Vector__24_at(std_vector_Vector__24 *this, u32 i);
void std_vector_Vector__24_resize(std_vector_Vector__24 *this, u32 new_capacity);
std_vector_Vector__24 *std_vector_Vector__24_new(u32 capacity);
void std_vector_Vector__24_push(std_vector_Vector__24 *this, compiler_ast_nodes_MatchCase value);
std_vector_Iterator__25 std_vector_Vector__25_iter(std_vector_Vector__25 *this);
std_span_Span std_vector_Iterator__25_cur(std_vector_Iterator__25 *this);
void std_vector_Iterator__25_next(std_vector_Iterator__25 *this);
bool std_vector_Iterator__25_has_value(std_vector_Iterator__25 *this);
std_vector_Iterator__25 std_vector_Iterator__25_make(std_vector_Vector__25 *vec);
void std_vector_Vector__25_free(std_vector_Vector__25 *this);
void std_vector_Vector__25_resize(std_vector_Vector__25 *this, u32 new_capacity);
std_vector_Vector__25 *std_vector_Vector__25_new(u32 capacity);
void std_vector_Vector__25_push(std_vector_Vector__25 *this, std_span_Span value);
std_value_Value *std_vector_Vector__26_at(std_vector_Vector__26 *this, u32 i);
void std_vector_Vector__26_resize(std_vector_Vector__26 *this, u32 new_capacity);
std_vector_Vector__26 *std_vector_Vector__26_new(u32 capacity);
void std_vector_Vector__26_push(std_vector_Vector__26 *this, std_value_Value *value);
std_vector_Iterator__27 std_vector_Vector__27_iter(std_vector_Vector__27 *this);
std_compact_map_Item__0 std_vector_Iterator__27_cur(std_vector_Iterator__27 *this);
void std_vector_Iterator__27_next(std_vector_Iterator__27 *this);
bool std_vector_Iterator__27_has_value(std_vector_Iterator__27 *this);
std_vector_Iterator__27 std_vector_Iterator__27_make(std_vector_Vector__27 *vec);
std_compact_map_Item__0 std_vector_Vector__27_at(std_vector_Vector__27 *this, u32 i);
void std_vector_Vector__27_resize(std_vector_Vector__27 *this, u32 new_capacity);
std_vector_Vector__27 *std_vector_Vector__27_new(u32 capacity);
void std_vector_Vector__27_push(std_vector_Vector__27 *this, std_compact_map_Item__0 value);
std_compact_map_Item__1 std_vector_Vector__28_at(std_vector_Vector__28 *this, u32 i);
void std_vector_Vector__28_resize(std_vector_Vector__28 *this, u32 new_capacity);
std_vector_Vector__28 *std_vector_Vector__28_new(u32 capacity);
void std_vector_Vector__28_push(std_vector_Vector__28 *this, std_compact_map_Item__1 value);
u32 std_vector_Vector__29_at(std_vector_Vector__29 *this, u32 i);
void std_vector_Vector__29_free(std_vector_Vector__29 *this);
void std_vector_Vector__29_resize(std_vector_Vector__29 *this, u32 new_capacity);
std_vector_Vector__29 *std_vector_Vector__29_new(u32 capacity);
void std_vector_Vector__29_push(std_vector_Vector__29 *this, u32 value);
void std_json_serialize_into(std_value_Value *val, std_buffer_Buffer *sb);
std_buffer_Buffer std_json_serialize(std_value_Value *val);
void std_json_write_to_file(std_value_Value *val, char *filename);
bool compiler_lsp_utils_verbose = false;
char *exec_path = "./out";
char *c_path = NULL;
char *filename = NULL;
bool compile_c = true;
bool silent = false;
bool debug = false;
u32 error_level = 2;
char *docs_path = NULL;
bool include_stdlib = true;
std_vector_Vector__8 *extra_c_flags;
bool run_after_compile = false;
void *std_mem_state_allocator = NULL;
void *(*std_mem_state_alloc_fn)(void *, u32) = std_mem_impl_my_calloc;
void *(*std_mem_state_realloc_fn)(void *, void *, u32, u32) = std_mem_impl_my_realloc;
void (*std_mem_state_free_fn)(void *, void *) = std_mem_impl_my_free;
std_logging_LogLevel std_logging_log_level = std_logging_LogLevel_Warn;
char *std_logging_log_time_format = "%H:%M:%S";
/* function implementations */

#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_enum(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Enum *enom) {

#line 25 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *enum_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 26 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(enum_doc, "id", std_format("%x", enom->type));

#line 27 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(enum_doc, "name", enom->sym->name);

#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (((bool)enom->sym->comment)) {

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(enum_doc, "description", enom->sym->comment);
  }

#line 31 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(enum_doc, "kind", "enum");

#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (enom->sym->is_extern) {

#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(enum_doc, "extern", compiler_ast_scopes_Symbol_out_name(enom->sym));
  } else {

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_docgen_DocGenerator_gen_location(this, enum_doc, enom->sym->span);
  }

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *shared_fields_doc = std_value_Value_new(std_value_ValueType_List);

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_vector_Iterator__3 _i229 = std_vector_Vector__3_iter(enom->shared_fields); std_vector_Iterator__3_has_value(&_i229); std_vector_Iterator__3_next(&_i229)) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i229);

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value *field_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert_str(field_doc, "name", field->sym->name);

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(field_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, field->type));

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (((bool)field->sym->comment)) {

#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(field_doc, "description", field->sym->comment);
      }

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_push(shared_fields_doc, field_doc);
    }
  }

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(enum_doc, "shared_fields", shared_fields_doc);

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *variants_doc = std_value_Value_new(std_value_ValueType_List);

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_vector_Iterator__20 _i230 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i230); std_vector_Iterator__20_next(&_i230)) {

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i230);

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value *variant_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert_str(variant_doc, "name", variant->sym->name);

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (((bool)variant->sym->comment)) {

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(variant_doc, "description", variant->sym->comment);
      }

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (variant->sym->is_extern) {

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(variant_doc, "extern", compiler_ast_scopes_Symbol_out_name(variant->sym));
      }

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value *fields_doc = std_value_Value_new(std_value_ValueType_List);

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      for (std_vector_Iterator__3 _i231 = std_vector_Vector__3_iter(variant->specific_fields); std_vector_Iterator__3_has_value(&_i231); std_vector_Iterator__3_next(&_i231)) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i231);

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        {

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_push(fields_doc, compiler_docgen_DocGenerator_gen_typename(this, field->type));
        }
      }

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(variant_doc, "fields", fields_doc);

#line 66 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_push(variants_doc, variant_doc);
    }
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(enum_doc, "variants", variants_doc);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, enom->type);

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(enum_doc, "methods", methods_doc);

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return enum_doc;
}


#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
void compiler_docgen_DocGenerator_gen_location(compiler_docgen_DocGenerator *this, std_value_Value *obj, std_span_Span span) {

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_span_Location start = span.start;

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (std_span_Location_is_valid(&start)) {

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    char *filename = start.filename;

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    if (str_starts_with(filename, this->ocen_root.data)) {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      filename=&filename[this->ocen_root.len];

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (filename[0]=='/') {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        filename=&filename[1];
      }
    }

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(obj, "source", std_format("%s#L%u", filename, start.line));
  }
}


#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
char *compiler_docgen_DocGenerator_gen_templated_type(compiler_docgen_DocGenerator *this, compiler_types_Type *base, std_vector_Vector__0 *args) {

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  char *base_name = compiler_docgen_DocGenerator_gen_typename_str(this, base);

#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_buffer_Buffer_write_str(&buf, base_name);

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_buffer_Buffer_write_str(&buf, "<");

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  bool first = true;

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_vector_Iterator__0 _i232 = std_vector_Vector__0_iter(args); std_vector_Iterator__0_has_value(&_i232); std_vector_Iterator__0_next(&_i232)) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_types_Type *arg_type = std_vector_Iterator__0_cur(&_i232);

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (!(first)) {

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_buffer_Buffer_write_str(&buf, ", ");
      }

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      first=false;

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      char *param_name = compiler_docgen_DocGenerator_gen_typename_str(this, arg_type);

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_buffer_Buffer_write_str(&buf, param_name);
    }
  }

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_buffer_Buffer_write_str(&buf, ">");

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return std_buffer_Buffer_str(buf);
}


#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
char *compiler_docgen_DocGenerator_gen_typename_str(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if(!(((bool)type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:108:12: Assertion failed: `type?`", "gen_typename_str called with null type"); }

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  switch ((type->base)) {
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    case compiler_types_BaseType_Alias:
    case compiler_types_BaseType_Enum:
    m_291_0:
      {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return std_format("{{%x}}", type);
      } break;
    case compiler_types_BaseType_Structure:
    m_291_1:
      {

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (!(((bool)type->template_instance))) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          return std_format("{{%x}}", type);
        } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          compiler_ast_nodes_Structure *struc = type->u.struc;

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          compiler_ast_scopes_TemplateInstance *instance = type->template_instance;

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          compiler_ast_scopes_Symbol *parent = instance->parent;

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          if(!(parent->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:123:24: Assertion failed: `parent.type == Structure`", "Template instance parent is not a structure"); }

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          compiler_ast_nodes_Structure *parent_struc = parent->u.struc;

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          return compiler_docgen_DocGenerator_gen_templated_type(this, parent_struc->type, instance->args);
        }
      } break;
    case compiler_types_BaseType_UnresolvedTemplate:
    m_291_2:
      {

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_types_UnresolvedTemplate uspec = type->u.unresolved_spec;

#line 131 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return compiler_docgen_DocGenerator_gen_templated_type(this, uspec.base, uspec.args);
      } break;
    case compiler_types_BaseType_Pointer:
    m_291_3:
      {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        char *sub = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.ptr);

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        str_replace_with(&sub, std_format("&%s", sub));

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return sub;
      } break;
    case compiler_types_BaseType_Array:
    m_291_4:
      {

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        char *sub = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.arr.elem_type);

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        str_replace_with(&sub, std_format("[%s]", sub));

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return sub;
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_291_5:
      {

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_buffer_Buffer_write_str(&buf, "fn(");

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        bool first = true;

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        for (std_vector_Iterator__3 _i233 = std_vector_Vector__3_iter(type->u.func.params); std_vector_Iterator__3_has_value(&_i233); std_vector_Iterator__3_next(&_i233)) {

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i233);

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
            if (!(first)) {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
              std_buffer_Buffer_write_str(&buf, ", ");
            }

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
            first=false;

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
            char *param_name = compiler_docgen_DocGenerator_gen_typename_str(this, param->type);

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
            std_buffer_Buffer_write_str_f(&buf, param_name);
          }
        }

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_buffer_Buffer_write_str(&buf, "): ");

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        char *return_name = compiler_docgen_DocGenerator_gen_typename_str(this, type->u.func.return_type);

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_buffer_Buffer_write_str_f(&buf, return_name);

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return std_buffer_Buffer_str(buf);
      } break;
    case compiler_types_BaseType_Unresolved:
    m_291_6:
      {

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_ast_nodes_AST *node = type->u.unresolved;

#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        switch ((node->type)) {
          case compiler_ast_nodes_ASTType_Identifier:
          m_292_0:
            {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
              return strdup(node->u.ident.name);
            } break;
          default:
            {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
              compiler_ast_program_Program_error(this->program, compiler_errors_Error_new(node->span, std_format("Unhandled node in gen_typename_str: %s", compiler_ast_nodes_ASTType_dbg(node->type))));

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
              return "<unknown>";
            } break;
        }
      } break;
    default:
      {

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_ast_program_Program_error(this->program, compiler_errors_Error_new(type->span, std_format("Unhandled type in gen_typename_str: %s", compiler_types_BaseType_dbg(type->base))));

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        return "<unknown>";
      } break;
  }
}


#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_typename(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {

#line 183 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if(!(((bool)type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:183:12: Assertion failed: `type?`", "gen_typename called with null type"); }

#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return std_value_Value_new_str(compiler_docgen_DocGenerator_gen_typename_str(this, type));
}


#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_methods(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if(!(compiler_types_Type_can_have_methods(type))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc:188:12: Assertion failed: `type.can_have_methods()`", "gen_methods called with type that can't have methods"); }

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *methods_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_map_Iterator__8 _i234 = std_map_Map__8_iter(type->methods); std_map_Iterator__8_has_value(&_i234); std_map_Iterator__8_next(&_i234)) {

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_map_Item__8 *it = std_map_Iterator__8_cur(&_i234);

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_Function *method = it->value;

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(methods_doc, method->sym->name, compiler_docgen_DocGenerator_gen_function(this, method));
    }
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return methods_doc;
}


#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_function(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Function *func) {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *func_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(func_doc, "id", std_format("%x", func));

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(func_doc, "name", std_format("%s", func->sym->name));

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (((bool)func->sym->comment)) {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(func_doc, "description", func->sym->comment);
  }

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(func_doc, "kind", "method");

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(func_doc, "parent", compiler_docgen_DocGenerator_gen_typename(this, func->parent_type));
  } else {

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(func_doc, "kind", "function");
  }

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (func->sym->is_extern) {

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(func_doc, "extern", compiler_ast_scopes_Symbol_out_name(func->sym));
  } else {

#line 216 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_docgen_DocGenerator_gen_location(this, func_doc, func->span);
  }

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *return_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  compiler_types_Type *ret_type = func->return_type;

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(return_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, ret_type));

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *params_doc = std_value_Value_new(std_value_ValueType_List);

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_vector_Iterator__3 _i235 = std_vector_Vector__3_iter(func->params); std_vector_Iterator__3_has_value(&_i235); std_vector_Iterator__3_next(&_i235)) {

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i235);

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value *param_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert_str(param_doc, "name", std_format("%s", param->sym->name));

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (((bool)param->sym->comment)) {

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(param_doc, "description", param->sym->comment);
      }

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(param_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, param->type));

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_AST *default_value = param->default_value;

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (((bool)default_value)) {

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *value_str = std_value_Value_new_str(compiler_ast_program_Program_get_source_text(this->program, default_value->span));

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(param_doc, "default_value", value_str);
      }

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_push(params_doc, param_doc);
    }
  }

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(func_doc, "params", params_doc);

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(func_doc, "return", return_doc);

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return func_doc;
}


#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_struct(compiler_docgen_DocGenerator *this, compiler_ast_nodes_Structure *struc) {

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *struc_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(struc_doc, "id", std_format("%x", struc->type));

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(struc_doc, "name", std_format("%s", struc->sym->name));

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (((bool)struc->sym->comment)) {

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(struc_doc, "description", struc->sym->comment);
  }

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (struc->is_union) {

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(struc_doc, "kind", "union");
  } else {

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(struc_doc, "kind", "struct");
  }

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(struc_doc, "is_templated", std_value_Value_new_bool(compiler_ast_scopes_Symbol_is_templated(struc->sym)));

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 261 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *params_doc = std_value_Value_new(std_value_ValueType_List);

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__9 _i236 = std_vector_Vector__9_iter(struc->sym->template->params); std_vector_Iterator__9_has_value(&_i236); std_vector_Iterator__9_next(&_i236)) {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_scopes_Symbol *sym = std_vector_Iterator__9_cur(&_i236);

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_push(params_doc, std_value_Value_new_str(sym->name));
      }
    }

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(struc_doc, "template_params", params_doc);
  }

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (struc->sym->is_extern) {

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(struc_doc, "extern", compiler_ast_scopes_Symbol_out_name(struc->sym));
  } else {

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_docgen_DocGenerator_gen_location(this, struc_doc, struc->span);
  }

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *fields_doc = std_value_Value_new(std_value_ValueType_List);

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (std_vector_Iterator__3 _i237 = std_vector_Vector__3_iter(struc->fields); std_vector_Iterator__3_has_value(&_i237); std_vector_Iterator__3_next(&_i237)) {

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i237);

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    {

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value *field_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert_str(field_doc, "name", field->sym->name);

#line 277 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(field_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, field->type));

#line 278 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (((bool)field->sym->comment)) {

#line 279 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(field_doc, "description", field->sym->comment);
      }

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      if (field->sym->is_extern) {

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(field_doc, "extern", compiler_ast_scopes_Symbol_out_name(field->sym));
      }

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_push(fields_doc, field_doc);
    }
  }

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(struc_doc, "fields", fields_doc);

#line 288 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, struc->type);

#line 289 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(struc_doc, "methods", methods_doc);

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return struc_doc;
}


#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_ns(compiler_docgen_DocGenerator *this, compiler_ast_program_Namespace *ns) {

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *ns_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(ns_doc, "id", std_format("%x", ns));

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (((bool)ns->sym->comment)) {

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert_str(ns_doc, "description", ns->sym->comment);
  }

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(ns_doc, "name", ns->sym->name);

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(ns_doc, "kind", "namespace");

#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (ns->is_a_file || ns->is_dir_with_mod) {

#line 303 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_docgen_DocGenerator_gen_location(this, ns_doc, ns->span);
  }

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_vector_Vector__15_is_empty(ns->enums))) {

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *enums_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__15 _i238 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i238); std_vector_Iterator__15_next(&_i238)) {

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i238);

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(enums_doc, enom->sym->name, compiler_docgen_DocGenerator_gen_enum(this, enom));
      }
    }

#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "enums", enums_doc);
  }

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_vector_Vector__14_is_empty(ns->structs))) {

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *structs_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 316 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *unions_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__14 _i239 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i239); std_vector_Iterator__14_next(&_i239)) {

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i239);

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 318 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *struct_doc = compiler_docgen_DocGenerator_gen_struct(this, struc);

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (!(struc->is_union)) {

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert(structs_doc, struc->sym->name, struct_doc);
        } else {

#line 322 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert(unions_doc, struc->sym->name, struct_doc);
        }
      }
    }

#line 326 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    if (!(std_compact_map_Map__0_is_empty(std_value_Value_as_dict(structs_doc)))) {

#line 327 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(ns_doc, "structs", structs_doc);
    }

#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    if (!(std_compact_map_Map__0_is_empty(std_value_Value_as_dict(unions_doc)))) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_value_Value_insert(ns_doc, "unions", unions_doc);
    }
  }

#line 334 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_vector_Vector__16_is_empty(ns->variables))) {

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *vars_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__16 _i240 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i240); std_vector_Iterator__16_next(&_i240)) {

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i240);

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 337 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *var_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 339 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(var_doc, "id", std_format("%x", var));

#line 340 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (((bool)var->sym->comment)) {

#line 341 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert_str(var_doc, "description", var->sym->comment);
        }

#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(var_doc, "name", var->sym->name);

#line 344 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(var_doc, "kind", "variable");

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(var_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, var->type));

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_docgen_DocGenerator_gen_location(this, var_doc, var->sym->span);

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (var->sym->is_extern) {

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert_str(var_doc, "extern", compiler_ast_scopes_Symbol_out_name(var->sym));
        }

#line 350 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(vars_doc, var->sym->name, var_doc);
      }
    }

#line 352 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "variables", vars_doc);
  }

#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_vector_Vector__16_is_empty(ns->constants))) {

#line 356 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *consts_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__16 _i241 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i241); std_vector_Iterator__16_next(&_i241)) {

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i241);

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *const_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(const_doc, "id", std_format("%x", var));

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (((bool)var->sym->comment)) {

#line 362 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert_str(const_doc, "description", var->sym->comment);
        }

#line 364 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(const_doc, "name", var->sym->name);

#line 365 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(const_doc, "kind", "constant");

#line 366 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(const_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, var->type));

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        compiler_docgen_DocGenerator_gen_location(this, const_doc, var->sym->span);

#line 368 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (var->sym->is_extern) {

#line 369 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          std_value_Value_insert_str(const_doc, "extern", compiler_ast_scopes_Symbol_out_name(var->sym));
        }

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(consts_doc, var->sym->name, const_doc);
      }
    }

#line 373 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "constants", consts_doc);
  }

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_vector_Vector__6_is_empty(ns->functions))) {

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *funcs_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 378 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_vector_Iterator__6 _i242 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i242); std_vector_Iterator__6_next(&_i242)) {

#line 378 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i242);

#line 378 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 379 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        if (func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 380 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
          continue;
        }

#line 382 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *func_doc = compiler_docgen_DocGenerator_gen_function(this, func);

#line 383 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(funcs_doc, func->sym->name, func_doc);
      }
    }

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "functions", funcs_doc);
  }

#line 388 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_map_Map__2_is_empty(ns->typedefs))) {

#line 389 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *typedefs_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_map_Iterator__2 _i243 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i243); std_map_Iterator__2_next(&_i243)) {

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_map_Item__2 *it = std_map_Iterator__2_cur(&_i243);

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *typedef_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(typedef_doc, "kind", "typedef");

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert_str(typedef_doc, "name", strdup(it->key));

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(typedef_doc, "type", compiler_docgen_DocGenerator_gen_typename(this, it->value));

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(typedefs_doc, it->key, typedef_doc);
      }
    }

#line 397 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "typedefs", typedefs_doc);
  }

#line 400 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(std_map_Map__3_is_empty(ns->namespaces))) {

#line 401 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value *namespaces_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    for (std_map_Iterator__3 _i244 = std_map_Map__3_iter(ns->namespaces); std_map_Iterator__3_has_value(&_i244); std_map_Iterator__3_next(&_i244)) {

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      std_map_Item__3 *it = std_map_Iterator__3_cur(&_i244);

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
      {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value *ns_doc = compiler_docgen_DocGenerator_gen_ns(this, it->value);

#line 404 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
        std_value_Value_insert(namespaces_doc, it->key, ns_doc);
      }
    }

#line 406 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(ns_doc, "namespaces", namespaces_doc);
  }

#line 409 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return ns_doc;
}


#line 412 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_builtin(compiler_docgen_DocGenerator *this, compiler_types_Type *type) {

#line 413 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *type_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(type_doc, "id", std_format("%x", type));

#line 415 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(type_doc, "name", std_format("%s", type->sym->name));

#line 416 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(type_doc, "description", std_format("Built-in type %s", type->sym->name));

#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert_str(type_doc, "kind", "builtin");

#line 419 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *methods_doc = compiler_docgen_DocGenerator_gen_methods(this, type);

#line 420 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(type_doc, "methods", methods_doc);

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return type_doc;
}


#line 425 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
std_value_Value *compiler_docgen_DocGenerator_gen_builtins(compiler_docgen_DocGenerator *this, compiler_ast_program_Program *program) {

#line 426 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *builtins_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 427 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  for (u32 i = 0; i < ((u32)compiler_types_BaseType_NUM_BASE_TYPES); i+=1) {

#line 428 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    compiler_types_Type *type = compiler_ast_program_Program_get_base_type(program, ((compiler_types_BaseType)i), std_span_Span_default());

#line 429 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    std_value_Value_insert(builtins_doc, type->name, compiler_docgen_DocGenerator_gen_builtin(this, type));
  }

#line 432 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  compiler_types_Type *str_type = compiler_ast_program_Program_get_type_by_name(program, "str", std_span_Span_default());

#line 433 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(builtins_doc, "str", compiler_docgen_DocGenerator_gen_builtin(this, str_type));

#line 435 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  compiler_types_Type *untyped_ptr_type = compiler_ast_program_Program_get_type_by_name(program, "untyped_ptr", std_span_Span_default());

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(builtins_doc, "untyped_ptr", compiler_docgen_DocGenerator_gen_builtin(this, untyped_ptr_type));

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  return builtins_doc;
}


#line 441 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
void compiler_docgen_generate_doc_json(compiler_ast_program_Program *program, char *json_path) {

#line 442 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  char *ocen_root = getenv("OCEN_ROOT");

#line 443 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  if (!(((bool)ocen_root))) {

#line 444 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
    ocen_root="";
  }

#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  compiler_docgen_DocGenerator docs_generator = (compiler_docgen_DocGenerator){.program=program, .ocen_root=std_sv_SV_from_str(ocen_root)};

#line 451 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *docs = compiler_docgen_DocGenerator_gen_ns(&docs_generator, program->global);

#line 452 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *builtins = compiler_docgen_DocGenerator_gen_builtins(&docs_generator, program);

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(docs, "builtins", builtins);

#line 455 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value *container = std_value_Value_new(std_value_ValueType_Dictionary);

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_value_Value_insert(container, "ocen", docs);

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/docgen.oc"
  std_json_write_to_file(container, json_path);
}


#line 10 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
void compiler_passes_run_typecheck_passes(compiler_ast_program_Program *program) {

#line 13 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  compiler_passes_register_types_RegisterTypes_run(program);

#line 14 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  compiler_passes_typechecker_TypeChecker_run(program);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
char *compiler_passes_run_codegen_passes(compiler_ast_program_Program *program) {

#line 19 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_run(program);

#line 20 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  compiler_passes_reorder_symbols_ReorderSymbols_run(program);

#line 21 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  char *code = compiler_passes_code_generator_CodeGenerator_run(program);

#line 22 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mod.oc"
  return code;
}


#line 18 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_struct(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Structure *struc) {

#line 19 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *item = struc->sym;

#line 20 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);

#line 22 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Structure, struc->sym->span);

#line 23 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->u.struc=struc;

#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  struc->type=typ;

#line 25 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->sym=struc->sym;
}


#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Enum *enum_) {

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *item = enum_->sym;

#line 30 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);

#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Enum, enum_->sym->span);

#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->u.enom=enum_;

#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  enum_->type=typ;

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->sym=enum_->sym;

#line 37 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_compact_map_Map__1 *values = std_compact_map_Map__1_new(16);

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_vector_Iterator__20 _i218 = std_vector_Vector__20_iter(enum_->variants); std_vector_Iterator__20_has_value(&_i218); std_vector_Iterator__20_next(&_i218)) {

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_nodes_EnumVariant *var = std_vector_Iterator__20_cur(&_i218);

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      var->parent=enum_;

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      char *name = var->sym->name;

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      std_compact_map_Item__1 *res = std_compact_map_Map__1_get_item(values, name);

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      if (((bool)res)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(var->sym->span, std_format("Duplicate enum variant: %s", var->sym->name), res->value, "Previous definition here"));
      } else {

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
        std_compact_map_Map__1_insert(values, name, var->sym->span);
      }
    }
  }
}


#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_globals(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_AST *node) {

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, var->sym, NULL);
}


#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(compiler_passes_register_types_RegisterTypes *this, compiler_ast_nodes_Enum *enom) {

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_span_Span span = enom->sym->span;

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->span=std_span_Span_default();

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Function, enom->sym->ns, enom->sym, "dbg", span);

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->sym->u.func=func;

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->return_type=compiler_ast_program_Program_get_type_by_name(this->o->program, "str", span);

#line 66 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->kind=compiler_ast_nodes_FunctionKind_Method;

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->parent_type=enom->type;

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(enom->type);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  var->sym=compiler_ast_scopes_Symbol_from_local_variable("this", var, span);

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_vector_Vector__3_push(func->params, var);

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, span);

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->u.func=(compiler_types_FunctionType){.orig=func, .params=func->params, .return_type=func->return_type, .is_variadic=func->is_variadic};

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->type=typ;

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_map_Map__8_insert(enom->type->methods, "dbg", func);
}


#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_namespace(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns) {

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_vector_Iterator__14 _i219 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i219); std_vector_Iterator__14_next(&_i219)) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i219);

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_struct(this, ns, struc);
    }
  }

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_vector_Iterator__15 _i220 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i220); std_vector_Iterator__15_next(&_i220)) {

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i220);

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_enum(this, ns, enom);

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_add_dbg_method_for_enum(this, enom);
    }
  }

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_vector_Iterator__16 _i221 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i221); std_vector_Iterator__16_next(&_i221)) {

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i221);

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_globals(this, node);
    }
  }

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_vector_Iterator__16 _i222 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i222); std_vector_Iterator__16_next(&_i222)) {

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i222);

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_globals(this, node);
    }
  }

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_map_Iterator__2 _i223 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i223); std_map_Iterator__2_next(&_i223)) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i223);

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_alias(this, it->key, it->value);
    }
  }

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_map_ValueIterator__3 _i224 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i224); std_map_ValueIterator__3_next(&_i224)) {

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i224);

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      if (child->always_add_to_scope) {

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
        compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, child->sym, NULL);
      }

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_register_namespace(this, child);
    }
  }

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_base_type(compiler_passes_register_types_RegisterTypes *this, compiler_types_BaseType base) {

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  char *name = compiler_types_BaseType_str(base);

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, name, name, name, std_span_Span_default());

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(base, std_span_Span_default());

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->sym=sym;

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  sym->u.type_def=typ;

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_map_Map__4_insert(this->o->program->global->scope->items, name, sym);
}


#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_alias(compiler_passes_register_types_RegisterTypes *this, char *name, compiler_types_Type *orig) {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, name, name, name, std_span_Span_default());

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *alias = compiler_types_Type_new_resolved(compiler_types_BaseType_Alias, std_span_Span_default());

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  alias->name=name;

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  alias->u.ptr=orig;

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  alias->sym=sym;

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  sym->u.type_def=alias;

#line 131 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, sym, name);
}


#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_print_function(compiler_passes_register_types_RegisterTypes *this, char *name) {

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Function, NULL, name, name, name, std_span_Span_default());

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->sym=sym;

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->sym->u.func=func;

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_vector_Vector__3 *params = std_vector_Vector__3_new(16);

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_nodes_Variable *param = compiler_ast_nodes_Variable_new(compiler_ast_program_Program_get_type_by_name(this->o->program, "str", std_span_Span_default()));

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  param->sym=compiler_ast_scopes_Symbol_from_local_variable("fmt", param, std_span_Span_default());

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  std_vector_Vector__3_push(params, param);

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->params=params;

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->is_variadic=true;

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->is_variadic_format=true;

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, std_span_Span_default());

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  typ->u.func=(compiler_types_FunctionType){.orig=func, .params=params, .return_type=compiler_ast_program_Program_get_type_by_name(this->o->program, "void", std_span_Span_default()), .is_variadic=true};

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  func->type=typ;

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, sym, name);
}


#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_builtin_types(compiler_passes_register_types_RegisterTypes *this) {

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (u32 i = 0; i < ((u32)compiler_types_BaseType_NUM_BASE_TYPES); i+=1) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_passes_register_types_RegisterTypes_register_base_type(this, ((compiler_types_BaseType)i));
  }

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, this->o->program->global->scope);

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_types_Type *base = compiler_ast_program_Program_get_base_type(this->o->program, compiler_types_BaseType_Void, std_span_Span_default());

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_default());

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    typ->u.ptr=base;

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_passes_register_types_RegisterTypes_register_alias(this, "untyped_ptr", typ);
  }

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  {

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_types_Type *base = compiler_ast_program_Program_get_base_type(this->o->program, compiler_types_BaseType_Char, std_span_Span_default());

#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_default());

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    typ->u.ptr=base;

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_passes_register_types_RegisterTypes_register_alias(this, "str", typ);
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "print");

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "println");

#line 183 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "eprint");

#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_print_function(this, "eprintln");

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
compiler_passes_register_types_Finder compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder this, char *name) {

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if (!(((bool)this.sym))) {

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    return this;
  }

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol(this.o, this.sym, name, true);

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if (((bool)res)) {

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    switch ((res->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_293_0:
        {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
          this.type=res->u.type_def;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_293_1:
        {

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
          this.type=res->u.struc->type;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_293_2:
        {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
          this.type=res->u.enom->type;
        } break;
      default:
        {

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
          this.type=NULL;
        } break;
    }
  } else {

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_errors_Error_panic(compiler_passes_generic_pass_GenericPass_error(this.o, compiler_errors_Error_new_note(this.sym->span, std_format("Could not find %s::%s", this.sym->display, name), "The compiler expects this internally (in RegisterTypes)")));
  }

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  this.sym=res;

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  return this;
}


#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_register_cached_types(compiler_passes_register_types_RegisterTypes *this) {

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_Finder finder = (compiler_passes_register_types_Finder){.o=this->o, .sym=this->o->program->global->sym, .type=NULL};

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *fmt_string_fn = compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(finder, "std"), "format").sym;

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *alloc_fn = compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(finder, "std"), "mem"), "state"), "alloc_fn").sym;

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Symbol *allocator = compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(compiler_passes_register_types_Finder_to(finder, "std"), "mem"), "state"), "allocator").sym;

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if(!(alloc_fn->type==compiler_ast_scopes_SymbolType_Variable && alloc_fn->u.var->type->base==compiler_types_BaseType_FunctionPtr)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:226:12: Assertion failed: `alloc_fn.type == Variable and alloc_fn.u.var.type.base == FunctionPtr`", NULL); }

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if(!(allocator->type==compiler_ast_scopes_SymbolType_Variable)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:227:12: Assertion failed: `allocator.type == Variable`", NULL); }

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if(!(alloc_fn->u.var->type->u.func.params->size==2)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc:228:12: Assertion failed: `alloc_fn.u.var.type.u.func.params.size == 2`", NULL); }

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  this->o->program->cached_symbols=(compiler_ast_program_CachedSymbols){.fmt_string_fn=fmt_string_fn, .mem_alloc_fn=alloc_fn, .mem_allocator=allocator};
}


#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_create_namespace_scopes(compiler_passes_register_types_RegisterTypes *this, compiler_ast_program_Namespace *ns, compiler_ast_program_Namespace *parent) {

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_ast_scopes_Scope *parent_scope = ({ compiler_ast_scopes_Scope *__yield_0;

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    if (!(((bool)parent))) {
      __yield_0 = NULL;
    } else if (parent->is_dir_with_mod) {
      __yield_0 = parent->scope->parent;
    } else {
      __yield_0 = parent->scope;
    }

  __yield_0; });

#line 244 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  ns->scope=compiler_ast_scopes_Scope_new(parent_scope);

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  for (std_map_ValueIterator__3 _i225 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i225); std_map_ValueIterator__3_next(&_i225)) {

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i225);

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    {

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
      compiler_passes_register_types_RegisterTypes_create_namespace_scopes(this, child, ns);
    }
  }
}


#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
void compiler_passes_register_types_RegisterTypes_run(compiler_ast_program_Program *program) {

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes pass = (compiler_passes_register_types_RegisterTypes){.o=compiler_passes_generic_pass_GenericPass_new(program)};

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_create_namespace_scopes(&pass, program->global, NULL);

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_builtin_types(&pass);

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  compiler_passes_register_types_RegisterTypes_register_namespace(&pass, program->global);

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
  if (program->include_stdlib) {

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    compiler_passes_register_types_RegisterTypes_register_cached_types(&pass);

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/register_types.oc"
    program->did_cache_symbols=true;
  }
}


#line 23 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
compiler_passes_mark_dead_code_MarkDeadCode *compiler_passes_mark_dead_code_MarkDeadCode_new(compiler_ast_program_Program *program) {

#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode *pass = std_mem_alloc__0(1);

#line 25 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  (*pass)=(compiler_passes_mark_dead_code_MarkDeadCode){.o=compiler_passes_generic_pass_GenericPass_new(program), .done=std_set_Set__0_new()};

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  return pass;
}


#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_free(compiler_passes_mark_dead_code_MarkDeadCode *this) {

#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_set_Set__0_free(this->done);

#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_mem_free(this->o);

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_mem_free(this);
}


#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)sym))) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  sym->is_dead=false;

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Function:
    m_294_0:
      {

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_294_1:
      {

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_294_2:
      {

#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Constant:
    case compiler_ast_scopes_SymbolType_Variable:
    m_294_3:
      {

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, sym->u.var->type);

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, sym->u.var->default_value);

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        sym->u.var->sym->is_dead=false;
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_294_4:
      {

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, sym->u.closure);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_294_5:
      {

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, sym->u.type_def);
      } break;
    case compiler_ast_scopes_SymbolType_ClosedVariable:
    m_294_6:
      {

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, sym->u.closed_var.orig->sym);
      } break;
    default:
      {
      } break;
  }
}


#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Function *f) {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)f)) || std_set_Set__0_contains(this->done, ((u64)f))) {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_set_Set__0_add(this->done, ((u64)f));

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  f->sym->is_dead=false;

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_mark(this, f->body);

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__3 _i67 = std_vector_Vector__3_iter(f->params); std_vector_Iterator__3_has_value(&_i67); std_vector_Iterator__3_next(&_i67)) {

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i67);

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, param->type);
    }
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, f->type->sym);

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, f->return_type);
}


#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_type(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_types_Type *typ) {

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)typ))) {

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  switch ((typ->base)) {
    case compiler_types_BaseType_Pointer:
    case compiler_types_BaseType_Alias:
    m_295_0:
      {

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, typ->u.ptr);
      } break;
    case compiler_types_BaseType_Array:
    m_295_1:
      {

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, typ->u.arr.elem_type);
      } break;
    case compiler_types_BaseType_FunctionPtr:
    case compiler_types_BaseType_Closure:
    m_295_2:
      {

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_types_FunctionType ft = typ->u.func;

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, ft.return_type);

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__3 _i68 = std_vector_Vector__3_iter(ft.params); std_vector_Iterator__3_has_value(&_i68); std_vector_Iterator__3_next(&_i68)) {

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i68);

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, param->type);
          }
        }
      } break;
    default:
      {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, typ->sym);

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        if (((bool)typ->template_instance)) {

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          for (std_vector_Iterator__0 _i69 = std_vector_Vector__0_iter(typ->template_instance->args); std_vector_Iterator__0_has_value(&_i69); std_vector_Iterator__0_next(&_i69)) {

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_types_Type *arg = std_vector_Iterator__0_cur(&_i69);

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
              compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, arg);
            }
          }
        }
      } break;
  }
}


#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_struct(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Structure *s) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)s)) || std_set_Set__0_contains(this->done, ((u64)s))) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_set_Set__0_add(this->done, ((u64)s));

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  s->sym->is_dead=false;

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__3 _i70 = std_vector_Vector__3_iter(s->fields); std_vector_Iterator__3_has_value(&_i70); std_vector_Iterator__3_next(&_i70)) {

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i70);

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, field->type);
    }
  }
}


#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_enum(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_Enum *e) {

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)e)) || std_set_Set__0_contains(this->done, ((u64)e))) {

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  std_set_Set__0_add(this->done, ((u64)e));

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  e->sym->is_dead=false;

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__20 _i71 = std_vector_Vector__20_iter(e->variants); std_vector_Iterator__20_has_value(&_i71); std_vector_Iterator__20_next(&_i71)) {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_nodes_EnumVariant *var = std_vector_Iterator__20_cur(&_i71);

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, var->sym);

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__3 _i72 = std_vector_Vector__3_iter(var->specific_fields); std_vector_Iterator__3_has_value(&_i72); std_vector_Iterator__3_next(&_i72)) {

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i72);

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, field->sym);

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, field->type);

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark(this, field->default_value);
        }
      }
    }
  }

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__3 _i73 = std_vector_Vector__3_iter(e->shared_fields); std_vector_Iterator__3_has_value(&_i73); std_vector_Iterator__3_next(&_i73)) {

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_nodes_Variable *var = std_vector_Iterator__3_cur(&_i73);

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, var->sym);

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, var->type);

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark(this, var->default_value);
    }
  }
}


#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_nodes_AST *node) {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)node))) {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, node->resolved_symbol);

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Import:
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    case compiler_ast_nodes_ASTType_IntLiteral:
    case compiler_ast_nodes_ASTType_FloatLiteral:
    case compiler_ast_nodes_ASTType_BoolLiteral:
    case compiler_ast_nodes_ASTType_StringLiteral:
    case compiler_ast_nodes_ASTType_CharLiteral:
    case compiler_ast_nodes_ASTType_Null:
    m_296_0:
      {
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    case compiler_ast_nodes_ASTType_Defer:
    m_296_1:
      {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_296_2:
      {

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.child);

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        if (this->o->program->did_cache_symbols) {

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.mem_alloc_fn);

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.mem_allocator);
        }
      } break;
    case compiler_ast_nodes_ASTType_Return:
    m_296_3:
      {

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.ret.expr);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_296_4:
      {

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.unary.expr);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_296_5:
      {

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, node->u.size_of_type);
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_296_6:
      {

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, node->u.var_decl->sym);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_296_7:
      {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__16 _i74 = std_vector_Vector__16_iter(node->u.block.statements); std_vector_Iterator__16_has_value(&_i74); std_vector_Iterator__16_next(&_i74)) {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_AST *statement = std_vector_Iterator__16_cur(&_i74);

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, statement);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_296_8:
      {

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, node->u.closure);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_296_9:
      {

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__23 _i75 = std_vector_Vector__23_iter(node->u.if_stmt.branches); std_vector_Iterator__23_has_value(&_i75); std_vector_Iterator__23_next(&_i75)) {

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i75);

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, branch.cond);

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, branch.body);
          }
        }

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.if_stmt.els);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_296_10:
      {

#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.match_stmt.expr);

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__24 _i76 = std_vector_Vector__24_iter(node->u.match_stmt.cases); std_vector_Iterator__24_has_value(&_i76); std_vector_Iterator__24_next(&_i76)) {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_MatchCase c = std_vector_Iterator__24_cur(&_i76);

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            for (std_vector_Iterator__10 _i77 = std_vector_Vector__10_iter(c.conds); std_vector_Iterator__10_has_value(&_i77); std_vector_Iterator__10_next(&_i77)) {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
              compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i77);

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
              {

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
                compiler_passes_mark_dead_code_MarkDeadCode_mark(this, cond->expr);

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
                if (((bool)cond->cmp_fn)) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
                  compiler_passes_mark_dead_code_MarkDeadCode_mark_function(this, cond->cmp_fn);
                }
              }
            }

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, c.body);
          }
        }

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.match_stmt.defolt);
      } break;
    case compiler_ast_nodes_ASTType_While:
    case compiler_ast_nodes_ASTType_For:
    m_296_11:
      {

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.init);

#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.cond);

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.step);

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.loop.body);
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_296_12:
      {

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.assertion.expr);

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.assertion.msg);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_296_13:
      {

#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        if (this->o->program->did_cache_symbols) {

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(this, this->o->program->cached_symbols.fmt_string_fn);
        }

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__16 _i78 = std_vector_Vector__16_iter(node->u.fmt_str.exprs); std_vector_Iterator__16_has_value(&_i78); std_vector_Iterator__16_next(&_i78)) {

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_AST *expr = std_vector_Iterator__16_cur(&_i78);

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_296_14:
      {

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.member.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_Specialization:
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_296_15:
      {
      } break;
    case compiler_ast_nodes_ASTType_NSLookup:
    m_296_16:
      {

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.lookup.lhs);
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_296_17:
      {

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.call.callee);

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__7 _i79 = std_vector_Vector__7_iter(node->u.call.args); std_vector_Iterator__7_has_value(&_i79); std_vector_Iterator__7_next(&_i79)) {

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_Argument *arg = std_vector_Iterator__7_cur(&_i79);

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, arg->expr);
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_296_18:
      {

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.binary.lhs);

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.binary.rhs);
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_296_19:
      {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark(this, node->u.cast.lhs);

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_type(this, node->u.cast.to);
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_296_20:
      {

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        for (std_vector_Iterator__16 _i80 = std_vector_Vector__16_iter(node->u.array_literal.elements); std_vector_Iterator__16_has_value(&_i80); std_vector_Iterator__16_next(&_i80)) {

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_ast_nodes_AST *expr = std_vector_Iterator__16_cur(&_i80);

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          {

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            compiler_passes_mark_dead_code_MarkDeadCode_mark(this, expr);
          }
        }
      } break;
    default:
      {

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(node->span, std_format("Unhandled expression type in MarkDeadCode: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
      } break;
  }
}


#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
compiler_ast_nodes_Function *compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_program_Program *program) {

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (compiler_ast_program_NSIterator _i81 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i81); compiler_ast_program_NSIterator_next(&_i81)) {

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i81);

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__6 _i82 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i82); std_vector_Iterator__6_next(&_i82)) {

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_Function *f = std_vector_Iterator__6_cur(&_i82);

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          if (str_eq(f->sym->full_name, "main")) {

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
            return f;
          }
        }
      }
    }
  }

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  return NULL;
}


#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(compiler_passes_mark_dead_code_MarkDeadCode *this, compiler_ast_scopes_Symbol *sym) {

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)sym))) {

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    return;
  }

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  sym->is_dead=true;

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (((bool)sym->template)) {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    for (std_vector_Iterator__4 _i83 = std_vector_Vector__4_iter(sym->template->instances); std_vector_Iterator__4_has_value(&_i83); std_vector_Iterator__4_next(&_i83)) {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__4_cur(&_i83);

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      {

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(this, instance->resolved);
      }
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
void compiler_passes_mark_dead_code_MarkDeadCode_run(compiler_ast_program_Program *program) {

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode *pass = compiler_passes_mark_dead_code_MarkDeadCode_new(program);

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_ast_nodes_Function *main = compiler_passes_mark_dead_code_MarkDeadCode_find_main_function(pass, program);

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (!(((bool)main)) && std_vector_Vector__9_is_empty(program->explicit_alive_symbols)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    printf("[+] No alive functions found, not marking any functions as dead.""\n");

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    /* defers */

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
    return;
  }

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (program->keep_all_code) {

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    /* defers */

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
    return;
  }

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (compiler_ast_program_NSIterator _i84 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i84); compiler_ast_program_NSIterator_next(&_i84)) {

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i84);

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__6 _i85 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i85); std_vector_Iterator__6_next(&_i85)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_Function *f = std_vector_Iterator__6_cur(&_i85);

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, f->sym);
        }
      }

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__14 _i86 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i86); std_vector_Iterator__14_next(&_i86)) {

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_Structure *s = std_vector_Iterator__14_cur(&_i86);

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 261 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, s->sym);
        }
      }

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__15 _i87 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i87); std_vector_Iterator__15_next(&_i87)) {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_Enum *e = std_vector_Iterator__15_cur(&_i87);

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, e->sym);
        }
      }

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__16 _i88 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i88); std_vector_Iterator__16_next(&_i88)) {

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_AST *v = std_vector_Iterator__16_cur(&_i88);

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, v->u.var_decl->sym);
        }
      }

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      for (std_vector_Iterator__16 _i89 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i89); std_vector_Iterator__16_next(&_i89)) {

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        compiler_ast_nodes_AST *c = std_vector_Iterator__16_cur(&_i89);

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
        {

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
          compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, c->u.var_decl->sym);
        }
      }
    }
  }

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__0 _i90 = std_vector_Vector__0_iter(program->closure_types); std_vector_Iterator__0_has_value(&_i90); std_vector_Iterator__0_next(&_i90)) {

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_types_Type *cty = std_vector_Iterator__0_cur(&_i90);

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, cty->sym);
    }
  }

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__6 _i91 = std_vector_Vector__6_iter(program->closures); std_vector_Iterator__6_has_value(&_i91); std_vector_Iterator__6_next(&_i91)) {

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_nodes_Function *clos = std_vector_Iterator__6_cur(&_i91);

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 277 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym_as_dead_by_default(pass, clos->sym);
    }
  }

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  if (((bool)main)) {

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_passes_mark_dead_code_MarkDeadCode_mark_function(pass, main);
  }

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  for (std_vector_Iterator__9 _i92 = std_vector_Vector__9_iter(program->explicit_alive_symbols); std_vector_Iterator__9_has_value(&_i92); std_vector_Iterator__9_next(&_i92)) {

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__9_cur(&_i92);

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
    {

#line 285 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
      compiler_passes_mark_dead_code_MarkDeadCode_mark_sym(pass, sym);
    }
  }
  /* defers */

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/mark_dead_code.oc"
  compiler_passes_mark_dead_code_MarkDeadCode_free(pass);
}


#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_passes_generic_pass_GenericPass *compiler_passes_generic_pass_GenericPass_new(compiler_ast_program_Program *program) {

#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  compiler_passes_generic_pass_GenericPass *pass = std_mem_alloc__1(1);

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  pass->scope_stack=std_vector_Vector__1_new(16);

#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  pass->namespace_stack=std_vector_Vector__2_new(16);

#line 37 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  pass->program=program;

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  pass->error_type=compiler_types_Type_new_resolved(compiler_types_BaseType_Error, std_span_Span_default());

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return pass;
}


#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_push_scope(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Scope *scope) {

#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_vector_Vector__1_push(this->scope_stack, scope);
}


#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_push_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns) {

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_vector_Vector__2_push(this->namespace_stack, ns);
}


#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_pop_scope(compiler_passes_generic_pass_GenericPass *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (this->scope_stack->size==0) {

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return NULL;
  }

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return ((compiler_ast_scopes_Scope *)std_vector_Vector__1_pop(this->scope_stack));
}


#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_pop_namespace(compiler_passes_generic_pass_GenericPass *this) {

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (this->namespace_stack->size==0) {

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return NULL;
  }

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return ((compiler_ast_program_Namespace *)std_vector_Vector__2_pop(this->namespace_stack));
}


#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_scopes_Scope *compiler_passes_generic_pass_GenericPass_scope(compiler_passes_generic_pass_GenericPass *this) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (this->scope_stack->size==0) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return NULL;
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return std_vector_Vector__1_at(this->scope_stack, (this->scope_stack->size - 1));
}


#line 66 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_program_Namespace *compiler_passes_generic_pass_GenericPass_ns(compiler_passes_generic_pass_GenericPass *this) {

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (this->namespace_stack->size==0) {

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return NULL;
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return std_vector_Vector__2_at(this->namespace_stack, (this->namespace_stack->size - 1));
}


#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_errors_Error *compiler_passes_generic_pass_GenericPass_error(compiler_passes_generic_pass_GenericPass *this, compiler_errors_Error *err) {

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_vector_Vector__13_push(this->program->errors, err);

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return err;
}


#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(compiler_passes_generic_pass_GenericPass *this, bool export, compiler_ast_scopes_Symbol *item, char *name) {

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (!(((bool)name))) {

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    name=item->name;
  }

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  compiler_ast_scopes_Symbol *prev = compiler_ast_scopes_Scope_lookup_local(compiler_passes_generic_pass_GenericPass_scope(this), name);

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (((bool)prev)) {

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(item->span, std_format("Name %s already exists in scope", name), prev->span, std_format("Previous use of %s", name)));

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return;
  }

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  compiler_ast_scopes_Scope_insert(compiler_passes_generic_pass_GenericPass_scope(this), name, item);

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (!(export)) {

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_map_Map__4 *exported = compiler_passes_generic_pass_GenericPass_ns(this)->exported_symbols;

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_map_Item__4 *it = std_map_Map__4_get_item(exported, name);

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (((bool)it)) {

#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(item->span, std_format("Name %s already exported from namespace", name), it->value->span, std_format("Previous export of %s", name)));

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return;
  }

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  std_map_Map__4_insert(compiler_passes_generic_pass_GenericPass_ns(this)->exported_symbols, name, item);
}


#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *item, char *name) {

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, false, item, name);
}


#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, bool allow_templated) {
  return ({ compiler_ast_scopes_Symbol *__yield_0;

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_Namespace:
      m_297_0:
        {
          __yield_0 = compiler_ast_program_Namespace_find_importable_symbol(sym->u.ns, name);
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_297_1:
        {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          if (compiler_ast_scopes_Symbol_is_templated(sym) && !(allow_templated)) {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            return NULL;
          }

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Structure *struc = sym->u.struc;

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Function *method = std_map_Map__8_get(struc->type->methods, name, NULL);

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          if (!(((bool)method))) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            return NULL;
          }

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          __yield_0 = method->sym;
        } break;
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_297_2:
        {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_types_Type *type_def = sym->u.type_def;

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Function *method = std_map_Map__8_get(type_def->methods, name, NULL);

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          if (!(((bool)method))) {

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            return NULL;
          }

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          __yield_0 = method->sym;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_297_3:
        {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Enum *enom = sym->u.enom;

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_Enum_get_variant(enom, name);

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          if (((bool)variant)) {

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            return variant->sym;
          }

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Function *method = std_map_Map__8_get(enom->type->methods, name, NULL);

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          if (((bool)method)) {

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            return method->sym;
          }

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          __yield_0 = NULL;
        } break;
      default:
        {
          __yield_0 = NULL;
        } break;
    }

  __yield_0; });}


#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
compiler_ast_scopes_Symbol *compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, char *name, std_span_Span span, bool error) {

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (error && compiler_ast_scopes_Symbol_is_templated(sym)) {

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new_hint(span, std_format("Need to specify template specialization for %s", sym->display), sym->span, std_format("Template was defined here")));
  }

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol(this, sym, name, true);

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  if (((bool)res) || !(error)) {

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    return res;
  }

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Namespace:
    m_298_0:
      {

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find symbol %s in namespace %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_298_1:
      {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find method %s in structure %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_298_2:
      {

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find method %s in type %s", name, sym->display)));
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_298_3:
      {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Could not find variant/method %s in enum %s", name, sym->display)));
      } break;
    default:
      {

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(span, std_format("Can't lookup a name inside a %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));
      } break;
  }

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  return NULL;
}


#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_import_all_from_namespace(compiler_passes_generic_pass_GenericPass *this, compiler_ast_program_Namespace *ns, bool export) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_vector_Iterator__6 _i100 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i100); std_vector_Iterator__6_next(&_i100)) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i100);

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      if (func->kind != compiler_ast_nodes_FunctionKind_Method) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, func->sym, NULL);
      }
    }
  }

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_vector_Iterator__14 _i101 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i101); std_vector_Iterator__14_next(&_i101)) {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i101);

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, struc->sym, NULL);
    }
  }

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_vector_Iterator__15 _i102 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i102); std_vector_Iterator__15_next(&_i102)) {

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i102);

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, enom->sym, NULL);
    }
  }

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_vector_Iterator__16 _i103 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i103); std_vector_Iterator__16_next(&_i103)) {

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i103);

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, var->sym, NULL);
    }
  }

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_vector_Iterator__16 _i104 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i104); std_vector_Iterator__16_next(&_i104)) {

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i104);

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, var->sym, NULL);
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_map_Iterator__2 _i105 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i105); std_map_Iterator__2_next(&_i105)) {

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i105);

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, it->value->sym, it->key);
    }
  }

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  for (std_map_Iterator__4 _i106 = std_map_Map__4_iter(ns->exported_symbols); std_map_Iterator__4_has_value(&_i106); std_map_Iterator__4_next(&_i106)) {

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    std_map_Item__4 *it = std_map_Iterator__4_cur(&_i106);

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
    {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
      compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, it->value, it->key);
    }
  }
}


#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
void compiler_passes_generic_pass_GenericPass_import_all_from_symbol(compiler_passes_generic_pass_GenericPass *this, compiler_ast_scopes_Symbol *sym, bool export) {

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Namespace:
    m_299_0:
      {

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_import_all_from_namespace(this, sym->u.ns, export);
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_299_1:
      {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        for (std_map_ValueIterator__8 _i107 = std_map_Map__8_iter_values(sym->u.type_def->methods); std_map_ValueIterator__8_has_value(&_i107); std_map_ValueIterator__8_next(&_i107)) {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Function *method = std_map_ValueIterator__8_cur(&_i107);

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          {

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, method->sym, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Structure:
    m_299_2:
      {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        for (std_map_ValueIterator__8 _i108 = std_map_Map__8_iter_values(sym->u.struc->type->methods); std_map_ValueIterator__8_has_value(&_i108); std_map_ValueIterator__8_next(&_i108)) {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_Function *method = std_map_ValueIterator__8_cur(&_i108);

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          {

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, method->sym, NULL);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_299_3:
      {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        for (std_vector_Iterator__20 _i109 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i109); std_vector_Iterator__20_next(&_i109)) {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i109);

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
          {

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked_and_export(this, export, variant->sym, NULL);
          }
        }
      } break;
    default:
      {

#line 209 "/Users/mustafa/ocen-lang/ocen/compiler/passes/generic_pass.oc"
        compiler_passes_generic_pass_GenericPass_error(this, compiler_errors_Error_new(sym->span, std_format("Can't imdo wildcard import from a %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));
      } break;
  }
}


#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_errors_Error *compiler_passes_typechecker_TypeChecker_error(compiler_passes_typechecker_TypeChecker *this, compiler_errors_Error *err) {
  return compiler_passes_generic_pass_GenericPass_error(this->o, err);}


#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_ast_scopes_Scope *compiler_passes_typechecker_TypeChecker_scope(compiler_passes_typechecker_TypeChecker *this) {
  return compiler_passes_generic_pass_GenericPass_scope(this->o);}


#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_base_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_BaseType base, std_span_Span span) {
  return compiler_ast_program_Program_get_base_type(this->o->program, base, span);}


#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_type_by_name(compiler_passes_typechecker_TypeChecker *this, char *name, std_span_Span span) {
  return compiler_ast_program_Program_get_type_by_name(this->o->program, name, span);}


#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_set_resolved_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->resolved_symbol=sym;

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (node->type==compiler_ast_nodes_ASTType_Import) {

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_ReferenceType ref_type = compiler_ast_scopes_ReferenceType_Normal;

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_span_Span span = ({ std_span_Span __yield_0;

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_300_0:
        {
          __yield_0 = node->span;
        } break;
      case compiler_ast_nodes_ASTType_Import:
      case compiler_ast_nodes_ASTType_Specialization:
      m_300_1:
        {

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        } break;
      case compiler_ast_nodes_ASTType_OverloadedOperator:
      m_300_2:
        {

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          ref_type=compiler_ast_scopes_ReferenceType_OperatorOverload;

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = node->u.operator_span;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_300_3:
        {
          __yield_0 = node->u.lookup.rhs_span;
        } break;
      case compiler_ast_nodes_ASTType_Member:
      m_300_4:
        {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (str_eq(sym->name, "this") && node->u.member.dot_shorthand) {

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            ref_type=compiler_ast_scopes_ReferenceType_DotShorthand;
          }

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = node->u.member.rhs_span;
        } break;
      default:
        {

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:64:20: Assertion failed: `false`", std_format("Unhandled node type in set_resolved_symbol: %s", compiler_ast_nodes_ASTType_dbg(node->type))); exit(1); }
        } break;
    }

  __yield_0; });

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)sym) && !(this->in_template_instance)) {

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol_add_reference(sym, ref_type, span);
  }
}


#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_get_closure_type(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__3 *params, compiler_types_Type *return_type, compiler_types_Type *old) {

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *canon = compiler_ast_program_Program_find_closure_type(this->o->program, params, return_type);

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)canon))) {

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_span_Span span = (((bool)old) ? old->span : std_span_Span_default());

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)old)) {

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_FunctionType func_ty = old->u.func;

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      canon=compiler_types_Type_shallow_copy(old);

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      canon->u.func=(compiler_types_FunctionType){.orig=func_ty.orig, .params=params, .return_type=return_type, .is_variadic=func_ty.is_variadic};
    } else {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      canon=compiler_types_Type_new_resolved(compiler_types_BaseType_Closure, span);

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      canon->u.func=(compiler_types_FunctionType){.orig=NULL, .params=params, .return_type=return_type, .is_variadic=false};
    }

#line 89 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    char *closure_name = std_format("_ClosureTy_%u", this->o->program->closure_types->size);

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__0_push(this->o->program->closure_types, canon);

#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_ClosureType, NULL, closure_name, closure_name, closure_name, span);

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    sym->u.type_def=canon;

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    canon->sym=sym;
  }

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return canon;
}


#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_resolve_type(compiler_passes_typechecker_TypeChecker *this, compiler_types_Type *old, bool allow_incomplete, bool error, bool resolve_templates) {

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool p_a = allow_incomplete;

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool p_e = error;

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool p_r = resolve_templates;

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *resolved = old;

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)old))) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((old->base)) {
    case compiler_types_BaseType_Pointer:
    m_301_0:
      {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *ptr = compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.ptr, p_a, p_e, p_r);

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)ptr))) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((ptr->base)) {
          case compiler_types_BaseType_Char:
          m_302_0:
            {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              resolved=compiler_ast_program_Program_get_type_by_name(this->o->program, "str", old->span);
            } break;
          case compiler_types_BaseType_Void:
          m_302_1:
            {

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              resolved=compiler_ast_program_Program_get_type_by_name(this->o->program, "untyped_ptr", old->span);
            } break;
          default:
            {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              resolved=compiler_types_Type_shallow_copy(old);

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              resolved->u.ptr=ptr;
            } break;
        }
      } break;
    case compiler_types_BaseType_Alias:
    m_301_1:
      {

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)old->u.ptr))) {

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(old->span, "This type does not point to anything", "Cannot use a typedef for a type when defining any of it's members.\nUse fully qualified type for all field / method definitions."));

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_resolve_type(this, old->u.ptr, p_a, p_e, p_r);
      } break;
    case compiler_types_BaseType_Closure:
    case compiler_types_BaseType_FunctionPtr:
    m_301_2:
      {

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_vector_Vector__3 *checked_params = std_vector_Vector__3_new(16);

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_FunctionType func = old->u.func;

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        for (std_vector_Iterator__3 _i153 = std_vector_Vector__3_iter(func.params); std_vector_Iterator__3_has_value(&_i153); std_vector_Iterator__3_next(&_i153)) {

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Variable *var = std_vector_Iterator__3_cur(&_i153);

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          {

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            var->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, p_a, p_e, p_r);

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (!(((bool)var->type))) {

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            }

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            std_vector_Vector__3_push(checked_params, var);
          }
        }

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *return_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, func.return_type, p_a, p_e, p_r);

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)return_type))) {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (old->base==compiler_types_BaseType_Closure) {

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          resolved=compiler_passes_typechecker_TypeChecker_get_closure_type(this, checked_params, return_type, old);
        } else {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          resolved=compiler_types_Type_shallow_copy(old);

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          resolved->u.func=(compiler_types_FunctionType){.orig=func.orig, .params=checked_params, .return_type=return_type, .is_variadic=func.is_variadic};
        }
      } break;
    case compiler_types_BaseType_Unresolved:
    m_301_3:
      {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *node = old->u.unresolved;

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *res = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, p_e, NULL, p_r);

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)res)) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          switch ((res->type)) {
            case compiler_ast_scopes_SymbolType_TypeDef:
            m_303_0:
              {

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                resolved=compiler_passes_typechecker_TypeChecker_resolve_type(this, res->u.type_def, p_a, p_e, p_r);
              } break;
            case compiler_ast_scopes_SymbolType_Structure:
            m_303_1:
              {

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_ast_nodes_Structure *struc = res->u.struc;

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (compiler_ast_scopes_Symbol_is_templated(res) && !(allow_incomplete)) {

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if (error) {

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Cannot use templated struct %s as a type", struc->sym->name)));
                  }

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  return resolved;
                }

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                resolved=res->u.struc->type;

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (node->type==compiler_ast_nodes_ASTType_Specialization && compiler_ast_scopes_Symbol_is_templated(res)) {

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if(!(!(resolve_templates))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:178:36: Assertion failed: `not resolve_templates`", "Should have been errored in resolve_scoped_identifier"); }

#line 179 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_UnresolvedTemplate, node->span);

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  type->u.unresolved_spec=(compiler_types_UnresolvedTemplate){.base=resolved, .args=node->u.spec.template_args};

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  resolved=type;
                }
              } break;
            case compiler_ast_scopes_SymbolType_Function:
            m_303_2:
              {

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_ast_nodes_Function *func = res->u.func;

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (compiler_ast_scopes_Symbol_is_templated(res) && !(allow_incomplete)) {

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if (error) {

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Cannot use templated function %s as a type", func->sym->name)));
                  }

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  return resolved;
                }

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                resolved=res->u.func->type;

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (node->type==compiler_ast_nodes_ASTType_Specialization && compiler_ast_scopes_Symbol_is_templated(res)) {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if(!(!(resolve_templates))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:194:36: Assertion failed: `not resolve_templates`", "Should have been errored in resolve_scoped_identifier"); }

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_UnresolvedTemplate, node->span);

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  type->u.unresolved_spec=(compiler_types_UnresolvedTemplate){.base=resolved, .args=node->u.spec.template_args};

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  resolved=type;
                }
              } break;
            case compiler_ast_scopes_SymbolType_Enum:
            m_303_3:
              {

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                resolved=res->u.enom->type;
              } break;
            default:
              {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (error) {

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(res->span, std_format("Cannot use %s as a type", res->display)));

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  resolved=NULL;
                }
              } break;
          }
        } else {

#line 209 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (error) {

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            resolved=NULL;
          }
        }
      } break;
    case compiler_types_BaseType_Array:
    m_301_4:
      {

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_ArrayType arr = old->u.arr;

#line 216 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *elem_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, arr.elem_type, p_a, p_e, p_r);

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, arr.size_expr, NULL);

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        resolved=compiler_types_Type_shallow_copy(old);

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        resolved->u.arr.elem_type=elem_type;

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_try_infer_array_size(this, &resolved->u.arr);
      } break;
    case compiler_types_BaseType_Structure:
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    case compiler_types_BaseType_Enum:
    m_301_5:
      {
      } break;
    default:
      {

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (error) {

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(old->span, std_format("Unhandled type in resolve %s", compiler_types_BaseType_str(old->base))));

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          resolved=NULL;
        }
      } break;
  }

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return resolved;
}


#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_try_infer_array_size(compiler_passes_typechecker_TypeChecker *this, compiler_types_ArrayType *arr_typ) {

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *size_expr = arr_typ->size_expr;

#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (size_expr->type==compiler_ast_nodes_ASTType_IntLiteral) {

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)size_expr->u.num_literal.suffix)) {

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(size_expr->span, "Array size literal cannot have a suffix"));
    }

#line 244 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    arr_typ->size_known=true;

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    arr_typ->size=str_to_u32(size_expr->u.num_literal.text);
  }
}


#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_templated_struct_methods(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *old, compiler_ast_nodes_Structure *cur) {

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *old_type = old->type;

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *cur_type = cur->type;

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__8 *old_methods = old_type->methods;

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__8 *cur_methods = cur_type->methods;

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_program_Namespace *parent_ns = old->sym->ns;

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_Iterator__8 _i154 = std_map_Map__8_iter(old_methods); std_map_Iterator__8_has_value(&_i154); std_map_Iterator__8_next(&_i154)) {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Item__8 *iter = std_map_Iterator__8_cur(&_i154);

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      char *name = iter->key;

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Function *method = iter->value;

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Function *new_method = compiler_ast_program_Program_get_function_deep_copy(this->o->program, method, parent_ns);

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      new_method->parent_type=cur_type;

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__8_insert(cur_methods, name, new_method);

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_scopes_Symbol_update_parent(new_method->sym, cur_type->sym);

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__6_push(parent_ns->functions, new_method);

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(method->is_static)) {

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Variable *this_param = std_vector_Vector__3_at(new_method->params, 0);

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (this_param->type->base==compiler_types_BaseType_Pointer) {

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          this_param->type->u.ptr=cur_type;
        } else {

#line 278 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          this_param->type=cur_type;
        }
      }

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      new_method->scope=compiler_passes_typechecker_TypeChecker_scope(this);

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_function_declaration(this, new_method);

#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__6_push(this->unchecked_functions, new_method);
    }
  }
}


#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc, compiler_ast_scopes_TemplateInstance *instance) {

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Symbol *sym = instance->resolved;

#line 293 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Structure *resolved_struc = compiler_ast_program_Program_get_struct_deep_copy(this->o->program, struc, struc->sym->ns);

#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_struc->sym->template=NULL;

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_struc->sym=sym;

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  sym->u.struc=resolved_struc;

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_struc->format_spec=struc->format_spec;

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_struc->format_args=struc->format_args;

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Structure, sym->span);

#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  typ->u.struc=resolved_struc;

#line 303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_struc->type=typ;

#line 304 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  typ->sym=sym;

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  typ->template_instance=instance;

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_struct(this, resolved_struc);

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_templated_struct_methods(this, struc, resolved_struc);
}


#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_templated_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_scopes_TemplateInstance *instance) {

#line 312 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Symbol *sym = instance->resolved;

#line 313 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Function *resolved_func = compiler_ast_program_Program_get_function_deep_copy(this->o->program, func, func->sym->ns);

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_func->sym->template=NULL;

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_func->sym=sym;

#line 316 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func->parent_type)) {

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol_update_parent(sym, func->parent_type->sym);
  }

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  sym->u.func=resolved_func;

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_func->scope=compiler_passes_typechecker_TypeChecker_scope(this);

#line 322 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_function_declaration(this, resolved_func);

#line 323 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  resolved_func->type->template_instance=instance;

#line 325 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__6_push(this->unchecked_functions, resolved_func);
}


#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_find_template_instance(compiler_passes_typechecker_TypeChecker *this, std_vector_Vector__4 *template_instances, std_vector_Vector__0 *args) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__4 _i155 = std_vector_Vector__4_iter(template_instances); std_vector_Iterator__4_has_value(&_i155); std_vector_Iterator__4_next(&_i155)) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__4_cur(&_i155);

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 331 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (compiler_ast_scopes_TemplateInstance_matches(instance, args)) {

#line 331 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return instance->resolved;
      }
    }
  }

#line 333 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return NULL;
}


#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node) {

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  {

#line 339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *found = compiler_passes_typechecker_TypeChecker_find_template_instance(this, sym->template->instances, node->u.spec.template_args);

#line 340 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)found)) {

#line 340 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return found;
    }
  }

#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_program_Namespace *parent_ns = sym->ns;

#line 344 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__0 *template_args = node->u.spec.template_args;

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__9 *template_params = sym->template->params;

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (template_params->size != template_args->size) {

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Invalid number of template arguments for %s", sym->name)));

#line 349 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 353 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer new_display_name = std_buffer_Buffer_make(16);

#line 354 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer_write_str(&new_display_name, sym->name);

#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer_write_str(&new_display_name, "<");

#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(sym->ns->scope);

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);

#line 365 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool was_in_template_instance = this->in_template_instance;

#line 366 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  this->in_template_instance=true;

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"

#line 370 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < template_params->size; i+=1) {

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *sym = std_vector_Vector__9_at(template_params, i);

#line 372 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *arg = std_vector_Vector__0_at(template_args, i);

#line 374 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (i > 0) {

#line 374 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_buffer_Buffer_write_str(&new_display_name, ", ");
    }

#line 375 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_buffer_Buffer_write_str(&new_display_name, compiler_types_Type_str(arg));

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *cur_sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, NULL, sym->name, sym->name, sym->name, sym->span);

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    cur_sym->u.type_def=arg;

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, cur_sym, NULL);
  }

#line 389 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer_write_str(&new_display_name, ">");

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  char *new_out_name = std_format("%s__%u", sym->name, sym->template->instances->size);

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Symbol *new_sym = compiler_ast_scopes_Symbol_new_with_parent(sym->type, parent_ns, parent_ns->sym, new_out_name, sym->span);

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  new_sym->display=std_buffer_Buffer_str(new_display_name);

#line 396 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_TemplateInstance *instance = compiler_ast_scopes_TemplateInstance_new(template_args, sym, new_sym);

#line 397 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__4_push(sym->template->instances, instance);

#line 399 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_304_0:
      {

#line 400 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_resolve_templated_struct(this, sym->u.struc, instance);
      } break;
    case compiler_ast_scopes_SymbolType_Function:
    m_304_1:
      {

#line 401 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_resolve_templated_function(this, sym->u.func, instance);
      } break;
    default:
      {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot specialize non-templated symbol %s", sym->name)));

#line 404 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        /* defers */

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        this->in_template_instance=was_in_template_instance;
        return NULL;
      } break;
  }

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);

#line 409 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  /* defers */

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  this->in_template_instance=was_in_template_instance;
  return new_sym;
}


#line 413 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_ast_scopes_Symbol *compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool error, compiler_types_Type *hint, bool resolve_templates) {

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_NSLookup:
    m_305_0:
      {

#line 416 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_span_Span lhs_span = node->u.lookup.lhs->span;

#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *lhs = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node->u.lookup.lhs, error, NULL, resolve_templates);

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)lhs))) {

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 420 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        char *name = node->u.lookup.rhs_name;

#line 421 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)name))) {

#line 421 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *res = compiler_passes_generic_pass_GenericPass_find_in_symbol_or_error(this->o, lhs, name, node->span, error);

#line 424 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, res);

#line 425 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return res;
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    m_305_1:
      {

#line 428 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        char *name = node->u.ident.name;

#line 429 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *res = ((compiler_ast_scopes_Symbol *)NULL);

#line 433 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)hint)) {

#line 434 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          switch ((hint->base)) {
            case compiler_types_BaseType_Enum:
            m_306_0:
              {

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_ast_nodes_Enum *enom = hint->u.enom;

#line 437 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_Enum_get_variant(enom, name);

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (((bool)variant)) {

#line 439 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  res=variant->sym;
                }
              } break;
            default:
              {
              } break;
          }
        }

#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)res))) {

#line 447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          res=compiler_ast_scopes_Scope_lookup_recursive(compiler_passes_typechecker_TypeChecker_scope(this), name);
        }

#line 450 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)res))) {

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_scopes_Scope *scope = compiler_passes_typechecker_TypeChecker_scope(this);

#line 454 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)scope->cur_func)) {

#line 455 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Function *cur_func = scope->cur_func;

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (cur_func->kind==compiler_ast_nodes_FunctionKind_Closure) {

#line 457 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_scopes_Symbol *tmp = compiler_ast_scopes_Scope_lookup_recursive(scope->cur_func->closure_scope, name);

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)tmp))) {
              } else if (tmp->type != compiler_ast_scopes_SymbolType_Variable) {

#line 462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can't close over non-variable %s", name)));
              } else {

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                std_map_Item__4 *it = std_map_Map__4_get_item(cur_func->closed_vars, name);

#line 466 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (((bool)it)) {

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  res=it->value;
                } else {

#line 469 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_ast_scopes_Symbol *closed_sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_ClosedVariable, NULL, name, name, name, node->span);

#line 470 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  closed_sym->u.closed_var=(compiler_ast_scopes_ClosedVariable){.orig=tmp->u.var, .closure=cur_func};

#line 471 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  std_map_Map__4_insert(cur_func->closed_vars, name, closed_sym);

#line 472 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  res=closed_sym;
                }
              }
            }
          }
        }

#line 480 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, res);

#line 481 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (error && !(((bool)res))) {

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Couldn't find this identifier: %s", name)));
        }

#line 484 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return res;
      } break;
    case compiler_ast_nodes_ASTType_Specialization:
    m_305_2:
      {

#line 487 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *base = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node->u.spec.base, error, hint, resolve_templates);

#line 488 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)base))) {

#line 488 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        base=compiler_ast_scopes_Symbol_remove_alias(base);

#line 491 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_ast_scopes_Symbol_is_templated(base))) {

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot specialize non-templated symbol %s", base->name)));

#line 493 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 496 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_vector_Vector__0 *args = node->u.spec.parsed_template_args;

#line 497 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_vector_Vector__0 *resolved_args = std_vector_Vector__0_new(args->size);

#line 498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        bool failed = false;

#line 499 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        for (u32 i = 0; i < args->size; i+=1) {

#line 500 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *resolved_arg = compiler_passes_typechecker_TypeChecker_resolve_type(this, std_vector_Vector__0_at(args, i), true, error, resolve_templates);

#line 501 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)resolved_arg))) {

#line 502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            failed=true;

#line 503 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            continue;
          }

#line 505 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          std_vector_Vector__0_push(resolved_args, resolved_arg);
        }

#line 507 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (failed) {

#line 507 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 508 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->u.spec.template_args=resolved_args;

#line 510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(resolve_templates)) {

#line 511 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, base);

#line 512 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return base;
        }

#line 515 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_resolve_templated_symbol(this, base, node);
      } break;
    default:
      {

#line 518 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (error) {

#line 519 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Don't know how to resolve node type %s", compiler_ast_nodes_ASTType_dbg(node->type))));
        }

#line 521 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return NULL;
      } break;
  }
}


#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_block(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {

#line 527 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Block *block = &node->u.block;

#line 529 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));

#line 530 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  scope->can_yield=(scope->can_yield || is_expr);

#line 531 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  block->scope=scope;

#line 533 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, block->scope);

#line 534 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__16 *stmts = block->statements;

#line 535 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_span_Span yield_span = std_span_Span_default();

#line 536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i156 = std_vector_Vector__16_iter(stmts); std_vector_Iterator__16_has_value(&_i156); std_vector_Iterator__16_next(&_i156)) {

#line 536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *stmt = std_vector_Iterator__16_cur(&_i156);

#line 536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 537 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_statement(this, stmt);

#line 538 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (stmt->returns) {

#line 538 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->returns=true;
      }

#line 540 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (stmt->type != compiler_ast_nodes_ASTType_Yield) {

#line 540 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }

#line 541 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)node->etype)) {

#line 542 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(stmt->span, "Cannot yield multiple times in a block", yield_span, "Previously yielded here"));
      }

#line 547 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      node->etype=stmt->etype;

#line 548 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      yield_span=stmt->span;

#line 549 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      node->u.block.final_stmt=stmt;
    }
  }

#line 551 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 554 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_method_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *method, compiler_ast_nodes_AST *node) {

#line 555 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 556 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((callee->type != compiler_ast_nodes_ASTType_Member) && (callee->type != compiler_ast_nodes_ASTType_NSLookup)) {

#line 557 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, "Method call is not to a member, internal compiler error"));

#line 558 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 561 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (callee->type != compiler_ast_nodes_ASTType_Member) {

#line 561 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 562 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (method->params->size==0) {

#line 564 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, "Instance method should have `this` argument, internal error"));

#line 565 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 567 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *method_param = std_vector_Vector__3_at(method->params, 0)->type;

#line 568 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)method_param))) {

#line 568 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 570 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Member member = callee->u.member;

#line 571 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *first_arg = member.lhs;

#line 573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (member.is_pointer && (method_param->base != compiler_types_BaseType_Pointer)) {

#line 574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    first_arg=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Dereference, first_arg->span, first_arg);
  } else if (!(member.is_pointer) && method_param->base==compiler_types_BaseType_Pointer) {

#line 576 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    first_arg=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, first_arg->span, first_arg);
  }

#line 578 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7_push_front(node->u.call.args, compiler_ast_nodes_Argument_new(first_arg, NULL));
}


#line 581 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_union_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params) {

#line 582 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 583 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (args->size != 1) {

#line 584 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Union constructors must have exactly one field")));

#line 585 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (std_vector_Iterator__7 _i157 = std_vector_Vector__7_iter(args); std_vector_Iterator__7_has_value(&_i157); std_vector_Iterator__7_next(&_i157)) {

#line 585 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Iterator__7_cur(&_i157);

#line 585 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      {

#line 586 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      }
    }

#line 588 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, 0);

#line 592 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)arg->label))) {

#line 593 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Union constructors must have a label for the field")));

#line 594 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 598 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Variable *param = NULL;

#line 599 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i158 = std_vector_Vector__3_iter(params); std_vector_Iterator__3_has_value(&_i158); std_vector_Iterator__3_next(&_i158)) {

#line 599 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *p = std_vector_Iterator__3_cur(&_i158);

#line 599 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 600 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)p->sym) && str_eq(p->sym->name, arg->label)) {

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        param=p;

#line 602 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        break;
      }
    }
  }

#line 605 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)param))) {

#line 606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Unknown field %s in union constructor", arg->label)));

#line 607 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);

#line 608 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 611 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, param->type);

#line 612 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg_type) && !(compiler_types_Type_eq(arg_type, param->type, false))) {

#line 613 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", arg->label, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type)), param->sym->span, "Parameter defined here"));
  }
}


#line 620 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 621 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.call_type=compiler_ast_nodes_CallType_StructConstructor;

#line 623 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 624 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Symbol *type_sym = compiler_ast_scopes_Symbol_remove_alias(callee->resolved_symbol);

#line 626 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if(!(type_sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:626:12: Assertion failed: `type_sym.type == Structure`", std_format("Got non-struct type in check_constructor: %s", compiler_ast_scopes_SymbolType_dbg(type_sym->type))); }

#line 627 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Structure *struc = type_sym->u.struc;

#line 629 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3 *params = struc->fields;

#line 630 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (struc->is_union) {

#line 631 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_union_constructor(this, node, params);
  } else {

#line 632 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, false);
  }

#line 636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return struc->type;
}


#line 639 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_enum_constructor(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.call_type=compiler_ast_nodes_CallType_EnumConstructor;

#line 642 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 643 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Symbol *type_sym = compiler_ast_scopes_Symbol_remove_alias(callee->resolved_symbol);

#line 645 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if(!(type_sym->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:645:12: Assertion failed: `type_sym.type == EnumVariant`", std_format("Got non-struct type in check_constructor: %s", compiler_ast_scopes_SymbolType_dbg(type_sym->type))); }

#line 646 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_EnumVariant *variant = type_sym->u.enum_var;

#line 647 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Enum *enom = variant->parent;

#line 649 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  u32 num_expected_fields = compiler_ast_nodes_EnumVariant_num_fields(variant);

#line 650 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3 *params = std_vector_Vector__3_new(16);

#line 651 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < num_expected_fields; i+=1) {

#line 652 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *field = compiler_ast_nodes_EnumVariant_get_field_by_idx(variant, i);

#line 653 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__3_push(params, field);
  }

#line 656 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 657 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (num_expected_fields==0 && args->size==0) {

#line 658 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_span_Span span = std_span_Span_join(node->u.call.open_paren_span, node->u.call.close_paren_span);

#line 659 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Unnecessary empty constructor for %s, no fields expected", variant->sym->display)));

#line 660 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return variant->parent->type;
  }

#line 663 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, false);

#line 664 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3_clear(params);

#line 665 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return enom->type;
}


#line 668 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_call_args_labelled(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params, u32 start) {

#line 669 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 670 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 671 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *new_args = std_vector_Vector__7_new(16);

#line 673 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__9 *kwargs = std_map_Map__9_new(8);

#line 674 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__10 *expected_params = std_map_Map__10_new(8);

#line 676 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < params->size; i++) {

#line 677 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(params, i);

#line 678 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)param->sym))) {

#line 679 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(param->type->span, "Not allowed to have unlabeled parameter here"));

#line 680 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 682 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Map__10_insert(expected_params, param->sym->name, param);

#line 683 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (i < start) {

#line 684 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 685 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__9_insert(kwargs, param->sym->name, arg);

#line 686 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__7_push(new_args, std_vector_Vector__7_at(args, i));
    }
  }

#line 690 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = start; i < args->size; i++) {

#line 691 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)arg->label))) {

#line 694 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, "Can't have positional arguments after labelled arguments"));

#line 695 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 697 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Item__10 *param_item = std_map_Map__10_get_item(expected_params, arg->label);

#line 698 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Item__9 *kwarg_item = std_map_Map__9_get_item(kwargs, arg->label);

#line 700 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *expected_type = NULL;

#line 701 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)param_item))) {

#line 702 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, std_format("Unknown labelled argument `%s`", arg->label)));
    } else if (((bool)kwarg_item)) {

#line 705 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->label_span, std_format("Duplicate argument for parameter `%s`", arg->label), kwarg_item->value->expr->span, "Previously specified here"));
    } else {

#line 710 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__9_insert(kwargs, arg->label, arg);

#line 711 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      expected_type=param_item->value->type;
    }

#line 714 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, expected_type);

#line 715 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if ((((bool)arg_type) && ((bool)expected_type)) && !(compiler_types_Type_eq(arg_type, expected_type, false))) {

#line 716 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", arg->label, compiler_types_Type_str(expected_type), compiler_types_Type_str(arg_type)), param_item->value->sym->span, "Parameter defined here"));
    }
  }

#line 723 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = start; i < params->size; i++) {

#line 724 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(params, i);

#line 725 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if(!(((bool)param->sym))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:725:16: Assertion failed: `param.sym?`", std_format("Expected a symbol for parameter %u", i)); }

#line 727 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Item__9 *item = std_map_Map__9_get_item(kwargs, param->sym->name);

#line 728 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)item)) {

#line 729 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__7_push(new_args, item->value);
    } else if (((bool)param->default_value)) {

#line 732 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *new_arg = compiler_ast_nodes_Argument_new(param->default_value, NULL);

#line 733 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__7_push(new_args, new_arg);
    } else {

#line 740 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->u.call.close_paren_span, std_format("Missing required argument `%s` of type %s", param->sym->name, compiler_types_Type_str(param->type)), param->sym->span, "Parameter defined here"));
    }
  }

#line 747 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7_free(args);

#line 748 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__9_free(kwargs);

#line 749 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__10_free(expected_params);

#line 750 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.args=new_args;
}


#line 754 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_call_args(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, std_vector_Vector__3 *params, bool is_variadic) {

#line 755 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 757 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < params->size; i++) {

#line 758 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(params, i);

#line 761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (i >= args->size) {

#line 762 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)param->default_value)) {

#line 763 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Argument *new_arg = compiler_ast_nodes_Argument_new(param->default_value, NULL);

#line 764 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_vector_Vector__7_push(args, new_arg);
      } else {

#line 766 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)param->sym)) {

#line 767 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->u.call.close_paren_span, std_format("Missing required argument `%s` of type %s", param->sym->name, compiler_types_Type_str(param->type)), param->sym->span, "Parameter defined here"));
        } else {

#line 772 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.call.close_paren_span, std_format("Missing required field %u of type %s", i, compiler_types_Type_str(param->type))));
        }
      }

#line 775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 778 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 779 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)arg->label)) {

#line 780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)param->sym))) {

#line 781 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, "Cannot use a labelled argument for a non-labeled parameter"));
      } else if (!(str_eq(arg->label, param->sym->name))) {

#line 788 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (is_variadic) {

#line 789 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->label_span, std_format("Variadic functions not allowed with default arguments")));
        }

#line 794 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_call_args_labelled(this, node, params, i);

#line 795 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        break;
      } else {
      }
    }

#line 802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, param->type);

#line 803 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)arg_type)) || !(((bool)param->type))) {

#line 804 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 806 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(compiler_types_Type_eq(arg_type, param->type, false))) {

#line 807 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)param->sym)) {

#line 808 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(arg->expr->span, std_format("Expected `%s` with type %s, but got %s", param->sym->name, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type)), param->sym->span, "Parameter defined here"));
      } else {

#line 813 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Expected field %u with type %s, but got %s", i, compiler_types_Type_str(param->type), compiler_types_Type_str(arg_type))));
      }
    }
  }

#line 819 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  args=node->u.call.args;

#line 821 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_variadic) {

#line 822 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (u32 i = params->size; i < args->size; i++) {

#line 823 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 824 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);

#line 825 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)arg_type))) {

#line 826 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }
    }
  } else {

#line 830 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (u32 i = params->size; i < args->size; i++) {

#line 831 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 832 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *arg_type = compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);

#line 833 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->expr->span, std_format("Unexpected argument, expected only %u", params->size)));
    }
  }
}


#line 838 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_call(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {

#line 839 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 840 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 842 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *res = ({ compiler_types_Type *__yield_0;

#line 842 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((callee->type)) {
      case compiler_ast_nodes_ASTType_Member:
      m_307_0:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_check_member(this, callee, true, NULL);
        } break;
      case compiler_ast_nodes_ASTType_Identifier:
      case compiler_ast_nodes_ASTType_NSLookup:
      case compiler_ast_nodes_ASTType_Specialization:
      m_307_1:
        {

#line 845 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, callee, true, hint, true);

#line 846 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = ({ compiler_types_Type *__yield_1;

#line 846 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (((bool)sym)) {

#line 848 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              sym=compiler_ast_scopes_Symbol_remove_alias(sym);

#line 849 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, callee, sym);

#line 851 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              __yield_1 = ({ compiler_types_Type *__yield_2;

#line 851 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                switch ((sym->type)) {
                  case compiler_ast_scopes_SymbolType_Structure:
                  case compiler_ast_scopes_SymbolType_TypeDef:
                  m_308_0:
                    {

#line 853 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                      node->u.call.call_type=compiler_ast_nodes_CallType_StructConstructor;

#line 854 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                      return compiler_passes_typechecker_TypeChecker_check_constructor(this, node);
                    } break;
                  case compiler_ast_scopes_SymbolType_EnumVariant:
                  m_308_1:
                    {

#line 857 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                      node->u.call.call_type=compiler_ast_nodes_CallType_EnumConstructor;

#line 858 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                      return compiler_passes_typechecker_TypeChecker_check_enum_constructor(this, node);
                    } break;
                  default:
                    {
                      __yield_2 = compiler_passes_typechecker_TypeChecker_check_expression(this, callee, NULL);
                    } break;
                }

              __yield_2; });
            } else {
              __yield_1 = this->o->error_type;
            }
          __yield_1; });
        } break;
      default:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_check_expression(this, callee, NULL);
        } break;
    }

  __yield_0; });

#line 869 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.call_type=compiler_ast_nodes_CallType_Normal;

#line 870 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)res)) {

#line 871 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (res->base==compiler_types_BaseType_Pointer && res->u.ptr->base==compiler_types_BaseType_FunctionPtr) {

#line 872 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      res=res->u.ptr;
    } else if (!(compiler_types_BaseType_is_callable(res->base))) {

#line 875 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(callee->span, std_format("Cannot call a non-function type: %s", compiler_types_Type_str(res))));

#line 877 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      res=this->o->error_type;
    }
  } else {

#line 882 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    res=this->o->error_type;
  }

#line 888 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (res->base==compiler_types_BaseType_Error) {

#line 889 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (std_vector_Iterator__7 _i159 = std_vector_Vector__7_iter(args); std_vector_Iterator__7_has_value(&_i159); std_vector_Iterator__7_next(&_i159)) {

#line 889 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Iterator__7_cur(&_i159);

#line 889 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      {

#line 890 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression(this, arg->expr, NULL);
      }
    }

#line 892 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 895 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_FunctionType func = res->u.func;

#line 896 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func.orig) && func.orig->exits) {

#line 896 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->returns=true;
  }

#line 897 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3 *params = func.params;

#line 899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((((bool)func.orig) && func.orig->kind==compiler_ast_nodes_FunctionKind_Method) && !(func.orig->is_static)) {

#line 900 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_method_call(this, func.orig, node);
  }

#line 903 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (res->base==compiler_types_BaseType_Closure) {

#line 904 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->u.call.call_type=compiler_ast_nodes_CallType_Closure;
  }

#line 907 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_call_args(this, node, params, func.is_variadic);

#line 909 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool is_variadic_format = (((bool)func.orig) && func.orig->is_variadic_format);

#line 910 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_variadic_format && (args->size >= params->size)) {

#line 911 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__7 *args = node->u.call.args;

#line 913 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Vector__3_back(params, 0);

#line 914 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *arg = std_vector_Vector__7_at(args, (params->size - 1))->expr;

#line 916 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(compiler_types_Type_is_str(param->type))) {

#line 917 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func.orig->sym->span, "Variadic-format function must have last positional argument of type 'str'"));
    }

#line 921 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((arg->type)) {
      case compiler_ast_nodes_ASTType_StringLiteral:
      case compiler_ast_nodes_ASTType_FormatStringLiteral:
      m_309_0:
        {
        } break;
      default:
        
#line 927 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (arg->etype==compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", arg->span)) {

#line 928 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->span, "Expected a string literal for variadic-format function"));
          }
         break;
    }

#line 935 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (u32 i = params->size; i < args->size; i++) {

#line 936 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 937 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(this, &arg->expr);
    }
  }

#line 941 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func.orig)) {

#line 942 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->u.call.is_function_pointer=false;

#line 943 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->u.call.func=func.orig;
  }

#line 946 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return func.return_type;
}


#line 949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_pointer_arith(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {

#line 950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_operators_Operator op = node->u.binary.op;

#line 951 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (op==compiler_ast_operators_Operator_Plus || op==compiler_ast_operators_Operator_Minus) {

#line 952 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (lhs->base==compiler_types_BaseType_Pointer && compiler_types_Type_is_integer(rhs)) {

#line 953 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return lhs;
    }

#line 955 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_types_Type_is_integer(lhs) && rhs->base==compiler_types_BaseType_Pointer) {

#line 956 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return rhs;
    }

#line 958 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_types_Type_eq(lhs, rhs, false) && lhs->base==compiler_types_BaseType_Pointer) {

#line 959 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (op==compiler_ast_operators_Operator_Minus) {

#line 960 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I64, node->span);
      }
    }
  }

#line 964 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Invalid pointer arithmetic"));

#line 965 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return NULL;
}


#line 968 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_operators_Operator op, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *arg1, compiler_ast_nodes_AST *arg2, compiler_ast_nodes_AST *arg3) {

#line 969 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(op)) {

#line 971 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_ast_nodes_AST_is_lvalue(arg1) && (arg1->etype->base != compiler_types_BaseType_Pointer)) {

#line 972 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      arg1=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, arg1->span, arg1);

#line 973 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg1, NULL)))) {

#line 973 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return NULL;
      }
    }
  }

#line 977 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_operators_OperatorOverload overload = {0};

#line 978 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  overload.op=op;

#line 979 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg1)) {

#line 979 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type1=arg1->etype;
  }

#line 980 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg2)) {

#line 980 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type2=arg2->etype;
  }

#line 981 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg3)) {

#line 981 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type3=arg3->etype;
  }

#line 982 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Function *func = std_map_Map__5_get(this->o->program->operator_overloads, overload, NULL);

#line 983 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)func))) {

#line 983 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 985 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *callee = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_OverloadedOperator, node->u.binary.op_span);

#line 986 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  callee->u.operator_span=({ std_span_Span __yield_0;

#line 986 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((node->type)) {
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_310_0:
        {
          __yield_0 = node->u.binary.op_span;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_310_1:
        {
          __yield_0 = node->u.unary.op_span;
        } break;
      default:
        {
          __yield_0 = node->span;
        } break;
    }

  __yield_0; });

#line 991 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, callee, func->sym);

#line 993 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__7 *args = std_vector_Vector__7_new(16);

#line 994 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg1)) {

#line 994 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__7_push(args, compiler_ast_nodes_Argument_new(arg1, NULL));
  }

#line 995 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg2)) {

#line 995 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__7_push(args, compiler_ast_nodes_Argument_new(arg2, NULL));
  }

#line 996 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)arg3)) {

#line 996 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_vector_Vector__7_push(args, compiler_ast_nodes_Argument_new(arg3, NULL));
  }

#line 998 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->type=compiler_ast_nodes_ASTType_Call;

#line 999 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.callee=callee;

#line 1000 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.call.args=args;

#line 1001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->etype=func->return_type;

#line 1002 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return func->return_type;
}


#line 1005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_binary_op(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {

#line 1006 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_operators_Operator op = node->u.binary.op;

#line 1007 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, op, node, node->u.binary.lhs, node->u.binary.rhs, NULL);

#line 1008 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)res)) {

#line 1008 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return res;
  }

#line 1010 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((op)) {
    case compiler_ast_operators_Operator_Plus:
    case compiler_ast_operators_Operator_Minus:
    case compiler_ast_operators_Operator_Multiply:
    case compiler_ast_operators_Operator_Divide:
    m_311_0:
      {

#line 1012 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (lhs->base==compiler_types_BaseType_Pointer || rhs->base==compiler_types_BaseType_Pointer) {

#line 1013 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return compiler_passes_typechecker_TypeChecker_check_pointer_arith(this, node, lhs, rhs);
        } else if (!(compiler_types_Type_is_numeric(lhs)) || !(compiler_types_Type_is_numeric(rhs))) {

#line 1016 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1019 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        } else if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1022 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1026 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        } else {

#line 1028 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return lhs;
        }
      } break;
    case compiler_ast_operators_Operator_PlusEquals:
    case compiler_ast_operators_Operator_MinusEquals:
    case compiler_ast_operators_Operator_DivideEquals:
    case compiler_ast_operators_Operator_MultiplyEquals:
    m_311_1:
      {

#line 1032 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;

#line 1033 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_ast_nodes_AST_is_lvalue(lhs_node))) {

#line 1034 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Left hand side of assignment must be assignable"));

#line 1035 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1037 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_is_numeric(lhs)) || !(compiler_types_Type_is_numeric(rhs))) {

#line 1038 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1041 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1043 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1044 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1048 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1050 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return lhs;
      } break;
    case compiler_ast_operators_Operator_LessThan:
    case compiler_ast_operators_Operator_LessThanEquals:
    case compiler_ast_operators_Operator_GreaterThan:
    case compiler_ast_operators_Operator_GreaterThanEquals:
    m_311_2:
      {

#line 1053 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1054 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }

#line 1059 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        lhs=compiler_types_Type_unaliased(lhs);

#line 1060 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_is_numeric_or_char(lhs)) && (lhs->base != compiler_types_BaseType_Pointer)) {

#line 1061 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1064 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1066 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_Equals:
    m_311_3:
      {

#line 1069 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        bool is_invalid = ({ bool __yield_0;

#line 1069 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(compiler_types_Type_eq(lhs, rhs, false))) {
            __yield_0 = true;
          } else if (lhs->base==compiler_types_BaseType_Structure) {
            __yield_0 = true;
          } else if (lhs->base==compiler_types_BaseType_Enum) {
            __yield_0 = ({ bool __yield_1;

#line 1072 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (lhs->u.enom->has_values) {

#line 1074 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support non-trivial enum `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs))));

#line 1075 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              } else {
                __yield_1 = false;
              }
            __yield_1; });
          } else {
            __yield_0 = false;
          }

        __yield_0; });

#line 1081 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (is_invalid) {

#line 1082 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }

#line 1086 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_NotEquals:
    m_311_4:
      {

#line 1089 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        bool is_invalid = ({ bool __yield_0;

#line 1089 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(compiler_types_Type_eq(lhs, rhs, false))) {
            __yield_0 = true;
          } else if (lhs->base==compiler_types_BaseType_Structure) {
            __yield_0 = true;
          } else if (lhs->base==compiler_types_BaseType_Enum && lhs->u.enom->has_values) {
            __yield_0 = true;
          } else {
            __yield_0 = false;
          }

        __yield_0; });

#line 1095 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (is_invalid) {

#line 1097 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_Equals, node, node->u.binary.lhs, node->u.binary.rhs, NULL);

#line 1098 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)res)) {

#line 1100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_AST *copy = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_UnaryOp, node->span);

#line 1101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            (*copy)=(*node);

#line 1102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            (*node)=(*compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Not, node->span, copy));

#line 1103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_check_expression(this, node, NULL);
          } else if (lhs->base==compiler_types_BaseType_Enum) {

#line 1105 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support non-trivial enum `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs))));
          } else {

#line 1108 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
          }
        }

#line 1113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_And:
    case compiler_ast_operators_Operator_Or:
    m_311_5:
      {

#line 1116 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_eq(lhs, rhs, false)) || (lhs->base != compiler_types_BaseType_Bool)) {

#line 1117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_operators_Operator_BitwiseXor:
    m_311_6:
      {

#line 1125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1131 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if ((lhs->base != compiler_types_BaseType_Bool) && !(compiler_types_Type_is_integer(lhs))) {

#line 1132 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Operator requires integer types"));
        }

#line 1134 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return lhs;
      } break;
    case compiler_ast_operators_Operator_Modulus:
    case compiler_ast_operators_Operator_BitwiseOr:
    case compiler_ast_operators_Operator_BitwiseAnd:
    case compiler_ast_operators_Operator_LeftShift:
    case compiler_ast_operators_Operator_RightShift:
    case compiler_ast_operators_Operator_LeftShiftEquals:
    case compiler_ast_operators_Operator_RightShiftEquals:
    m_311_7:
      {

#line 1137 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_is_integer(lhs)) || !(compiler_types_Type_is_integer(rhs))) {

#line 1138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Operator `%s` does not support `%s` and `%s`", compiler_ast_operators_Operator_dbg(op), compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));

#line 1141 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->span, "Operands must be of the same type", std_format("Got types '%s' and '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
        }

#line 1150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;

#line 1151 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((op)) {
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          m_312_0:
            
#line 1152 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(compiler_ast_nodes_AST_is_lvalue(lhs_node))) {

#line 1153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs_node->span, std_format("Must be an l-value")));

#line 1154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }
             break;
          default:
            {
            } break;
        }

#line 1159 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return lhs;
      } break;
    default:
      {

#line 1161 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_panic(std_format("Internal error: unhandled op in check_binary_op: %s", compiler_ast_nodes_ASTType_dbg(node->type)));
      } break;
  }
}


#line 1165 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_format_string(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 1166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__8 *parts = node->u.fmt_str.parts;

#line 1167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__16 *exprs = node->u.fmt_str.exprs;

#line 1169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (parts->size != (exprs->size + 1)) {

#line 1170 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Number of format string parts does not match number of expressions"));
  }

#line 1173 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < exprs->size; i+=1) {

#line 1174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *expr = std_vector_Vector__16_at(exprs, i);

#line 1175 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);

#line 1176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)typ))) {

#line 1176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 1178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    typ=compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(this, &expr);

#line 1179 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    exprs->data[i]=expr;

#line 1181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)typ))) {

#line 1181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      continue;
    }

#line 1182 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    typ=compiler_types_Type_unaliased(typ);

#line 1184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((typ->base)) {
      case compiler_types_BaseType_Bool:
      case compiler_types_BaseType_Char:
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      case compiler_types_BaseType_Pointer:
      m_313_0:
        {
        } break;
      default:
        {

#line 1188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          bool can_format = false;

#line 1189 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (typ->base==compiler_types_BaseType_Structure) {

#line 1190 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Structure *struc = typ->u.struc;

#line 1191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (((bool)struc) && ((bool)struc->format_spec)) {

#line 1192 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              can_format=true;
            }
          }

#line 1196 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (can_format) {

#line 1202 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            switch ((expr->type)) {
              case compiler_ast_nodes_ASTType_Identifier:
              case compiler_ast_nodes_ASTType_Member:
              case compiler_ast_nodes_ASTType_NSLookup:
              m_314_0:
                {

#line 1203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  continue;
                } break;
              default:
                {

#line 1205 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(expr->span, std_format("Can only format %s in simple expressions", typ->sym->display), "Try moving the expression into a variable and formatting that instead"));
                } break;
            }
          } else {

#line 1213 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Type '%s' cannot be formatted automatically", compiler_types_Type_str(typ))));
          }
        } break;
    }
  }

#line 1221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
}


#line 1224 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_member(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_being_called, compiler_types_Type *hint) {

#line 1225 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.member.lhs, NULL);

#line 1226 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)lhs))) {

#line 1226 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 1229 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool is_pointer = false;

#line 1230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (lhs->base==compiler_types_BaseType_Pointer) {

#line 1231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    is_pointer=true;

#line 1233 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)lhs->u.ptr))) {

#line 1234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs->span, "Got unresolved type"));

#line 1235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return hint;
    }

#line 1237 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    lhs=lhs->u.ptr;
  }

#line 1242 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (lhs->base==compiler_types_BaseType_UnresolvedTemplate) {

#line 1243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    lhs=lhs->u.unresolved_spec.base;
  }

#line 1246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  char *rhs_name = node->u.member.rhs_name;

#line 1247 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)rhs_name))) {

#line 1247 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return hint;
  }

#line 1249 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((lhs->base)) {
    case compiler_types_BaseType_Structure:
    m_315_0:
      {

#line 1251 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Structure *struc = lhs->u.struc;

#line 1252 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Variable *field = compiler_ast_nodes_Structure_get_field(struc, rhs_name);

#line 1253 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)field)) {

#line 1254 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          node->u.member.is_pointer=is_pointer;

#line 1255 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, field->sym);

#line 1256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return field->type;
        }
      } break;
    case compiler_types_BaseType_Enum:
    m_315_1:
      {

#line 1260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Enum *enom = lhs->u.enom;

#line 1261 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Variable *field = compiler_ast_nodes_Enum_get_shared_field(enom, rhs_name);

#line 1262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)field)) {

#line 1263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          node->u.member.is_pointer=is_pointer;

#line 1264 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, field->sym);

#line 1265 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return field->type;
        }
      } break;
    default:
      {
      } break;
  }

#line 1273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_types_Type_can_have_methods(lhs)) {

#line 1274 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *method = std_map_Map__8_get(lhs->methods, rhs_name, NULL);

#line 1275 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)method)) {

#line 1276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(is_being_called)) {

#line 1277 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot access method without calling it"));

#line 1278 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return hint;
      }

#line 1280 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (method->is_static) {

#line 1281 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot call static method as instance method"));

#line 1282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return hint;
      }

#line 1284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      node->u.member.is_pointer=is_pointer;

#line 1285 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_set_resolved_symbol(this, node, method->sym);

#line 1286 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return method->type;
    }
  }

#line 1290 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Type %s has no member named '%s'", compiler_types_Type_str(lhs), rhs_name)));

#line 1293 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return hint;
}


#line 1299 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {

#line 1300 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)node->etype)) {

#line 1300 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return node->etype;
  }

#line 1302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression_helper(this, node, hint);

#line 1303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)typ) && (node->type != compiler_ast_nodes_ASTType_ArrayLiteral)) {

#line 1303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    typ=compiler_types_Type_decay_array(typ);
  }

#line 1304 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->etype=typ;

#line 1305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->hint=(((bool)typ) ? typ : hint);

#line 1306 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return typ;
}


#line 1309 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_index(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint, bool is_being_assigned) {

#line 1310 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);

#line 1311 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, NULL);

#line 1312 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 1312 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 1314 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(is_being_assigned)) {

#line 1315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_Index, node, node->u.binary.lhs, node->u.binary.rhs, NULL);

#line 1316 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)res)) {

#line 1316 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return res;
    }
  }

#line 1319 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  rhs=compiler_types_Type_unaliased(rhs);

#line 1320 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(compiler_types_Type_is_integer(rhs))) {

#line 1321 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Index must be an integer, got %s", compiler_types_Type_str(rhs))));

#line 1322 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 1324 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  lhs=compiler_types_Type_unaliased(lhs);

#line 1325 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((lhs->base)) {
    case compiler_types_BaseType_Array:
    m_316_0:
      {

#line 1326 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return lhs->u.arr.elem_type;
      } break;
    case compiler_types_BaseType_Pointer:
    m_316_1:
      {

#line 1327 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return lhs->u.ptr;
      } break;
    default:
      {

#line 1329 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot index type %s", compiler_types_Type_str(lhs))));

#line 1330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return NULL;
      } break;
  }
}


#line 1337 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_assignment(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *lhs, compiler_types_Type *rhs) {

#line 1338 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(compiler_ast_nodes_AST_is_lvalue(node->u.binary.lhs))) {

#line 1339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.binary.lhs->span, "Must be an l-value"));
  }

#line 1341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(compiler_types_Type_eq(lhs, rhs, false))) {

#line 1342 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.binary.rhs->span, std_format("Variable type does not match assignment type, Expected type '%s', got '%s'", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs))));
  }

#line 1346 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return lhs;
}


#line 1349 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_expression_helper(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {

#line 1350 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    m_317_0:
      {

#line 1352 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)node->u.num_literal.suffix)) {

#line 1353 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.num_literal.suffix, false, true, true);
        }

#line 1355 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)hint) && compiler_types_Type_is_integer(hint)) {

#line 1355 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return hint;
        }

#line 1356 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_U32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_FloatLiteral:
    m_317_1:
      {

#line 1359 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)node->u.num_literal.suffix)) {

#line 1360 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.num_literal.suffix, false, true, true);
        }

#line 1362 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)hint) && compiler_types_Type_is_float(hint)) {

#line 1362 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return hint;
        }

#line 1363 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_F32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_StringLiteral:
    m_317_2:
      {

#line 1366 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
      } break;
    case compiler_ast_nodes_ASTType_Null:
    m_317_3:
      {

#line 1369 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)hint)) {

#line 1370 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          switch ((hint->base)) {
            case compiler_types_BaseType_Pointer:
            case compiler_types_BaseType_FunctionPtr:
            case compiler_types_BaseType_Closure:
            m_318_0:
              {

#line 1371 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return hint;
              } break;
            default:
              {
              } break;
          }
        }

#line 1376 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "untyped_ptr", node->span);
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_317_4:
      {

#line 1379 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.cast.lhs, NULL);

#line 1380 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)typ))) {

#line 1380 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1381 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *target = compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.cast.to, false, true, true);

#line 1382 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)target))) {

#line 1382 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1383 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->u.cast.to=target;

#line 1385 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return target;
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_317_5:
      {

#line 1388 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_check_format_string(this, node);
      } break;
    case compiler_ast_nodes_ASTType_CharLiteral:
    m_317_6:
      {

#line 1391 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Char, node->span);
      } break;
    case compiler_ast_nodes_ASTType_BoolLiteral:
    m_317_7:
      {

#line 1394 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_317_8:
      {

#line 1396 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((node->u.unary.op)) {
          case compiler_ast_operators_Operator_PreIncrement:
          case compiler_ast_operators_Operator_PostIncrement:
          case compiler_ast_operators_Operator_PreDecrement:
          case compiler_ast_operators_Operator_PostDecrement:
          m_319_0:
            {

#line 1398 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);

#line 1399 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)lhs))) {

#line 1399 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1400 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(compiler_types_Type_is_integer(lhs)) && (lhs->base != compiler_types_BaseType_Pointer)) {

#line 1401 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot increment or decrement non-integer type: %s", compiler_types_Type_str(lhs))));

#line 1402 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1404 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(compiler_ast_nodes_AST_is_lvalue(node->u.unary.expr))) {

#line 1405 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can't perform %s on a non-lvalue", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
              }

#line 1407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return lhs;
            } break;
          case compiler_ast_operators_Operator_Negate:
          m_319_1:
            {

#line 1410 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!((((bool)hint) && compiler_types_Type_is_numeric(hint)))) {

#line 1411 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                hint=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
              }

#line 1413 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, hint);

#line 1414 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1414 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1415 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(compiler_types_Type_is_numeric(typ))) {

#line 1416 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-numeric type: %s", compiler_types_Type_str(typ))));

#line 1417 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1419 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return typ;
            } break;
          case compiler_ast_operators_Operator_BitwiseNot:
          m_319_2:
            {

#line 1422 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, hint);

#line 1423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1424 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(compiler_types_Type_is_integer(typ))) {

#line 1425 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot do bitwise-not on non-integer type: %s", compiler_types_Type_str(typ))));

#line 1426 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1428 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return typ;
            } break;
          case compiler_ast_operators_Operator_IsNotNull:
          m_319_3:
            {

#line 1431 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);

#line 1432 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1432 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1433 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              typ=compiler_types_Type_unaliased(typ);

#line 1434 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              switch ((typ->base)) {
                case compiler_types_BaseType_Pointer:
                case compiler_types_BaseType_FunctionPtr:
                case compiler_types_BaseType_Closure:
                m_320_0:
                  {
                  } break;
                default:
                  {

#line 1437 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only use ? on pointer types, got %s", compiler_types_Type_str(typ))));

#line 1438 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return NULL;
                  } break;
              }

#line 1441 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
            } break;
          case compiler_ast_operators_Operator_Not:
          m_319_4:
            {

#line 1444 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));

#line 1445 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1445 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1446 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (typ->base != compiler_types_BaseType_Bool) {

#line 1447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-boolean type: %s", compiler_types_Type_str(typ))));

#line 1448 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1450 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return typ;
            } break;
          case compiler_ast_operators_Operator_Address:
          m_319_5:
            {

#line 1453 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);

#line 1454 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1454 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              switch ((typ->base)) {
                case compiler_types_BaseType_Char:
                m_321_0:
                  {

#line 1457 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
                  } break;
                case compiler_types_BaseType_Void:
                m_321_1:
                  {

#line 1458 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "untyped_ptr", node->span);
                  } break;
                default:
                  {

#line 1460 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    compiler_types_Type *ptr = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);

#line 1461 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    ptr->u.ptr=typ;

#line 1462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return ptr;
                  } break;
              }
            } break;
          case compiler_ast_operators_Operator_Dereference:
          m_319_6:
            {

#line 1467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.unary.expr, NULL);

#line 1468 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)typ))) {

#line 1468 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1469 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (typ->base != compiler_types_BaseType_Pointer) {

#line 1470 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot dereference non-pointer type: %s", compiler_types_Type_str(typ))));

#line 1471 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1473 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return typ->u.ptr;
            } break;
          default:
            {

#line 1476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Unknown unary operator in check_expression: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));

#line 1477 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_317_9:
      {

#line 1481 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_check_member(this, node, false, hint);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_317_10:
      {

#line 1483 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_resolve_type(this, node->u.size_of_type, false, true, true);

#line 1484 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)typ))) {

#line 1484 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1485 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->u.size_of_type=typ;

#line 1486 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_U32, node->span);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_317_11:
      {

#line 1489 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_if(this, node, true, hint);

#line 1490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_317_12:
      {

#line 1493 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_block(this, node, true, hint);

#line 1494 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_317_13:
      {

#line 1497 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_match(this, node, true, hint);

#line 1498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return node->etype;
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_NSLookup:
    case compiler_ast_nodes_ASTType_Specialization:
    m_317_14:
      {

#line 1501 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *item = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, true, hint, true);

#line 1502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)item))) {

#line 1502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1504 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        item=compiler_ast_scopes_Symbol_remove_alias(item);

#line 1505 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((item->type)) {
          case compiler_ast_scopes_SymbolType_Function:
          m_322_0:
            {

#line 1506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return item->u.func->type;
            } break;
          case compiler_ast_scopes_SymbolType_Variable:
          case compiler_ast_scopes_SymbolType_Constant:
          m_322_1:
            {

#line 1507 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return item->u.var->type;
            } break;
          case compiler_ast_scopes_SymbolType_ClosedVariable:
          m_322_2:
            {

#line 1508 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return item->u.closed_var.orig->type;
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_322_3:
            {

#line 1510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_EnumVariant *variant = item->u.enum_var;

#line 1511 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (compiler_ast_nodes_EnumVariant_num_fields(variant) != 0) {

#line 1512 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s needs %u fields to construct", item->display, compiler_ast_nodes_EnumVariant_num_fields(variant))));

#line 1513 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1515 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return variant->parent->type;
            } break;
          case compiler_ast_scopes_SymbolType_TypeDef:
          m_322_4:
            {

#line 1519 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot use type `%s` as an expression", item->name)));

#line 1520 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            } break;
          case compiler_ast_scopes_SymbolType_Structure:
          case compiler_ast_scopes_SymbolType_Namespace:
          case compiler_ast_scopes_SymbolType_Enum:
          m_322_5:
            {

#line 1523 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot use %s `%s` as an expression", compiler_ast_scopes_SymbolType_dbg(item->type), item->name)));

#line 1524 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            } break;
          default:
            {

#line 1527 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Should not get %s `%s` as an expression", compiler_ast_scopes_SymbolType_dbg(item->type), item->name)));

#line 1528 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_317_15:
      {

#line 1532 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return compiler_passes_typechecker_TypeChecker_check_call(this, node, hint);
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_317_16:
      {

#line 1536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *lhs_node = node->u.binary.lhs;

#line 1537 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *rhs_node = node->u.binary.rhs;

#line 1538 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_operators_Operator op = node->u.binary.op;

#line 1539 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((op)) {
          case compiler_ast_operators_Operator_Plus:
          case compiler_ast_operators_Operator_Minus:
          case compiler_ast_operators_Operator_Multiply:
          case compiler_ast_operators_Operator_Divide:
          case compiler_ast_operators_Operator_LessThan:
          case compiler_ast_operators_Operator_LessThanEquals:
          case compiler_ast_operators_Operator_GreaterThan:
          case compiler_ast_operators_Operator_GreaterThanEquals:
          case compiler_ast_operators_Operator_Equals:
          case compiler_ast_operators_Operator_NotEquals:
          case compiler_ast_operators_Operator_PlusEquals:
          case compiler_ast_operators_Operator_MinusEquals:
          case compiler_ast_operators_Operator_MultiplyEquals:
          case compiler_ast_operators_Operator_DivideEquals:
          case compiler_ast_operators_Operator_And:
          case compiler_ast_operators_Operator_Or:
          case compiler_ast_operators_Operator_Modulus:
          case compiler_ast_operators_Operator_BitwiseOr:
          case compiler_ast_operators_Operator_BitwiseAnd:
          case compiler_ast_operators_Operator_BitwiseXor:
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          case compiler_ast_operators_Operator_LeftShift:
          case compiler_ast_operators_Operator_RightShift:
          m_323_0:
            {

#line 1564 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, lhs_node, NULL);

#line 1565 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, rhs_node, lhs);

#line 1566 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 1566 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1567 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_check_binary_op(this, node, compiler_types_Type_unaliased(lhs), compiler_types_Type_unaliased(rhs));
            } break;
          case compiler_ast_operators_Operator_In:
          m_323_1:
            {

#line 1571 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);

#line 1572 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, NULL);

#line 1573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 1573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
              }

#line 1574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_In, node, node->u.binary.rhs, node->u.binary.lhs, NULL);

#line 1575 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
            } break;
          case compiler_ast_operators_Operator_Index:
          m_323_2:
            {

#line 1577 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_check_index(this, node, hint, false);
            } break;
          case compiler_ast_operators_Operator_Assignment:
          m_323_3:
            {

#line 1579 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.lhs, NULL);

#line 1580 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.binary.rhs, lhs);

#line 1581 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 1581 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1582 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_check_assignment(this, node, lhs, rhs);
            } break;
          case compiler_ast_operators_Operator_IndexAssign:
          m_323_4:
            {

#line 1589 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_AST *index = node->u.binary.lhs;

#line 1590 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_AST *arg1 = index->u.binary.lhs;

#line 1591 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_AST *arg2 = index->u.binary.rhs;

#line 1592 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_AST *arg3 = node->u.binary.rhs;

#line 1593 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg1, NULL)))) {

#line 1593 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1594 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg2, NULL)))) {

#line 1594 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1597 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *arg3_hint = NULL;

#line 1598 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *arg1_typ = compiler_types_Type_unaliased(arg1->etype);

#line 1599 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (arg1_typ->base==compiler_types_BaseType_Pointer) {

#line 1600 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                arg3_hint=arg1_typ->u.ptr;
              }

#line 1603 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)compiler_passes_typechecker_TypeChecker_check_expression(this, arg3, arg3_hint)))) {

#line 1603 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1605 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_find_and_replace_overloaded_op(this, compiler_ast_operators_Operator_IndexAssign, node, arg1, arg2, arg3);

#line 1606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (((bool)res)) {

#line 1606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return res;
              }

#line 1608 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_index(this, index, NULL, true);

#line 1609 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_expression(this, arg3, lhs);

#line 1610 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 1610 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return NULL;
              }

#line 1611 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return compiler_passes_typechecker_TypeChecker_check_assignment(this, node, lhs, rhs);
            } break;
          default:
            {

#line 1613 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              std_panic(std_format("Internal error: unhandled op in check_expression binary_op: %s", compiler_ast_nodes_ASTType_dbg(node->type)));
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_317_17:
      {

#line 1618 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *hint_elem_type = ((compiler_types_Type *)NULL);

#line 1619 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)hint) && hint->base==compiler_types_BaseType_Array) {

#line 1620 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          hint_elem_type=hint->u.arr.elem_type;
        }

#line 1623 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *elem_type = ((compiler_types_Type *)NULL);

#line 1624 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_span_Span first_span = std_span_Span_default();

#line 1625 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        for (std_vector_Iterator__16 _i160 = std_vector_Vector__16_iter(node->u.array_literal.elements); std_vector_Iterator__16_has_value(&_i160); std_vector_Iterator__16_next(&_i160)) {

#line 1625 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_AST *elem = std_vector_Iterator__16_cur(&_i160);

#line 1625 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          {

#line 1626 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_expression(this, elem, hint_elem_type);

#line 1627 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (!(((bool)typ))) {

#line 1627 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              continue;
            }

#line 1629 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (!(((bool)elem_type))) {

#line 1630 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              elem_type=typ;

#line 1632 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              hint_elem_type=elem_type;

#line 1633 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              first_span=elem->span;
            } else if (!(compiler_types_Type_eq(elem_type, typ, false))) {

#line 1636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(elem->span, std_format("Expected type %s, but got %s", compiler_types_Type_str(elem_type), compiler_types_Type_str(typ)), first_span, std_format("First element was of type %s", compiler_types_Type_str(elem_type))));

#line 1640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return NULL;
            }
          }
        }

#line 1643 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)elem_type))) {

#line 1644 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Array literal must have at least one element"));

#line 1645 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1647 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *arr = compiler_types_Type_new_resolved(compiler_types_BaseType_Array, node->span);

#line 1648 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        arr->u.arr.elem_type=elem_type;

#line 1649 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        arr->u.arr.size_known=true;

#line 1650 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        arr->u.arr.size=node->u.array_literal.elements->size;

#line 1651 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return arr;
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_317_18:
      {

#line 1654 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(this->o->program->did_cache_symbols)) {

#line 1655 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use `@new` without using stdlib"));
        }

#line 1658 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *child_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.child, NULL);

#line 1659 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)child_typ))) {

#line 1659 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        }

#line 1661 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (child_typ->base==compiler_types_BaseType_Pointer) {

#line 1663 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot use `@new` on a pointer type"));
        }

#line 1666 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, node->span);

#line 1667 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        typ->u.ptr=child_typ;

#line 1668 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return typ;
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_317_19:
      {

#line 1671 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Function *clos = node->u.closure;

#line 1672 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        clos->scope=compiler_passes_generic_pass_GenericPass_ns(this->o)->scope;

#line 1674 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        clos->closure_scope=compiler_passes_generic_pass_GenericPass_scope(this->o);

#line 1675 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        clos->closed_vars=std_map_Map__4_new(8);

#line 1677 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        bool hint_matches = ({ bool __yield_0;

#line 1677 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)hint))) {
            __yield_0 = false;
          } else if (hint->base != compiler_types_BaseType_Closure) {
            __yield_0 = false;
          } else if (hint->u.func.params->size != clos->params->size) {
            __yield_0 = false;
          } else {
            __yield_0 = true;
          }

        __yield_0; });

#line 1684 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (hint_matches) {

#line 1685 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_FunctionType hfunc = hint->u.func;

#line 1686 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          for (u32 i = 0; i < clos->params->size; i+=1) {

#line 1687 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(clos->params, i);

#line 1688 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_types_Type *hint_type = std_vector_Vector__3_at(hfunc.params, i)->type;

#line 1689 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_types_Type *param_type = (((bool)param->type) ? param->type : hint_type);

#line 1693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            param->type=param_type;
          }

#line 1696 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *hint_ret_type = hfunc.return_type;

#line 1697 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *clos_ret_type = (((bool)clos->return_type) ? clos->return_type : hint_ret_type);

#line 1701 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          clos->return_type=clos_ret_type;
        } else {

#line 1703 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          for (std_vector_Iterator__3 _i161 = std_vector_Vector__3_iter(clos->params); std_vector_Iterator__3_has_value(&_i161); std_vector_Iterator__3_next(&_i161)) {

#line 1703 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i161);

#line 1703 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            {

#line 1704 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (!(((bool)param->type))) {

#line 1705 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(param->sym->span, "Cannot infer type, specify it explicitly"));
              }
            }
          }
        }

#line 1709 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)clos->return_type))) {

#line 1710 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          clos->return_type=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Void, node->span);
        }

#line 1713 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_function_declaration(this, clos);

#line 1714 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_function(this, clos);

#line 1715 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return clos->type;
      } break;
    case compiler_ast_nodes_ASTType_Error:
    m_317_20:
      {

#line 1718 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return hint;
      } break;
    default:
      {

#line 1721 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Invalid expression in TypeChecker::check_expression: %s", compiler_ast_nodes_ASTType_dbg(node->type))));

#line 1722 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return NULL;
      } break;
  }
}


#line 1729 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_call_dbg_on_enum_value(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST **node_ptr) {

#line 1730 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *node = (*node_ptr);

#line 1732 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)node->etype))) {

#line 1732 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 1733 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((node->etype->base)) {
    case compiler_types_BaseType_Enum:
    m_324_0:
      {
      } break;
    default:
      {

#line 1735 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return node->etype;
      } break;
  }

#line 1738 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, node->span);

#line 1739 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  member->u.member.lhs=node;

#line 1740 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  member->u.member.rhs_name="dbg";

#line 1741 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  member->u.member.rhs_span=node->span;

#line 1743 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, node->span);

#line 1744 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  call->u.call.callee=member;

#line 1745 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  call->u.call.args=std_vector_Vector__7_new(16);

#line 1747 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  (*node_ptr)=call;

#line 1749 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return compiler_passes_typechecker_TypeChecker_check_expression(this, call, NULL);
}


#line 1752 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_match_for_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {

#line 1753 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__11 *mapping = std_map_Map__11_new(8);

#line 1754 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"

#line 1756 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__24 *cases = node->u.match_stmt.cases;

#line 1757 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->returns=(cases->size > 0);

#line 1760 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__2 *current_args = std_map_Map__2_new(8);

#line 1761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__24 _i162 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i162); std_vector_Iterator__24_next(&_i162)) {

#line 1761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i162);

#line 1761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 1762 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__10 *conds = _case.conds;

#line 1764 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__2_clear(current_args);

#line 1765 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      for (u32 i = 0; i < conds->size; i++) {

#line 1766 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_MatchCond *cond = std_vector_Vector__10_at(conds, i);

#line 1767 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        char *name;

#line 1769 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *expr = cond->expr;

#line 1770 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        expr->hint=enom->type;

#line 1771 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((expr->type)) {
          case compiler_ast_nodes_ASTType_Identifier:
          case compiler_ast_nodes_ASTType_NSLookup:
          case compiler_ast_nodes_ASTType_Specialization:
          m_325_0:
            {
            } break;
          default:
            {

#line 1774 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Expected value enum variant, got %s", compiler_ast_nodes_ASTType_dbg(expr->type))));

#line 1775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              continue;
            } break;
        }

#line 1779 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *resolved_sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, expr, true, enom->type, true);

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)resolved_sym))) {

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          continue;
        }

#line 1781 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (resolved_sym->type != compiler_ast_scopes_SymbolType_EnumVariant) {

#line 1782 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, std_format("Expected value enum variant, got %s (%s)", compiler_ast_scopes_SymbolType_dbg(resolved_sym->type), resolved_sym->display)));

#line 1785 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          continue;
        }

#line 1787 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_EnumVariant *variant = resolved_sym->u.enum_var;

#line 1789 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (variant->parent != enom) {

#line 1790 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(expr->span, "Condition does not match expression type", node->u.match_stmt.expr->span, std_format("Match expression is of type '%s'", compiler_types_Type_str(enom->type))));
        }

#line 1795 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        expr->etype=enom->type;

#line 1797 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_vector_Vector__19 *args = cond->args;

#line 1800 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (i==0) {

#line 1801 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)args)) {

#line 1802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            for (u32 j = 0; j < args->size; j+=1) {

#line 1803 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, j);

#line 1809 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_Variable *sp_field = compiler_ast_nodes_EnumVariant_get_specific_field(variant, arg->var->sym->name);

#line 1810 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_Variable *sh_field = compiler_ast_nodes_Enum_get_shared_field(enom, arg->var->sym->name);

#line 1811 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_ast_nodes_Variable *field = ({ compiler_ast_nodes_Variable *__yield_0;

#line 1811 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                if (((bool)sp_field)) {
                  __yield_0 = sp_field;
                } else if (((bool)sh_field)) {

#line 1814 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  arg->is_shared=true;

#line 1815 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  __yield_0 = sh_field;
                } else {

#line 1818 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, std_format("Field `%s` does not exist in enum variant %s", arg->var->sym->name, variant->sym->display)));

#line 1821 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  __yield_0 = NULL;
                }

              __yield_0; });

#line 1824 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (((bool)field)) {

#line 1825 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                arg->var->type=field->type;

#line 1826 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                std_map_Map__2_insert(current_args, arg->var->sym->name, field->type);
              }
            }
          }
        } else {

#line 1834 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          u32 found_args = 0;

#line 1835 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          for (u32 j = 0; ((bool)args) && (j < args->size); j+=1) {

#line 1836 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, j);

#line 1839 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *sp_field = compiler_ast_nodes_EnumVariant_get_specific_field(variant, arg->var->sym->name);

#line 1840 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *sh_field = compiler_ast_nodes_Enum_get_shared_field(enom, arg->var->sym->name);

#line 1841 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *field = ({ compiler_ast_nodes_Variable *__yield_0;

#line 1841 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (((bool)sp_field)) {
                __yield_0 = sp_field;
              } else if (((bool)sh_field)) {

#line 1844 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                arg->is_shared=true;

#line 1845 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                __yield_0 = sh_field;
              } else {

#line 1848 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, "Field does not exist in enum variant"));

#line 1851 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                __yield_0 = NULL;
              }

            __yield_0; });

#line 1856 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (((bool)field)) {

#line 1857 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              arg->var->type=field->type;
            }

#line 1860 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            std_map_Item__2 *item = std_map_Map__2_get_item(current_args, arg->var->sym->name);

#line 1861 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (!(((bool)item))) {

#line 1862 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, "All conditions in this branch must have the same fields"));

#line 1865 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              continue;
            }

#line 1868 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            found_args+=1;

#line 1869 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (((bool)field) && !(compiler_types_Type_eq(item->value, field->type, false))) {

#line 1870 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(arg->var->sym->span, std_format("Field type does not match previous branch: %s", compiler_types_Type_str(item->value))));

#line 1873 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              continue;
            }
          }

#line 1876 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (found_args != current_args->size) {

#line 1877 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, "All conditions in this branch must have the same fields"));
          }
        }

#line 1883 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        name=expr->resolved_symbol->name;

#line 1884 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_MatchCond *prev = std_map_Map__11_get(mapping, name, NULL);

#line 1885 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)prev)) {

#line 1886 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(expr->span, "Duplicate condition name in match", prev->expr->span, "This condition was previously used here"));
        }

#line 1891 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_map_Map__11_insert(mapping, name, cond);
      }

#line 1894 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)_case.body)) {

#line 1895 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_generic_pass_GenericPass_push_scope(this->o, compiler_ast_scopes_Scope_new(compiler_passes_generic_pass_GenericPass_scope(this->o)));

#line 1896 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        for (std_map_Iterator__2 _i163 = std_map_Map__2_iter(current_args); std_map_Iterator__2_has_value(&_i163); std_map_Iterator__2_next(&_i163)) {

#line 1896 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          std_map_Item__2 *arg = std_map_Iterator__2_cur(&_i163);

#line 1896 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          {

#line 1897 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(arg->value);

#line 1898 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            var->sym=compiler_ast_scopes_Symbol_from_local_variable(arg->key, var, arg->value->span);

#line 1899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, var->sym, NULL);
          }
        }

#line 1902 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);

#line 1903 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
      }
    }
  }

#line 1907 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *defolt = node->u.match_stmt.defolt;

#line 1908 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (mapping->size != enom->variants->size) {

#line 1909 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 1910 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_buffer_Buffer_write_str(&buf, "Remaining fields: ");

#line 1911 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    bool first = true;

#line 1912 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (std_vector_Iterator__20 _i164 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i164); std_vector_Iterator__20_next(&_i164)) {

#line 1912 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i164);

#line 1912 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      {

#line 1913 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(std_map_Map__11_contains(mapping, variant->sym->name))) {

#line 1914 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(first)) {

#line 1914 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            std_buffer_Buffer_write_str(&buf, " | ");
          }

#line 1915 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          std_buffer_Buffer_write_str(&buf, variant->sym->name);

#line 1916 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          first=false;
        }
      }
    }

#line 1919 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)defolt))) {

#line 1920 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(node->u.match_stmt.expr->span, std_format("Match does not cover all cases (Only %u of %u)", mapping->size, enom->variants->size), std_buffer_Buffer_str(buf)));
    } else {

#line 1925 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, defolt, is_expr, hint);
    }
  } else {

#line 1928 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)defolt)) {

#line 1929 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.defolt_span, "`else` case is not needed for this match"));
    }
  }

#line 1933 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_expr && !(((bool)node->etype))) {

#line 1934 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.match_span, "Expression-match must yield a value"));
  }
  /* defers */

#line 1754 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__11_free(mapping);
}


#line 1939 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_match_for_bool(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {

#line 1940 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;

#line 1941 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((match_stmt->cases->size != 2) || ((bool)match_stmt->defolt)) {

#line 1942 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Match for bool must have exactly `true` and `false` cases"));
  }

#line 1945 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool seen_true = false;

#line 1946 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool seen_false = false;

#line 1947 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->returns=true;

#line 1949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__24 _i165 = std_vector_Vector__24_iter(match_stmt->cases); std_vector_Iterator__24_has_value(&_i165); std_vector_Iterator__24_next(&_i165)) {

#line 1949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i165);

#line 1949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 1950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      for (std_vector_Iterator__10 _i166 = std_vector_Vector__10_iter(_case.conds); std_vector_Iterator__10_has_value(&_i166); std_vector_Iterator__10_next(&_i166)) {

#line 1950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i166);

#line 1950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        {

#line 1951 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_AST *expr = cond->expr;

#line 1952 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);

#line 1953 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (expr->type != compiler_ast_nodes_ASTType_BoolLiteral) {

#line 1954 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(expr->span, "Expected either `true` or `false`"));
          } else {

#line 1956 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (expr->u.bool_literal) {

#line 1957 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              seen_true=true;
            } else {

#line 1959 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              seen_false=true;
            }
          }
        }
      }

#line 1963 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)_case.body)) {

#line 1964 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);
      } else {

#line 1979 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Case must have a body"));
      }
    }
  }

#line 1983 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(seen_true)) {

#line 1983 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Missing `true` case"));
  }

#line 1984 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(seen_false)) {

#line 1984 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Missing `false` case"));
  }

#line 1986 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_expr && !(((bool)node->etype))) {

#line 1987 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Expression-match must yield a value"));
  }
}


#line 1991 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_ast_nodes_Function *compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *expr, compiler_ast_nodes_MatchCond *cond) {

#line 1992 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *lhs = expr->etype;

#line 1993 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *rhs = cond->expr->etype;

#line 1995 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_types_Type_eq(lhs, rhs, false)) {

#line 1996 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_types_Type_is_numeric_or_char(lhs)) {

#line 1996 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return NULL;
    }

#line 1997 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (lhs->base==compiler_types_BaseType_Bool) {

#line 1997 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return NULL;
    }
  }

#line 2001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_operators_OperatorOverload overload = {0};

#line 2002 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  overload.op=compiler_ast_operators_Operator_Equals;

#line 2003 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  overload.type1=lhs;

#line 2004 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  overload.type2=rhs;

#line 2005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Function *func = std_map_Map__5_get(this->o->program->operator_overloads, overload, NULL);

#line 2006 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)func))) {

#line 2007 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(cond->expr->span, std_format("Cannot match %s with this case: %s", compiler_types_Type_str(lhs), compiler_types_Type_str(rhs)), expr->span, std_format("Match expression is of type %s", compiler_types_Type_str(lhs))));

#line 2011 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 2014 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *ret = compiler_types_Type_unaliased(func->return_type);

#line 2015 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (ret->base != compiler_types_BaseType_Bool) {

#line 2016 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(cond->expr->span, std_format("Overload %s must return a boolean", func->sym->display), func->sym->span, std_format("Defined here, return type is %s", compiler_types_Type_str(ret))));

#line 2020 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return NULL;
  }

#line 2023 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  cond->cmp_fn=func;

#line 2024 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return func;
}


#line 2028 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_match(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {

#line 2029 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;

#line 2030 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *expr = match_stmt->expr;

#line 2031 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *expr_type = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, NULL);

#line 2032 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)expr_type))) {

#line 2033 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(match_stmt->match_span, "Match statement must have a valid expression"));

#line 2034 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2037 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((expr_type->base)) {
    case compiler_types_BaseType_Enum:
    m_326_0:
      {

#line 2039 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_match_for_enum(this, expr_type->u.enom, node, is_expr, hint);

#line 2040 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      } break;
    case compiler_types_BaseType_Bool:
    m_326_1:
      {

#line 2043 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_match_for_bool(this, node, is_expr, hint);

#line 2044 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      } break;
    default:
      {
      } break;
  }

#line 2049 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__24 *cases = match_stmt->cases;

#line 2050 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->returns=(cases->size > 0);

#line 2052 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__24 _i167 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i167); std_vector_Iterator__24_next(&_i167)) {

#line 2052 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i167);

#line 2052 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2053 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      for (std_vector_Iterator__10 _i168 = std_vector_Vector__10_iter(_case.conds); std_vector_Iterator__10_has_value(&_i168); std_vector_Iterator__10_next(&_i168)) {

#line 2053 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i168);

#line 2053 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        {

#line 2054 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_AST *cond_expr = cond->expr;

#line 2055 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond_expr, expr_type);

#line 2056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)cond_type))) {

#line 2056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            continue;
          }

#line 2058 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Function *cmp_fn = compiler_passes_typechecker_TypeChecker_check_match_case_and_find_overload(this, expr, cond);

#line 2059 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)cmp_fn)) {

#line 2060 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            match_stmt->is_custom_match=true;
          } else {

#line 2063 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            bool is_constant = (((bool)cond_expr->resolved_symbol) && cond_expr->resolved_symbol->type==compiler_ast_scopes_SymbolType_Constant);

#line 2065 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (((cond_expr->type != compiler_ast_nodes_ASTType_IntLiteral) && (cond_expr->type != compiler_ast_nodes_ASTType_CharLiteral)) && !(is_constant)) {

#line 2067 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(cond_expr->span, "Match condition must use only literals"));
            }
          }
        }
      }

#line 2072 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)_case.body)) {

#line 2073 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, _case.body, is_expr, hint);
      }
    }
  }

#line 2077 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *defolt = node->u.match_stmt.defolt;

#line 2079 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)defolt))) {

#line 2080 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.match_stmt.match_span, "`else` case is missing"));
  } else {

#line 2082 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, defolt, is_expr, hint);
  }

#line 2085 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((is_expr && !(((bool)node->etype))) && !(node->returns)) {

#line 2086 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Expression-match must yield a value"));
  }
}


#line 2090 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_if(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_expr, compiler_types_Type *hint) {

#line 2092 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->returns=true;

#line 2094 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__23 _i169 = std_vector_Vector__23_iter(node->u.if_stmt.branches); std_vector_Iterator__23_has_value(&_i169); std_vector_Iterator__23_next(&_i169)) {

#line 2094 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i169);

#line 2094 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2095 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, branch.cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));

#line 2096 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {

#line 2097 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(branch.cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
      }

#line 2102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, branch.body, is_expr, hint);
    }
  }

#line 2105 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)node->u.if_stmt.els)) {

#line 2106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *else_stmt = node->u.if_stmt.els;

#line 2107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_expression_statement(this, node, else_stmt, is_expr, hint);
  } else if (is_expr) {

#line 2110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->u.if_stmt.if_span, "If expressions must have an else branch"));
  } else {

#line 2116 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->returns=false;
  }
}


#line 2120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_expression_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body, bool is_expr, compiler_types_Type *hint) {

#line 2121 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((body->type)) {
    case compiler_ast_nodes_ASTType_Match:
    m_327_0:
      {

#line 2123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_match(this, body, is_expr, hint);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_327_1:
      {

#line 2124 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_if(this, body, is_expr, hint);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_327_2:
      {

#line 2126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_block(this, body, is_expr, hint);
      } break;
    default:
      {

#line 2128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (is_expr) {

#line 2129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_check_expression(this, body, hint);
        } else {

#line 2131 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_check_statement(this, body);
        }
      } break;
  }

#line 2136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->returns=(node->returns && body->returns);

#line 2138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(is_expr)) {

#line 2138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *ret = body->etype;

#line 2144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (body->returns) {
  } else if (!(((bool)ret))) {

#line 2147 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_span_Span start_span = (std_span_Span){.start=body->span.start, .end=body->span.start};

#line 2148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(start_span, std_format("Must yield a value in this branch, body type is %s", compiler_ast_nodes_ASTType_dbg(body->type))));
  } else if (!(((bool)node->etype))) {

#line 2150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    node->etype=ret;
  } else if (!(compiler_types_Type_eq(node->etype, ret, false))) {

#line 2152 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *yield_stmt = (node->type==compiler_ast_nodes_ASTType_Block ? node->u.block.final_stmt : body);

#line 2153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)yield_stmt))) {

#line 2153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      yield_stmt=body;
    }

#line 2154 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(compiler_ast_nodes_AST_display_span(yield_stmt), "Yield type of branch doesn't match previous branches", std_format("Expected type '%s', got '%s'", compiler_types_Type_str(node->etype), compiler_types_Type_str(ret))));
  }
}


#line 2162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_while(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 2163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));

#line 2164 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  scope->loop_count+=1;

#line 2166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);

#line 2167 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *cond = node->u.loop.cond;

#line 2168 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *body = node->u.loop.body;

#line 2170 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));

#line 2171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {

#line 2172 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
  }

#line 2177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_statement(this, body);

#line 2178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 2181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_for(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 2182 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Scope *scope = compiler_ast_scopes_Scope_new(compiler_passes_typechecker_TypeChecker_scope(this));

#line 2183 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  scope->loop_count+=1;

#line 2184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, scope);

#line 2186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *init = node->u.loop.init;

#line 2187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *cond = node->u.loop.cond;

#line 2188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *step = node->u.loop.step;

#line 2189 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *body = node->u.loop.body;

#line 2191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)init)) {

#line 2191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_statement(this, init);
  }

#line 2193 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)cond)) {

#line 2194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *cond_type = compiler_passes_typechecker_TypeChecker_check_expression(this, cond, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));

#line 2195 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)cond_type) && (cond_type->base != compiler_types_BaseType_Bool)) {

#line 2196 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(cond->span, "Condition must be a boolean", std_format("Got type '%s'", compiler_types_Type_str(cond_type))));
    }
  }

#line 2203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)step)) {

#line 2203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_expression(this, step, NULL);
  }

#line 2204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)body)) {

#line 2204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_statement(this, body);
  }

#line 2206 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 2209 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 2210 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Return:
    m_328_0:
      {

#line 2212 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Function *cur_func = compiler_passes_typechecker_TypeChecker_scope(this)->cur_func;

#line 2213 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(((bool)cur_func))) {

#line 2214 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot return from outside a function"));

#line 2215 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        }

#line 2218 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *expected = cur_func->return_type;

#line 2220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *res = NULL;

#line 2221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *child = node->u.ret.expr;

#line 2222 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_span_Span ret_span = node->u.ret.return_span;

#line 2223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)child)) {

#line 2223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          res=compiler_passes_typechecker_TypeChecker_check_expression(this, child, expected);
        }

#line 2225 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)child) && child->returns) {
        } else if (expected->base==compiler_types_BaseType_Void) {

#line 2230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)node->u.child)) {

#line 2231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, "Cannot return a value from a void function"));
          }
        } else if (((bool)child)) {

#line 2234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)res) && !(compiler_types_Type_eq(res, expected, false))) {

#line 2235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, std_format("Return type %s does not match function return type %s", compiler_types_Type_str(res), compiler_types_Type_str(expected))));
          }
        } else {

#line 2238 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(ret_span, "Expected a return value for non-void function"));
        }

#line 2240 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->returns=true;
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_328_1:
      {

#line 2243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *expr = node->u.assertion.expr;

#line 2244 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *expr_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, expr, compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span));

#line 2245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)expr_typ) && (expr_typ->base != compiler_types_BaseType_Bool)) {

#line 2246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only assert boolean types, got %s", compiler_types_Type_str(expr_typ))));
        }

#line 2249 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)node->u.assertion.msg)) {

#line 2250 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *msg_typ = compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.assertion.msg, NULL);

#line 2251 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)msg_typ) && (msg_typ != compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span))) {

#line 2252 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Can only assert strings, got %s", compiler_types_Type_str(msg_typ))));
          }
        }

#line 2256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (expr->type==compiler_ast_nodes_ASTType_BoolLiteral && expr->u.bool_literal==false) {

#line 2257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          node->returns=true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    m_328_2:
      {

#line 2260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_statement(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    m_328_3:
      {

#line 2262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (!(compiler_passes_typechecker_TypeChecker_scope(this)->can_yield)) {

#line 2263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot yield here"));
        }

#line 2265 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        node->etype=compiler_passes_typechecker_TypeChecker_check_expression(this, node->u.child, NULL);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_328_4:
      {

#line 2268 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_handle_import_statement(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_328_5:
      {

#line 2271 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (compiler_passes_typechecker_TypeChecker_scope(this)->loop_count==0) {

#line 2272 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s statement outside of loop", compiler_ast_nodes_ASTType_dbg(node->type))));
        }
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_328_6:
      {

#line 2275 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_if(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_While:
    m_328_7:
      {

#line 2276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_while(this, node);
      } break;
    case compiler_ast_nodes_ASTType_For:
    m_328_8:
      {

#line 2277 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_for(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_328_9:
      {

#line 2278 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_block(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_328_10:
      {

#line 2279 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_match(this, node, false, NULL);
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_328_11:
      {

#line 2281 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 2282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *res = compiler_ast_scopes_Scope_lookup_local(compiler_passes_typechecker_TypeChecker_scope(this), var->sym->name);

#line 2283 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)res)) {

#line 2284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Variable %s already exists in this scope", var->sym->name)));

#line 2285 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        }

#line 2288 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *sym = var->sym;

#line 2289 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Scope_insert(compiler_passes_typechecker_TypeChecker_scope(this), var->sym->name, sym);

#line 2291 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        bool is_inferred = var->type==NULL;

#line 2292 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (is_inferred) {

#line 2293 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          var->type=compiler_types_Type_new_unresolved("<inferred>", node->span);
        } else {

#line 2296 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          var->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, false, true, true);

#line 2297 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)var->type))) {

#line 2297 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            return;
          }
        }

#line 2300 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_AST *init = node->u.var_decl->default_value;

#line 2301 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)init)) {

#line 2302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_check_expression(this, init, var->type);

#line 2303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)res))) {

#line 2303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            return;
          }

#line 2305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (is_inferred) {

#line 2306 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            var->type=res;
          } else if (!(compiler_types_Type_eq(res, var->type, false))) {

#line 2308 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(init->span, std_format("Variable %s has type %s but initializer has type %s", var->sym->name, compiler_types_Type_str(var->type), compiler_types_Type_str(res))));
          }
        } else if (is_inferred) {

#line 2311 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Variable %s has no type and no initializer", var->sym->name)));
        }
      } break;
    default:
      {

#line 2315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression(this, node, NULL);
      } break;
  }
}


#line 2320 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func) {

#line 2321 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, func->sym);

#line 2323 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool is_templated = false;

#line 2324 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method && func->parent_type->base==compiler_types_BaseType_Structure) {

#line 2325 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Structure *struc = func->parent_type->u.struc;

#line 2326 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 2326 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      is_templated=true;
    }
  }

#line 2328 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {

#line 2328 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    is_templated=true;
  }

#line 2329 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (func->checked) {

#line 2329 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  func->checked=true;

#line 2332 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_scopes_Scope *new_scope = compiler_ast_scopes_Scope_new(func->scope);

#line 2333 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3 *params = func->params;

#line 2339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool was_in_template_instance = this->in_template_instance;

#line 2340 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  this->in_template_instance=(this->in_template_instance || compiler_ast_nodes_Function_is_template_instance(func));

#line 2341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"

#line 2349 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  u32 error_count_before = this->o->program->errors->size;

#line 2351 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i170 = std_vector_Vector__3_iter(params); std_vector_Iterator__3_has_value(&_i170); std_vector_Iterator__3_next(&_i170)) {

#line 2351 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i170);

#line 2351 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2352 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)param->type))) {

#line 2352 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }

#line 2353 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_AST *default_expr = param->default_value;

#line 2354 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)default_expr)) {

#line 2358 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_types_Type *default_type = compiler_passes_typechecker_TypeChecker_check_expression(this, default_expr, param->type);

#line 2360 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (((bool)default_type) && !(compiler_types_Type_eq(default_type, param->type, false))) {

#line 2361 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(default_expr->span, std_format("Default argument has type %s but expected %s", compiler_types_Type_str(default_type), compiler_types_Type_str(param->type))));
        }
      }

#line 2365 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__4_insert(new_scope->items, param->sym->name, param->sym);
    }
  }

#line 2367 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  new_scope->cur_func=func;

#line 2369 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func->sym) && func->sym->is_extern) {

#line 2369 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    /* defers */

#line 2341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    this->in_template_instance=was_in_template_instance;
    return;
  }

#line 2371 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, new_scope);

#line 2372 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *ret_type = func->return_type;

#line 2373 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((func->is_arrow && ((bool)ret_type)) && (ret_type->base != compiler_types_BaseType_Void)) {

#line 2374 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *stmt_type = compiler_passes_typechecker_TypeChecker_check_expression(this, func->body, ret_type);

#line 2375 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)stmt_type))) {

#line 2376 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->body->span, "Arrow function must yield a value"));
    } else if (!(compiler_types_Type_eq(stmt_type, ret_type, false))) {

#line 2378 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(func->body->span, std_format("Expected return type %s, but got %s", compiler_types_Type_str(ret_type), compiler_types_Type_str(stmt_type)), ret_type->span, std_format("Arrow function has return type %s", compiler_types_Type_str(ret_type))));
    } else {

#line 2383 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      func->body->returns=true;
    }
  } else {

#line 2387 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_statement(this, func->body);
  }

#line 2390 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if ((!(func->body->returns) && (func->return_type->base != compiler_types_BaseType_Void)) && !(str_eq(func->sym->full_name, "main"))) {

#line 2391 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, "Function does not always return"));
  }

#line 2393 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);

#line 2396 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_templated) {

#line 2397 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (this->o->program->errors->size > error_count_before) {

#line 2398 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      this->o->program->errors->size=error_count_before;
    }
  }
  /* defers */

#line 2341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  this->in_template_instance=was_in_template_instance;
}


#line 2403 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_handle_imports(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool is_global) {

#line 2404 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);

#line 2405 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 2407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_ValueIterator__3 _i171 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i171); std_map_ValueIterator__3_next(&_i171)) {

#line 2407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i171);

#line 2407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2408 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_handle_imports(this, child, false);
    }
  }

#line 2411 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i172 = std_vector_Vector__16_iter(ns->imports); std_vector_Iterator__16_has_value(&_i172); std_vector_Iterator__16_next(&_i172)) {

#line 2411 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *import_ = std_vector_Iterator__16_cur(&_i172);

#line 2411 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2412 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_handle_import_statement(this, import_);
    }
  }

#line 2415 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);

#line 2416 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);
}


#line 2419 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const) {

#line 2420 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 2421 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, var->sym);

#line 2423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_AST *init = node->u.var_decl->default_value;

#line 2424 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (is_const) {

#line 2425 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)init)) {

#line 2426 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_const_expression(this, init, NULL);
    } else if (!(node->u.var_decl->sym->is_extern)) {

#line 2428 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Constant must have an initializer"));
    }
  } else if (((bool)init)) {

#line 2432 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *init_type = compiler_passes_typechecker_TypeChecker_check_expression(this, init, var->type);

#line 2433 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)init_type)) || !(((bool)var->type))) {

#line 2433 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2435 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(compiler_types_Type_eq(init_type, var->type, false))) {

#line 2436 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(init->span, std_format("Variable %s has type %s but got %s", var->sym->name, compiler_types_Type_str(var->type), compiler_types_Type_str(init_type))));
    }
  }
}


#line 2442 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {

#line 2443 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 2444 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);

#line 2445 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, ns->sym);

#line 2447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__6 _i173 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i173); std_vector_Iterator__6_next(&_i173)) {

#line 2447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i173);

#line 2447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2448 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_function(this, func);
    }
  }

#line 2451 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i174 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i174); std_vector_Iterator__16_next(&_i174)) {

#line 2451 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i174);

#line 2451 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2452 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_globals(this, node, true);
    }
  }

#line 2455 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i175 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i175); std_vector_Iterator__16_next(&_i175)) {

#line 2455 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i175);

#line 2455 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_globals(this, node, false);
    }
  }

#line 2459 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__15 _i176 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i176); std_vector_Iterator__15_next(&_i176)) {

#line 2459 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i176);

#line 2459 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2461 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, enom->sym);

#line 2462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      for (std_vector_Iterator__20 _i177 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i177); std_vector_Iterator__20_next(&_i177)) {

#line 2462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i177);

#line 2462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        {

#line 2463 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, variant->sym);
        }
      }
    }
  }

#line 2467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_ValueIterator__3 _i178 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i178); std_map_ValueIterator__3_next(&_i178)) {

#line 2467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i178);

#line 2467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2468 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_namespace(this, child);
    }
  }

#line 2470 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);

#line 2471 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 2475 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_doc_links(compiler_passes_typechecker_TypeChecker *this, compiler_ast_scopes_Symbol *sym) {

#line 2476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!((((bool)sym) && ((bool)sym->comment)))) {

#line 2476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2478 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer buffer = std_buffer_Buffer_make(16);

#line 2479 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  u32 prev = 0;

#line 2480 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  char *doc = sym->comment;

#line 2481 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  u32 doc_len = strlen(doc);

#line 2482 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < (doc_len - 1); i++) {

#line 2483 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (doc[i]=='\\') {

#line 2484 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      i++;
    } else if (doc[i]==doc[(i + 1)] && doc[(i + 1)]=='{') {

#line 2486 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_buffer_Buffer_write_str_f(&buffer, str_substring(doc, prev, (i - prev)));

#line 2487 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      prev=(i + 2);

#line 2488 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      i++;
    } else if (doc[i]==doc[(i + 1)] && doc[(i + 1)]=='}') {

#line 2491 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      char *part = str_substring(doc, prev, (i - prev));

#line 2496 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(this->o->program->check_doc_links)) {

#line 2497 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_buffer_Buffer_write_char(&buffer, '`');

#line 2498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_buffer_Buffer_write_str_f(&buffer, part);

#line 2499 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        std_buffer_Buffer_write_char(&buffer, '`');

#line 2500 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        prev=(i + 2);

#line 2501 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        i++;

#line 2502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }

#line 2506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(part, sym->span.start.filename);

#line 2507 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_span_Span span = (std_span_Span){.start=sym->comment_loc, .end=sym->comment_loc};

#line 2508 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);

#line 2510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (lexer.errors->size > 0) {

#line 2511 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Invalid link: '%s' in this doc", part)));

#line 2512 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      }

#line 2515 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_parser_Parser parser = compiler_parser_Parser_make(this->o->program, compiler_passes_generic_pass_GenericPass_ns(this->o));

#line 2516 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      parser.tokens=tokens;

#line 2517 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      parser.curr=0;

#line 2519 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(&parser, true);

#line 2520 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)ident))) {

#line 2521 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Invalid link: '%s' in this doc", part)));

#line 2522 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      }

#line 2525 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, ident, false, NULL, true);

#line 2526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)sym))) {

#line 2527 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Couldn't find symbol '%s' in this doc link", part)));

#line 2528 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      }

#line 2531 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      char *linked_part = ({ char *__yield_0;

#line 2531 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        switch ((sym->type)) {
          case compiler_ast_scopes_SymbolType_Structure:
          m_329_0:
            {

#line 2533 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_types_Type *typ = sym->u.struc->type;

#line 2535 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              if (((bool)typ->template_instance)) {

#line 2536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_note(span, std_format("Cannot link directly to specialezed type '%s'", part), "Try doing `{{A}}<{{B}}>` instead of `{{A<B>}}`"));

#line 2540 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                return;
              }

#line 2542 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              __yield_0 = std_format("%x", sym->u.struc->type);
            } break;
          case compiler_ast_scopes_SymbolType_Function:
          m_329_1:
            {
              __yield_0 = std_format("%x", sym->u.func);
            } break;
          case compiler_ast_scopes_SymbolType_Enum:
          m_329_2:
            {
              __yield_0 = std_format("%x", sym->u.enom);
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_329_3:
            {
              __yield_0 = std_format("%x", sym->u.enum_var);
            } break;
          case compiler_ast_scopes_SymbolType_TypeDef:
          m_329_4:
            {
              __yield_0 = std_format("%x", sym->u.type_def);
            } break;
          case compiler_ast_scopes_SymbolType_Variable:
          m_329_5:
            {
              __yield_0 = std_format("%x", sym->u.var);
            } break;
          case compiler_ast_scopes_SymbolType_Constant:
          m_329_6:
            {
              __yield_0 = std_format("%x", sym->u.var);
            } break;
          case compiler_ast_scopes_SymbolType_Namespace:
          m_329_7:
            {
              __yield_0 = std_format("%x", sym->u.ns);
            } break;
          default:
            {

#line 2552 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(span, std_format("Cannot link to symbol of type %s", compiler_ast_scopes_SymbolType_dbg(sym->type))));

#line 2553 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return;
            } break;
        }

      __yield_0; });

#line 2557 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_buffer_Buffer_write_str(&buffer, "{{");

#line 2558 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_buffer_Buffer_write_str_f(&buffer, linked_part);

#line 2559 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_buffer_Buffer_write_str(&buffer, "}}");

#line 2560 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_mem_free(part);

#line 2562 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      prev=(i + 2);

#line 2563 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      i++;
    }
  }

#line 2566 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_buffer_Buffer_write_str_f(&buffer, str_substring(doc, prev, (doc_len - prev)));

#line 2567 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  sym->comment=std_buffer_Buffer_str(buffer);
}


#line 2570 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
compiler_types_Type *compiler_passes_typechecker_TypeChecker_check_const_expression(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_types_Type *hint) {

#line 2571 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *typ = ({ compiler_types_Type *__yield_0;

#line 2571 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      case compiler_ast_nodes_ASTType_NSLookup:
      m_330_0:
        {

#line 2573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_scopes_Symbol *sym = compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, node, true, hint, true);

#line 2574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)sym))) {

#line 2574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            return NULL;
          }

#line 2575 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (sym->type != compiler_ast_scopes_SymbolType_Constant) {

#line 2576 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(node->span, "Cannot use a non-constant value in a constant expression", sym->span, "Value was defined here"));

#line 2580 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            return hint;
          }

#line 2582 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = sym->u.var->type;
        } break;
      case compiler_ast_nodes_ASTType_IntLiteral:
      m_330_1:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
        } break;
      case compiler_ast_nodes_ASTType_FloatLiteral:
      m_330_2:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_F32, node->span);
        } break;
      case compiler_ast_nodes_ASTType_BoolLiteral:
      m_330_3:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Bool, node->span);
        } break;
      case compiler_ast_nodes_ASTType_CharLiteral:
      m_330_4:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Char, node->span);
        } break;
      case compiler_ast_nodes_ASTType_StringLiteral:
      m_330_5:
        {
          __yield_0 = compiler_passes_typechecker_TypeChecker_get_type_by_name(this, "str", node->span);
        } break;
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_330_6:
        {

#line 2591 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *lhs = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.binary.lhs, NULL);

#line 2592 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *rhs = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.binary.rhs, NULL);

#line 2593 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (!(((bool)lhs)) || !(((bool)rhs))) {

#line 2593 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            return NULL;
          }

#line 2595 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (lhs->base==compiler_types_BaseType_Pointer || rhs->base==compiler_types_BaseType_Pointer) {

#line 2596 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot do pointer arithmetic in constant expressions"));
          }

#line 2598 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = compiler_passes_typechecker_TypeChecker_check_binary_op(this, node, compiler_types_Type_unaliased(lhs), compiler_types_Type_unaliased(rhs));
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_330_7:
        {
          __yield_0 = ({ compiler_types_Type *__yield_1;

#line 2600 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            switch ((node->u.unary.op)) {
              case compiler_ast_operators_Operator_BitwiseNot:
              case compiler_ast_operators_Operator_Negate:
              m_331_0:
                {

#line 2602 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if (!(((bool)hint)) || !(compiler_types_Type_is_numeric(hint))) {

#line 2603 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    hint=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_I32, node->span);
                  }

#line 2605 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_types_Type *typ = compiler_passes_typechecker_TypeChecker_check_const_expression(this, node->u.unary.expr, hint);

#line 2606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if (!(((bool)typ))) {

#line 2606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return NULL;
                  }

#line 2607 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  if (!(compiler_types_Type_is_numeric(typ))) {

#line 2608 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Cannot negate non-numeric type: %s", compiler_types_Type_str(typ))));

#line 2609 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                    return NULL;
                  }

#line 2611 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  __yield_1 = typ;
                } break;
              default:
                {

#line 2614 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("Unsupported operator in constant expression: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));

#line 2615 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
                  return NULL;
                } break;
            }

          __yield_1; });
        } break;
      default:
        {

#line 2619 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Unsupported operator in constant expression"));

#line 2620 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return NULL;
        } break;
    }

  __yield_0; });

#line 2623 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->etype=typ;

#line 2624 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  return typ;
}


#line 2627 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_handle_import_path_base(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Import *imp, std_vector_Vector__5 *parts, compiler_ast_scopes_Symbol *base, bool search_in_ns_scope, char *alias) {

#line 2635 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (u32 i = 0; i < parts->size; i+=1) {

#line 2636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_ImportPart *part = std_vector_Vector__5_at(parts, i);

#line 2638 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_332_0:
        {

#line 2640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_generic_pass_GenericPass_import_all_from_symbol(this->o, base, imp->export);

#line 2641 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_332_1:
        {

#line 2644 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          std_vector_Vector__22 *paths = part->u.multiple.paths;

#line 2645 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          for (u32 j = 0; j < paths->size; j+=1) {

#line 2646 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            std_vector_Vector__5 *path = std_vector_Vector__22_at(paths, j);

#line 2647 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_typechecker_TypeChecker_handle_import_path_base(this, node, imp, path, base, search_in_ns_scope, alias);
          }

#line 2649 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        } break;
      case compiler_ast_nodes_ImportPartType_Single:
      m_332_2:
        {
        } break;
    }

#line 2654 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    char *name = part->u.single.name;

#line 2655 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)name))) {

#line 2655 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2657 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (str_eq(name, "this")) {

#line 2658 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if ((i + 1) != parts->size) {

#line 2659 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, "`this` can only be used as the last part of an import path"));

#line 2660 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        return;
      }

#line 2662 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)part->u.single.alias)) {

#line 2662 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        alias=part->u.single.alias;
      }

#line 2663 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      break;
    }

#line 2666 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_span_Span err_span = part->u.single.alias_span;

#line 2667 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *new_base = ({ compiler_ast_scopes_Symbol *__yield_0;

#line 2667 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (search_in_ns_scope) {

#line 2669 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (base->type != compiler_ast_scopes_SymbolType_Namespace) {

#line 2670 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, "Cannot scope-import from a non-namespace"));

#line 2671 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        }

#line 2673 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_scopes_Symbol *res = compiler_ast_scopes_Scope_lookup_recursive(base->u.ns->scope, name);

#line 2674 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        search_in_ns_scope=false;

#line 2675 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        __yield_0 = res;
      } else {
        __yield_0 = compiler_passes_generic_pass_GenericPass_find_in_symbol(this->o, base, name, false);
      }
    __yield_0; });

#line 2680 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)new_base))) {

#line 2681 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(part->span, std_format("Invalid import, %s::%s does not exist", base->name, name)));

#line 2682 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2685 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    base=new_base;

#line 2686 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    alias=part->u.single.alias;

#line 2687 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)alias))) {

#line 2687 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      alias=name;
    }

#line 2689 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    part->resolved_symbol=base;

#line 2690 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol_add_reference(base, compiler_ast_scopes_ReferenceType_Normal, part->u.single.name_span);
  }

#line 2693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, base, alias);

#line 2694 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (imp->export) {

#line 2695 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Map__4_insert(compiler_passes_generic_pass_GenericPass_ns(this->o)->exported_symbols, alias, base);
  }
}


#line 2700 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_handle_import_statement(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node) {

#line 2701 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Import path = node->u.import_path;

#line 2703 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool search_in_ns_scope = false;

#line 2704 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_program_Namespace *base_ns = ({ compiler_ast_program_Namespace *__yield_0;

#line 2704 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((path.type)) {
      case compiler_ast_nodes_ImportType_GlobalNamespace:
      m_333_0:
        {
          __yield_0 = this->o->program->global;
        } break;
      case compiler_ast_nodes_ImportType_ProjectNamespace:
      m_333_1:
        {
          __yield_0 = compiler_ast_program_Namespace_get_project_root(compiler_passes_generic_pass_GenericPass_ns(this->o), node->span, this->o->program);
        } break;
      case compiler_ast_nodes_ImportType_ParentNamespace:
      m_333_2:
        {

#line 2708 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_program_Namespace *cur = compiler_passes_generic_pass_GenericPass_ns(this->o);

#line 2709 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          for (u32 i = 0; i < path.parent_count; i+=1) {

#line 2710 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            if (!(((bool)cur->parent))) {

#line 2712 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              compiler_errors_Error_panic(compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Cannot import from parent of root namespace")));

#line 2713 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
              return;
            }

#line 2715 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            cur=cur->parent;
          }

#line 2717 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = cur;
        } break;
      case compiler_ast_nodes_ImportType_CurrentScope:
      m_333_3:
        {

#line 2720 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          search_in_ns_scope=true;

#line 2721 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          __yield_0 = compiler_passes_generic_pass_GenericPass_ns(this->o);
        } break;
    }

  __yield_0; });

#line 2725 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)base_ns))) {

#line 2726 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, "Couldn't resolve the search base for the import"));

#line 2727 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2730 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  node->u.import_path.root_sym=base_ns->sym;

#line 2731 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_handle_import_path_base(this, node, &path, path.parts, base_ns->sym, search_in_ns_scope, NULL);
}


#line 2734 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_pre_check_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, compiler_ast_nodes_Function *func) {

#line 2735 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 2736 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_span_Span parent_span = func->parent_type->span;

#line 2737 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *parent_type = compiler_passes_typechecker_TypeChecker_resolve_type(this, func->parent_type, true, true, true);

#line 2738 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(((bool)parent_type))) {

#line 2739 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(parent_span, "Could not find this type"));

#line 2740 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2743 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (!(compiler_types_Type_can_have_methods(parent_type))) {

#line 2744 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(parent_span, "This type cannot have methods"));

#line 2745 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2748 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((parent_type->base)) {
      case compiler_types_BaseType_Structure:
      m_334_0:
        {

#line 2750 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Structure *struc = parent_type->u.struc;

#line 2751 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Variable *name = compiler_ast_nodes_Structure_get_field(struc, func->sym->name);

#line 2752 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)name)) {

#line 2753 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Field with name `%s` already exists", func->sym->name), name->sym->span, "Previous definition here"));
          }
        } break;
      case compiler_types_BaseType_Enum:
      m_334_1:
        {

#line 2760 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Enum *enom = parent_type->u.enom;

#line 2761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_EnumVariant *var = compiler_ast_nodes_Enum_get_variant(enom, func->sym->name);

#line 2762 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)var)) {

#line 2763 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Enum variant with name `%s` already exists", func->sym->name), var->sym->span, "Previous definition here"));
          }

#line 2768 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_ast_nodes_Variable *field = compiler_ast_nodes_Enum_get_shared_field(enom, func->sym->name);

#line 2769 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)field)) {

#line 2770 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, std_format("Field with name `%s` already exists", func->sym->name), field->sym->span, "Previous definition here"));
          }
        } break;
      default:
        {
        } break;
    }

#line 2780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *res = std_map_Map__8_get(parent_type->methods, func->sym->name, NULL);

#line 2781 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (((bool)res)) {

#line 2782 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new_hint(func->sym->span, "Method with this name already exists", res->sym->span, "Previous definition here"));

#line 2786 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }

#line 2791 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol_update_parent(func->sym, parent_type->sym);

#line 2793 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Map__8_insert(parent_type->methods, func->sym->name, func);

#line 2794 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    func->parent_type=parent_type;
  } else {

#line 2797 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_scopes_Symbol *item = func->sym;

#line 2798 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_generic_pass_GenericPass_insert_into_scope_checked(this->o, item, NULL);
  }

#line 2801 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  func->scope=compiler_passes_typechecker_TypeChecker_scope(this);
}


#line 2806 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc) {

#line 2807 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i179 = std_vector_Vector__3_iter(struc->fields); std_vector_Iterator__3_has_value(&_i179); std_vector_Iterator__3_next(&_i179)) {

#line 2807 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i179);

#line 2807 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2809 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, true, false, false);

#line 2810 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      field->type=res;
    }
  }
}


#line 2814 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_struct(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Structure *struc) {

#line 2815 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_vector_Vector__3 *fields = struc->fields;

#line 2816 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, struc->sym);

#line 2819 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 2820 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_loosely_resolve_templated_struct(this, struc);

#line 2821 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2824 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i180 = std_vector_Vector__3_iter(fields); std_vector_Iterator__3_has_value(&_i180); std_vector_Iterator__3_next(&_i180)) {

#line 2824 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i180);

#line 2824 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2825 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);

#line 2826 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_resolve_doc_links(this, field->sym);

#line 2827 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)res))) {

#line 2828 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_generic_pass_GenericPass_error(this->o, compiler_errors_Error_new(field->sym->span, "Couldn't resolve type"));
      } else {

#line 2830 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        field->type=res;
      }

#line 2832 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)field->default_value)) {

#line 2833 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression(this, field->default_value, field->type);
      }
    }
  }
}


#line 2838 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_resolve_enum(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Enum *enom) {

#line 2839 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__12 *seen_fields = std_map_Map__12_new(8);

#line 2840 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"

#line 2842 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i181 = std_vector_Vector__3_iter(enom->shared_fields); std_vector_Iterator__3_has_value(&_i181); std_vector_Iterator__3_next(&_i181)) {

#line 2842 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i181);

#line 2842 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2843 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);

#line 2844 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)res)) {

#line 2845 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        field->type=res;
      }

#line 2847 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Item__12 *item = std_map_Map__12_get_item(seen_fields, field->sym->name);

#line 2848 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)item)) {

#line 2849 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(field->sym->span, std_format("Field with name `%s` already exists", field->sym->name), item->value, "Previous definition here"));
      }

#line 2854 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      std_map_Map__12_insert(seen_fields, field->sym->name, field->sym->span);

#line 2855 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (((bool)field->default_value)) {

#line 2856 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_expression(this, field->default_value, field->type);
      }
    }
  }

#line 2859 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__20 _i182 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i182); std_vector_Iterator__20_next(&_i182)) {

#line 2859 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i182);

#line 2859 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2860 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      for (std_vector_Iterator__3 _i183 = std_vector_Vector__3_iter(variant->specific_fields); std_vector_Iterator__3_has_value(&_i183); std_vector_Iterator__3_next(&_i183)) {

#line 2860 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i183);

#line 2860 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        {

#line 2861 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, field->type, false, true, true);

#line 2862 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          if (((bool)res)) {

#line 2863 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
            field->type=res;
          }
        }
      }
    }
  }
  /* defers */

#line 2840 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__12_free(seen_fields);
}


#line 2871 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_operator_overload_function(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func, compiler_ast_operators_Operator op) {

#line 2872 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  u32 num_params_needed = compiler_ast_operators_Operator_num_overload_params(op);

#line 2873 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (num_params_needed != func->params->size) {

#line 2874 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, std_format("Operator overload for %s must have %u parameters", compiler_ast_operators_Operator_dbg(op), num_params_needed)));

#line 2875 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2878 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(op)) {

#line 2879 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *lhs = std_vector_Vector__3_at(func->params, 0);

#line 2880 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *lhs_type = compiler_types_Type_unaliased(lhs->type);

#line 2881 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (lhs_type->base != compiler_types_BaseType_Pointer) {

#line 2882 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(lhs->sym->span, std_format("First parameter of %s operator must be a pointer-type", compiler_ast_operators_Operator_dbg(op))));

#line 2883 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      return;
    }
  }

#line 2888 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  switch ((op)) {
    case compiler_ast_operators_Operator_Equals:
    case compiler_ast_operators_Operator_NotEquals:
    case compiler_ast_operators_Operator_IsNotNull:
    m_335_0:
      
#line 2890 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        if (func->return_type->base != compiler_types_BaseType_Bool) {

#line 2891 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(func->sym->span, "`==` operator must return a boolean"));

#line 2892 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
          return;
        }
       break;
    default:
      {
      } break;
  }

#line 2897 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_operators_OperatorOverload overload = {0};

#line 2898 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  overload.op=op;

#line 2899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (num_params_needed > 0) {

#line 2899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type1=std_vector_Vector__3_at(func->params, 0)->type;
  }

#line 2900 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (num_params_needed > 1) {

#line 2900 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type2=std_vector_Vector__3_at(func->params, 1)->type;
  }

#line 2901 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (num_params_needed > 2) {

#line 2901 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    overload.type3=std_vector_Vector__3_at(func->params, 2)->type;
  }

#line 2903 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Item__5 *it = std_map_Map__5_get_item(this->o->program->operator_overloads, overload);

#line 2904 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)it)) {

#line 2905 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (it->value != func) {

#line 2906 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new_hint(func->sym->span, std_format("Operator overload for %s already exists (%s)", compiler_ast_operators_Operator_dbg(op), func->sym->display), it->value->sym->span, std_format("Previous definition here (%s)", it->value->sym->display)));
    }

#line 2911 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 2914 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_map_Map__5_insert(this->o->program->operator_overloads, overload, func);
}


#line 2917 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_function_declaration(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_Function *func) {

#line 2918 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool allow_incomplete = false;

#line 2919 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool error = true;

#line 2920 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  bool resolve_templates = true;

#line 2922 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method && func->parent_type->base==compiler_types_BaseType_Structure) {

#line 2923 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Structure *struc = func->parent_type->u.struc;

#line 2924 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 2925 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      allow_incomplete=true;

#line 2926 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      error=false;

#line 2927 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      resolve_templates=false;
    }
  }

#line 2930 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  std_span_Span func_span = ({ std_span_Span __yield_0;

#line 2930 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    switch ((func->kind)) {
      case compiler_ast_nodes_FunctionKind_Closure:
      m_336_0:
        {
          __yield_0 = func->span;
        } break;
      default:
        {
          __yield_0 = func->sym->span;
        } break;
    }

  __yield_0; });

#line 2934 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func->sym) && compiler_ast_scopes_Symbol_is_templated(func->sym)) {

#line 2935 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    allow_incomplete=true;

#line 2936 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    error=false;

#line 2937 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    resolve_templates=false;
  }

#line 2940 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  func->return_type=compiler_passes_typechecker_TypeChecker_resolve_type(this, func->return_type, allow_incomplete, error, resolve_templates);

#line 2941 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)func->return_type))) {

#line 2942 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    func->return_type=compiler_passes_typechecker_TypeChecker_get_base_type(this, compiler_types_BaseType_Void, func_span);
  }

#line 2945 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__3 _i184 = std_vector_Vector__3_iter(func->params); std_vector_Iterator__3_has_value(&_i184); std_vector_Iterator__3_next(&_i184)) {

#line 2945 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i184);

#line 2945 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2946 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      param->type=compiler_passes_typechecker_TypeChecker_resolve_type(this, param->type, allow_incomplete, error, resolve_templates);
    }
  }

#line 2949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func->operator_overloads)) {

#line 2950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    for (std_vector_Iterator__21 _i185 = std_vector_Vector__21_iter(func->operator_overloads); std_vector_Iterator__21_has_value(&_i185); std_vector_Iterator__21_next(&_i185)) {

#line 2950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_operators_Operator op = std_vector_Iterator__21_cur(&_i185);

#line 2950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      {

#line 2951 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        compiler_passes_typechecker_TypeChecker_check_operator_overload_function(this, func, op);
      }
    }
  }

#line 2957 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (((bool)func->name_ast) && func->name_ast->type==compiler_ast_nodes_ASTType_NSLookup) {

#line 2958 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_resolve_scoped_identifier(this, func->name_ast->u.lookup.lhs, false, NULL, false);
  }

#line 2963 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Closure) {

#line 2964 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    func->type=compiler_passes_typechecker_TypeChecker_get_closure_type(this, func->params, func->return_type, func->type);
  } else {

#line 2967 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_FunctionPtr, func_span);

#line 2968 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    typ->u.func=(compiler_types_FunctionType){.orig=func, .params=func->params, .return_type=func->return_type, .is_variadic=func->is_variadic};

#line 2969 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    func->type=typ;
  }
}


#line 2973 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns, bool pre_import) {

#line 2974 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_Iterator__2 _i186 = std_map_Map__2_iter(ns->typedefs); std_map_Iterator__2_has_value(&_i186); std_map_Iterator__2_next(&_i186)) {

#line 2974 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    std_map_Item__2 *it = std_map_Iterator__2_cur(&_i186);

#line 2974 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 2975 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (compiler_types_Type_is_resolved(it->value)) {

#line 2975 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }

#line 2977 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_recursive(compiler_passes_generic_pass_GenericPass_scope(this->o), it->key);

#line 2978 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if(!(((bool)sym))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:2978:16: Assertion failed: `sym?`", "Should have added the symbol into scope already"); }

#line 2982 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if(!(sym->type==compiler_ast_scopes_SymbolType_TypeDef)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc:2982:16: Assertion failed: `sym.type == TypeDef`", NULL); }

#line 2985 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_types_Type *res = compiler_passes_typechecker_TypeChecker_resolve_type(this, it->value, false, !(pre_import), true);

#line 2990 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      if (!(((bool)res))) {

#line 2990 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
        continue;
      }

#line 2991 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      sym->u.type_def->u.ptr=res;

#line 2992 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      sym->u.type_def=res;

#line 2993 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      it->value=res;
    }
  }
}


#line 2997 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_post_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {

#line 2998 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 2999 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_namespace(this->o, ns);

#line 3001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__6 _i187 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i187); std_vector_Iterator__6_next(&_i187)) {

#line 3001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i187);

#line 3001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3002 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_function_declaration(this, func);
    }
  }

#line 3005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__14 _i188 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i188); std_vector_Iterator__14_next(&_i188)) {

#line 3005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i188);

#line 3005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3006 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_resolve_struct(this, struc);
    }
  }

#line 3009 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__15 _i189 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i189); std_vector_Iterator__15_next(&_i189)) {

#line 3009 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i189);

#line 3009 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3010 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_resolve_enum(this, enom);
    }
  }

#line 3013 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i190 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i190); std_vector_Iterator__16_next(&_i190)) {

#line 3013 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i190);

#line 3013 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3014 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_pre_check_globals(this, node, true);
    }
  }

#line 3017 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__16 _i191 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i191); std_vector_Iterator__16_next(&_i191)) {

#line 3017 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i191);

#line 3017 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3018 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_pre_check_globals(this, node, false);
    }
  }

#line 3022 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(this, ns, false);

#line 3024 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_ValueIterator__3 _i192 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i192); std_map_ValueIterator__3_next(&_i192)) {

#line 3024 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i192);

#line 3024 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3025 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_post_import(this, child);
    }
  }

#line 3028 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);

#line 3029 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_namespace(this->o);
}


#line 3032 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_pre_check_globals(compiler_passes_typechecker_TypeChecker *this, compiler_ast_nodes_AST *node, bool is_const) {

#line 3033 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 3034 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)var->type))) {

#line 3035 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    char *c = (is_const ? "Constant" : "Global variable");

#line 3036 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_error(this, compiler_errors_Error_new(node->span, std_format("%s must have a type", c)));

#line 3037 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 3039 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_types_Type *type = compiler_passes_typechecker_TypeChecker_resolve_type(this, var->type, false, true, true);

#line 3040 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  if (!(((bool)type))) {

#line 3040 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    return;
  }

#line 3041 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  var->type=type;
}


#line 3044 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_check_pre_import(compiler_passes_typechecker_TypeChecker *this, compiler_ast_program_Namespace *ns) {

#line 3045 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 3047 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_vector_Iterator__6 _i193 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i193); std_vector_Iterator__6_next(&_i193)) {

#line 3047 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i193);

#line 3047 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3048 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_pre_check_function(this, ns, func);
    }
  }

#line 3054 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_try_resolve_typedefs_in_namespace(this, ns, true);

#line 3056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  for (std_map_ValueIterator__3 _i194 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i194); std_map_ValueIterator__3_next(&_i194)) {

#line 3056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i194);

#line 3056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    {

#line 3057 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
      compiler_passes_typechecker_TypeChecker_check_pre_import(this, child);
    }
  }

#line 3060 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 3063 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
void compiler_passes_typechecker_TypeChecker_run(compiler_ast_program_Program *program) {

#line 3064 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker pass = (compiler_passes_typechecker_TypeChecker){.o=compiler_passes_generic_pass_GenericPass_new(program), .unchecked_functions=std_vector_Vector__6_new(16), .in_template_instance=false};

#line 3069 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_pre_import(&pass, program->global);

#line 3070 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_handle_imports(&pass, program->global, true);

#line 3071 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_post_import(&pass, program->global);

#line 3073 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_typechecker_TypeChecker_check_namespace(&pass, program->global);

#line 3075 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_push_namespace(pass.o, program->global);

#line 3076 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  while (pass.unchecked_functions->size > 0) {

#line 3077 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_ast_nodes_Function *func = ((compiler_ast_nodes_Function *)std_vector_Vector__6_pop(pass.unchecked_functions));

#line 3078 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
    compiler_passes_typechecker_TypeChecker_check_function(&pass, func);
  }

#line 3080 "/Users/mustafa/ocen-lang/ocen/compiler/passes/typechecker.oc"
  compiler_passes_generic_pass_GenericPass_pop_namespace(pass.o);
}


#line 22 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_indent(compiler_passes_code_generator_CodeGenerator *this) {

#line 23 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < this->indent; i+=1) {

#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "  ");
  }
}


#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void str_replace(char **this, char *other) {

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *s = (*this);

#line 30 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_mem_free(s);

#line 31 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  (*this)=other;
}


#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
compiler_errors_Error *compiler_passes_code_generator_CodeGenerator_error(compiler_passes_code_generator_CodeGenerator *this, compiler_errors_Error *err) {
  return compiler_passes_generic_pass_GenericPass_error(this->o, err);}


#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
compiler_ast_scopes_Scope *compiler_passes_code_generator_CodeGenerator_scope(compiler_passes_code_generator_CodeGenerator *this) {
  return compiler_passes_generic_pass_GenericPass_scope(this->o);}


#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_debug_info(compiler_passes_code_generator_CodeGenerator *this, std_span_Span span, bool force) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(this->o->program->gen_debug_info) && !(force)) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_span_Location loc = span.start;

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("\n#line %u \"%s\"\n", loc.line, loc.filename));
}


#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_get_op(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {
  return ({ char *__yield_0;

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    switch ((node->type)) {
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_337_0:
        {
          __yield_0 = ({ char *__yield_1;

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            switch ((node->u.binary.op)) {
              case compiler_ast_operators_Operator_And:
              m_338_0:
                {
                  __yield_1 = "&&";
                } break;
              case compiler_ast_operators_Operator_Assignment:
              case compiler_ast_operators_Operator_IndexAssign:
              m_338_1:
                {
                  __yield_1 = "=";
                } break;
              case compiler_ast_operators_Operator_BitwiseAnd:
              m_338_2:
                {
                  __yield_1 = "&";
                } break;
              case compiler_ast_operators_Operator_BitwiseOr:
              m_338_3:
                {
                  __yield_1 = "|";
                } break;
              case compiler_ast_operators_Operator_BitwiseXor:
              m_338_4:
                {
                  __yield_1 = "^";
                } break;
              case compiler_ast_operators_Operator_Divide:
              m_338_5:
                {
                  __yield_1 = "/";
                } break;
              case compiler_ast_operators_Operator_Equals:
              m_338_6:
                {
                  __yield_1 = "==";
                } break;
              case compiler_ast_operators_Operator_GreaterThan:
              m_338_7:
                {
                  __yield_1 = ">";
                } break;
              case compiler_ast_operators_Operator_GreaterThanEquals:
              m_338_8:
                {
                  __yield_1 = ">=";
                } break;
              case compiler_ast_operators_Operator_LeftShift:
              m_338_9:
                {
                  __yield_1 = "<<";
                } break;
              case compiler_ast_operators_Operator_LessThan:
              m_338_10:
                {
                  __yield_1 = "<";
                } break;
              case compiler_ast_operators_Operator_LessThanEquals:
              m_338_11:
                {
                  __yield_1 = "<=";
                } break;
              case compiler_ast_operators_Operator_Minus:
              m_338_12:
                {
                  __yield_1 = "-";
                } break;
              case compiler_ast_operators_Operator_Modulus:
              m_338_13:
                {
                  __yield_1 = "%";
                } break;
              case compiler_ast_operators_Operator_Multiply:
              m_338_14:
                {
                  __yield_1 = "*";
                } break;
              case compiler_ast_operators_Operator_NotEquals:
              m_338_15:
                {
                  __yield_1 = "!=";
                } break;
              case compiler_ast_operators_Operator_Or:
              m_338_16:
                {
                  __yield_1 = "||";
                } break;
              case compiler_ast_operators_Operator_Plus:
              m_338_17:
                {
                  __yield_1 = "+";
                } break;
              case compiler_ast_operators_Operator_PlusEquals:
              m_338_18:
                {
                  __yield_1 = "+=";
                } break;
              case compiler_ast_operators_Operator_MinusEquals:
              m_338_19:
                {
                  __yield_1 = "-=";
                } break;
              case compiler_ast_operators_Operator_MultiplyEquals:
              m_338_20:
                {
                  __yield_1 = "*=";
                } break;
              case compiler_ast_operators_Operator_DivideEquals:
              m_338_21:
                {
                  __yield_1 = "/=";
                } break;
              case compiler_ast_operators_Operator_RightShift:
              m_338_22:
                {
                  __yield_1 = ">>";
                } break;
              case compiler_ast_operators_Operator_LeftShiftEquals:
              m_338_23:
                {
                  __yield_1 = "<<=";
                } break;
              case compiler_ast_operators_Operator_RightShiftEquals:
              m_338_24:
                {
                  __yield_1 = ">>=";
                } break;
              default:
                {
                  std_panic(std_format("Unknown binary op type in get_op: %s", compiler_ast_operators_Operator_dbg(node->u.binary.op)));
                } break;
            }

          __yield_1; });
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_337_1:
        {
          __yield_0 = ({ char *__yield_1;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            switch ((node->u.unary.op)) {
              case compiler_ast_operators_Operator_PreDecrement:
              m_339_0:
                {
                  __yield_1 = "--";
                } break;
              case compiler_ast_operators_Operator_PreIncrement:
              m_339_1:
                {
                  __yield_1 = "++";
                } break;
              case compiler_ast_operators_Operator_PostDecrement:
              m_339_2:
                {
                  __yield_1 = "--";
                } break;
              case compiler_ast_operators_Operator_PostIncrement:
              m_339_3:
                {
                  __yield_1 = "++";
                } break;
              default:
                {
                  std_panic(std_format("Unknown unary op type in get_op: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op)));
                } break;
            }

          __yield_1; });
        } break;
      default:
        {
          std_panic(std_format("Unknown op type in get_op: %s", compiler_ast_nodes_ASTType_dbg(node->type)));
        } break;
    }

  __yield_0; });}


#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
bool compiler_passes_code_generator_CodeGenerator_gen_internal_print(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after, bool is_stderr) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (is_stderr) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "fprintf(stderr, ");
  } else {

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "printf(");
  }

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Argument *first = std_vector_Vector__7_at(args, 0);

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (first->expr->type==compiler_ast_nodes_ASTType_FormatStringLiteral) {

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, first->expr, newline_after);

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ")");

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return true;
  }

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < args->size; i+=1) {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (i > 0) {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ", ");
    }

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (i==0 && newline_after) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "\"\\n\"");
    }
  }

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ")");

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return true;
}


#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_format_string_part(compiler_passes_code_generator_CodeGenerator *this, char *part) {

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  u32 len = strlen(part);

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < len; i+=1) {

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    switch (part[i]) {
      case '\\': {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        i+=1;

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        switch (part[i]) {
          case '`':          case '{':          case '}': {
          } break;
          default: {

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_char(&this->out, '\\');
          } break;
        }

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '"': {

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, '\\');

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '%': {

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, '%');

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
      case '\n': {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\\n");
      } break;
      default: {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, part[i]);
      } break;
    }
  }
}


#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_string_literal(compiler_passes_code_generator_CodeGenerator *this, char *literal) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  u32 len = strlen(literal);

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < len; i+=1) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    switch (literal[i]) {
      case '\n': {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\\n");
      } break;
      default: {

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_char(&this->out, literal[i]);
      } break;
    }
  }
}


#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr) {

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (type->base==compiler_types_BaseType_Structure) {

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Structure *struc = type->u.struc;

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (((bool)struc) && ((bool)struc->format_spec)) {

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, struc->format_spec);

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      return;
    }
  }

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(expr->span, std_format("Invalid type in CodeGenerator::format_string_custom_specifier: '%s'", compiler_types_Type_str(type))));

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "%s");
}


#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, compiler_ast_nodes_AST *expr) {

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (type->base==compiler_types_BaseType_Structure) {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Structure *struc = type->u.struc;

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (((bool)struc) && ((bool)struc->format_args)) {

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      for (std_CharIterator _i110 = str_chars(struc->format_args, 0); std_CharIterator_has_value(&_i110); std_CharIterator_next(&_i110)) {

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char c = std_CharIterator_cur(&_i110);

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        {

#line 189 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (c=='$') {

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, "(");

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ")");
          } else {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_char(&this->out, c);
          }
        }
      }

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      return;
    }
  }

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(expr->span, std_format("Invalid type in CodeGenerator::format_string_custom_argument: '%s'", compiler_types_Type_str(type))));

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
}


#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool newline_after) {

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__8 *parts = node->u.fmt_str.parts;

#line 209 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__16 *exprs = node->u.fmt_str.exprs;

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__8 *specs = node->u.fmt_str.specs;

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_char(&this->out, '"');

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < exprs->size; i+=1) {

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    char *part = std_vector_Vector__8_at(parts, i);

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_AST *expr = std_vector_Vector__16_at(exprs, i);

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_format_string_part(this, part);

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    char *spec = std_vector_Vector__8_at(specs, i);

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (((bool)spec)) {

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "%");

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, spec);

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      continue;
    }

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_types_Type *expr_type = compiler_types_Type_unaliased(expr->etype);

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    switch ((expr_type->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      m_340_0:
        {

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%d");
        } break;
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      m_340_1:
        {

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%u");
        } break;
      case compiler_types_BaseType_I64:
      m_340_2:
        {

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%\" PRId64 \"");
        } break;
      case compiler_types_BaseType_U64:
      m_340_3:
        {

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%\" PRIu64 \"");
        } break;
      case compiler_types_BaseType_Bool:
      m_340_4:
        {

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%s");
        } break;
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_340_5:
        {

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%f");
        } break;
      case compiler_types_BaseType_Char:
      m_340_6:
        {

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "%c");
        } break;
      case compiler_types_BaseType_Pointer:
      m_340_7:
        {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          switch ((expr_type->u.ptr->base)) {
            case compiler_types_BaseType_Char:
            m_341_0:
              {

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, "%s");
              } break;
            default:
              {

#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, "%p");
              } break;
          }
        } break;
      default:
        {

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_format_string_custom_specifier(this, expr_type, expr);
        } break;
    }
  }

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *part = std_vector_Vector__8_back(parts, 0);

#line 244 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_format_string_part(this, part);

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (newline_after) {

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "\\n");
  }

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_char(&this->out, '"');

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__16 _i111 = std_vector_Vector__16_iter(exprs); std_vector_Iterator__16_has_value(&_i111); std_vector_Iterator__16_next(&_i111)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_AST *expr = std_vector_Iterator__16_cur(&_i111);

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_types_Type *expr_type = compiler_types_Type_unaliased(expr->etype);

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ", ");

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      switch ((expr_type->base)) {
        case compiler_types_BaseType_I8:
        case compiler_types_BaseType_I16:
        case compiler_types_BaseType_I32:
        case compiler_types_BaseType_U8:
        case compiler_types_BaseType_U16:
        case compiler_types_BaseType_U32:
        case compiler_types_BaseType_I64:
        case compiler_types_BaseType_U64:
        case compiler_types_BaseType_F32:
        case compiler_types_BaseType_F64:
        case compiler_types_BaseType_Char:
        case compiler_types_BaseType_Pointer:
        m_342_0:
          {

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
          } break;
        case compiler_types_BaseType_Bool:
        m_342_1:
          {

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, "((");

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ") ? \"true\" : \"false\")");
          } break;
        default:
          {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_format_string_custom_argument(this, expr_type, expr);
          } break;
      }
    }
  }
}


#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_format_string(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (this->o->program->did_cache_symbols) {

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, this->o->program->cached_symbols.fmt_string_fn->full_name);
  } else {

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, "Can't use format string without using stdlib"));

#line 272 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "unknown");
  }

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "(");

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, node, false);

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ")");
}


#line 279 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_yield_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *expr) {

#line 280 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *yield_var = std_vector_Vector__8_back(this->yield_vars, 0);

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(expr->returns)) {

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, yield_var);

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " = ");
  }

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n");
}


#line 290 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_constant(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Variable *const_ = node->u.var_decl;

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (const_->sym->is_dead) {

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(const_->sym->is_extern)) {

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "#define ");

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(const_->sym));

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " (");

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.var_decl->default_value, false);

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ")\n");
  }
}


#line 304 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_constants(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__16 _i112 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i112); std_vector_Iterator__16_next(&_i112)) {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_AST *const_ = std_vector_Iterator__16_cur(&_i112);

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_constant(this, const_);
    }
  }

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_ValueIterator__3 _i113 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i113); std_map_ValueIterator__3_next(&_i113)) {

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i113);

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 310 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_constants(this, child);
    }
  }
}


#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_global_variables(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__16 _i114 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i114); std_vector_Iterator__16_next(&_i114)) {

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i114);

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 316 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (var->sym->is_dead) {

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        continue;
      }

#line 318 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (!(var->sym->is_extern)) {

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, node);

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }
  }

#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_ValueIterator__3 _i115 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i115); std_map_ValueIterator__3_next(&_i115)) {

#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i115);

#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 325 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_global_variables(this, child);
    }
  }
}


#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_control_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (body->type==compiler_ast_nodes_ASTType_Block) {

#line 331 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
  } else {

#line 334 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    bool is_elif = body->type==compiler_ast_nodes_ASTType_If;

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (!(is_elif)) {

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "{\n");
    }

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (((bool)node->etype) && (body->type != compiler_ast_nodes_ASTType_Yield)) {

#line 339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, body);
    } else {

#line 341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, body);
    }

#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (!(is_elif)) {

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "}");
    }
  }
}


#line 350 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 354 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *yield_var = std_format("__yield_%u", this->yield_vars->size);

#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__8_push(this->yield_vars, yield_var);

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type *ret_type = node->etype;

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "({ ");

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, ret_type, yield_var);

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n");

#line 363 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (node->type==compiler_ast_nodes_ASTType_Block) {

#line 364 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_block(this, node, false);
  } else {

#line 366 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_statement(this, node);

#line 368 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;
  }

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n");

#line 372 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 373 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, yield_var);

#line 374 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "; })");

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__8_pop(this->yield_vars);
}


#line 379 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_EnumVariant *variant, std_vector_Vector__7 *args) {

#line 380 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Enum *enom = variant->parent;

#line 383 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(enom->has_values)) {

#line 384 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 388 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%s){", compiler_ast_scopes_Symbol_out_name(enom->sym)));

#line 389 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format(".tag=%s,", compiler_ast_scopes_Symbol_out_name(variant->sym)));

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__3 *shared_fields = enom->shared_fields;

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  u32 i = 0;

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (NULL; i < shared_fields->size; i+=1) {

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Variable *field = std_vector_Vector__3_at(shared_fields, i);

#line 396 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));

#line 397 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);

#line 398 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ", ");
  }

#line 400 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)args) && (i < args->size)) {

#line 401 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s={", compiler_ast_scopes_Symbol_out_name(variant->sym)));

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (NULL; i < args->size; i+=1) {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 404 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);

#line 405 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ", ");
    }

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "}");
  }

#line 409 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}");
}


#line 412 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_constructor(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_Structure *struc) {

#line 413 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("(%s){", compiler_ast_scopes_Symbol_out_name(struc->sym)));

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__3 *fields = struc->fields;

#line 415 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__7 *args = node->u.call.args;

#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->is_union) {

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if(!(args->size==1)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:418:16: Assertion failed: `args.size == 1`", "Should have been checked in the type checker"); }

#line 419 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, 0);

#line 420 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if(!(((bool)arg->label))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:420:16: Assertion failed: `arg.label?`", "Should have been checked in the type checker"); }

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Variable *field = NULL;

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (std_vector_Iterator__3 _i116 = std_vector_Vector__3_iter(fields); std_vector_Iterator__3_has_value(&_i116); std_vector_Iterator__3_next(&_i116)) {

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Variable *f = std_vector_Iterator__3_cur(&_i116);

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      {

#line 424 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)f->sym) && str_eq(f->sym->name, arg->label)) {

#line 425 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          field=f;

#line 426 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          break;
        }
      }
    }

#line 429 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if(!(((bool)field))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:429:16: Assertion failed: `field?`", "Should have been checked in the type checker"); }

#line 430 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));

#line 431 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);
  } else {

#line 434 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (u32 i = 0; i < args->size; i+=1) {

#line 435 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (i != 0) {

#line 435 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ", ");
      }

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 437 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Variable *field = std_vector_Vector__3_at(fields, i);

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=", compiler_ast_scopes_Symbol_out_name(field->sym)));

#line 439 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);
    }
  }

#line 443 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}");
}


#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_create_new(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if(!(node->type==compiler_ast_nodes_ASTType_CreateNew)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:447:12: Assertion failed: `node.type == CreateNew`", std_format("Expected CreateNew, got %s", compiler_ast_nodes_ASTType_dbg(node->type))); }

#line 448 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_AST *child = node->u.child;

#line 449 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *var_name = std_format("_new_%u", this->o->program->uid++);

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "({");

#line 457 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, node->etype, var_name);

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " = ");

#line 459 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.mem_alloc_fn));

#line 460 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "(");

#line 461 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(this->o->program->cached_symbols.mem_allocator));

#line 462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ", sizeof(");

#line 463 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type(this, child->etype);

#line 464 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format(")); *%s = ", var_name));

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, child, false);

#line 466 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("; %s; ", var_name));

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "})");

#line 469 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  str_free(&var_name);
}


#line 472 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_call_args(compiler_passes_code_generator_CodeGenerator *this, std_vector_Vector__7 *args, bool is_variadic_format) {

#line 473 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < args->size; i+=1) {

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (i != 0) {

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ", ");
    }

#line 475 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 477 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if ((i==(args->size - 1) && is_variadic_format) && arg->expr->type==compiler_ast_nodes_ASTType_FormatStringLiteral) {

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_format_string_variadic(this, arg->expr, false);
    } else {

#line 484 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, arg->expr, false);
    }
  }
}


#line 489 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_call(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_scopes_Symbol *sym) {

#line 490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false);

#line 493 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format(".%s(", compiler_passes_code_generator_cls_fn_field_name));

#line 494 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false);

#line 495 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ".");

#line 496 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_cls_ctx_name);

#line 497 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (node->u.call.args->size > 0) {

#line 498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ", ");

#line 499 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_call_args(this, node->u.call.args, false);
  }

#line 501 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ")");
}


#line 505 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_expression(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool is_top_level) {

#line 506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    m_343_0:
      {

#line 508 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_NumLiteral *num_lit = &node->u.num_literal;

#line 509 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if ((node->etype->base != compiler_types_BaseType_I32) && (node->etype->base != compiler_types_BaseType_U32)) {

#line 510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "((");

#line 511 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_type(this, node->etype);

#line 512 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ")");

#line 513 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, num_lit->text);

#line 514 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {

#line 516 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, num_lit->text);
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_343_1:
      {

#line 520 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_Function *func = node->u.closure;

#line 521 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "({");

#line 522 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char *ctx_name = std_format("%s%u", compiler_passes_code_generator_cls_ctx_name, this->o->program->uid++);

#line 523 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char *ctx_typ = compiler_passes_code_generator_cls_ctx_type(func);

#line 525 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str_f(&this->out, std_format("%s *%s = alloca(sizeof(%s));", ctx_typ, ctx_name, ctx_typ));

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (std_map_Iterator__4 _i117 = std_map_Map__4_iter(func->closed_vars); std_map_Iterator__4_has_value(&_i117); std_map_Iterator__4_next(&_i117)) {

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_map_Item__4 *it = std_map_Iterator__4_cur(&_i117);

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          {

#line 527 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_ast_nodes_Variable *var = it->value->u.closed_var.orig;

#line 528 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ctx_name);

#line 529 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, "->");

#line 530 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));

#line 531 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, " = &");

#line 532 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));

#line 533 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ";");
          }
        }

#line 536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char *cls_name = std_format("_ci%u", this->o->program->uid++);

#line 537 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str_f(&this->out, std_format("%s %s = {", compiler_ast_scopes_Symbol_out_name(func->type->sym), cls_name));

#line 538 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str_f(&this->out, std_format(".%s=%s, .%s=&%s};", compiler_passes_code_generator_cls_ctx_name, ctx_name, compiler_passes_code_generator_cls_fn_field_name, compiler_ast_scopes_Symbol_out_name(func->sym)));

#line 539 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, cls_name);

#line 540 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "; })");
      } break;
    case compiler_ast_nodes_ASTType_FloatLiteral:
    m_343_2:
      {

#line 543 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_NumLiteral *num_lit = &node->u.num_literal;

#line 544 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, num_lit->text);

#line 545 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (node->etype->base==compiler_types_BaseType_F32) {

#line 546 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "f");
        }
      } break;
    case compiler_ast_nodes_ASTType_ArrayLiteral:
    m_343_3:
      {

#line 550 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_vector_Vector__16 *elements = node->u.array_literal.elements;

#line 551 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "{");

#line 552 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (u32 i = 0; i < elements->size; i+=1) {

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (i != 0) {

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ", ");
          }

#line 554 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_ast_nodes_AST *expr = std_vector_Vector__16_at(elements, i);

#line 555 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
        }

#line 557 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "}");
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_343_4:
      {

#line 559 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_format_string(this, node);
      } break;
    case compiler_ast_nodes_ASTType_StringLiteral:
    m_343_5:
      {

#line 561 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char *str_lit = node->u.string_literal;

#line 562 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\"");

#line 563 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_string_literal(this, str_lit);

#line 564 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\"");
      } break;
    case compiler_ast_nodes_ASTType_CharLiteral:
    m_343_6:
      {

#line 567 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        char *char_lit = node->u.char_literal;

#line 568 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "'");

#line 569 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, char_lit);

#line 570 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "'");
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_343_7:
      {

#line 573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_vector_Vector__23 *branches = node->u.if_stmt.branches;

#line 574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *els = node->u.if_stmt.els;

#line 579 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((branches->size==1 && (std_vector_Vector__23_at(branches, 0).body->type != compiler_ast_nodes_ASTType_Block)) && ((bool)els)) && (els->type != compiler_ast_nodes_ASTType_Block)) {

#line 584 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_ast_nodes_IfBranch branch = std_vector_Vector__23_at(branches, 0);

#line 585 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "(");

#line 586 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.cond, false);

#line 587 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " ? ");

#line 588 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.body, false);

#line 589 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " : ");

#line 590 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, els, false);

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_343_8:
      {

#line 598 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_343_9:
      {

#line 599 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_in_yield_context(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_343_10:
      {

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Symbol *sym = node->resolved_symbol;

#line 602 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Function) {

#line 604 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(sym));

#line 605 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          return;
        }

#line 608 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *lhs = node->u.member.lhs;

#line 609 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false);

#line 610 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (node->u.member.is_pointer) {

#line 611 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "->");
        } else {

#line 613 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ".");
        }

#line 615 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, node->u.member.rhs_name);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    case compiler_ast_nodes_ASTType_NSLookup:
    case compiler_ast_nodes_ASTType_Specialization:
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_343_11:
      {

#line 618 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Symbol *sym = node->resolved_symbol;

#line 619 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (!(((bool)sym))) {

#line 620 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, "Symbol not found in CodeGenerator::gen_expression"));

#line 621 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          return;
        }

#line 623 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        switch ((sym->type)) {
          case compiler_ast_scopes_SymbolType_Function:
          case compiler_ast_scopes_SymbolType_Variable:
          case compiler_ast_scopes_SymbolType_Constant:
          m_344_0:
            {

#line 624 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(sym));
            } break;
          case compiler_ast_scopes_SymbolType_EnumVariant:
          m_344_1:
            {

#line 625 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(this, sym->u.enum_var, NULL);
            } break;
          case compiler_ast_scopes_SymbolType_ClosedVariable:
          m_344_2:
            {

#line 627 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;

#line 628 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str_f(&this->out, std_format("(*%s->", compiler_passes_code_generator_cls_ctx_name));

#line 629 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(var->sym));

#line 630 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          default:
            {

#line 632 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:632:32: Assertion failed: `false`", std_format("Unhandled symbol type: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_343_12:
      {

#line 636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *callee = node->u.call.callee;

#line 639 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (callee->type==compiler_ast_nodes_ASTType_Identifier) {

#line 640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          bool matched = ({ bool __yield_0;

#line 640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            {
              char *__match_var_345 = callee->u.ident.name;
              if (str_eq(__match_var_345, "print")) {
                __yield_0 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, false, false);
              } else if (str_eq(__match_var_345, "println")) {
                __yield_0 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, true, false);
              } else if (str_eq(__match_var_345, "eprint")) {
                __yield_0 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, false, true);
              } else if (str_eq(__match_var_345, "eprintln")) {
                __yield_0 = compiler_passes_code_generator_CodeGenerator_gen_internal_print(this, node, true, true);
              } else  {
                __yield_0 = false;
              }
            }

          __yield_0; });

#line 647 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (matched) {

#line 647 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            return;
          }
        }

#line 650 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Symbol *sym = compiler_ast_nodes_AST_symbol(callee);

#line 651 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)sym)) {

#line 652 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          switch ((node->u.call.call_type)) {
            case compiler_ast_nodes_CallType_StructConstructor:
            m_346_0:
              {

#line 654 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                if(!(sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:654:32: Assertion failed: `sym.type == Structure`", NULL); }

#line 655 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                compiler_passes_code_generator_CodeGenerator_gen_constructor(this, node, sym->u.struc);

#line 656 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                return;
              } break;
            case compiler_ast_nodes_CallType_EnumConstructor:
            m_346_1:
              {

#line 659 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                if(!(sym->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:659:32: Assertion failed: `sym.type == EnumVariant`", NULL); }

#line 660 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                compiler_passes_code_generator_CodeGenerator_gen_enum_constructor(this, sym->u.enum_var, node->u.call.args);

#line 661 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                return;
              } break;
            case compiler_ast_nodes_CallType_Closure:
            m_346_2:
              {

#line 664 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                compiler_passes_code_generator_CodeGenerator_gen_closure_call(this, node, sym);

#line 665 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                return;
              } break;
            default:
              {
              } break;
          }
        }

#line 673 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, callee, false);

#line 675 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        bool is_variadic_format = (((((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Function) && ((bool)sym->u.func)) && sym->u.func->is_variadic_format);

#line 682 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "(");

#line 683 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_call_args(this, node->u.call.args, is_variadic_format);

#line 684 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ")");
      } break;
    case compiler_ast_nodes_ASTType_BoolLiteral:
    m_343_13:
      {

#line 687 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        bool bool_lit = node->u.bool_literal;

#line 688 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, (bool_lit ? "true" : "false"));
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_343_14:
      {

#line 690 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_create_new(this, node);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_343_15:
      {

#line 691 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        switch ((node->u.unary.op)) {
          case compiler_ast_operators_Operator_Address:
          m_347_0:
            {

#line 693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 694 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "&");

#line 695 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
            } break;
          case compiler_ast_operators_Operator_Dereference:
          m_347_1:
            {

#line 698 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 699 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "(*");

#line 700 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 701 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_Negate:
          m_347_2:
            {

#line 704 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 705 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "-");

#line 706 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
            } break;
          case compiler_ast_operators_Operator_BitwiseNot:
          m_347_3:
            {

#line 709 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 710 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "~");

#line 711 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
            } break;
          case compiler_ast_operators_Operator_Not:
          m_347_4:
            {

#line 714 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 715 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "!(");

#line 716 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 717 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_IsNotNull:
          m_347_5:
            {

#line 720 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *expr = node->u.unary.expr;

#line 721 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "((bool)");

#line 723 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_types_Type *type = expr->etype;

#line 727 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              if (((bool)type) && type->base==compiler_types_BaseType_Closure) {

#line 728 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 729 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, ".");

#line 730 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_cls_fn_field_name);
              } else {

#line 733 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);
              }

#line 736 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, ")");
            } break;
          case compiler_ast_operators_Operator_PreIncrement:
          case compiler_ast_operators_Operator_PreDecrement:
          m_347_6:
            {

#line 739 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));

#line 740 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.unary.expr, false);
            } break;
          case compiler_ast_operators_Operator_PostIncrement:
          case compiler_ast_operators_Operator_PostDecrement:
          m_347_7:
            {

#line 744 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.unary.expr, false);

#line 745 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));
            } break;
          default:
            {

#line 747 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled unary op type in CodeGenerator: %s", compiler_ast_operators_Operator_dbg(node->u.unary.op))));
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_343_16:
      {

#line 750 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *expr = node->u.cast.lhs;

#line 751 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_types_Type *type = node->etype;

#line 752 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "((");

#line 753 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, type, "", false));

#line 754 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ")");

#line 755 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 756 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ")");
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_343_17:
      {

#line 759 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "((u32)sizeof(");

#line 760 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_type(this, node->u.size_of_type);

#line 761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "))");
      } break;
    case compiler_ast_nodes_ASTType_Null:
    m_343_18:
      {

#line 763 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        switch ((node->etype->base)) {
          case compiler_types_BaseType_Closure:
          m_348_0:
            {

#line 767 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str_f(&this->out, std_format("((%s){0})", compiler_ast_scopes_Symbol_out_name(node->etype->sym)));
            } break;
          default:
            {

#line 768 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "NULL");
            } break;
        }
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_343_19:
      {

#line 770 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        switch ((node->u.binary.op)) {
          case compiler_ast_operators_Operator_Index:
          m_349_0:
            {

#line 772 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *lhs = node->u.binary.lhs;

#line 773 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *rhs = node->u.binary.rhs;

#line 774 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false);

#line 775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "[");

#line 776 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, rhs, false);

#line 777 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, "]");
            } break;
          case compiler_ast_operators_Operator_And:
          case compiler_ast_operators_Operator_BitwiseAnd:
          case compiler_ast_operators_Operator_BitwiseOr:
          case compiler_ast_operators_Operator_BitwiseXor:
          case compiler_ast_operators_Operator_Divide:
          case compiler_ast_operators_Operator_GreaterThan:
          case compiler_ast_operators_Operator_GreaterThanEquals:
          case compiler_ast_operators_Operator_LeftShift:
          case compiler_ast_operators_Operator_LeftShiftEquals:
          case compiler_ast_operators_Operator_RightShiftEquals:
          case compiler_ast_operators_Operator_LessThan:
          case compiler_ast_operators_Operator_LessThanEquals:
          case compiler_ast_operators_Operator_Minus:
          case compiler_ast_operators_Operator_Modulus:
          case compiler_ast_operators_Operator_Multiply:
          case compiler_ast_operators_Operator_NotEquals:
          case compiler_ast_operators_Operator_Or:
          case compiler_ast_operators_Operator_Plus:
          case compiler_ast_operators_Operator_RightShift:
          m_349_1:
            {

#line 798 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *lhs = node->u.binary.lhs;

#line 799 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_ast_nodes_AST *rhs = node->u.binary.rhs;

#line 800 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              if (!(is_top_level)) {

#line 800 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, "(");
              }

#line 801 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, lhs, false);

#line 802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, " ");

#line 803 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));

#line 804 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, " ");

#line 805 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, rhs, false);

#line 806 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              if (!(is_top_level)) {

#line 806 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, ")");
              }
            } break;
          case compiler_ast_operators_Operator_Equals:
          case compiler_ast_operators_Operator_Assignment:
          case compiler_ast_operators_Operator_IndexAssign:
          case compiler_ast_operators_Operator_PlusEquals:
          case compiler_ast_operators_Operator_MinusEquals:
          case compiler_ast_operators_Operator_DivideEquals:
          case compiler_ast_operators_Operator_MultiplyEquals:
          m_349_2:
            {

#line 815 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.binary.lhs, false);

#line 816 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_get_op(this, node));

#line 817 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.binary.rhs, false);
            } break;
          default:
            {

#line 819 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
              compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled binary op type in CodeGenerator: %s", compiler_ast_operators_Operator_dbg(node->u.binary.op))));
            } break;
        }
      } break;
    default:
      {

#line 822 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(node->span, std_format("Unhandled expression type in CodeGenerator: %s", compiler_ast_nodes_ASTType_dbg(node->type))));
      } break;
  }
}


#line 826 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_var_declaration(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 827 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 829 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (var->is_atomic) {

#line 830 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "_Atomic ");
  }

#line 833 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, var->type, compiler_ast_scopes_Symbol_out_name(var->sym));

#line 834 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)node->u.var_decl->default_value)) {

#line 835 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " = ");

#line 836 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.var_decl->default_value, false);
  } else if (!(var->is_atomic)) {

#line 840 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    switch ((var->type->base)) {
      case compiler_types_BaseType_Array:
      case compiler_types_BaseType_Structure:
      m_350_0:
        {

#line 841 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " = {0}");
        } break;
      default:
        {
        } break;
    }
  }
}


#line 847 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_match_case_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, compiler_ast_nodes_AST *body) {

#line 848 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (body->type==compiler_ast_nodes_ASTType_Block) {

#line 849 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " ");

#line 850 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);
  } else if (body->type==compiler_ast_nodes_ASTType_Call && body->returns) {

#line 854 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " ");

#line 855 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_expression(this, body, false);

#line 856 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ";");
  } else if (((bool)node->etype) && (body->type != compiler_ast_nodes_ASTType_Yield)) {

#line 860 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " {\n");

#line 861 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 862 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, body);

#line 863 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;

#line 864 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 865 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "}");
  } else {

#line 868 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " {\n");

#line 869 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 870 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_statement(this, body);

#line 871 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;

#line 872 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 873 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "}");
  }
}


#line 877 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_custom_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 878 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Match stmt = node->u.match_stmt;

#line 879 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 880 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "{\n");

#line 882 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *match_var = std_format("__match_var_%u", this->o->program->uid++);

#line 884 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 885 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 886 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, stmt.expr->etype, match_var);

#line 887 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " = ");

#line 888 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false);

#line 889 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n");

#line 891 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__24 *cases = stmt.cases;

#line 892 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 894 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < cases->size; i++) {

#line 895 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Vector__24_at(cases, i);

#line 897 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "if (");

#line 898 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    bool first = true;

#line 899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (std_vector_Iterator__10 _i118 = std_vector_Vector__10_iter(_case.conds); std_vector_Iterator__10_has_value(&_i118); std_vector_Iterator__10_next(&_i118)) {

#line 899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i118);

#line 899 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      {

#line 900 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (!(first)) {

#line 900 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " || ");
        }

#line 901 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        first=false;

#line 902 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)cond->cmp_fn)) {

#line 903 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(cond->cmp_fn->sym));

#line 904 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "(");

#line 905 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, match_var);

#line 906 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ", ");

#line 907 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false);

#line 908 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ")");
        } else {

#line 911 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, std_format("(%s == ", match_var));

#line 912 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false);

#line 913 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ")");
        }
      }
    }

#line 916 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ")");

#line 917 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, _case.body);

#line 918 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " else ");
  }

#line 920 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)stmt.defolt)) {

#line 921 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, stmt.defolt);
  }

#line 923 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n");

#line 925 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 926 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 927 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}\n");
}


#line 930 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_match_enum(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 931 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Match *match_stmt = &node->u.match_stmt;

#line 932 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_AST *expr = match_stmt->expr;

#line 933 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if(!(((bool)expr->etype) && expr->etype->base==compiler_types_BaseType_Enum)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:933:12: Assertion failed: `expr.etype? and expr.etype.base == Enum`", NULL); }

#line 935 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Enum *enom = expr->etype->u.enom;

#line 936 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__3 *shared_fields = enom->shared_fields;

#line 938 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 939 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "switch ((");

#line 940 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 941 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->has_values) {

#line 942 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ").tag) {\n");
  } else {

#line 944 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, ")) {\n");
  }

#line 947 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  u32 uid = this->o->program->uid++;

#line 948 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 949 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < match_stmt->cases->size; i+=1) {

#line 950 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Vector__24_at(match_stmt->cases, i);

#line 952 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    bool has_args = ((_case.conds->size > 0) && ((bool)std_vector_Vector__10_at(_case.conds, 0)->args));

#line 954 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (has_args) {

#line 955 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_vector_Vector__19 *args = std_vector_Vector__10_at(_case.conds, 0)->args;

#line 956 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 957 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "{\n");

#line 958 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent+=1;

#line 959 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      for (std_vector_Iterator__19 _i119 = std_vector_Vector__19_iter(args); std_vector_Iterator__19_has_value(&_i119); std_vector_Iterator__19_next(&_i119)) {

#line 959 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_MatchCondArg *arg = std_vector_Iterator__19_cur(&_i119);

#line 959 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        {

#line 960 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (!(str_eq(arg->var->sym->name, "_"))) {

#line 961 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 962 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, arg->var->type, compiler_ast_scopes_Symbol_out_name(arg->var->sym));

#line 963 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ";\n");
          }
        }
      }
    }

#line 968 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (u32 j = 0; j < _case.conds->size; j++) {

#line 969 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_MatchCond *cond = std_vector_Vector__10_at(_case.conds, j);

#line 971 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_scopes_Symbol *resolved = cond->expr->resolved_symbol;

#line 972 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if(!(((bool)resolved) && resolved->type==compiler_ast_scopes_SymbolType_EnumVariant)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:972:20: Assertion failed: `resolved? and resolved.type == EnumVariant`", NULL); }

#line 973 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_EnumVariant *variant = resolved->u.enum_var;

#line 975 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 976 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "case ");

#line 977 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));

#line 978 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ":\n");

#line 980 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent+=1;

#line 981 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (((bool)cond->args)) {

#line 982 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_vector_Vector__19 *args = cond->args;

#line 983 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (u32 i = 0; i < args->size; i+=1) {

#line 984 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_ast_nodes_MatchCondArg *arg = std_vector_Vector__19_at(args, i);

#line 985 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (arg->is_shared) {

#line 986 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 988 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));

#line 989 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, " = (");

#line 990 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 991 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ").");

#line 995 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));

#line 996 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ";\n");
          } else {

#line 999 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1000 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(arg->var->sym));

#line 1001 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, " = (");

#line 1002 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, false);

#line 1003 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ").");

#line 1004 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));

#line 1005 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str_f(&this->out, std_format(".%s;\n", compiler_ast_scopes_Symbol_out_name(arg->var->sym)));
          }
        }

#line 1008 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1009 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, std_format("goto m_%u_%u;\n", uid, i));
      }

#line 1011 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent-=1;
    }

#line 1015 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (((bool)_case.body)) {

#line 1016 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1017 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, std_format("m_%u_%u:\n", uid, i));

#line 1018 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent+=1;

#line 1019 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1020 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, _case.body);

#line 1021 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, " break;\n");

#line 1022 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent-=1;
    }

#line 1025 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (has_args) {

#line 1026 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      this->indent-=1;

#line 1027 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1028 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "}\n");
    }
  }

#line 1032 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)match_stmt->defolt)) {

#line 1033 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1034 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "default:\n");

#line 1035 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 1036 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1037 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, match_stmt->defolt);

#line 1038 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " break;\n");

#line 1039 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;
  }

#line 1042 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 1043 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1044 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}\n");
}


#line 1048 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_match_bool(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 1049 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Match stmt = node->u.match_stmt;

#line 1051 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_MatchCase true_case = std_vector_Vector__24_at(stmt.cases, 0);

#line 1052 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_MatchCase false_case = std_vector_Vector__24_at(stmt.cases, 1);

#line 1054 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_AST *true_expr = std_vector_Vector__10_at(true_case.conds, 0)->expr;

#line 1055 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if(!(true_expr->type==compiler_ast_nodes_ASTType_BoolLiteral)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1055:12: Assertion failed: `true_expr.type == BoolLiteral`", "Expected a boolean literal in gen_match_bool"); }

#line 1056 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(true_expr->u.bool_literal)) {

#line 1057 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_MatchCase tmp = true_case;

#line 1058 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    true_case=false_case;

#line 1059 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    false_case=tmp;
  }

#line 1062 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1063 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "if (");

#line 1064 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false);

#line 1065 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ") ");

#line 1066 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, true_case.body);

#line 1067 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " else ");

#line 1068 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, false_case.body);
}


#line 1071 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_match(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 1072 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Match stmt = node->u.match_stmt;

#line 1074 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (stmt.is_custom_match) {

#line 1075 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_custom_match(this, node);

#line 1076 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1080 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((stmt.expr->etype->base)) {
    case compiler_types_BaseType_Bool:
    m_351_0:
      {

#line 1082 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_match_bool(this, node);

#line 1083 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        return;
      } break;
    case compiler_types_BaseType_Enum:
    m_351_1:
      {

#line 1086 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_match_enum(this, node);

#line 1087 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        return;
      } break;
    default:
      {
      } break;
  }

#line 1092 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1093 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "switch (");

#line 1094 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_expression(this, stmt.expr, false);

#line 1095 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ") {\n");

#line 1097 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__24 *cases = stmt.cases;

#line 1098 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 1099 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__24 _i120 = std_vector_Vector__24_iter(cases); std_vector_Iterator__24_has_value(&_i120); std_vector_Iterator__24_next(&_i120)) {

#line 1099 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i120);

#line 1099 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      for (std_vector_Iterator__10 _i121 = std_vector_Vector__10_iter(_case.conds); std_vector_Iterator__10_has_value(&_i121); std_vector_Iterator__10_next(&_i121)) {

#line 1100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i121);

#line 1100 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        {

#line 1101 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "case ");

#line 1103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond->expr, false);

#line 1104 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ":");
        }
      }

#line 1106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (((bool)_case.body)) {

#line 1107 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, _case.body);

#line 1108 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, " break;\n");
      } else {

#line 1111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\n");
      }
    }
  }

#line 1114 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)stmt.defolt)) {

#line 1115 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1116 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "default:");

#line 1117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_match_case_body(this, node, stmt.defolt);

#line 1118 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " break;\n");
  }

#line 1120 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 1121 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}\n");
}


#line 1125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_defers_upto(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Scope *end_scope) {

#line 1126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  bool first = true;

#line 1127 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur); cur=cur->parent) {

#line 1128 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (u32 i = 0; i < cur->defers->size; i+=1) {

#line 1129 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (first) {

#line 1130 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        first=false;

#line 1131 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1132 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "/* defers */\n");
      }

#line 1136 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      u32 idx = ((cur->defers->size - i) - 1);

#line 1137 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_AST *stmt = std_vector_Vector__16_at(cur->defers, idx);

#line 1138 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, stmt);
    }

#line 1140 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (cur==end_scope) {

#line 1140 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      break;
    }
  }
}


#line 1144 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_statement(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node) {

#line 1145 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_debug_info(this, node->span, false);

#line 1146 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_Return:
    m_352_0:
      {

#line 1148 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Scope *upto = compiler_passes_code_generator_CodeGenerator_scope(this);

#line 1149 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur) && ((bool)cur->cur_func); cur=cur->parent) {

#line 1150 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          upto=cur;
        }

#line 1152 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, upto);

#line 1153 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1155 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *expr = node->u.ret.expr;

#line 1156 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)expr)) {

#line 1157 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (!(expr->returns)) {

#line 1158 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, "return ");
          }

#line 1160 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, true);

#line 1161 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ";\n");
        } else {

#line 1163 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "return;\n");
        }
      } break;
    case compiler_ast_nodes_ASTType_Yield:
    m_352_1:
      {

#line 1166 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_yield_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_352_2:
      {
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_352_3:
      {

#line 1169 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        u32 loop_count = compiler_passes_code_generator_CodeGenerator_scope(this)->loop_count;

#line 1170 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Scope *upto = compiler_passes_code_generator_CodeGenerator_scope(this);

#line 1171 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (compiler_ast_scopes_Scope *cur = compiler_passes_code_generator_CodeGenerator_scope(this); ((bool)cur) && cur->loop_count==loop_count; cur=cur->parent) {

#line 1172 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          upto=cur;
        }

#line 1174 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, upto);

#line 1176 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1177 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (node->type==compiler_ast_nodes_ASTType_Break) {

#line 1178 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "break;\n");
        } else {

#line 1180 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "continue;\n");
        }
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_352_4:
      {

#line 1184 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1185 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, node);

#line 1186 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ";\n");
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_352_5:
      {

#line 1189 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1190 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_block(this, node, true);

#line 1191 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\n");
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    m_352_6:
      {

#line 1194 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_vector_Vector__16_push(compiler_passes_code_generator_CodeGenerator_scope(this)->defers, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_352_7:
      {

#line 1197 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1199 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_vector_Vector__23 *branches = node->u.if_stmt.branches;

#line 1200 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (u32 i = 0; i < branches->size; i+=1) {

#line 1201 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_ast_nodes_IfBranch branch = std_vector_Vector__23_at(branches, i);

#line 1202 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (i > 0) {

#line 1202 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, " else ");
          }

#line 1203 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "if (");

#line 1204 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, branch.cond, true);

#line 1205 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ") ");

#line 1206 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, branch.body);
        }

#line 1209 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *else_body = node->u.if_stmt.els;

#line 1211 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)else_body)) {

#line 1212 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " else ");

#line 1213 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_control_body(this, node, else_body);

#line 1214 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "\n");
        } else {

#line 1216 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "\n");
        }
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_352_8:
      {

#line 1219 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_match(this, node);
      } break;
    case compiler_ast_nodes_ASTType_While:
    m_352_9:
      {

#line 1221 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *cond = node->u.loop.cond;

#line 1222 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *body = node->u.loop.body;

#line 1223 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1224 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "while (");

#line 1225 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond, true);

#line 1226 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ") ");

#line 1227 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);

#line 1228 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\n");
      } break;
    case compiler_ast_nodes_ASTType_For:
    m_352_10:
      {

#line 1231 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *init = node->u.loop.init;

#line 1232 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *cond = node->u.loop.cond;

#line 1233 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *step = node->u.loop.step;

#line 1234 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *body = node->u.loop.body;

#line 1235 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1236 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "for (");

#line 1237 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)init)) {

#line 1238 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          if (init->type==compiler_ast_nodes_ASTType_VarDeclaration) {

#line 1239 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_var_declaration(this, init);
          } else {

#line 1241 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_expression(this, init, true);
          }
        }

#line 1244 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "; ");

#line 1245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)cond)) {

#line 1245 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, cond, true);
        }

#line 1246 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "; ");

#line 1247 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)step)) {

#line 1247 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, step, true);
        }

#line 1248 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ") ");

#line 1249 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_block(this, body, true);

#line 1250 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "\n");
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_352_11:
      {

#line 1253 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_AST *expr = node->u.assertion.expr;

#line 1254 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1255 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "if(!(");

#line 1256 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, expr, true);

#line 1257 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ")) { ae_assert_fail(");

#line 1258 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        {

#line 1259 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "\"");

#line 1260 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str_f(&this->out, std_span_Location_str(&expr->span.start));

#line 1261 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          char *expr_str = compiler_ast_program_Program_get_source_text(this->o->program, expr->span);

#line 1262 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, ": Assertion failed: `");

#line 1263 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          u32 len = strlen(expr_str);

#line 1264 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          for (u32 i = 0; i < len; i+=1) {

#line 1265 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            switch (expr_str[i]) {
              case '"': {

#line 1266 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_str(&this->out, "\\\"");
              } break;
              default: {

#line 1267 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
                std_buffer_Buffer_write_char(&this->out, expr_str[i]);
              } break;
            }
          }

#line 1270 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "`\"");
        }

#line 1272 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ", ");

#line 1273 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)node->u.assertion.msg)) {

#line 1274 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, node->u.assertion.msg, false);
        } else {

#line 1276 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "NULL");
        }

#line 1278 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ");");

#line 1282 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (expr->type==compiler_ast_nodes_ASTType_BoolLiteral && expr->u.bool_literal==false) {

#line 1283 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " exit(1);");
        }

#line 1285 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, " }\n");
      } break;
    default:
      {

#line 1288 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1289 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_expression(this, node, true);

#line 1290 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ";\n");
      } break;
  }
}


#line 1295 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_block(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_AST *node, bool with_braces) {

#line 1296 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (with_braces) {

#line 1296 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "{\n");
  }

#line 1297 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_scopes_Scope *scope = node->u.block.scope;

#line 1298 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, node->u.block.scope);

#line 1300 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__16 *statements = node->u.block.statements;

#line 1301 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 1302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__16 _i122 = std_vector_Vector__16_iter(statements); std_vector_Iterator__16_has_value(&_i122); std_vector_Iterator__16_next(&_i122)) {

#line 1302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_AST *statement = std_vector_Iterator__16_cur(&_i122);

#line 1302 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1303 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, statement);
    }
  }

#line 1306 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(node->returns)) {

#line 1307 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_defers_upto(this, scope);
  }

#line 1310 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 1311 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1313 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (with_braces) {

#line 1313 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "}");
  }

#line 1314 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 1317 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def, char *param_prefix, std_vector_Vector__3 *params) {

#line 1326 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer args_str = std_buffer_Buffer_make(16);

#line 1327 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (!(((bool)params))) {

#line 1328 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    params=cur->u.func.params;
  }

#line 1331 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (params->size==0) {

#line 1331 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&args_str, "void");
  }

#line 1332 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (((bool)param_prefix)) {

#line 1332 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&args_str, param_prefix);
  }

#line 1333 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (u32 i = 0; i < params->size; i+=1) {

#line 1334 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (i != 0) {

#line 1334 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&args_str, ", ");
    }

#line 1335 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Variable *var = std_vector_Vector__3_at(params, i);

#line 1336 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    char *arg_str = compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, var->type, compiler_ast_scopes_Symbol_out_name(var->sym), false);

#line 1337 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&args_str, arg_str);
  }

#line 1339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (cur->u.func.is_variadic) {

#line 1339 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&args_str, ", ...");
  }

#line 1341 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (is_func_def && cur==top) {

#line 1343 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    str_replace(&acc, std_format("%s(%s)", acc, std_buffer_Buffer_str(args_str)));
  } else {

#line 1345 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    str_replace(&acc, std_format("(*%s)(%s)", acc, std_buffer_Buffer_str(args_str)));
  }

#line 1347 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_mem_free(args_str.data);

#line 1348 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.func.return_type, acc, false);
}


#line 1356 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_helper_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *top, compiler_types_Type *cur, char *acc, bool is_func_def) {

#line 1357 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((cur->base)) {
    case compiler_types_BaseType_Void:
    case compiler_types_BaseType_Bool:
    case compiler_types_BaseType_Char:
    case compiler_types_BaseType_I8:
    case compiler_types_BaseType_I16:
    case compiler_types_BaseType_I32:
    case compiler_types_BaseType_I64:
    case compiler_types_BaseType_U8:
    case compiler_types_BaseType_U16:
    case compiler_types_BaseType_U32:
    case compiler_types_BaseType_U64:
    case compiler_types_BaseType_F32:
    case compiler_types_BaseType_F64:
    m_353_0:
      {

#line 1362 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        str_replace(&acc, std_format("%s %s", compiler_types_BaseType_str(cur->base), acc));
      } break;
    case compiler_types_BaseType_Structure:
    m_353_1:
      {

#line 1363 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->u.struc->sym), acc));
      } break;
    case compiler_types_BaseType_Enum:
    m_353_2:
      {

#line 1364 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->u.enom->sym), acc));
      } break;
    case compiler_types_BaseType_Alias:
    m_353_3:
      {

#line 1366 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.ptr, acc, false);
      } break;
    case compiler_types_BaseType_Closure:
    m_353_4:
      {

#line 1368 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        str_replace(&acc, std_format("%s %s", compiler_ast_scopes_Symbol_out_name(cur->sym), acc));
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_353_5:
      {

#line 1369 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, top, cur, acc, is_func_def, NULL, NULL);
      } break;
    case compiler_types_BaseType_Pointer:
    m_353_6:
      {

#line 1372 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        bool needs_parens = (((bool)cur->u.ptr) && cur->u.ptr->base==compiler_types_BaseType_Array);

#line 1373 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (cur->u.ptr->base==compiler_types_BaseType_FunctionPtr) {
        } else if (needs_parens) {

#line 1376 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          str_replace(&acc, std_format("(*%s)", acc));
        } else {

#line 1378 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          str_replace(&acc, std_format("*%s", acc));
        }

#line 1380 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.ptr, acc, false);
      } break;
    case compiler_types_BaseType_Array:
    m_353_7:
      {

#line 1385 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer prev_buffer = this->out;

#line 1387 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        this->out=std_buffer_Buffer_make(16);

#line 1389 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_types_ArrayType *arr_typ = &cur->u.arr;

#line 1390 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (((bool)arr_typ->size_expr)) {

#line 1391 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_gen_expression(this, arr_typ->size_expr, false);
        } else if (arr_typ->size_known) {

#line 1393 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str_f(&this->out, std_format("%u", arr_typ->size));
        } else {

#line 1395 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(cur->span, "Array size not known at compile time"));
        }

#line 1398 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        str_replace(&acc, std_format("%s[%s]", acc, std_buffer_Buffer_str(this->out)));

#line 1399 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_mem_free(this->out.data);

#line 1401 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        this->out=prev_buffer;

#line 1402 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        acc=compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, top, cur->u.arr.elem_type, acc, false);
      } break;
    default:
      {

#line 1404 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_error(this, compiler_errors_Error_new(cur->span, std_format("Unhandled type found in CodeGenerator::helper_gen_type: %s: %s", compiler_types_BaseType_dbg(cur->base), compiler_types_Type_str(cur))));
      } break;
  }

#line 1406 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return acc;
}


#line 1410 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_get_type_name_string(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name, bool is_func_def) {

#line 1411 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if(!(type != NULL)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1411:12: Assertion failed: `type != null`", NULL); }

#line 1412 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *final = compiler_passes_code_generator_CodeGenerator_helper_gen_type(this, type, type, strdup(name), is_func_def);

#line 1413 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  str_strip_trailing_whitespace(final);

#line 1414 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return final;
}


#line 1418 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_type_and_name(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type, char *name) {

#line 1419 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, type, name, false));
}


#line 1422 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_type(compiler_passes_code_generator_CodeGenerator *this, compiler_types_Type *type) {

#line 1424 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, type, "");
}


#line 1427 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_function_body(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {

#line 1428 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type *ret_type = func->return_type;

#line 1429 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->is_arrow) {

#line 1430 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "{\n");

#line 1431 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent+=1;

#line 1432 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1434 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (ret_type->base != compiler_types_BaseType_Void) {

#line 1435 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "return ");

#line 1436 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_expression(this, func->body, false);

#line 1437 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ";");
    } else {

#line 1439 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_statement(this, func->body);
    }

#line 1442 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    this->indent-=1;

#line 1443 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1444 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "}");
  } else {

#line 1447 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_block(this, func->body, true);
  }
}


#line 1451 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_function(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {

#line 1452 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method && func->parent_type->base==compiler_types_BaseType_Structure) {

#line 1453 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Structure *struc = func->parent_type->u.struc;

#line 1454 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 1454 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      return;
    }
  }

#line 1456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {

#line 1456 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1457 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->sym->is_dead) {

#line 1457 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1459 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_debug_info(this, func->sym->span, false);

#line 1460 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);

#line 1461 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " ");

#line 1462 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_body(this, func);

#line 1463 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n\n");
}


#line 1466 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_function_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {

#line 1467 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *funfull_name = compiler_ast_scopes_Symbol_out_name(func->sym);

#line 1468 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *s = compiler_passes_code_generator_CodeGenerator_get_type_name_string(this, func->type, funfull_name, true);

#line 1469 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, s);
}


#line 1472 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_functions(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {

#line 1473 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_vector_Vector__6 *functions = ns->functions;

#line 1474 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_generic_pass_GenericPass_push_scope(this->o, ns->scope);

#line 1476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__6 _i123 = std_vector_Vector__6_iter(functions); std_vector_Iterator__6_has_value(&_i123); std_vector_Iterator__6_next(&_i123)) {

#line 1476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i123);

#line 1476 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1477 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (func->sym->is_extern) {

#line 1477 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        continue;
      }

#line 1478 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {

#line 1479 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        for (std_vector_Iterator__4 _i124 = std_vector_Vector__4_iter(func->sym->template->instances); std_vector_Iterator__4_has_value(&_i124); std_vector_Iterator__4_next(&_i124)) {

#line 1479 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__4_cur(&_i124);

#line 1479 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          {

#line 1480 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_ast_scopes_Symbol *sym = instance->resolved;

#line 1481 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            if(!(sym->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1481:24: Assertion failed: `sym.type == Function`", NULL); }

#line 1482 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_ast_nodes_Function *func = sym->u.func;

#line 1483 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_function(this, func);
          }
        }
      } else {

#line 1486 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_function(this, func);
      }
    }
  }

#line 1490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_ValueIterator__3 _i125 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i125); std_map_ValueIterator__3_next(&_i125)) {

#line 1490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i125);

#line 1490 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1491 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_functions(this, child);
    }
  }

#line 1493 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_generic_pass_GenericPass_pop_scope(this->o);
}


#line 1497 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *func) {

#line 1498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->sym->is_extern) {

#line 1498 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1500 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->kind==compiler_ast_nodes_FunctionKind_Method && func->parent_type->base==compiler_types_BaseType_Structure) {

#line 1501 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Structure *struc = func->parent_type->u.struc;

#line 1502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 1502 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      return;
    }
  }

#line 1505 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (compiler_ast_scopes_Symbol_is_templated(func->sym)) {

#line 1506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (std_vector_Iterator__4 _i126 = std_vector_Vector__4_iter(func->sym->template->instances); std_vector_Iterator__4_has_value(&_i126); std_vector_Iterator__4_next(&_i126)) {

#line 1506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__4_cur(&_i126);

#line 1506 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      {

#line 1507 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_scopes_Symbol *sym = instance->resolved;

#line 1508 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if(!(sym->type==compiler_ast_scopes_SymbolType_Function)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1508:20: Assertion failed: `sym.type == Function`", NULL); }

#line 1509 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_ast_nodes_Function *func = sym->u.func;

#line 1510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (func->sym->is_dead) {

#line 1510 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          continue;
        }

#line 1512 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);

#line 1513 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (func->exits) {

#line 1513 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, " __attribute__((noreturn))");
        }

#line 1514 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }

#line 1516 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1519 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->sym->is_dead) {

#line 1519 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1520 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, func);

#line 1521 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (func->exits) {

#line 1521 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, " __attribute__((noreturn))");
  }

#line 1522 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n");
}


#line 1525 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_function_decls(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_program_Namespace *ns) {

#line 1526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__6 _i127 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i127); std_vector_Iterator__6_next(&_i127)) {

#line 1526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i127);

#line 1526 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1527 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_function_decl_toplevel(this, func);
    }
  }

#line 1530 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_ValueIterator__3 _i128 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i128); std_map_ValueIterator__3_next(&_i128)) {

#line 1530 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i128);

#line 1530 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1531 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_function_decls(this, child);
    }
  }
}


#line 1536 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {

#line 1537 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_ast_nodes_Function *dbg = std_map_Map__8_at(enom->type->methods, "dbg");

#line 1538 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_decl(this, dbg);

#line 1539 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " {\n");

#line 1540 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 1541 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1543 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->has_values) {

#line 1544 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "switch (this.tag) {\n");
  } else {

#line 1546 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "switch (this) {\n");
  }

#line 1549 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent+=1;

#line 1550 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__20 _i129 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i129); std_vector_Iterator__20_next(&_i129)) {

#line 1550 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i129);

#line 1550 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1551 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1552 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "case ");

#line 1553 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, compiler_ast_scopes_Symbol_out_name(variant->sym));

#line 1554 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str_f(&this->out, std_format(": return \"%s\";\n", variant->sym->name));
    }
  }

#line 1558 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1559 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("default: return \"<unknown>\";\n"));

#line 1561 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 1562 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_indent(this);

#line 1563 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}\n");

#line 1564 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  this->indent-=1;

#line 1565 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "}\n\n");
}


#line 1568 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc) {

#line 1569 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->sym->is_extern) {

#line 1569 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1570 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->sym->is_dead) {

#line 1570 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1572 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *strufull_name = compiler_ast_scopes_Symbol_out_name(struc->sym);

#line 1573 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->is_union) {

#line 1574 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef union %s %s;\n", strufull_name, strufull_name));
  } else {

#line 1576 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", strufull_name, strufull_name));
  }
}


#line 1580 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {

#line 1581 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (sym->is_dead) {

#line 1581 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1582 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(sym);

#line 1583 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", name, name));
}


#line 1586 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {

#line 1587 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (sym->is_dead) {

#line 1587 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1588 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(sym);

#line 1589 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type *type = sym->u.type_def;

#line 1590 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", name));

#line 1591 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("  void *%s;\n", compiler_passes_code_generator_cls_ctx_name));

#line 1592 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "  ");

#line 1594 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *acc = strdup(compiler_passes_code_generator_cls_fn_field_name);

#line 1595 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, false, std_format("void *_%s, ", compiler_passes_code_generator_cls_ctx_name), NULL));

#line 1602 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n};\n");
}


#line 1605 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {

#line 1606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (clos->sym->is_dead) {

#line 1606 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1607 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);

#line 1608 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *type_name = compiler_passes_code_generator_cls_ctx_type(clos);

#line 1609 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", type_name, type_name));
}


#line 1612 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {

#line 1613 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (clos->sym->is_dead) {

#line 1613 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1614 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);

#line 1616 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *type_name = compiler_passes_code_generator_cls_ctx_type(clos);

#line 1617 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", type_name));

#line 1619 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type dummy_ptr_type = {0};

#line 1620 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  dummy_ptr_type.base=compiler_types_BaseType_Pointer;

#line 1622 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_Iterator__4 _i130 = std_map_Map__4_iter(clos->closed_vars); std_map_Iterator__4_has_value(&_i130); std_map_Iterator__4_next(&_i130)) {

#line 1622 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_map_Item__4 *it = std_map_Iterator__4_cur(&_i130);

#line 1622 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1623 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_scopes_Symbol *sym = it->value;

#line 1624 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if(!(sym->type==compiler_ast_scopes_SymbolType_ClosedVariable)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1624:16: Assertion failed: `sym.type == ClosedVariable`", NULL); }

#line 1625 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "  ");

#line 1626 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;

#line 1628 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      dummy_ptr_type.u.ptr=var->type;

#line 1629 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, &dummy_ptr_type, compiler_ast_scopes_Symbol_out_name(var->sym));

#line 1630 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ";\n");
    }
  }

#line 1632 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "};\n");
}


#line 1635 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {

#line 1636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (clos->sym->is_dead) {

#line 1636 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1637 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);

#line 1638 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type *type = clos->type;

#line 1640 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *acc = strdup(name);

#line 1641 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, true, std_format("void *_%s, ", compiler_passes_code_generator_cls_ctx_name), clos->params));

#line 1649 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, ";\n");
}


#line 1652 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_closure_func(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Function *clos) {

#line 1653 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (clos->sym->is_dead) {

#line 1653 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1654 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(clos->sym);

#line 1655 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_types_Type *type = clos->type;

#line 1657 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *ctx = compiler_passes_code_generator_cls_ctx_name;

#line 1658 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *ctx_type = compiler_passes_code_generator_cls_ctx_type(clos);

#line 1660 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *acc = strdup(name);

#line 1661 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, compiler_passes_code_generator_CodeGenerator_helper_gen_function_type(this, type, type, acc, true, std_format("void *_%s, ", ctx), clos->params));

#line 1669 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, " {\n");

#line 1670 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str_f(&this->out, std_format("  %s *%s = (%s *)_%s;\n", ctx_type, ctx, ctx_type, ctx));

#line 1671 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_body(this, clos);

#line 1672 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n}\n\n");
}


#line 1676 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  
#line 1676 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_354_0:
      {

#line 1677 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_struct_typedef(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_354_1:
      {

#line 1678 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_354_2:
      {

#line 1679 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_closure_typedef(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_354_3:
      {

#line 1680 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_closure_type_typedef(this, sym);
      } break;
    default:
      {

#line 1681 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1681:20: Assertion failed: `false`", std_format("Unhandled symbol type in CodeGenerator::gen_typedef: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
      } break;
  }
}


#line 1684 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_sym_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_scopes_Symbol *sym) {
  
#line 1684 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_355_0:
      {

#line 1685 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_struct_def(this, sym->u.struc);
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_355_1:
      {

#line 1686 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_enum_def(this, sym->u.enom);
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_355_2:
      {

#line 1687 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_closure_def(this, sym->u.func);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_355_3:
      {

#line 1688 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_closure_type_def(this, sym);
      } break;
    default:
      {

#line 1689 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc:1689:20: Assertion failed: `false`", std_format("Unhandled symbol type in CodeGenerator::gen_def: %s", compiler_ast_scopes_SymbolType_dbg(sym->type))); exit(1); }
      } break;
  }
}


#line 1692 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_enum_typedef(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {

#line 1693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->sym->is_extern) {

#line 1693 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1694 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->sym->is_dead) {

#line 1694 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1696 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(enom->sym);

#line 1697 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->has_values) {

#line 1698 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef enum %s__kind %s__kind;\n", name, name));

#line 1699 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef struct %s %s;\n", name, name));
  } else {

#line 1701 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("typedef enum %s %s;\n", name, name));
  }
}


#line 1705 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_struct_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Structure *struc) {

#line 1706 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->sym->is_extern) {

#line 1706 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1707 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->sym->is_dead) {

#line 1707 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1709 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *strufull_name = compiler_ast_scopes_Symbol_out_name(struc->sym);

#line 1710 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (struc->is_union) {

#line 1711 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("union %s {\n", strufull_name));
  } else {

#line 1713 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", strufull_name));
  }

#line 1716 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__3 _i131 = std_vector_Vector__3_iter(struc->fields); std_vector_Iterator__3_has_value(&_i131); std_vector_Iterator__3_next(&_i131)) {

#line 1716 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i131);

#line 1716 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1717 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "  ");

#line 1718 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      if (field->is_atomic) {

#line 1719 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "_Atomic ");
      }

#line 1721 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, compiler_ast_scopes_Symbol_out_name(field->sym));

#line 1722 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, ";\n");
    }
  }

#line 1724 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "};\n\n");
}


#line 1727 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
void compiler_passes_code_generator_CodeGenerator_gen_enum_def(compiler_passes_code_generator_CodeGenerator *this, compiler_ast_nodes_Enum *enom) {

#line 1728 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->sym->is_dead) {

#line 1728 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    return;
  }

#line 1730 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  char *name = compiler_ast_scopes_Symbol_out_name(enom->sym);

#line 1731 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"

#line 1733 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->sym->is_extern) {

#line 1733 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    /* defers */

#line 1731 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(this, enom);
    return;
  }

#line 1736 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->has_values) {

#line 1737 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("enum %s__kind {\n", name));
  } else {

#line 1739 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("enum %s {\n", name));
  }

#line 1741 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__20 _i132 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i132); std_vector_Iterator__20_next(&_i132)) {

#line 1741 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i132);

#line 1741 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1742 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str_f(&this->out, std_format("  %s,\n", compiler_ast_scopes_Symbol_out_name(variant->sym)));
    }
  }

#line 1744 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "};\n\n");

#line 1746 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  if (enom->has_values) {

#line 1747 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("struct %s {\n", name));

#line 1748 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str_f(&this->out, std_format("  %s__kind tag;\n", name));

#line 1749 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (std_vector_Iterator__3 _i133 = std_vector_Vector__3_iter(enom->shared_fields); std_vector_Iterator__3_has_value(&_i133); std_vector_Iterator__3_next(&_i133)) {

#line 1749 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i133);

#line 1749 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      {

#line 1750 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, "  ");

#line 1751 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, compiler_ast_scopes_Symbol_out_name(field->sym));

#line 1752 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        std_buffer_Buffer_write_str(&this->out, ";\n");
      }
    }

#line 1754 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "  union {\n");

#line 1755 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    for (std_vector_Iterator__20 _i134 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i134); std_vector_Iterator__20_next(&_i134)) {

#line 1755 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i134);

#line 1755 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      {

#line 1756 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
        if (variant->specific_fields->size > 0) {

#line 1757 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str(&this->out, "    struct {\n");

#line 1758 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          for (u32 i = 0; i < variant->specific_fields->size; i+=1) {

#line 1760 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_ast_nodes_Variable *field = std_vector_Vector__3_at(variant->specific_fields, i);

#line 1761 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            char *name = compiler_ast_scopes_Symbol_out_name(field->sym);

#line 1762 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, "      ");

#line 1763 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            compiler_passes_code_generator_CodeGenerator_gen_type_and_name(this, field->type, name);

#line 1764 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
            std_buffer_Buffer_write_str(&this->out, ";\n");
          }

#line 1766 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
          std_buffer_Buffer_write_str_f(&this->out, std_format("    } %s;\n", compiler_ast_scopes_Symbol_out_name(variant->sym)));
        }
      }
    }

#line 1769 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "  };\n");

#line 1770 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_buffer_Buffer_write_str(&this->out, "};\n\n");
  }
  /* defers */

#line 1731 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_enum_dbg_method(this, enom);
}


#line 1774 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_generate(compiler_passes_code_generator_CodeGenerator *this) {

#line 1775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__8 _i135 = std_vector_Vector__8_iter(this->o->program->c_includes); std_vector_Iterator__8_has_value(&_i135); std_vector_Iterator__8_next(&_i135)) {

#line 1775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    char *include = std_vector_Iterator__8_cur(&_i135);

#line 1775 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1776 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str_f(&this->out, std_format("#include \"%s\"\n", include));
    }
  }

#line 1778 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n");

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_map_Iterator__6 _i136 = std_map_Map__6_iter(this->o->program->c_embeds); std_map_Iterator__6_has_value(&_i136); std_map_Iterator__6_next(&_i136)) {

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    std_map_Item__6 *it = std_map_Iterator__6_cur(&_i136);

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1781 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str_f(&this->out, std_format("/* Embed: %s */\n", it->key));

#line 1782 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, it->value);

#line 1783 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      std_buffer_Buffer_write_str(&this->out, "\n\n");
    }
  }

#line 1786 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "/* Constants */\n");

#line 1787 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_constants(this, this->o->program->global);

#line 1789 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "/* Typedefs */\n");

#line 1790 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__9 _i137 = std_vector_Vector__9_iter(this->o->program->ordered_symbols); std_vector_Iterator__9_has_value(&_i137); std_vector_Iterator__9_next(&_i137)) {

#line 1790 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__9_cur(&_i137);

#line 1790 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1791 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_sym_typedef(this, sym);
    }
  }

#line 1793 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "\n");

#line 1795 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "/* Structs */\n");

#line 1796 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__9 _i138 = std_vector_Vector__9_iter(this->o->program->ordered_symbols); std_vector_Iterator__9_has_value(&_i138); std_vector_Iterator__9_next(&_i138)) {

#line 1796 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__9_cur(&_i138);

#line 1796 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1797 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_sym_def(this, sym);
    }
  }

#line 1800 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "/* function declarations */\n");

#line 1801 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_function_decls(this, this->o->program->global);

#line 1802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__6 _i139 = std_vector_Vector__6_iter(this->o->program->closures); std_vector_Iterator__6_has_value(&_i139); std_vector_Iterator__6_next(&_i139)) {

#line 1802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Function *clos = std_vector_Iterator__6_cur(&_i139);

#line 1802 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1803 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_closure_func_decl(this, clos);
    }
  }

#line 1806 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_global_variables(this, this->o->program->global);

#line 1808 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  std_buffer_Buffer_write_str(&this->out, "/* function implementations */\n");

#line 1809 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator_gen_functions(this, this->o->program->global);

#line 1810 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  for (std_vector_Iterator__6 _i140 = std_vector_Vector__6_iter(this->o->program->closures); std_vector_Iterator__6_has_value(&_i140); std_vector_Iterator__6_next(&_i140)) {

#line 1810 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    compiler_ast_nodes_Function *clos = std_vector_Iterator__6_cur(&_i140);

#line 1810 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
    {

#line 1811 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
      compiler_passes_code_generator_CodeGenerator_gen_closure_func(this, clos);
    }
  }

#line 1814 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return std_buffer_Buffer_str(this->out);
}


#line 1817 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
compiler_passes_code_generator_CodeGenerator compiler_passes_code_generator_CodeGenerator_make(compiler_ast_program_Program *program) {

#line 1818 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return (compiler_passes_code_generator_CodeGenerator){.o=compiler_passes_generic_pass_GenericPass_new(program), .out=std_buffer_Buffer_make(16), .yield_vars=std_vector_Vector__8_new(16), .indent=0};
}


#line 1825 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_CodeGenerator_run(compiler_ast_program_Program *program) {

#line 1826 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  compiler_passes_code_generator_CodeGenerator pass = compiler_passes_code_generator_CodeGenerator_make(program);

#line 1827 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
  return compiler_passes_code_generator_CodeGenerator_generate(&pass);
}


#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/passes/code_generator.oc"
char *compiler_passes_code_generator_cls_ctx_type(compiler_ast_nodes_Function *func) {
  return std_format("%sCtx", compiler_ast_scopes_Symbol_out_name(func->sym));}


#line 20 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
compiler_passes_reorder_symbols_ReorderSymbols *compiler_passes_reorder_symbols_ReorderSymbols_new(compiler_ast_program_Program *program) {

#line 21 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols *pass = std_mem_alloc__2(1);

#line 22 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  (*pass)=(compiler_passes_reorder_symbols_ReorderSymbols){.o=compiler_passes_generic_pass_GenericPass_new(program), .all_syms=std_vector_Vector__9_new(16), .done=std_set_Set__1_new()};

#line 27 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  return pass;
}


#line 30 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_free(compiler_passes_reorder_symbols_ReorderSymbols *this) {

#line 31 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_vector_Vector__9_free(this->all_syms);

#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_set_Set__1_free(this->done);

#line 33 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_mem_free(this->o);

#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_mem_free(this);
}


#line 37 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym) {

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  if (((bool)sym) && !(sym->is_dead)) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    std_vector_Vector__9_push(this->all_syms, sym);
  }
}


#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_program_Namespace *ns) {

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_vector_Iterator__14 _i141 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i141); std_vector_Iterator__14_next(&_i141)) {

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i141);

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      if (compiler_ast_scopes_Symbol_is_templated(struc->sym)) {

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        for (std_vector_Iterator__4 _i142 = std_vector_Vector__4_iter(struc->sym->template->instances); std_vector_Iterator__4_has_value(&_i142); std_vector_Iterator__4_next(&_i142)) {

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          compiler_ast_scopes_TemplateInstance *instance = std_vector_Iterator__4_cur(&_i142);

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          {

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            compiler_ast_scopes_Symbol *sym = instance->resolved;

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            if(!(sym->type==compiler_ast_scopes_SymbolType_Structure)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc:49:24: Assertion failed: `sym.type == Structure`", NULL); }

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, sym);
          }
        }
      } else {

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, struc->sym);
      }
    }
  }

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_vector_Iterator__15 _i143 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i143); std_vector_Iterator__15_next(&_i143)) {

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i143);

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, enom->sym);
    }
  }

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_map_ValueIterator__3 _i144 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i144); std_map_ValueIterator__3_next(&_i144)) {

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i144);

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(this, child);
    }
  }
}


#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(compiler_passes_reorder_symbols_ReorderSymbols *this) {

#line 66 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols_ns(this, this->o->program->global);

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_vector_Iterator__0 _i145 = std_vector_Vector__0_iter(this->o->program->closure_types); std_vector_Iterator__0_has_value(&_i145); std_vector_Iterator__0_next(&_i145)) {

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_types_Type *cty = std_vector_Iterator__0_cur(&_i145);

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, cty->sym);
    }
  }

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_vector_Iterator__6 _i146 = std_vector_Vector__6_iter(this->o->program->closures); std_vector_Iterator__6_has_value(&_i146); std_vector_Iterator__6_next(&_i146)) {

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_ast_nodes_Function *closure = std_vector_Iterator__6_cur(&_i146);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      compiler_passes_reorder_symbols_ReorderSymbols_collect_sym(this, closure->sym);
    }
  }
}


#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_dfs(compiler_passes_reorder_symbols_ReorderSymbols *this, compiler_ast_scopes_Symbol *sym) {

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  if (!(((bool)sym)) || std_set_Set__1_contains(this->done, sym)) {

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    return;
  }

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_set_Set__1_add(this->done, sym);

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_356_0:
      {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        for (std_vector_Iterator__3 _i147 = std_vector_Vector__3_iter(sym->u.struc->fields); std_vector_Iterator__3_has_value(&_i147); std_vector_Iterator__3_next(&_i147)) {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i147);

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          {

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            if (((bool)field->type)) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
              compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
            }
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_356_1:
      {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        for (std_vector_Iterator__3 _i148 = std_vector_Vector__3_iter(sym->u.enom->shared_fields); std_vector_Iterator__3_has_value(&_i148); std_vector_Iterator__3_next(&_i148)) {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i148);

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          {

#line 89 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            if (((bool)field->type)) {

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
              compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
            }
          }
        }

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        for (std_vector_Iterator__20 _i149 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i149); std_vector_Iterator__20_next(&_i149)) {

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i149);

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            for (std_vector_Iterator__3 _i150 = std_vector_Vector__3_iter(variant->specific_fields); std_vector_Iterator__3_has_value(&_i150); std_vector_Iterator__3_next(&_i150)) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
              compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i150);

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
              {

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
                if (((bool)field->type)) {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
                  compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, field->type->sym);
                }
              }
            }
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Closure:
    m_356_2:
      {

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        compiler_ast_nodes_Function *func = sym->u.func;

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        for (std_vector_Iterator__3 _i151 = std_vector_Vector__3_iter(func->params); std_vector_Iterator__3_has_value(&_i151); std_vector_Iterator__3_next(&_i151)) {

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i151);

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
          {

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
            compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, param->type->sym);
          }
        }

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, func->return_type->sym);
      } break;
    case compiler_ast_scopes_SymbolType_ClosureType:
    m_356_3:
      {

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, sym->u.type_def->sym);
      } break;
    default:
      {

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
        return;
      } break;
  }

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  std_vector_Vector__9_push(this->o->program->ordered_symbols, sym);
}


#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(compiler_passes_reorder_symbols_ReorderSymbols *this) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  for (std_vector_Iterator__9 _i152 = std_vector_Vector__9_iter(this->all_syms); std_vector_Iterator__9_has_value(&_i152); std_vector_Iterator__9_next(&_i152)) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    compiler_ast_scopes_Symbol *sym = std_vector_Iterator__9_cur(&_i152);

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
    {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
      compiler_passes_reorder_symbols_ReorderSymbols_dfs(this, sym);
    }
  }
}


#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
void compiler_passes_reorder_symbols_ReorderSymbols_run(compiler_ast_program_Program *program) {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols *pass = compiler_passes_reorder_symbols_ReorderSymbols_new(program);

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols_collect_all_symbols(pass);

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols_reorder_structs(pass);

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/passes/reorder_symbols.oc"
  compiler_passes_reorder_symbols_ReorderSymbols_free(pass);
}


#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_parser_Parser compiler_parser_Parser_make(compiler_ast_program_Program *program, compiler_ast_program_Namespace *ns) {

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return (compiler_parser_Parser){.tokens=NULL, .curr=0, .curr_func=NULL, .program=program, .ns=ns, .attrs=std_vector_Vector__12_new(16), .attrs_span=std_span_Span_default(), .attrs_start_tok=NULL, .prev_expr_error_span=std_span_Span_default()};
}


#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_free(compiler_parser_Parser *this) {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__12_free(this->attrs);
}


#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_tokens_Token *compiler_parser_Parser_peek(compiler_parser_Parser *this, i32 off) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  i32 idx = (((i32)this->curr) + off);

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if(!((0 <= idx) && (idx < ((i32)this->tokens->size)))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:63:12: Assertion failed: `0i32 <= idx < (.tokens.size as i32)`", NULL); }

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return std_vector_Vector__11_at(this->tokens, ((u32)idx));
}


#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_errors_Error *compiler_parser_Parser_error_msg(compiler_parser_Parser *this, char *msg) {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_errors_Error *err = compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, msg);

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__13_push(this->program->errors, err);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return err;
}


#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_errors_Error *compiler_parser_Parser_error(compiler_parser_Parser *this, compiler_errors_Error *err) {

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__13_push(this->program->errors, err);

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return err;
}


#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_unhandled_type(compiler_parser_Parser *this, char *func) {

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_error_msg(this, std_format("Unexpected token in %s: %s", func, compiler_tokens_TokenType_str(compiler_parser_Parser_token(this)->type)));
}


#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_tokens_Token *compiler_parser_Parser_token(compiler_parser_Parser *this) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (this->curr >= this->tokens->size) {

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->curr=(this->tokens->size - 1);

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error_msg(this, "Unexpected end of file");

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return std_vector_Vector__11_unchecked_at(this->tokens, ((u32)this->curr));
}


#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_token_is(compiler_parser_Parser *this, compiler_tokens_TokenType type) {

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (type==compiler_tokens_TokenType_Newline) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_parser_Parser_token(this)->seen_newline;
  }

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return compiler_parser_Parser_token(this)->type==type;
}


#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_token_is_eof_or(compiler_parser_Parser *this, compiler_tokens_TokenType type) {

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)) {

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return true;
  }

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return compiler_parser_Parser_token_is(this, type);
}


#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_token_is_identifier(compiler_parser_Parser *this, char *name) {
  return compiler_tokens_Token_is_identifier((*compiler_parser_Parser_token(this)), name);}


#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_peek_token_is(compiler_parser_Parser *this, u32 off, compiler_tokens_TokenType type) {

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if ((this->curr + off) >= this->tokens->size) {

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return false;
  }

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *tok = std_vector_Vector__11_at(this->tokens, (this->curr + off));

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return tok->type==type;
}


#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_consume_if(compiler_parser_Parser *this, compiler_tokens_TokenType type) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, type)) {

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (type != compiler_tokens_TokenType_Newline) {

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (this->curr < (this->tokens->size - 1)) {

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        this->curr+=1;
      }
    }

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return true;
  }

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return false;
}


#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_consume_newline_or(compiler_parser_Parser *this, compiler_tokens_TokenType type) {

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, type)) {

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (this->curr < (this->tokens->size - 1)) {

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      this->curr+=1;
    }
  } else if (!(compiler_parser_Parser_token(this)->seen_newline)) {

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error_msg(this, std_format("Expected %s or newline", compiler_tokens_TokenType_str(type)));

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }
}


#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_consume_tokens_until_newline(compiler_parser_Parser *this) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token(this)->seen_newline)) {

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)) {

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->curr+=1;
  }
}


#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_tokens_Token *compiler_parser_Parser_consume(compiler_parser_Parser *this, compiler_tokens_TokenType type) {

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *tok = compiler_parser_Parser_token(this);

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_consume_if(this, type))) {

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error_msg(this, std_format("Expected TokenType::%s", compiler_tokens_TokenType_str(type)));

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return tok;
}


#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_is_end_of_statement(compiler_parser_Parser *this) {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly)) {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return true;
  }

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Semicolon)) {

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return true;
  }

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token(this)->seen_newline) {

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return true;
  }

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return false;
}


#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_consume_end_of_statement(compiler_parser_Parser *this) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly)) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Semicolon);
}


#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_clear_attributes(compiler_parser_Parser *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i195 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i195); std_vector_Iterator__12_next(&_i195)) {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i195);

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_mem_free(attr);
    }
  }

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__12_clear(this->attrs);

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->attrs_start_tok=NULL;
}


#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_is_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op) {
  return ({ bool __yield_0;

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((op)) {
      case compiler_ast_operators_Operator_LeftShift:
      m_357_0:
        {
          __yield_0 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_LessThan));
        } break;
      case compiler_ast_operators_Operator_RightShift:
      m_357_1:
        {
          __yield_0 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_GreaterThan));
        } break;
      case compiler_ast_operators_Operator_LeftShiftEquals:
      m_357_2:
        {
          __yield_0 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_LessThanEquals));
        } break;
      case compiler_ast_operators_Operator_RightShiftEquals:
      m_357_3:
        {
          __yield_0 = (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_GreaterThanEquals));
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
std_span_Span compiler_parser_Parser_consume_compound_operator(compiler_parser_Parser *this, compiler_ast_operators_Operator op) {

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span span = compiler_parser_Parser_token(this)->span;

#line 179 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  switch ((op)) {
    case compiler_ast_operators_Operator_LeftShift:
    m_358_0:
      {

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);
      } break;
    case compiler_ast_operators_Operator_RightShift:
    m_358_1:
      {

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);
      } break;
    case compiler_ast_operators_Operator_LeftShiftEquals:
    m_358_2:
      {

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThanEquals);
      } break;
    case compiler_ast_operators_Operator_RightShiftEquals:
    m_358_3:
      {

#line 183 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);

#line 183 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThanEquals);
      } break;
    default:
      {

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(span, std_format("Unknown operator %s in Parser::consume_compound_operator", compiler_ast_operators_Operator_dbg(op))));
      } break;
  }

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *prev_token = std_vector_Vector__11_at(this->tokens, (this->curr - 1));

#line 189 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return std_span_Span_join(span, prev_token->span);
}


#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_types_Type *compiler_parser_Parser_parse_type(compiler_parser_Parser *this) {
  return ({ compiler_types_Type *__yield_0;

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_Identifier:
      m_359_0:
        {

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(this, true);

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          char *name = (ident->type==compiler_ast_nodes_ASTType_Identifier ? ident->u.ident.name : "<unresolved>");

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *typ = compiler_types_Type_new_unresolved(name, ident->span);

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          typ->u.unresolved=ident;

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = typ;
        } break;
      case compiler_tokens_TokenType_Ampersand:
      m_359_1:
        {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *amp = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ampersand);

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *base = compiler_parser_Parser_parse_type(this);

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, std_span_Span_join(amp->span, base->span));

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          typ->u.ptr=base;

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = typ;
        } break;
      case compiler_tokens_TokenType_AtSign:
      case compiler_tokens_TokenType_Fn:
      m_359_2:
        {

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span start_span = compiler_parser_Parser_token(this)->span;

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_BaseType base_type = ({ compiler_types_BaseType __yield_1;

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            switch ((compiler_parser_Parser_token(this)->type)) {
              case compiler_tokens_TokenType_AtSign:
              m_360_0:
                {

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Fn);

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  __yield_1 = compiler_types_BaseType_Closure;
                } break;
              case compiler_tokens_TokenType_Fn:
              m_360_1:
                {

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Fn);

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  __yield_1 = compiler_types_BaseType_FunctionPtr;
                } break;
              default:
                {
                  std_panic("unreachable");
                } break;
            }

          __yield_1; });

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_vector_Vector__3 *params = std_vector_Vector__3_new(16);

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          bool is_variadic = false;

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ellipsis)) {

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              is_variadic=true;

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              break;
            }

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_types_Type *param_type = compiler_parser_Parser_parse_type(this);

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(param_type);

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            var->sym=compiler_ast_scopes_Symbol_from_local_variable("", var, param_type->span);

#line 244 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__3_push(params, var);

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseParen))) {

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
            }
          }

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *return_type;

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return_type=compiler_parser_Parser_parse_type(this);
          } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Void, start_span);
          }

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *type = compiler_types_Type_new_resolved(base_type, std_span_Span_join(start_span, close->span));

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          type->u.func=(compiler_types_FunctionType){.orig=NULL, .params=params, .return_type=return_type, .is_variadic=is_variadic};

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = type;
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_359_3:
        {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span start_span = compiler_parser_Parser_token(this)->span;

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *elem_type = compiler_parser_Parser_parse_type(this);

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *size_expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseSquare);

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *typ = compiler_types_Type_new_resolved(compiler_types_BaseType_Array, std_span_Span_join(start_span, close->span));

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          typ->u.arr=(compiler_types_ArrayType){.elem_type=elem_type, .size_expr=size_expr, .size_known=false, .size=0};

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = typ;
        } break;
      default:
        {

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_unhandled_type(this, "parse_type");

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Error, compiler_parser_Parser_token(this)->span);
        } break;
    }

  __yield_0; });}


#line 280 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_identifier(compiler_parser_Parser *this) {

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, tok->span);

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.ident.name=tok->text;

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_scoped_identifier(compiler_parser_Parser *this, bool consume_template) {

#line 288 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_parser_Parser_parse_identifier(this);

#line 290 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (true) {

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_ColonColon:
      m_361_0:
        {

#line 293 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *colons = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_ColonColon);

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *lookup = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_NSLookup, node->span);

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          lookup->u.lookup.lhs=node;

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=lookup;

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Newline) || !(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_span_Span span = (std_span_Span){.start=colons->span.end, .end=colons->span.end};

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Expected identifier after `::`"));

#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->span.end=compiler_parser_Parser_token(this)->span.start;
          } else {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->span=std_span_Span_join(node->span, name->span);

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.lookup.rhs_name=name->text;

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.lookup.rhs_span=name->span;
          }
        } break;
      case compiler_tokens_TokenType_LessThan:
      m_361_1:
        {

#line 312 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (!(consume_template)) {

#line 312 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return node;
          }

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *prev_token = std_vector_Vector__11_at(this->tokens, (((u32)this->curr) - 1));

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (!(std_span_Span_starts_right_after(compiler_parser_Parser_token(this)->span, prev_token->span))) {

#line 321 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return node;
          }

#line 325 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *next_next_token = std_vector_Vector__11_at(this->tokens, (((u32)this->curr) + 2));

#line 326 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (next_next_token->type==compiler_tokens_TokenType_Dot) {

#line 327 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return node;
          }

#line 331 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan);

#line 332 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_vector_Vector__0 *args = std_vector_Vector__0_new(16);

#line 334 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_GreaterThan))) {

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__0_push(args, compiler_parser_Parser_parse_type(this));

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan))) {

#line 337 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                compiler_parser_Parser_error(this, compiler_errors_Error_new_note(compiler_parser_Parser_token(this)->span, "Parsing template specialization: expected `,` or `>`", "If you're comparing values, put a space before the `<` earlier"));

#line 342 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, node->span);
              }
            }
          }

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan);

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *spec = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Specialization, std_span_Span_join(node->span, end->span));

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          spec->u.spec=(compiler_ast_nodes_Specialization){.base=node, .parsed_template_args=args, .template_args=args};

#line 353 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=spec;
        } break;
      default:
        {

#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return node;
        } break;
    }
  }

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return NULL;
}


#line 363 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_format_string(compiler_parser_Parser *this) {

#line 364 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *fstr = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FormatStringLiteral);

#line 365 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  u32 fstr_len = strlen(fstr->text);

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8 *expr_parts = std_vector_Vector__8_new(16);

#line 368 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__29 *expr_start = std_vector_Vector__29_new(16);

#line 370 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8 *format_parts = std_vector_Vector__8_new(16);

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8 *specifiers = std_vector_Vector__8_new(16);

#line 373 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  u32 specifier_loc = 0;

#line 374 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool specifier_found = false;

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  u32 count = 0;

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  u32 cur_start = 0;

#line 379 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (u32 i = 0; i < fstr_len; i+=1) {

#line 380 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch (fstr->text[i]) {
      case '\\': {

#line 381 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        i+=1;
      } break;
      case '{': {

#line 383 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (count==0) {

#line 384 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          char *part = str_substring(fstr->text, cur_start, (i - cur_start));

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_vector_Vector__8_push(format_parts, part);

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          cur_start=(i + 1);
        }

#line 388 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        count+=1;
      } break;
      case '}': {

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        count-=1;

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (count==0) {

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (specifier_loc > 0) {

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            u32 len = (specifier_loc - cur_start);

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            char *part = str_substring(fstr->text, cur_start, len);

#line 396 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__8_push(expr_parts, part);

#line 397 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__29_push(expr_start, cur_start);

#line 399 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            specifier_loc+=1;

#line 400 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            while ((specifier_loc < i) && fstr->text[specifier_loc]==' ') {

#line 401 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              specifier_loc+=1;
            }

#line 404 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (specifier_loc==i) {

#line 405 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              std_span_Location loc = fstr->span.start;

#line 406 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              loc.col+=(specifier_loc + 1);

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              std_span_Span span = (std_span_Span){.start=loc, .end=loc};

#line 408 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Expected format specifier"));

#line 409 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              return NULL;
            }

#line 412 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            char *spec = str_substring(fstr->text, specifier_loc, (i - specifier_loc));

#line 413 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__8_push(specifiers, spec);
          } else {

#line 415 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            char *part = str_substring(fstr->text, cur_start, (i - cur_start));

#line 416 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__8_push(expr_parts, part);

#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__29_push(expr_start, cur_start);

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__8_push(specifiers, NULL);
          }

#line 420 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          cur_start=(i + 1);

#line 421 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          specifier_loc=0;

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          specifier_found=false;
        } else if (count < 0) {

#line 425 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(fstr->span, "Unmatched '}' in format string"));

#line 426 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return NULL;
        }
      } break;
      case ':': {

#line 432 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if ((count==1 && (fstr->text[(i - 1)] != ':')) && (fstr->text[(i + 1)] != ':')) {

#line 433 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          specifier_loc=i;

#line 434 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          specifier_found=true;
        }
      } break;
      default: {
      } break;
    }
  }

#line 440 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (count != 0) {

#line 441 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(fstr->span, "Unmatched '{' in format string"));

#line 442 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 444 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *part = str_substring(fstr->text, cur_start, (fstr_len - cur_start));

#line 445 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8_push(format_parts, part);

#line 447 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_FormatStringLiteral, fstr->span);

#line 448 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.fmt_str.parts=format_parts;

#line 450 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Location fstr_start = fstr->span.start;

#line 451 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16 *expr_nodes = std_vector_Vector__16_new(16);

#line 452 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (u32 i = 0; i < expr_parts->size; i+=1) {

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *part = std_vector_Vector__8_at(expr_parts, i);

#line 454 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    u32 start = std_vector_Vector__29_at(expr_start, i);

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(part, fstr_start.filename);

#line 457 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lexer.loc=fstr_start;

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lexer.loc.col+=(start + 1);

#line 460 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);

#line 461 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    for (std_vector_Iterator__13 _i196 = std_vector_Vector__13_iter(lexer.errors); std_vector_Iterator__13_has_value(&_i196); std_vector_Iterator__13_next(&_i196)) {

#line 461 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_errors_Error *error = std_vector_Iterator__13_cur(&_i196);

#line 461 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      {

#line 462 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, error);
      }
    }

#line 464 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__13_free(lexer.errors);

#line 466 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser sub_parser = compiler_parser_Parser_make(this->program, this->ns);

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sub_parser.tokens=tokens;

#line 468 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sub_parser.curr=0;

#line 469 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sub_parser.curr_func=this->curr_func;

#line 471 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(&sub_parser, compiler_tokens_TokenType_CloseCurly);

#line 472 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(&sub_parser, compiler_tokens_TokenType_EOF))) {

#line 473 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(expr->span, "Invalid expression in format string"));
    }

#line 476 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__16_push(expr_nodes, expr);
  }

#line 478 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.fmt_str.exprs=expr_nodes;

#line 479 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.fmt_str.specs=specifiers;

#line 480 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8_free(expr_parts);

#line 481 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__29_free(expr_start);

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 485 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
std_vector_Vector__10 *compiler_parser_Parser_parse_match_case_conds(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 486 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__10 *conds = std_vector_Vector__10_new(16);

#line 487 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, end_type))) {

#line 488 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_atom(this, compiler_tokens_TokenType_Line);

#line 490 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__19 *args = NULL;

#line 491 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_OpenParen)) {

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      args=std_vector_Vector__19_new(16);

#line 493 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {

#line 494 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 495 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);

#line 496 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);

#line 497 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_vector_Vector__19_push(args, ({compiler_ast_nodes_MatchCondArg *_new_362 = std_mem_state_alloc_fn(std_mem_state_allocator, sizeof(compiler_ast_nodes_MatchCondArg)); *_new_362 = (compiler_ast_nodes_MatchCondArg){.var=var, .is_shared=false}; _new_362; }));

#line 499 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {

#line 500 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          break;
        }
      }

#line 503 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);
    }

#line 505 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__10_push(conds, compiler_ast_nodes_MatchCond_new(expr, args, NULL));

#line 506 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Line))) {

#line 506 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }
  }

#line 509 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return conds;
}


#line 512 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_match(compiler_parser_Parser *this) {

#line 513 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *op = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Match);

#line 514 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);

#line 515 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Match, std_span_Span_join(op->span, expr->span));

#line 516 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.match_stmt.expr=expr;

#line 517 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.match_stmt.match_span=op->span;

#line 519 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__24 *cases = std_vector_Vector__24_new(16);

#line 520 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.match_stmt.cases=cases;

#line 522 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly))) {

#line 523 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '{' after match expression"));

#line 524 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return node;
  }

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 527 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 528 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {

#line 529 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      node->u.match_stmt.defolt_span=compiler_parser_Parser_token(this)->span;

#line 530 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);

#line 531 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {

#line 532 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected => after match case"));
      }

#line 534 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      node->u.match_stmt.defolt=compiler_parser_Parser_parse_statement(this);
    } else {

#line 537 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__10 *conds = compiler_parser_Parser_parse_match_case_conds(this, compiler_tokens_TokenType_FatArrow);

#line 538 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {

#line 539 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected => after match case"));
      }

#line 541 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);

#line 542 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {

#line 543 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Comma);
      }

#line 545 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_MatchCase _case = (compiler_ast_nodes_MatchCase){.conds=conds, .body=body};

#line 546 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__24_push(cases, _case);
    }

#line 549 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }

#line 551 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->span=std_span_Span_join(op->span, compiler_parser_Parser_token(this)->span);

#line 552 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.match_stmt.cases=cases;

#line 555 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 559 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_sync_toplevel(compiler_parser_Parser *this) {

#line 560 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!((((((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Import)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Def)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Let)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Const)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Struct)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Enum)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_AtSign)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EOF)))) {

#line 572 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->curr+=1;
  }
}


#line 576 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_types_Type *compiler_parser_Parser_parse_literal_suffix_type(compiler_parser_Parser *this, compiler_tokens_Token *suffix) {

#line 577 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)suffix))) {

#line 577 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 579 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *ident = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, suffix->span);

#line 580 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  ident->u.ident.name=suffix->text;

#line 582 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_types_Type *typ = compiler_types_Type_new_unresolved(suffix->text, suffix->span);

#line 583 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  typ->u.unresolved=ident;

#line 585 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return typ;
}


#line 588 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_call(compiler_parser_Parser *this, compiler_ast_nodes_AST *callee) {

#line 589 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 590 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__7 *args = std_vector_Vector__7_new(16);

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {

#line 592 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *label_tok = NULL;

#line 593 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_Colon)) {

#line 594 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      label_tok=compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);
    }

#line 597 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);

#line 599 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__7_push(args, compiler_ast_nodes_Argument_new(expr, label_tok));

#line 600 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseParen))) {

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }

#line 605 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 606 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_ASTType call_type = compiler_ast_nodes_ASTType_Call;

#line 607 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(call_type, std_span_Span_join(callee->span, end->span));

#line 608 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  call->u.call.callee=callee;

#line 609 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  call->u.call.args=args;

#line 610 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  call->u.call.open_paren_span=start->span;

#line 611 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  call->u.call.close_paren_span=end->span;

#line 612 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return call;
}


#line 616 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_initializer(compiler_parser_Parser *this) {

#line 617 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) {

#line 618 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);

#line 619 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__16 *elements = std_vector_Vector__16_new(16);

#line 620 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseSquare))) {

#line 621 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__16_push(elements, compiler_parser_Parser_parse_var_initializer(this));

#line 622 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseSquare))) {

#line 623 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
      }
    }

#line 626 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);

#line 627 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_ArrayLiteral, std_span_Span_join(start->span, close->span));

#line 628 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.array_literal.elements=elements;

#line 629 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return node;
  }

#line 631 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
}


#line 634 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_var_declaration(compiler_parser_Parser *this) {

#line 635 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Let);

#line 636 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 637 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end_span = name->span;

#line 639 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_types_Type *type = ((compiler_types_Type *)NULL);

#line 640 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 641 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    type=compiler_parser_Parser_parse_type(this);

#line 642 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    end_span=type->span;
  }

#line 644 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *init = ((compiler_ast_nodes_AST *)NULL);

#line 645 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 646 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    init=compiler_parser_Parser_parse_var_initializer(this);

#line 647 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    end_span=init->span;
  }

#line 649 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume_end_of_statement(this);

#line 651 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, std_span_Span_join(start->span, end_span));

#line 653 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);

#line 654 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);

#line 655 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  var->default_value=init;

#line 657 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.var_decl=var;

#line 658 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 661 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_global_value(compiler_parser_Parser *this, bool is_const) {

#line 662 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start_token = ({ compiler_tokens_Token *__yield_0;

#line 662 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (is_const) {

#line 663 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Const);
    } else {

#line 665 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Let);
    }

  __yield_0; });

#line 668 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, compiler_parser_Parser_token(this)->span);

#line 669 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = ({ compiler_tokens_Token *__yield_0;

#line 669 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier)) {

#line 670 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);
    } else {

#line 672 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier"));

#line 673 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      return node;
    }

  __yield_0; });

#line 676 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_types_Type *type = ((compiler_types_Type *)NULL);

#line 677 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 677 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    type=compiler_parser_Parser_parse_type(this);
  }

#line 679 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);

#line 680 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  var->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Variable, this->ns, this->ns->sym, name->text, name->span);

#line 681 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  var->sym->u.var=var;

#line 683 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (is_const) {

#line 684 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->sym->type=compiler_ast_scopes_SymbolType_Constant;
  }

#line 687 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_extern_into_symbol(this, var->sym);

#line 689 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i197 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i197); std_vector_Iterator__12_next(&_i197)) {

#line 689 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i197);

#line 689 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 690 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_363_0:
          {

#line 691 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_get_extern_from_attr(this, var->sym, attr);
          } break;
        case compiler_attributes_AttributeType_Atomic:
        m_363_1:
          {

#line 692 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            var->is_atomic=true;
          } break;
        default:
          {

#line 693 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Unexpected attribute for variable"));
          } break;
      }
    }
  }

#line 697 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.var_decl=var;

#line 698 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 699 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (is_const) {

#line 700 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
    } else {

#line 702 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->default_value=compiler_parser_Parser_parse_var_initializer(this);
    }
  }

#line 705 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Semicolon);

#line 706 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 709 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_atom(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 710 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = ((compiler_ast_nodes_AST *)NULL);

#line 711 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_If:
    m_364_0:
      {

#line 712 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_if(this);
      } break;
    case compiler_tokens_TokenType_Match:
    m_364_1:
      {

#line 713 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_match(this);
      } break;
    case compiler_tokens_TokenType_OpenCurly:
    m_364_2:
      {

#line 714 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_block(this);
      } break;
    case compiler_tokens_TokenType_FormatStringLiteral:
    m_364_3:
      {

#line 715 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_format_string(this);
      } break;
    case compiler_tokens_TokenType_Null:
    m_364_4:
      {

#line 717 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Null);

#line 718 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Null, tok->span);
      } break;
    case compiler_tokens_TokenType_IntLiteral:
    m_364_5:
      {

#line 721 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_IntLiteral, compiler_parser_Parser_token(this)->span);

#line 722 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_IntLiteral);

#line 723 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.num_literal=(compiler_ast_nodes_NumLiteral){.text=tok->text, .suffix=compiler_parser_Parser_parse_literal_suffix_type(this, tok->suffix)};
      } break;
    case compiler_tokens_TokenType_FloatLiteral:
    m_364_6:
      {

#line 729 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_FloatLiteral, compiler_parser_Parser_token(this)->span);

#line 730 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FloatLiteral);

#line 731 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.num_literal=(compiler_ast_nodes_NumLiteral){.text=tok->text, .suffix=compiler_parser_Parser_parse_literal_suffix_type(this, tok->suffix)};
      } break;
    case compiler_tokens_TokenType_StringLiteral:
    m_364_7:
      {

#line 737 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_StringLiteral, compiler_parser_Parser_token(this)->span);

#line 738 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 739 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.string_literal=tok->text;
      } break;
    case compiler_tokens_TokenType_CharLiteral:
    m_364_8:
      {

#line 742 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CharLiteral, compiler_parser_Parser_token(this)->span);

#line 743 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CharLiteral);

#line 744 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.char_literal=tok->text;
      } break;
    case compiler_tokens_TokenType_Identifier:
    m_364_9:
      {

#line 746 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_scoped_identifier(this, true);
      } break;
    case compiler_tokens_TokenType_True:
    case compiler_tokens_TokenType_False:
    m_364_10:
      {

#line 748 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 749 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BoolLiteral, tok->span);

#line 750 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.bool_literal=tok->type==compiler_tokens_TokenType_True;
      } break;
    case compiler_tokens_TokenType_OpenParen:
    m_364_11:
      {

#line 753 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 754 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseParen);

#line 755 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 756 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->span=std_span_Span_join(start->span, end->span);
      } break;
    case compiler_tokens_TokenType_Dot:
    m_364_12:
      {

#line 759 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dot);

#line 760 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if ((!(((bool)this->curr_func)) || !(this->curr_func->kind==compiler_ast_nodes_FunctionKind_Method)) || this->curr_func->is_static) {

#line 761 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(tok->span, "Cannot use dot shorthand outside of a method"));

#line 762 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, tok->span);
        }

#line 765 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *lhs = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, tok->span);

#line 766 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        lhs->u.ident.name="this";

#line 768 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, tok->span);

#line 769 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.member.lhs=lhs;

#line 770 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.member.dot_shorthand=true;

#line 772 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {

#line 773 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier after `.`"));

#line 774 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node->span.end=compiler_parser_Parser_token(this)->span.start;
        } else {

#line 776 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 777 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node->span=std_span_Span_join(tok->span, ident->span);

#line 778 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node->u.member.rhs_name=ident->text;

#line 779 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node->u.member.rhs_span=ident->span;
        }
      } break;
    case compiler_tokens_TokenType_EOF:
    m_364_13:
      {

#line 783 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Unexpected end of file"));

#line 784 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
      } break;
    case compiler_tokens_TokenType_Line:
    m_364_14:
      {

#line 787 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Location start_loc = compiler_parser_Parser_token(this)->span.start;

#line 788 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_Function *closure_func = compiler_parser_Parser_parse_closure(this);

#line 789 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CreateClosure, closure_func->span);

#line 790 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.closure=closure_func;

#line 792 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        char *closure_name = std_format("_Closure_%u", this->program->closures->size);

#line 793 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_vector_Vector__6_push(this->program->closures, closure_func);

#line 795 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_scopes_Symbol *parent_sym = (((bool)this->curr_func) ? this->curr_func->sym : this->ns->sym);

#line 799 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Closure, this->ns, parent_sym, closure_name, (std_span_Span){.start=start_loc, .end=start_loc});

#line 800 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        sym->u.func=closure_func;

#line 801 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        closure_func->sym=sym;

#line 802 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    default:
      {

#line 805 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Span prev_span = std_vector_Vector__11_at(this->tokens, (this->curr - 1))->span;

#line 806 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Span cur_span = compiler_parser_Parser_token(this)->span;

#line 808 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Span err_span = (std_span_Span){.start=prev_span.end, .end=cur_span.start};

#line 809 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_token_is(this, end_type))) {

#line 810 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->curr+=1;

#line 811 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          err_span=cur_span;

#line 812 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_unhandled_type(this, "parse_expression");
        } else if (std_span_Span_eq(this->prev_expr_error_span, err_span)) {

#line 818 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->curr+=1;
        } else {

#line 821 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->prev_expr_error_span=err_span;

#line 822 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_unhandled_type(this, "parse_expression");
        }

#line 825 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, err_span);
      } break;
  }

#line 828 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 831 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_postfix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 832 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_parser_Parser_parse_atom(this, end_type);

#line 834 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool running = true;

#line 835 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (running) {

#line 836 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 836 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 837 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_OpenParen:
      m_365_0:
        {

#line 838 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=compiler_parser_Parser_parse_call(this, node);
        } break;
      case compiler_tokens_TokenType_Dot:
      m_365_1:
        {

#line 840 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (compiler_parser_Parser_token_is(this, end_type)) {

#line 840 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            break;
          }

#line 841 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dot);

#line 842 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, node->span);

#line 843 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          member->u.member.lhs=node;

#line 844 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=member;

#line 846 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (compiler_parser_Parser_token_is(this, end_type) || !(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {

#line 847 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier after `.`"));

#line 848 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->span.end=compiler_parser_Parser_token(this)->span.start;
          } else {

#line 851 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 852 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->span=std_span_Span_join(node->span, ident->span);

#line 853 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.member.rhs_name=ident->text;

#line 854 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.member.rhs_span=ident->span;
          }
        } break;
      case compiler_tokens_TokenType_Question:
      m_365_2:
        {

#line 858 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Question);

#line 859 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_IsNotNull, std_span_Span_join(node->span, tok->span), node);
        } break;
      case compiler_tokens_TokenType_OpenSquare:
      m_365_3:
        {

#line 862 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *open = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);

#line 863 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *index = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_CloseSquare);

#line 864 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);

#line 868 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BinaryOp, std_span_Span_join(node->span, close->span));

#line 869 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          op->u.binary.op=compiler_ast_operators_Operator_Index;

#line 870 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          op->u.binary.lhs=node;

#line 871 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          op->u.binary.rhs=index;

#line 872 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          op->u.binary.op_span=open->span;

#line 873 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=op;
        } break;
      case compiler_tokens_TokenType_MinusMinus:
      case compiler_tokens_TokenType_PlusPlus:
      m_365_4:
        {

#line 876 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span span = std_span_Span_join(node->span, compiler_parser_Parser_token(this)->span);

#line 877 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_operators_Operator op = ({ compiler_ast_operators_Operator __yield_0;

#line 877 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusMinus)) {

#line 878 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_MinusMinus);

#line 879 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              __yield_0 = compiler_ast_operators_Operator_PostDecrement;
            } else {

#line 881 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_consume(this, compiler_tokens_TokenType_PlusPlus);

#line 882 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              __yield_0 = compiler_ast_operators_Operator_PostIncrement;
            }

          __yield_0; });

#line 884 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          node=compiler_ast_nodes_AST_new_unop(op, span, node);
        } break;
      default:
        {

#line 886 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          running=false;
        } break;
    }
  }

#line 890 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 893 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_prefix(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 894 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_Ampersand:
    m_366_0:
      {

#line 896 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *amp = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ampersand);

#line 897 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 898 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Address, std_span_Span_join(amp->span, expr->span), expr);

#line 899 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    case compiler_tokens_TokenType_MinusMinus:
    case compiler_tokens_TokenType_PlusPlus:
    m_366_1:
      {

#line 902 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Span start_span = compiler_parser_Parser_token(this)->span;

#line 903 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_operators_Operator op = ({ compiler_ast_operators_Operator __yield_0;

#line 903 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusMinus)) {

#line 904 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_consume(this, compiler_tokens_TokenType_MinusMinus);

#line 905 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            __yield_0 = compiler_ast_operators_Operator_PreDecrement;
          } else {

#line 907 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_consume(this, compiler_tokens_TokenType_PlusPlus);

#line 908 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            __yield_0 = compiler_ast_operators_Operator_PreIncrement;
          }

        __yield_0; });

#line 910 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 911 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return compiler_ast_nodes_AST_new_unop(op, std_span_Span_join(start_span, expr->span), expr);
      } break;
    case compiler_tokens_TokenType_SizeOf:
    m_366_2:
      {

#line 914 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_SizeOf);

#line 915 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 916 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_types_Type *type = compiler_parser_Parser_parse_type(this);

#line 917 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 918 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_SizeOf, std_span_Span_join(start->span, close->span));

#line 919 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.size_of_type=type;

#line 920 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    case compiler_tokens_TokenType_AtSign:
    m_366_3:
      {

#line 924 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *atsign = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);

#line 925 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {

#line 926 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected compiler operation after @"));

#line 927 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, atsign->span);
        }

#line 929 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 930 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        {
          char *__match_var_367 = ident->text;
          if (str_eq(__match_var_367, "new")) {

#line 932 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 933 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_CreateNew, std_span_Span_join(atsign->span, expr->span));

#line 934 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.child=expr;

#line 935 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return node;
          } else  {

#line 938 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(ident->span, "Unknown compiler operation"));

#line 939 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, atsign->span);
          }
        }
      } break;
    case compiler_tokens_TokenType_Star:
    m_366_4:
      {

#line 944 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *star = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Star);

#line 945 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 946 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Dereference, std_span_Span_join(star->span, expr->span), expr);

#line 947 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    case compiler_tokens_TokenType_Minus:
    m_366_5:
      {

#line 950 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *minus = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Minus);

#line 951 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 952 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Negate, std_span_Span_join(minus->span, expr->span), expr);

#line 953 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    case compiler_tokens_TokenType_Tilde:
    m_366_6:
      {

#line 956 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Tilde);

#line 957 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_prefix(this, end_type);

#line 958 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_BitwiseNot, std_span_Span_join(tok->span, expr->span), expr);

#line 959 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    default:
      {

#line 961 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return compiler_parser_Parser_parse_postfix(this, end_type);
      } break;
  }
}


#line 965 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_cast(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 966 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_prefix(this, end_type);

#line 967 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_As)) {

#line 968 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 968 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 969 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_As);

#line 970 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_types_Type *type_node = compiler_parser_Parser_parse_type(this);

#line 971 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Cast, std_span_Span_join(lhs->span, type_node->span));

#line 972 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    op->u.cast.lhs=lhs;

#line 973 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    op->u.cast.to=type_node;

#line 974 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    op->u.cast.parsed_to=type_node;

#line 975 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=op;
  }

#line 977 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 980 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_term(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 981 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_cast(this, end_type);

#line 982 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while ((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Star) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Slash)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Percent)) {

#line 985 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 985 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 986 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 987 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 988 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_cast(this, end_type);

#line 989 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 991 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 995 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_additive(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 996 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_term(this, end_type);

#line 997 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Plus) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Minus)) {

#line 998 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 998 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 999 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1000 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1001 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_term(this, end_type);

#line 1002 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1004 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1007 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_shift(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1008 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_additive(this, end_type);

#line 1009 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShift) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShift)) {

#line 1012 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = ({ compiler_ast_operators_Operator __yield_0;

#line 1012 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (compiler_parser_Parser_token(this)->type==compiler_tokens_TokenType_LessThan) {

#line 1013 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        __yield_0 = compiler_ast_operators_Operator_LeftShift;
      } else {

#line 1015 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        __yield_0 = compiler_ast_operators_Operator_RightShift;
      }

    __yield_0; });

#line 1017 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_span_Span op_span = compiler_parser_Parser_consume_compound_operator(this, op);

#line 1018 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_additive(this, end_type);

#line 1019 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_span);
  }

#line 1021 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1024 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1025 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_shift(this, end_type);

#line 1026 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ampersand)) {

#line 1027 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1027 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1028 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1029 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1030 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_shift(this, end_type);

#line 1031 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1033 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1036 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_xor(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1037 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_and(this, end_type);

#line 1038 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Caret)) {

#line 1039 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1039 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1040 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1041 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1042 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_bw_and(this, end_type);

#line 1043 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1045 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1048 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_bw_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1049 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_xor(this, end_type);

#line 1050 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Line)) {

#line 1051 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1051 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1052 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1053 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1054 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_bw_xor(this, end_type);

#line 1055 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1057 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1060 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_relational(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1061 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_bw_or(this, end_type);

#line 1063 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16 *operands = NULL;

#line 1064 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__11 *operators = NULL;

#line 1065 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while ((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThanEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThanEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_EqualEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_NotEquals)) || compiler_parser_Parser_token_is_identifier(this, "in")) {

#line 1073 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1073 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1075 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool done = ({ bool __yield_0;

#line 1075 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((compiler_parser_Parser_token(this)->type)) {
        case compiler_tokens_TokenType_LessThan:
        m_368_0:
          {
            __yield_0 = compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals);
          } break;
        case compiler_tokens_TokenType_GreaterThan:
        m_368_1:
          {
            __yield_0 = compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals);
          } break;
        default:
          {
            __yield_0 = false;
          } break;
      }

    __yield_0; });

#line 1080 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (done) {

#line 1080 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1082 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(((bool)operators))) {

#line 1083 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      operators=std_vector_Vector__11_new(2);

#line 1084 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      operands=std_vector_Vector__16_new(3);

#line 1085 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__16_push(operands, lhs);
    }

#line 1088 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *token = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1089 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__11_push(operators, token);

#line 1090 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *term = compiler_parser_Parser_parse_bw_or(this, end_type);

#line 1091 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__16_push(operands, term);
  }

#line 1094 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)operators))) {

#line 1094 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return lhs;
  }

#line 1096 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *root = ((compiler_ast_nodes_AST *)NULL);

#line 1097 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (u32 i = 0; i < operators->size; i+=1) {

#line 1098 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *tok = std_vector_Vector__11_at(operators, i);

#line 1099 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *lhs = std_vector_Vector__16_at(operands, i);

#line 1100 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = std_vector_Vector__16_at(operands, (i + 1));

#line 1101 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *op = compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator_from_token(tok), lhs, rhs, tok->span);

#line 1102 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (((bool)root)) {

#line 1103 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      root=compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator_And, root, op, tok->span);
    } else {

#line 1105 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      root=op;
    }
  }

#line 1109 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16_free(operands);

#line 1110 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__11_free(operators);

#line 1112 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return root;
}


#line 1115 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_not(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1116 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Not)) {

#line 1117 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Not);

#line 1118 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_logical_not(this, end_type);

#line 1119 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator_Not, std_span_Span_join(tok->span, expr->span), expr);
  }

#line 1121 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return compiler_parser_Parser_parse_relational(this, end_type);
}


#line 1124 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_and(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1125 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_not(this, end_type);

#line 1126 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_And)) {

#line 1127 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1127 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1128 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1129 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1130 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_logical_not(this, end_type);

#line 1131 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1133 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1136 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_logical_or(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1137 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_and(this, end_type);

#line 1138 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Or)) {

#line 1139 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1139 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1140 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *op_tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1141 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_token(op_tok);

#line 1142 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_logical_and(this, end_type);

#line 1143 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_tok->span);
  }

#line 1145 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1149 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_expression(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1150 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *lhs = compiler_parser_Parser_parse_logical_or(this, end_type);

#line 1151 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while ((((((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Equals) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_PlusEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_MinusEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_StarEquals)) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_SlashEquals)) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals)) || compiler_parser_Parser_is_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals)) {

#line 1158 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, end_type)) {

#line 1158 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1160 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_span_Span op_span = {0};

#line 1161 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_operators_Operator op = ({ compiler_ast_operators_Operator __yield_0;

#line 1161 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((compiler_parser_Parser_token(this)->type)) {
        case compiler_tokens_TokenType_LessThan:
        m_369_0:
          {

#line 1163 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            op_span=compiler_parser_Parser_consume_compound_operator(this, compiler_ast_operators_Operator_LeftShiftEquals);

#line 1164 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            __yield_0 = compiler_ast_operators_Operator_LeftShiftEquals;
          } break;
        case compiler_tokens_TokenType_GreaterThan:
        m_369_1:
          {

#line 1167 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            op_span=compiler_parser_Parser_consume_compound_operator(this, compiler_ast_operators_Operator_RightShiftEquals);

#line 1168 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            __yield_0 = compiler_ast_operators_Operator_RightShiftEquals;
          } break;
        default:
          {

#line 1171 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1172 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            op_span=tok->span;

#line 1173 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            __yield_0 = compiler_ast_operators_Operator_from_token(tok);
          } break;
      }

    __yield_0; });

#line 1181 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if ((op==compiler_ast_operators_Operator_Assignment && lhs->type==compiler_ast_nodes_ASTType_BinaryOp) && lhs->u.binary.op==compiler_ast_operators_Operator_Index) {

#line 1182 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      op=compiler_ast_operators_Operator_IndexAssign;
    }

#line 1185 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *rhs = compiler_parser_Parser_parse_expression(this, end_type);

#line 1186 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    lhs=compiler_ast_nodes_AST_new_binop(op, lhs, rhs, op_span);
  }

#line 1188 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return lhs;
}


#line 1191 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_multi_if(compiler_parser_Parser *this, compiler_tokens_Token *start_tok) {

#line 1192 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span start_span = start_tok->span;

#line 1194 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_If, start_span);

#line 1195 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 1196 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__23 *branches = std_vector_Vector__23_new(16);

#line 1197 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.if_stmt.branches=branches;

#line 1198 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.if_stmt.if_span=start_span;

#line 1200 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 1201 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {

#line 1202 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      node->u.if_stmt.els_span=compiler_parser_Parser_token(this)->span;

#line 1203 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);

#line 1204 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FatArrow);

#line 1205 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      node->u.if_stmt.els=compiler_parser_Parser_parse_statement(this);
    } else {

#line 1208 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_FatArrow);

#line 1209 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_FatArrow))) {

#line 1210 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected `=>` after condition"));
      }

#line 1212 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);

#line 1213 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__23_push(branches, (compiler_ast_nodes_IfBranch){.cond=cond, .body=body});
    }

#line 1215 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }

#line 1217 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly)->span;

#line 1218 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->span=std_span_Span_join(start_span, end_span);

#line 1219 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1222 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_if(compiler_parser_Parser *this) {

#line 1223 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start_tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_If);

#line 1224 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span start_span = start_tok->span;

#line 1226 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {

#line 1226 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_parser_Parser_parse_multi_if(this, start_tok);
  }

#line 1228 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__23 *cases = std_vector_Vector__23_new(16);

#line 1229 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end_span = start_span;

#line 1230 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (true) {

#line 1231 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1232 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Then);

#line 1233 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_statement(this);

#line 1234 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__23_push(cases, (compiler_ast_nodes_IfBranch){.cond=cond, .body=body});

#line 1235 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    end_span=body->span;

#line 1237 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else) && compiler_parser_Parser_peek_token_is(this, 1, compiler_tokens_TokenType_If)) {

#line 1238 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);

#line 1239 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_If);
    } else {

#line 1242 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }
  }

#line 1245 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_If, std_span_Span_join(start_span, end_span));

#line 1246 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.if_stmt.branches=cases;

#line 1247 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.if_stmt.if_span=start_span;

#line 1249 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Else)) {

#line 1250 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *els_tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Else);

#line 1251 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.if_stmt.els=compiler_parser_Parser_parse_statement(this);

#line 1252 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.if_stmt.els_span=els_tok->span;
  }

#line 1255 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->span=std_span_Span_join(start_span, end_span);

#line 1256 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1275 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for_each(compiler_parser_Parser *this, std_span_Span start_span) {

#line 1277 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 1278 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_token_is_identifier(this, "in"))) {

#line 1279 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected `in` after for-each loop variable"));

#line 1280 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, start_span);
  }

#line 1282 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 1284 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1285 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *iter_var_name = std_format("_i%u", this->program->uid++);

#line 1287 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *init = ({ compiler_ast_nodes_AST *__yield_0;

#line 1288 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, start_span);

#line 1289 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);

#line 1290 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(iter_var_name, var, start_span);

#line 1291 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->default_value=expr;

#line 1293 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.var_decl=var;

#line 1294 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    __yield_0 = node;
  
  __yield_0; });

#line 1297 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *cond = ({ compiler_ast_nodes_AST *__yield_0;

#line 1298 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);

#line 1299 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    iter_name->u.ident.name=iter_var_name;

#line 1301 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);

#line 1302 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.lhs=iter_name;

#line 1303 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_name="has_value";

#line 1304 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_span=expr->span;

#line 1306 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);

#line 1307 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.callee=member;

#line 1308 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.args=std_vector_Vector__7_new(16);

#line 1309 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.open_paren_span=name->span;

#line 1310 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.close_paren_span=name->span;

#line 1311 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    __yield_0 = node;
  
  __yield_0; });

#line 1314 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *step = ({ compiler_ast_nodes_AST *__yield_0;

#line 1315 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);

#line 1316 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    iter_name->u.ident.name=iter_var_name;

#line 1318 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);

#line 1319 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.lhs=iter_name;

#line 1320 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_name="next";

#line 1321 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_span=expr->span;

#line 1323 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);

#line 1324 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.callee=member;

#line 1325 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.args=std_vector_Vector__7_new(16);

#line 1326 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.open_paren_span=name->span;

#line 1327 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.call.close_paren_span=name->span;

#line 1328 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    __yield_0 = node;
  
  __yield_0; });

#line 1332 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *loop_var_decl = ({ compiler_ast_nodes_AST *__yield_0;

#line 1333 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);

#line 1334 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);

#line 1336 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *iter_name = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, start_span);

#line 1337 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    iter_name->u.ident.name=iter_var_name;

#line 1339 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *member = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Member, start_span);

#line 1340 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.lhs=iter_name;

#line 1341 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_name="cur";

#line 1342 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    member->u.member.rhs_span=expr->span;

#line 1344 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *call = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Call, start_span);

#line 1345 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    call->u.call.callee=member;

#line 1346 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    call->u.call.args=std_vector_Vector__7_new(16);

#line 1347 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    call->u.call.open_paren_span=name->span;

#line 1348 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    call->u.call.close_paren_span=name->span;

#line 1350 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_VarDeclaration, start_span);

#line 1351 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->default_value=call;

#line 1352 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    node->u.var_decl=var;

#line 1353 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    __yield_0 = node;
  
  __yield_0; });

#line 1356 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *inner_body = compiler_parser_Parser_parse_block(this);

#line 1358 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16 *statements = std_vector_Vector__16_new(16);

#line 1359 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16_push(statements, loop_var_decl);

#line 1360 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16_push(statements, inner_body);

#line 1362 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *body = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Block, inner_body->span);

#line 1363 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  body->u.block.statements=statements;

#line 1365 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_For, std_span_Span_join(start_span, body->span));

#line 1366 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.init=init;

#line 1367 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.cond=cond;

#line 1368 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.step=step;

#line 1369 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.body=body;

#line 1370 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1373 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_for(compiler_parser_Parser *this) {

#line 1374 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_For);

#line 1376 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && compiler_tokens_Token_is_identifier((*compiler_parser_Parser_peek(this, 1)), "in")) {

#line 1377 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_parser_Parser_parse_for_each(this, tok->span);
  }

#line 1380 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *init = NULL;

#line 1381 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Let)) {

#line 1382 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    init=compiler_parser_Parser_parse_statement(this);
  } else if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon))) {

#line 1384 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    init=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Semicolon);

#line 1385 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);
  }

#line 1387 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  void *cond = ({ void *__yield_0;

#line 1387 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon)) {
      __yield_0 = NULL;
    } else {

#line 1390 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_AST *res = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Semicolon);

#line 1391 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Semicolon);

#line 1392 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = res;
    }

  __yield_0; });

#line 1395 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  void *step = ({ void *__yield_0;

#line 1395 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {
      __yield_0 = NULL;
    } else {

#line 1398 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_AST *res = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);

#line 1399 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = res;
    }

  __yield_0; });

#line 1402 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_block(this);

#line 1403 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_For, std_span_Span_join(tok->span, body->span));

#line 1404 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.init=init;

#line 1405 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.cond=cond;

#line 1406 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.step=step;

#line 1407 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.loop.body=body;

#line 1408 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1411 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_statement(compiler_parser_Parser *this) {

#line 1412 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = ((compiler_ast_nodes_AST *)NULL);

#line 1413 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span start_span = compiler_parser_Parser_token(this)->span;

#line 1415 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  switch ((compiler_parser_Parser_token(this)->type)) {
    case compiler_tokens_TokenType_OpenCurly:
    m_370_0:
      {

#line 1416 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_block(this);
      } break;
    case compiler_tokens_TokenType_Return:
    m_370_1:
      {

#line 1418 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Return);

#line 1419 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = ((compiler_ast_nodes_AST *)NULL);

#line 1420 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_is_end_of_statement(this))) {

#line 1421 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          expr=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);
        }

#line 1423 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Return, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));

#line 1424 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.ret.expr=expr;

#line 1425 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.ret.return_span=tok->span;

#line 1426 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Yield:
    m_370_2:
      {

#line 1429 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Yield);

#line 1430 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1431 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Yield, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));

#line 1432 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.child=expr;

#line 1433 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Break:
    m_370_3:
      {

#line 1436 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Break);

#line 1437 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Break, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));

#line 1438 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Continue:
    m_370_4:
      {

#line 1441 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Continue);

#line 1442 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Continue, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));

#line 1443 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_While:
    m_370_5:
      {

#line 1446 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_While);

#line 1447 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *cond = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_OpenCurly);

#line 1448 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *body = compiler_parser_Parser_parse_block(this);

#line 1449 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_While, std_span_Span_join(tok->span, body->span));

#line 1450 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.loop.cond=cond;

#line 1451 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.loop.body=body;
      } break;
    case compiler_tokens_TokenType_Assert:
    m_370_6:
      {

#line 1454 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Assert);

#line 1455 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1457 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *msg = ((compiler_ast_nodes_AST *)NULL);

#line 1458 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_span_Span end_span = expr->span;

#line 1460 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma)) {

#line 1461 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          msg=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1462 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          end_span=msg->span;
        }

#line 1465 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Assert, std_span_Span_join(start->span, end_span));

#line 1466 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.assertion.expr=expr;

#line 1467 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.assertion.msg=msg;

#line 1468 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return node;
      } break;
    case compiler_tokens_TokenType_Defer:
    m_370_7:
      {

#line 1471 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Defer);

#line 1472 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_AST *expr = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1473 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Defer, std_span_Span_join(start_span, compiler_parser_Parser_token(this)->span));

#line 1474 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node->u.child=expr;

#line 1475 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_Import:
    m_370_8:
      {

#line 1478 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_import(this);

#line 1479 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_end_of_statement(this);
      } break;
    case compiler_tokens_TokenType_For:
    m_370_9:
      {

#line 1481 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_for(this);
      } break;
    case compiler_tokens_TokenType_Let:
    m_370_10:
      {

#line 1483 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_var_declaration(this);
      } break;
    case compiler_tokens_TokenType_TypeDef:
    m_370_11:
      {

#line 1486 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "TypeDefs are only allowed in the global scope"));

#line 1487 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        this->curr+=1;

#line 1488 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_tokens_until_newline(this);
      } break;
    case compiler_tokens_TokenType_Const:
    m_370_12:
      {

#line 1491 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Constants are only allowed in the global scope"));

#line 1492 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        this->curr+=1;

#line 1493 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_tokens_until_newline(this);
      } break;
    default:
      {

#line 1496 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        node=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1497 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Semicolon);
      } break;
  }

#line 1501 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1504 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_block(compiler_parser_Parser *this) {

#line 1505 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly))) {

#line 1506 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '{'"));

#line 1507 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
  }

#line 1509 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 1511 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16 *statements = std_vector_Vector__16_new(16);

#line 1512 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 1513 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *statement = compiler_parser_Parser_parse_statement(this);

#line 1514 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (((bool)statement)) {

#line 1514 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__16_push(statements, statement);
    }
  }

#line 1517 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {

#line 1518 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected '}' at end of block"));

#line 1519 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Error, compiler_parser_Parser_token(this)->span);
  }

#line 1521 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);

#line 1523 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Block, std_span_Span_join(start->span, end->span));

#line 1524 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.block.statements=statements;

#line 1525 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1528 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_template_params(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, std_span_Span *out_span) {

#line 1529 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_LessThan)->span;

#line 1530 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__9 *params = std_vector_Vector__9_new(16);

#line 1531 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_GreaterThan))) {

#line 1532 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *type = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 1533 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *name = type->text;

#line 1534 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, this->ns, name, name, name, type->span);

#line 1535 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->u.type_def=compiler_types_Type_new_unresolved(name, type->span);

#line 1536 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->u.type_def->sym=sym;

#line 1538 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__9_push(params, sym);

#line 1540 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_GreaterThan))) {

#line 1541 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }

#line 1544 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_GreaterThan)->span;

#line 1545 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (((bool)out_span)) {

#line 1546 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    (*out_span)=std_span_Span_join(start, end);
  }

#line 1549 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  sym->template=compiler_ast_scopes_Template_new(params);
}


#line 1552 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_add_doc_comment(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_tokens_Token *token) {

#line 1553 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (((bool)token->comment)) {

#line 1554 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->comment=token->comment;

#line 1555 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->comment_loc=token->comment_loc;
  }

#line 1558 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if ((this->attrs->size > 0) && ((bool)this->attrs_start_tok->comment)) {

#line 1559 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(((bool)sym->comment))) {

#line 1560 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      sym->comment=this->attrs_start_tok->comment;

#line 1561 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      sym->comment_loc=this->attrs_start_tok->comment_loc;
    }
  }
}


#line 1566 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_function_args(compiler_parser_Parser *this, compiler_ast_nodes_Function *func, compiler_tokens_TokenType end, bool need_types) {

#line 1567 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool seen_default = false;

#line 1568 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, end))) {

#line 1571 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Ellipsis)) {

#line 1572 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (seen_default) {

#line 1573 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Cannot have variadic parameters and default parameters"));
      }

#line 1575 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);

#line 1576 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      func->is_variadic=true;

#line 1577 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1580 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool found_amp = compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Ampersand);

#line 1581 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *var_name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 1582 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_types_Type *type = ((compiler_types_Type *)NULL);

#line 1583 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (std_vector_Vector__3_is_empty(func->params) && func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 1584 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (str_eq(var_name->text, "this")) {

#line 1585 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        type=func->parent_type;

#line 1586 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (found_amp) {

#line 1587 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          type=compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, func->parent_type->span);

#line 1588 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          type->u.ptr=func->parent_type;
        }

#line 1590 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        func->is_static=false;
      } else if (found_amp) {

#line 1592 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(var_name->span, "Expected 'this' over here"));
      }
    }

#line 1595 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(((bool)type))) {

#line 1596 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (need_types || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Colon)) {

#line 1597 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);

#line 1598 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        type=compiler_parser_Parser_parse_type(this);
      }
    }

#line 1602 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *default_value = ((compiler_ast_nodes_AST *)NULL);

#line 1603 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 1604 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);

#line 1605 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      seen_default=true;
    } else if (seen_default) {

#line 1608 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(var_name->span, "Cannot have non-default parameters after default parameters"));
    }

#line 1611 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);

#line 1612 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(var_name->text, var, var_name->span);

#line 1613 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->default_value=default_value;

#line 1614 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__3_push(func->params, var);

#line 1616 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_add_doc_comment(this, var->sym, var_name);

#line 1618 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, end))) {

#line 1619 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Comma);
    }
  }
}


#line 1624 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_function_body(compiler_parser_Parser *this, compiler_ast_nodes_Function *func) {

#line 1625 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token(this)->type != compiler_tokens_TokenType_FatArrow) {

#line 1626 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->is_arrow=false;

#line 1627 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return compiler_parser_Parser_parse_block(this);
  }

#line 1630 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->is_arrow=true;

#line 1631 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *arrow = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_FatArrow);

#line 1632 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {

#line 1633 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected an expression for an arrow function"));

#line 1634 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 1637 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *stmt = compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Newline);

#line 1638 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return stmt;
}


#line 1641 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_Function *compiler_parser_Parser_parse_closure(compiler_parser_Parser *this) {

#line 1642 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Line);

#line 1643 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();

#line 1644 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->name_ast=NULL;

#line 1645 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->kind=compiler_ast_nodes_FunctionKind_Closure;

#line 1647 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_function_args(this, func, compiler_tokens_TokenType_Line, false);

#line 1648 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Line)->span;

#line 1650 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 1651 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->return_type=compiler_parser_Parser_parse_type(this);

#line 1652 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    end_span=func->return_type->span;
  } else {

#line 1654 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->return_type=NULL;
  }

#line 1657 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->parsed_return_type=func->return_type;

#line 1658 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->body=compiler_parser_Parser_parse_function_body(this, func);

#line 1659 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->span=std_span_Span_join(start->span, func->body->span);

#line 1660 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return func;
}


#line 1663 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_Function *compiler_parser_Parser_parse_function(compiler_parser_Parser *this) {

#line 1664 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Def);

#line 1666 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_types_Type *parent_type = ((compiler_types_Type *)NULL);

#line 1667 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_FunctionKind kind = compiler_ast_nodes_FunctionKind_Normal;

#line 1669 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *ident = compiler_parser_Parser_parse_scoped_identifier(this, false);

#line 1670 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)ident))) {

#line 1670 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 1672 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span name_span = ident->span;

#line 1674 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Function *func = compiler_ast_nodes_Function_new();

#line 1675 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->name_ast=ident;

#line 1676 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->is_static=true;

#line 1677 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->kind=compiler_ast_nodes_FunctionKind_Normal;

#line 1678 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *name = ({ char *__yield_0;

#line 1678 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((ident->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_371_0:
        {
          __yield_0 = ident->u.ident.name;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_371_1:
        {

#line 1681 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          parent_type=compiler_types_Type_new_unresolved("<unresolved>", ident->span);

#line 1682 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          parent_type->u.unresolved=ident->u.lookup.lhs;

#line 1683 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          kind=compiler_ast_nodes_FunctionKind_Method;

#line 1684 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          name_span=ident->u.lookup.rhs_span;

#line 1685 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          func->parent_type=parent_type;

#line 1686 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          func->kind=compiler_ast_nodes_FunctionKind_Method;

#line 1687 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = ident->u.lookup.rhs_name;
        } break;
      default:
        {

#line 1690 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(ident->span, "Expected identifier"));

#line 1691 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = "<error>";
        } break;
    }

  __yield_0; });

#line 1695 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Function, this->ns, this->ns->sym, name, name_span);

#line 1696 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->sym->u.func=func;

#line 1697 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_add_doc_comment(this, func->sym, start);

#line 1699 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan)) {

#line 1700 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_template_params(this, func->sym, NULL);
  }

#line 1703 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 1704 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_function_args(this, func, compiler_tokens_TokenType_CloseParen, true);

#line 1705 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end_span = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen)->span;

#line 1707 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool returns = false;

#line 1708 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 1709 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->return_type=compiler_parser_Parser_parse_type(this);

#line 1710 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    end_span=func->return_type->span;

#line 1711 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    returns=true;
  } else if (str_eq(func->sym->full_name, "main")) {

#line 1714 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_I32, name_span);

#line 1715 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    returns=true;
  } else {

#line 1718 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->return_type=compiler_types_Type_new_unresolved_base(compiler_types_BaseType_Void, name_span);

#line 1721 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) && str_eq(compiler_parser_Parser_token(this)->text, "exits")) {

#line 1722 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      end_span=compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier)->span;

#line 1723 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      func->exits=true;
    }
  }

#line 1727 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->parsed_return_type=func->return_type;

#line 1730 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_extern_into_symbol(this, func->sym);

#line 1732 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i198 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i198); std_vector_Iterator__12_next(&_i198)) {

#line 1732 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i198);

#line 1732 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 1733 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((attr->type)) {
        case compiler_attributes_AttributeType_Exits:
        m_372_0:
          {

#line 1734 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            func->exits=true;
          } break;
        case compiler_attributes_AttributeType_Extern:
        m_372_1:
          {

#line 1735 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_get_extern_from_attr(this, func->sym, attr);
          } break;
        case compiler_attributes_AttributeType_VariadicFormat:
        m_372_2:
          {

#line 1737 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(func->is_variadic)) {

#line 1738 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Variadic format attribute can only be used on variadic functions"));
            }

#line 1742 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            func->is_variadic_format=true;
          } break;
        case compiler_attributes_AttributeType_Operator:
        m_372_3:
          {

#line 1745 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_ast_operators_Operator op = compiler_ast_operators_Operator_from_operator_overload(std_vector_Vector__8_at(attr->args, 0), func->params);

#line 1746 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (op==compiler_ast_operators_Operator_Error) {

#line 1747 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid operator"));

#line 1748 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              continue;
            }

#line 1750 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(((bool)func->operator_overloads))) {

#line 1751 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              func->operator_overloads=std_vector_Vector__21_new(16);
            }

#line 1753 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__21_push(func->operator_overloads, op);
          } break;
        case compiler_attributes_AttributeType_Alive:
        m_372_4:
          {

#line 1755 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__9_push(this->program->explicit_alive_symbols, func->sym);
          } break;
        default:
          {

#line 1756 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, std_format("Invalid attribute for function: %s", compiler_attributes_AttributeType_dbg(attr->type))));
          } break;
      }
    }
  }

#line 1759 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_clear_attributes(this);

#line 1761 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (func->sym->is_extern) {

#line 1762 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    func->span=std_span_Span_join(start->span, end_span);

#line 1763 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return func;
  }

#line 1766 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->curr_func=func;

#line 1768 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->body=compiler_parser_Parser_parse_function_body(this, func);

#line 1770 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->curr_func=NULL;

#line 1771 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  func->span=std_span_Span_join(start->span, func->body->span);

#line 1772 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return func;
}


#line 1775 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_extern_into_symbol(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym) {

#line 1776 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Extern))) {

#line 1776 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 1777 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  sym->is_extern=true;

#line 1778 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenParen)) {

#line 1779 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 1780 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 1781 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 1782 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->extern_name=name->text;
  } else {

#line 1784 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->extern_name=sym->name;
  }
}


#line 1788 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_get_extern_from_attr(compiler_parser_Parser *this, compiler_ast_scopes_Symbol *sym, compiler_attributes_Attribute *attr) {

#line 1789 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if(!(attr->type==compiler_attributes_AttributeType_Extern)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:1789:12: Assertion failed: `attr.type == Extern`", NULL); }

#line 1790 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  sym->is_extern=true;

#line 1791 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (attr->args->size > 0) {

#line 1792 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->extern_name=std_vector_Vector__8_at(attr->args, 0);
  } else {

#line 1794 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    sym->extern_name=sym->name;
  }
}


#line 1798 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
std_vector_Vector__5 *compiler_parser_Parser_parse_import_path(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 1799 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__5 *parts = std_vector_Vector__5_new(16);

#line 1801 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (true) {

#line 1802 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool done = false;

#line 1804 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, end_type)) && compiler_tokens_Token_is_word((*compiler_parser_Parser_token(this)))) {

#line 1805 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *word = compiler_parser_Parser_token(this);

#line 1806 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      this->curr+=1;

#line 1808 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Single, word->span);

#line 1809 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.single.name=word->text;

#line 1810 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.single.name_span=word->span;

#line 1812 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_As)) {

#line 1813 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *alias = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 1814 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        part->u.single.alias=alias->text;

#line 1815 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        part->u.single.alias_span=alias->span;

#line 1816 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        done=true;
      }

#line 1819 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__5_push(parts, part);
    } else if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Star)) {

#line 1822 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *tok = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Star);

#line 1824 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Wildcard, tok->span);

#line 1825 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__5_push(parts, part);

#line 1826 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      done=true;
    } else if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {

#line 1829 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *open = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 1831 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__22 *sub_paths = std_vector_Vector__22_new(16);

#line 1832 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 1833 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_vector_Vector__5 *sub_path = compiler_parser_Parser_parse_import_path(this, compiler_tokens_TokenType_CloseCurly);

#line 1834 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(((bool)sub_path))) {

#line 1834 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return NULL;
        }

#line 1836 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_vector_Vector__22_push(sub_paths, sub_path);

#line 1837 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {

#line 1837 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          break;
        }
      }

#line 1839 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);

#line 1841 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Multiple, std_span_Span_join(open->span, close->span));

#line 1842 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.multiple.paths=sub_paths;

#line 1843 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.multiple.open_curly_span=open->span;

#line 1844 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.multiple.close_curly_span=close->span;

#line 1845 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__5_push(parts, part);

#line 1846 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      done=true;
    } else {

#line 1849 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier"));

#line 1850 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_span_Span prev_tok = std_vector_Vector__11_at(this->tokens, (this->curr - 1))->span;

#line 1851 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_ImportPart *part = compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType_Single, (std_span_Span){.start=prev_tok.end, .end=prev_tok.end});

#line 1852 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.single.name=NULL;

#line 1853 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      part->u.single.name_span=part->span;

#line 1854 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__5_push(parts, part);

#line 1855 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      done=true;
    }

#line 1858 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (done) {

#line 1858 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 1859 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_ColonColon))) {

#line 1859 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }
  }

#line 1861 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return parts;
}


#line 1864 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_AST *compiler_parser_Parser_parse_import(compiler_parser_Parser *this) {

#line 1865 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span span = compiler_parser_Parser_token(this)->span;

#line 1866 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Import);

#line 1868 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  u32 parent_count = 0;

#line 1869 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_ImportType type = ({ compiler_ast_nodes_ImportType __yield_0;

#line 1869 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_AtSign:
      m_373_0:
        {

#line 1871 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);

#line 1872 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = compiler_ast_nodes_ImportType_ProjectNamespace;
        } break;
      case compiler_tokens_TokenType_ColonColon:
      m_373_1:
        {

#line 1875 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_ColonColon);

#line 1876 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = compiler_ast_nodes_ImportType_CurrentScope;
        } break;
      case compiler_tokens_TokenType_Dot:
      case compiler_tokens_TokenType_Ellipsis:
      m_373_2:
        {

#line 1879 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          bool done = false;

#line 1880 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          while (!(done)) {

#line 1881 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            switch ((compiler_parser_Parser_token(this)->type)) {
              case compiler_tokens_TokenType_Dot:
              m_374_0:
                {

#line 1883 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Dot);

#line 1884 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  parent_count+=1;
                } break;
              case compiler_tokens_TokenType_Ellipsis:
              m_374_1:
                {

#line 1887 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Ellipsis);

#line 1888 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  parent_count+=3;
                } break;
              default:
                {

#line 1890 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                  done=true;
                } break;
            }
          }

#line 1893 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = compiler_ast_nodes_ImportType_ParentNamespace;
        } break;
      default:
        {
          __yield_0 = compiler_ast_nodes_ImportType_GlobalNamespace;
        } break;
    }

  __yield_0; });

#line 1899 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (this->ns->is_dir_with_mod) {

#line 1900 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    parent_count-=1;
  }

#line 1903 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__5 *parts = compiler_parser_Parser_parse_import_path(this, compiler_tokens_TokenType_Newline);

#line 1904 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)parts))) {

#line 1904 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 1906 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (parts->size==0) {

#line 1907 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(span, "Invalid import statement"));

#line 1908 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 1911 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *node = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Import, span);

#line 1912 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  node->u.import_path=(compiler_ast_nodes_Import){.parts=parts, .type=type, .parent_count=parent_count, .export=false, .root_sym=NULL};

#line 1920 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i199 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i199); std_vector_Iterator__12_next(&_i199)) {

#line 1920 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i199);

#line 1920 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 1921 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((attr->type)) {
        case compiler_attributes_AttributeType_Export:
        m_375_0:
          {

#line 1922 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            node->u.import_path.export=true;
          } break;
        default:
          {

#line 1923 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for import"));
          } break;
      }
    }
  }

#line 1930 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__16_push(this->ns->unhandled_imports, node);

#line 1931 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return node;
}


#line 1934 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_parse_struct_field(compiler_parser_Parser *this, compiler_ast_nodes_Structure *struc) {

#line 1937 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__3 *fields = std_vector_Vector__3_new(1);

#line 1939 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_attributes_if_any(this);

#line 1940 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (true) {

#line 1941 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier))) {

#line 1942 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected identifier for field name"));

#line 1943 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      return false;
    }

#line 1946 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 1947 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(NULL);

#line 1948 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);

#line 1949 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_add_doc_comment(this, var->sym, name);

#line 1951 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__3_push(fields, var);

#line 1953 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma))) {

#line 1953 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }
  }

#line 1956 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (fields->size==1) {

#line 1957 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *field = std_vector_Vector__3_at(fields, 0);

#line 1958 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    for (std_vector_Iterator__12 _i200 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i200); std_vector_Iterator__12_next(&_i200)) {

#line 1958 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i200);

#line 1958 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      {

#line 1959 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        switch ((attr->type)) {
          case compiler_attributes_AttributeType_Extern:
          m_376_0:
            {

#line 1960 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_get_extern_from_attr(this, field->sym, attr);
            } break;
          case compiler_attributes_AttributeType_Atomic:
          m_376_1:
            {

#line 1961 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              field->is_atomic=true;
            } break;
          default:
            {

#line 1962 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for field"));
            } break;
        }
      }
    }
  } else if ((fields->size > 1) && (this->attrs->size > 0)) {

#line 1967 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new_note(std_vector_Vector__3_at(fields, 0)->sym->span, "Can't use attributes on multi-field declaration", "Split this into separate field declarations"));
  }

#line 1973 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon))) {

#line 1974 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected ':' after struct field names for type"));

#line 1975 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return false;
  }

#line 1978 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_types_Type *type = compiler_parser_Parser_parse_type(this);

#line 1980 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_AST *default_value = NULL;

#line 1981 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 1982 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
  }

#line 1985 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__3 _i201 = std_vector_Vector__3_iter(fields); std_vector_Iterator__3_has_value(&_i201); std_vector_Iterator__3_next(&_i201)) {

#line 1985 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_Variable *var = std_vector_Iterator__3_cur(&_i201);

#line 1985 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 1986 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->type=type;

#line 1987 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->parsed_type=type;

#line 1988 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->default_value=default_value;

#line 1989 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__3_push(struc->fields, var);
    }
  }

#line 1992 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__3_free(fields);

#line 1993 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return true;
}


#line 1996 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_Structure *compiler_parser_Parser_parse_struct(compiler_parser_Parser *this) {

#line 1997 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_token(this);

#line 1998 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool is_union = ({ bool __yield_0;

#line 1998 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Union)) {

#line 1999 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Union);

#line 2000 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = true;
    } else {

#line 2002 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Struct);

#line 2003 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      __yield_0 = false;
    }

  __yield_0; });

#line 2006 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2007 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Structure *struc = compiler_ast_nodes_Structure_new();

#line 2008 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  struc->is_union=is_union;

#line 2009 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  struc->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Structure, this->ns, this->ns->sym, name->text, name->span);

#line 2010 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  struc->sym->u.struc=struc;

#line 2011 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_add_doc_comment(this, struc->sym, start);

#line 2013 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_LessThan)) {

#line 2014 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_template_params(this, struc->sym, NULL);
  }

#line 2018 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_extern_into_symbol(this, struc->sym);

#line 2020 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i202 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i202); std_vector_Iterator__12_next(&_i202)) {

#line 2020 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i202);

#line 2020 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 2021 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_377_0:
          {

#line 2022 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_get_extern_from_attr(this, struc->sym, attr);
          } break;
        case compiler_attributes_AttributeType_Formatting:
        m_377_1:
          {

#line 2024 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            struc->format_spec=std_vector_Vector__8_at(attr->args, 0);

#line 2025 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            struc->format_args=std_vector_Vector__8_at(attr->args, 1);
          } break;
        default:
          {

#line 2027 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for struct"));
          } break;
      }
    }
  }

#line 2032 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(struc->sym->is_extern) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenCurly)) {

#line 2033 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 2034 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 2035 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_parse_struct_field(this, struc))) {

#line 2035 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        break;
      }

#line 2036 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_CloseCurly))) {

#line 2037 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_newline_or(this, compiler_tokens_TokenType_Comma);
      }
    }

#line 2040 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);

#line 2041 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    struc->span=std_span_Span_join(start->span, end->span);
  }

#line 2044 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return struc;
}


#line 2047 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_nodes_Enum *compiler_parser_Parser_parse_enum(compiler_parser_Parser *this) {

#line 2048 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Enum);

#line 2049 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2051 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Enum *enom = compiler_ast_nodes_Enum_new(start->span);

#line 2052 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Enum, this->ns, this->ns->sym, name->text, name->span);

#line 2053 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  sym->u.enom=enom;

#line 2054 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  enom->sym=sym;

#line 2055 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_add_doc_comment(this, sym, start);

#line 2056 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  enom->has_values=false;

#line 2058 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool is_extern = false;

#line 2059 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__12 _i203 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i203); std_vector_Iterator__12_next(&_i203)) {

#line 2059 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i203);

#line 2059 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 2060 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      switch ((attr->type)) {
        case compiler_attributes_AttributeType_Extern:
        m_378_0:
          {

#line 2062 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_get_extern_from_attr(this, enom->sym, attr);

#line 2063 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            is_extern=true;
          } break;
        default:
          {

#line 2065 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for value enum"));
          } break;
      }
    }
  }

#line 2069 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Extern)) {

#line 2070 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_extern_into_symbol(this, enom->sym);
  }

#line 2073 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 2074 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseCurly))) {

#line 2076 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_attributes_if_any(this);

#line 2078 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2081 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Colon)) {

#line 2082 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_types_Type *type = compiler_parser_Parser_parse_type(this);

#line 2083 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);

#line 2084 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      var->sym=compiler_ast_scopes_Symbol_from_local_variable(name->text, var, name->span);

#line 2085 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_add_doc_comment(this, var->sym, name);

#line 2086 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__3_push(enom->shared_fields, var);

#line 2088 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 2089 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
      }

#line 2092 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);

#line 2093 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      enom->has_values=true;

#line 2094 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      continue;
    }

#line 2098 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_EnumVariant *variant = compiler_ast_nodes_EnumVariant_new(name->span);

#line 2099 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_scopes_Symbol *vsym = compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_EnumVariant, this->ns, sym, name->text, name->span);

#line 2100 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    vsym->u.enum_var=variant;

#line 2101 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    variant->sym=vsym;

#line 2102 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    variant->parent=enom;

#line 2103 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_add_doc_comment(this, vsym, name);

#line 2105 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenParen)) {

#line 2106 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenParen);

#line 2107 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseParen))) {

#line 2108 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_tokens_Token *ident = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2109 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Colon);

#line 2110 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_types_Type *type = compiler_parser_Parser_parse_type(this);

#line 2111 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_nodes_Variable *var = compiler_ast_nodes_Variable_new(type);

#line 2112 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        var->sym=compiler_ast_scopes_Symbol_from_local_variable(ident->text, var, ident->span);

#line 2114 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 2115 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          var->default_value=compiler_parser_Parser_parse_expression(this, compiler_tokens_TokenType_Comma);
        }

#line 2118 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        enom->has_values=true;

#line 2119 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_vector_Vector__3_push(variant->specific_fields, var);

#line 2120 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
      }

#line 2122 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseParen);

#line 2123 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (is_extern && (compiler_ast_nodes_EnumVariant_num_fields(variant) > 0)) {

#line 2124 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(std_span_Span_join(start->span, end->span), "Extern value enum variants cannot have fields"));
      }
    }

#line 2129 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Equals)) {

#line 2130 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_parse_extern_into_symbol(this, variant->sym);

#line 2131 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (enom->has_values) {

#line 2132 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(variant->sym->span, "Non-trivial value enums can't be extern"));
      }
    }

#line 2135 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    for (std_vector_Iterator__12 _i204 = std_vector_Vector__12_iter(this->attrs); std_vector_Iterator__12_has_value(&_i204); std_vector_Iterator__12_next(&_i204)) {

#line 2135 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_attributes_Attribute *attr = std_vector_Iterator__12_cur(&_i204);

#line 2135 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      {

#line 2136 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        switch ((attr->type)) {
          case compiler_attributes_AttributeType_Extern:
          m_379_0:
            {

#line 2138 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_get_extern_from_attr(this, variant->sym, attr);

#line 2139 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              if (enom->has_values) {

#line 2140 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
                compiler_parser_Parser_error(this, compiler_errors_Error_new(variant->sym->span, "Non-trivial value enums can't be extern"));
              }
            } break;
          default:
            {

#line 2143 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(attr->span, "Invalid attribute for value enum variant"));
            } break;
        }
      }
    }

#line 2147 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__20_push(enom->variants, variant);

#line 2148 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_consume_if(this, compiler_tokens_TokenType_Comma);
  }

#line 2150 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly);

#line 2151 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return enom;
}


#line 2154 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_attribute(compiler_parser_Parser *this) {

#line 2155 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenSquare);

#line 2156 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (this->attrs->size==0) {

#line 2157 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->attrs_span=start->span;

#line 2158 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->attrs_start_tok=start;
  }

#line 2162 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!((compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Identifier) || compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_Extern)))) {

#line 2163 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Expected attribute name here"));

#line 2164 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2167 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_parser_Parser_token(this)->type);

#line 2168 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_attributes_AttributeType attr_type = compiler_attributes_AttributeType_from_str(name->text);

#line 2169 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (attr_type==compiler_attributes_AttributeType_Invalid) {

#line 2170 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(name->span, "Unknown attribute type"));

#line 2171 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2173 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_attributes_Attribute *attr = compiler_attributes_Attribute_new(attr_type, name->span);

#line 2175 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, compiler_tokens_TokenType_CloseSquare))) {

#line 2176 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_StringLiteral))) {

#line 2177 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Only string literals supported in attribute arguments"));

#line 2178 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      this->curr+=1;

#line 2179 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      continue;
    }

#line 2182 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_tokens_Token *arg = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 2183 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__8_push(attr->args, arg->text);
  }

#line 2185 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *close = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseSquare);

#line 2186 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->attrs_span=std_span_Span_join(this->attrs_span, close->span);

#line 2189 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(compiler_attributes_Attribute_validate(attr, this))) {

#line 2189 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2191 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__12_push(this->attrs, attr);
}


#line 2195 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_attributes_if_any(compiler_parser_Parser *this) {

#line 2196 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_clear_attributes(this);

#line 2197 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (compiler_parser_Parser_token_is(this, compiler_tokens_TokenType_OpenSquare)) {

#line 2198 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_attribute(this);
  }
}


#line 2202 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_namespace_until(compiler_parser_Parser *this, compiler_tokens_TokenType end_type) {

#line 2203 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_add_doc_comment(this, this->ns->sym, compiler_parser_Parser_token(this));

#line 2205 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  jmp_buf *ctx = compiler_ast_program_Program_add_error_context(this->program);

#line 2206 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (setjmp((*ctx)) > 0) {

#line 2209 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_sync_toplevel(this);
  }

#line 2212 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (!(compiler_parser_Parser_token_is_eof_or(this, end_type))) {

#line 2214 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_parse_attributes_if_any(this);

#line 2215 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((compiler_parser_Parser_token(this)->type)) {
      case compiler_tokens_TokenType_Def:
      m_380_0:
        {

#line 2217 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_Function *func = compiler_parser_Parser_parse_function(this);

#line 2218 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)func)) {

#line 2218 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__6_push(this->ns->functions, func);
          }
        } break;
      case compiler_tokens_TokenType_Import:
      m_380_1:
        {

#line 2221 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *import_ = compiler_parser_Parser_parse_import(this);

#line 2222 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)import_)) {

#line 2222 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__16_push(this->ns->imports, import_);
          }
        } break;
      case compiler_tokens_TokenType_Namespace:
      m_380_2:
        {

#line 2225 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (this->attrs->size > 0) {

#line 2226 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on namespaces"));
          }

#line 2229 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Namespace)->span;

#line 2230 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2232 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_program_Namespace *old_ns = this->ns;

#line 2233 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_program_Namespace *new_ns = compiler_ast_program_Namespace_new(this->ns, this->ns->path);

#line 2234 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          new_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, old_ns, old_ns->sym, name->text, name->span);

#line 2235 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          new_ns->sym->u.ns=new_ns;

#line 2237 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          new_ns->always_add_to_scope=true;

#line 2238 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_map_Map__3_insert(old_ns->namespaces, name->text, new_ns);

#line 2240 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->ns=new_ns;

#line 2241 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_OpenCurly);

#line 2242 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_parse_namespace_until(this, compiler_tokens_TokenType_CloseCurly);

#line 2243 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span end = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_CloseCurly)->span;

#line 2244 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          new_ns->span=std_span_Span_join(start, end);

#line 2246 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->ns=old_ns;
        } break;
      case compiler_tokens_TokenType_Struct:
      case compiler_tokens_TokenType_Union:
      m_380_3:
        {

#line 2249 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_Structure *struc = compiler_parser_Parser_parse_struct(this);

#line 2250 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)struc)) {

#line 2250 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__14_push(this->ns->structs, struc);
          }
        } break;
      case compiler_tokens_TokenType_TypeDef:
      m_380_4:
        {

#line 2253 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (this->attrs->size > 0) {

#line 2254 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on typedefs"));
          }

#line 2257 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_span_Span start = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_TypeDef)->span;

#line 2258 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2259 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Equals);

#line 2260 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_types_Type *type = compiler_parser_Parser_parse_type(this);

#line 2261 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_consume_end_of_statement(this);

#line 2263 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_TypeDef, this->ns, name->text, name->text, name->text, name->span);

#line 2264 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          sym->u.type_def=type;

#line 2265 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          type->sym=sym;

#line 2267 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)type)) {

#line 2268 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_map_Map__2_insert(this->ns->typedefs, name->text, type);
          }
        } break;
      case compiler_tokens_TokenType_Enum:
      m_380_5:
        {

#line 2272 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_Enum *enom = compiler_parser_Parser_parse_enum(this);

#line 2273 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)enom)) {

#line 2273 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__15_push(this->ns->enums, enom);
          }
        } break;
      case compiler_tokens_TokenType_Let:
      m_380_6:
        {

#line 2276 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *var = compiler_parser_Parser_parse_global_value(this, false);

#line 2277 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)var)) {

#line 2277 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__16_push(this->ns->variables, var);
          }
        } break;
      case compiler_tokens_TokenType_Const:
      m_380_7:
        {

#line 2280 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_AST *con = compiler_parser_Parser_parse_global_value(this, true);

#line 2281 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (((bool)con)) {

#line 2281 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__16_push(this->ns->constants, con);
          }
        } break;
      case compiler_tokens_TokenType_AtSign:
      m_380_8:
        {

#line 2283 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_parse_compiler_option(this);
        } break;
      default:
        {

#line 2285 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, std_format("Unexpected token in Parser: %s", compiler_tokens_TokenType_dbg(compiler_parser_Parser_token(this)->type))));

#line 2286 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          this->curr+=1;
        } break;
    }
  }

#line 2291 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Program_pop_error_context(this->program);

#line 2294 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (this->ns->unhandled_imports->size > 0) {

#line 2295 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_AST *imp = std_vector_Vector__16_pop(this->ns->unhandled_imports);

#line 2296 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_load_import_path(this, imp);
  }
}


#line 2300 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_compiler_option(compiler_parser_Parser *this) {

#line 2301 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (this->attrs->size > 0) {

#line 2302 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler_parser_Parser_token(this)->span, "Attributes are not allowed on compiler options"));
  }

#line 2305 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_consume(this, compiler_tokens_TokenType_AtSign);

#line 2306 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *compiler = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2307 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(str_eq(compiler->text, "compiler"))) {

#line 2308 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(compiler->span, "Expected 'compiler'"));
  }

#line 2311 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_tokens_Token *name = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_Identifier);

#line 2312 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  {
    char *__match_var_381 = name->text;
    if (str_eq(__match_var_381, "c_include")) {

#line 2314 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *filename = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 2315 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__8_push(this->program->c_includes, filename->text);
    } else if (str_eq(__match_var_381, "c_flag")) {

#line 2318 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *flag = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 2319 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_vector_Vector__8_push(this->program->c_flags, flag->text);
    } else if (str_eq(__match_var_381, "c_embed")) {

#line 2322 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_tokens_Token *path = compiler_parser_Parser_consume(this, compiler_tokens_TokenType_StringLiteral);

#line 2324 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      char *cur_dir = ({ char *__yield_0;

#line 2324 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        if (this->ns->is_dir_with_mod) {

#line 2325 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = this->ns->path;
        } else {

#line 2327 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = this->ns->parent->path;
        }

      __yield_0; });

#line 2330 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      char *full_path = std_format("%s/%s", cur_dir, path->text);

#line 2331 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(std_fs_file_exists(full_path))) {

#line 2332 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_parser_Parser_error(this, compiler_errors_Error_new(path->span, std_format("File '%s' does not exist", full_path)));

#line 2333 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return;
      }

#line 2336 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_buffer_Buffer contents = std_fs_read_file(full_path);

#line 2337 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_map_Map__6_insert(this->program->c_embeds, full_path, std_buffer_Buffer_str(contents));
    } else  {

#line 2339 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(name->span, "Unknown compiler option"));
    }
  }
}


#line 2343 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_try_load_mod_for_namespace(compiler_parser_Parser *this, compiler_ast_program_Namespace *ns) {

#line 2344 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *mod_path = std_format("%s/mod.oc", ns->path);

#line 2347 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (std_fs_file_exists(mod_path) && !(ns->is_dir_with_mod)) {

#line 2348 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    ns->is_dir_with_mod=true;

#line 2349 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, ns);

#line 2350 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_load_file(&parser, mod_path, NULL);
  } else {

#line 2352 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_mem_free(mod_path);
  }
}


#line 2356 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_program_Namespace *compiler_parser_Parser_load_single_import_part(compiler_parser_Parser *this, compiler_ast_program_Namespace *base, char *name, std_span_Span span) {

#line 2357 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_try_load_mod_for_namespace(this, base);

#line 2359 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)name))) {

#line 2359 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 2360 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_program_Namespace_find_importable_symbol(base, name);

#line 2364 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (str_eq(name, "this")) {

#line 2364 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return base;
  }

#line 2366 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (((bool)sym) && (sym->type != compiler_ast_scopes_SymbolType_Namespace)) {

#line 2366 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return base;
  }

#line 2367 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *next = (((bool)sym) ? sym->u.ns : NULL);

#line 2369 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *part_path = std_format("%s/%s", base->path, name);

#line 2370 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)next))) {

#line 2371 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool dir_exists = compiler_utils_directory_exists(part_path);

#line 2372 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *path = std_format("%s/%s.oc", base->path, name);

#line 2373 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool file_exists = std_fs_file_exists(path);

#line 2375 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (!(dir_exists) && !(file_exists)) {

#line 2376 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_error(this, compiler_errors_Error_new(span, std_format("Could not find import path %s(.oc)", part_path)));

#line 2377 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      return NULL;
    }

#line 2380 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    next=compiler_ast_program_Namespace_new(base, part_path);

#line 2381 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    next->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, base, base->sym, name, span);

#line 2388 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    next->sym->u.ns=next;

#line 2390 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_map_Map__3_insert(base->namespaces, name, next);

#line 2392 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (file_exists) {

#line 2393 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, next);

#line 2394 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_load_file(&parser, strdup(path), NULL);
    } else {

#line 2397 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_try_load_mod_for_namespace(this, next);
    }

#line 2399 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_mem_free(path);
  }

#line 2402 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return next;
}


#line 2405 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_load_import_path_from_base(compiler_parser_Parser *this, std_vector_Vector__5 *parts, compiler_ast_program_Namespace *base) {

#line 2406 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (u32 i = 0; (i < parts->size) && (!(base->is_a_file) || base->is_dir_with_mod); i+=1) {

#line 2407 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_nodes_ImportPart *part = std_vector_Vector__5_at(parts, i);

#line 2409 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_382_0:
        {

#line 2411 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_parser_Parser_error(this, compiler_errors_Error_new(part->span, std_format("Wildcard import is not allowed from non-module")));

#line 2412 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_382_1:
        {

#line 2415 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_vector_Vector__22 *paths = part->u.multiple.paths;

#line 2416 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          bool success = true;

#line 2417 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          for (std_vector_Iterator__22 _i205 = std_vector_Vector__22_iter(paths); std_vector_Iterator__22_has_value(&_i205); std_vector_Iterator__22_next(&_i205)) {

#line 2417 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_vector_Vector__5 *path = std_vector_Iterator__22_cur(&_i205);

#line 2417 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            {

#line 2418 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              success=(compiler_parser_Parser_load_import_path_from_base(this, path, base) && success);
            }
          }

#line 2420 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return success;
        } break;
      case compiler_ast_nodes_ImportPartType_Single:
      m_382_2:
        {

#line 2423 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          base=compiler_parser_Parser_load_single_import_part(this, base, part->u.single.name, part->span);

#line 2424 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (!(((bool)base))) {

#line 2424 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            return false;
          }
        } break;
    }
  }

#line 2428 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return true;
}


#line 2436 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_parser_LibraryInfo compiler_parser_Parser_find_external_library(compiler_parser_Parser *this, char *name) {

#line 2437 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (std_vector_Iterator__8 _i206 = std_vector_Vector__8_iter(this->program->library_paths); std_vector_Iterator__8_has_value(&_i206); std_vector_Iterator__8_next(&_i206)) {

#line 2437 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *lib_path = std_vector_Iterator__8_cur(&_i206);

#line 2437 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    {

#line 2438 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      char *dir_path = ((strlen(lib_path) > 0) ? std_format("%s/%s", lib_path, name) : strdup(name));

#line 2439 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (compiler_utils_directory_exists(dir_path)) {

#line 2440 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return (compiler_parser_LibraryInfo){.parent_dir=std_fs_realpath(lib_path), .path=std_fs_realpath(dir_path)};
      }

#line 2445 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_mem_free(dir_path);

#line 2447 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      char *file_path = ((strlen(lib_path) > 0) ? std_format("%s/%s.oc", lib_path, name) : std_format("%s.oc", name));

#line 2448 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (std_fs_file_exists(file_path)) {

#line 2449 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return (compiler_parser_LibraryInfo){.parent_dir=std_fs_realpath(lib_path), .path=std_fs_realpath(file_path)};
      }

#line 2454 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      std_mem_free(file_path);
    }
  }

#line 2456 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return (compiler_parser_LibraryInfo){.parent_dir=NULL, .path=NULL};
}


#line 2460 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
compiler_ast_program_Namespace *compiler_parser_Parser_import_external_lib(compiler_parser_Parser *this, char *name) {

#line 2461 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_LibraryInfo lib = compiler_parser_Parser_find_external_library(this, name);

#line 2462 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)lib.path))) {

#line 2462 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return NULL;
  }

#line 2464 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *ns = compiler_ast_program_Namespace_new(this->program->global, lib.path);

#line 2465 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, this->program->global, this->program->global->sym, name, std_span_Span_default());

#line 2472 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  ns->sym->u.ns=ns;

#line 2473 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  ns->always_add_to_scope=true;

#line 2474 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  ns->internal_project_root=ns;

#line 2476 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (std_fs_directory_exists(lib.path)) {

#line 2477 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_try_load_mod_for_namespace(this, ns);
  } else {

#line 2480 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser parser = compiler_parser_Parser_make(this->program, ns);

#line 2481 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_load_file(&parser, lib.path, NULL);

#line 2482 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_free(&parser);
  }

#line 2484 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return ns;
}


#line 2487 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
bool compiler_parser_Parser_load_import_path(compiler_parser_Parser *this, compiler_ast_nodes_AST *import_stmt) {

#line 2488 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_nodes_Import *path = &import_stmt->u.import_path;

#line 2490 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *base = ({ compiler_ast_program_Namespace *__yield_0;

#line 2490 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    switch ((path->type)) {
      case compiler_ast_nodes_ImportType_GlobalNamespace:
      m_383_0:
        {

#line 2492 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          std_vector_Vector__5 *parts = path->parts;

#line 2493 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if(!(parts->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:2493:20: Assertion failed: `parts.size > 0`", "Expected at least one part in import path"); }

#line 2494 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if(!(std_vector_Vector__5_at(parts, 0)->type==compiler_ast_nodes_ImportPartType_Single)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/parser.oc:2494:20: Assertion failed: `parts.at(0).type == Single`", "Expected first part to be a single import"); }

#line 2496 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_nodes_ImportPartSingle first_part = std_vector_Vector__5_at(parts, 0)->u.single;

#line 2497 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          char *lib_name = first_part.name;

#line 2499 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          if (!(std_map_Map__3_contains(this->program->global->namespaces, lib_name))) {

#line 2500 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            compiler_ast_program_Namespace *lib = compiler_parser_Parser_import_external_lib(this, lib_name);

#line 2501 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(((bool)lib))) {

#line 2502 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(import_stmt->span, std_format("Could not find library '%s'", lib_name)));

#line 2503 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              return false;
            }

#line 2506 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            std_map_Map__3_insert(this->program->global->namespaces, lib_name, lib);
          }

#line 2509 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = this->program->global;
        } break;
      case compiler_ast_nodes_ImportType_ProjectNamespace:
      m_383_1:
        {
          __yield_0 = compiler_ast_program_Namespace_get_project_root(this->ns, import_stmt->span, this->program);
        } break;
      case compiler_ast_nodes_ImportType_ParentNamespace:
      m_383_2:
        {

#line 2513 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          compiler_ast_program_Namespace *cur = this->ns;

#line 2514 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          for (u32 i = 0; i < path->parent_count; i+=1) {

#line 2515 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            if (!(((bool)cur->parent))) {

#line 2516 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_ast_nodes_ImportPart *first_part = std_vector_Vector__5_at(path->parts, 0);

#line 2517 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              compiler_parser_Parser_error(this, compiler_errors_Error_new(first_part->span, "Cannot import from parent of root namespace"));

#line 2518 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
              longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
            }

#line 2520 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
            cur=cur->parent;
          }

#line 2522 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          __yield_0 = cur;
        } break;
      case compiler_ast_nodes_ImportType_CurrentScope:
      m_383_3:
        {

#line 2527 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
          return true;
        } break;
    }

  __yield_0; });

#line 2531 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)base))) {

#line 2531 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return false;
  }

#line 2532 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_load_import_path_from_base(this, path->parts, base);

#line 2533 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  return true;
}


#line 2536 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_load_file(compiler_parser_Parser *this, char *filename, char *contents) {

#line 2537 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (std_map_Map__6_contains(this->program->sources, filename)) {

#line 2537 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2538 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Location loc = (std_span_Location){.filename=strdup(filename), .line=0, .col=0, .index=0};

#line 2539 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span span = (std_span_Span){.start=loc, .end=loc};

#line 2540 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->ns->span=span;

#line 2541 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->ns->sym->span=span;

#line 2543 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)contents))) {

#line 2544 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    contents=std_buffer_Buffer_str(std_fs_read_file(filename));
  }

#line 2546 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_map_Map__6_insert(this->program->sources, filename, contents);

#line 2548 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(contents, filename);

#line 2549 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->tokens=compiler_lexer_Lexer_lex(&lexer);

#line 2550 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->curr=0;

#line 2552 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->ns->is_a_file=true;

#line 2554 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span start = compiler_parser_Parser_token(this)->span;

#line 2555 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_parse_namespace_until(this, compiler_tokens_TokenType_EOF);

#line 2556 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_span_Span end = compiler_parser_Parser_token(this)->span;

#line 2557 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->ns->span=std_span_Span_join(start, end);
}


#line 2560 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_couldnt_find_stdlib(compiler_parser_Parser *this) {

#line 2561 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  printf("--------------------------------------------------------------------------------""\n");

#line 2562 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  printf("    Could not find standard library. Set OCEN_ROOT environment variable.""\n");

#line 2563 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  printf("      Alternatively, compile from the root of `ocen` repository.""\n");

#line 2564 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  printf("--------------------------------------------------------------------------------""\n");

#line 2565 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
}


#line 2568 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_find_and_import_stdlib(compiler_parser_Parser *this) {

#line 2569 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *std_ns = compiler_parser_Parser_import_external_lib(this, "std");

#line 2570 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_map_Map__3_insert(this->program->global->namespaces, "std", std_ns);
}


#line 2573 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_include_prelude_only(compiler_parser_Parser *this) {

#line 2575 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_LibraryInfo stdlib = compiler_parser_Parser_find_external_library(this, "std");

#line 2576 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)stdlib.path))) {

#line 2577 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }

#line 2579 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *prelude_path = std_format("%s/prelude.h", stdlib.path);

#line 2580 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(std_fs_file_exists(prelude_path))) {

#line 2581 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }

#line 2583 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_buffer_Buffer content = std_fs_read_file(prelude_path);

#line 2584 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_map_Map__6_insert(this->program->c_embeds, prelude_path, std_buffer_Buffer_str(content));
}


#line 2605 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_create_namespaces_for_initial_file(compiler_parser_Parser *this, char *filename, bool single_file) {

#line 2606 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(this->program->include_stdlib)) {

#line 2607 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_include_prelude_only(this);

#line 2608 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2614 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *std_lib_ns = compiler_parser_Parser_import_external_lib(this, "std");

#line 2615 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)std_lib_ns))) {

#line 2615 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_couldnt_find_stdlib(this);
  }

#line 2616 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *std_lib_ns_path = std_fs_realpath(std_lib_ns->path);

#line 2618 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *cur = std_fs_realpath(filename);

#line 2619 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (!(((bool)cur))) {

#line 2620 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_error(this, compiler_errors_Error_new(std_span_Span_default(), std_format("Could not find file: %s", filename)));

#line 2621 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    longjmp((*compiler_ast_program_Program_get_error_context(this->program)), 1);
  }

#line 2623 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_vector_Vector__8 *namespace_paths = std_vector_Vector__8_new(16);

#line 2624 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  bool found_root = false;

#line 2625 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  while (true) {

#line 2626 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *base = strdup(dirname(strdup(cur)));

#line 2628 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_vector_Vector__8_push(namespace_paths, base);

#line 2629 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (str_eq(base, "/")) {

#line 2629 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 2631 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (single_file) {

#line 2631 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 2632 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *potential_main_path = std_format("%s/main.oc", base);

#line 2633 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    bool main_exists = std_fs_file_exists(potential_main_path);

#line 2634 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    str_free(&potential_main_path);

#line 2637 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (str_eq(base, std_lib_ns_path) || main_exists) {

#line 2638 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      found_root=true;

#line 2639 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      break;
    }

#line 2641 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    cur=base;
  }

#line 2646 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  i32 start = (found_root ? ((i32)namespace_paths->size) : 0);

#line 2649 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *cur_ns = this->program->global;

#line 2650 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  for (i32 i = (start - 1); i >= 0; i-=1) {

#line 2651 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *path = namespace_paths->data[i];

#line 2652 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *t1 = strdup(path);

#line 2653 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *base = strdup(basename(t1));

#line 2654 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    str_free(&t1);

#line 2658 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (std_map_Map__3_contains(cur_ns->namespaces, base)) {

#line 2659 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      cur_ns=std_map_Map__3_at(cur_ns->namespaces, base);

#line 2660 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      continue;
    }

#line 2663 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_ast_program_Namespace *new_ns = compiler_ast_program_Namespace_new(cur_ns, path);

#line 2664 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_span_Location loc = (std_span_Location){.filename=path, .line=0, .col=0, .index=0};

#line 2665 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    new_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, cur_ns, cur_ns->sym, base, (std_span_Span){.start=loc, .end=loc});

#line 2666 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    new_ns->sym->u.ns=new_ns;

#line 2668 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (i==(start - 1)) {

#line 2669 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      new_ns->internal_project_root=new_ns;
    }

#line 2672 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    std_map_Map__3_insert(cur_ns->namespaces, base, new_ns);

#line 2673 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    cur_ns=new_ns;
  }

#line 2677 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  char *file_base = strdup(basename(filename));

#line 2678 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (str_ends_with(file_base, ".oc")) {

#line 2679 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    file_base[(strlen(file_base) - 3)]='\0';
  }

#line 2683 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (str_eq(file_base, "mod")) {

#line 2684 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    cur_ns->is_dir_with_mod=true;

#line 2685 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->ns=cur_ns;

#line 2686 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2692 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (std_map_Map__3_contains(cur_ns->namespaces, file_base)) {

#line 2693 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    this->ns=std_map_Map__3_at(cur_ns->namespaces, file_base);

#line 2694 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2698 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *child_ns = compiler_ast_program_Namespace_new(cur_ns, filename);

#line 2699 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  child_ns->sym=compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Namespace, cur_ns, file_base, "", "", std_span_Span_default());

#line 2706 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  child_ns->sym->u.ns=child_ns;

#line 2707 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  std_map_Map__3_insert(cur_ns->namespaces, file_base, child_ns);

#line 2711 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  child_ns->sym->full_name="";

#line 2712 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  this->ns=child_ns;
}


#line 2715 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
void compiler_parser_Parser_parse_toplevel(compiler_ast_program_Program *program, char *filename, char *file_contents, bool include_workspace_main) {

#line 2717 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  jmp_buf *ctx = compiler_ast_program_Program_add_error_context(program);

#line 2718 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (setjmp((*ctx)) > 0) {

#line 2719 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    printf("Error in parse_toplevel context""\n");

#line 2720 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    return;
  }

#line 2723 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser parser = compiler_parser_Parser_make(program, program->global);

#line 2724 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (program->include_stdlib) {

#line 2725 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_find_and_import_stdlib(&parser);
  } else {

#line 2727 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    compiler_parser_Parser_include_prelude_only(&parser);
  }

#line 2729 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_create_namespaces_for_initial_file(&parser, filename, false);

#line 2730 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_parser_Parser_load_file(&parser, filename, file_contents);

#line 2733 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  compiler_ast_program_Namespace *file_ns = parser.ns;

#line 2734 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
  if (include_workspace_main && ((bool)file_ns->internal_project_root)) {

#line 2735 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    char *potential_main = std_format("%s/main.oc", file_ns->internal_project_root->path);

#line 2736 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
    if (std_fs_file_exists(potential_main)) {

#line 2737 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_ast_program_Namespace *main_ns = std_map_Map__3_get(file_ns->internal_project_root->namespaces, "main", NULL);

#line 2738 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (main_ns==file_ns) {

#line 2738 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        return;
      }

#line 2740 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      if (!(((bool)main_ns))) {

#line 2742 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        compiler_ast_program_Namespace *root = file_ns->internal_project_root;

#line 2743 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        main_ns=compiler_ast_program_Namespace_new(root, "main");

#line 2744 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        main_ns->sym=compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType_Namespace, root, root->sym, "main", std_span_Span_default());

#line 2745 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        main_ns->sym->u.ns=main_ns;

#line 2746 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
        std_map_Map__3_insert(root->namespaces, "main", main_ns);
      }

#line 2749 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      parser.ns=main_ns;

#line 2750 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      compiler_parser_Parser_load_file(&parser, potential_main, NULL);
    } else {

#line 2752 "/Users/mustafa/ocen-lang/ocen/compiler/parser.oc"
      str_free(&potential_main);
    }
  }
}


#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
bool compiler_utils_directory_exists(char *path) {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
  DIR *dir = opendir(path);

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
  if (dir==NULL) {

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
    return false;
  }

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
  closedir(dir);

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/utils.oc"
  return true;
}


#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
compiler_lexer_Lexer compiler_lexer_Lexer_make(char *source, char *filename) {

#line 25 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = (std_span_Location){.filename=filename, .line=1, .col=1, .index=0};

#line 26 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  return (compiler_lexer_Lexer){.source=source, .source_len=strlen(source), .i=0, .loc=start_loc, .seen_newline=false, .tokens=std_vector_Vector__11_new(16), .errors=std_vector_Vector__13_new(16), .in_comment=false, .comment=std_buffer_Buffer_make(16), .comment_start=start_loc};
}


#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_push(compiler_lexer_Lexer *this, compiler_tokens_Token *token) {

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  token->seen_newline=this->seen_newline;

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (this->comment.size > 0) {

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    token->comment=std_buffer_Buffer_new_str(this->comment);

#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    token->comment_loc=this->comment_start;
  }

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_buffer_Buffer_clear(&this->comment);

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_vector_Vector__11_push(this->tokens, token);

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  this->seen_newline=false;

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  this->in_comment=false;
}


#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_push_type(compiler_lexer_Lexer *this, compiler_tokens_TokenType type, u32 len) {

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  for (u32 i = 0; i < len; i+=1) {

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_from_type(type, (std_span_Span){.start=start_loc, .end=this->loc}));
}


#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
char compiler_lexer_Lexer_cur(compiler_lexer_Lexer *this) {
  return this->source[this->i];}


#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_inc(compiler_lexer_Lexer *this) {

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  switch (compiler_lexer_Lexer_cur(this)) {
    case '\n': {

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      this->loc.line+=1;

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      this->loc.col=1;

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      this->seen_newline=true;
    } break;
    default: {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      this->loc.col+=1;
    } break;
  }

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  this->i+=1;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  this->loc.index+=1;
}


#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
char compiler_lexer_Lexer_peek(compiler_lexer_Lexer *this, u32 offset) {

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if ((this->i + offset) >= this->source_len) {

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    return '\0';
  }

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  return this->source[(this->i + offset)];
}


#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_lex_char_literal(compiler_lexer_Lexer *this) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 start = (this->i + 1);

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (compiler_lexer_Lexer_cur(this)=='\\') {

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (compiler_lexer_Lexer_cur(this) != '\'') {

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_vector_Vector__13_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Expected ' after character literal"));
  }

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 len = (this->i - start);

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char *text = str_substring(this->source, start, len);

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_CharLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
}


#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_lex_string_literal(compiler_lexer_Lexer *this, bool has_seen_f) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char end_char = compiler_lexer_Lexer_cur(this);

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 start = (this->i + 1);

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while ((this->i < this->source_len) && (compiler_lexer_Lexer_cur(this) != end_char)) {

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    if (compiler_lexer_Lexer_cur(this)=='\\') {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      compiler_lexer_Lexer_inc(this);
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 len = (this->i - start);

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char *text = str_substring(this->source, start, len);

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (this->i >= this->source_len) {

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_vector_Vector__13_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Unterminated string literal"));
  }

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if ((end_char=='`' || has_seen_f)) {

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_FormatStringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
  } else {

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_StringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text));
  }}


#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_lex_raw_string_literal(compiler_lexer_Lexer *this) {

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char end_char = compiler_lexer_Lexer_cur(this);

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 start = (this->i + 1);

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_buffer_Buffer buffer = std_buffer_Buffer_make(16);

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while ((this->i < this->source_len) && (compiler_lexer_Lexer_cur(this) != end_char)) {

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    if (compiler_lexer_Lexer_cur(this)=='\\') {

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      std_buffer_Buffer_write_char(&buffer, '\\');
    }

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_buffer_Buffer_write_char(&buffer, compiler_lexer_Lexer_cur(this));

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (this->i >= this->source_len) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_vector_Vector__13_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, "Unterminated string literal"));
  }

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_push(this, compiler_tokens_Token_new(compiler_tokens_TokenType_StringLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, std_buffer_Buffer_str(buffer)));
}


#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
compiler_tokens_Token *compiler_lexer_Lexer_lex_int_literal_different_base(compiler_lexer_Lexer *this) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 start = this->i;

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_inc(this);

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  switch (compiler_lexer_Lexer_cur(this)) {
    case 'x': {

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      compiler_lexer_Lexer_inc(this);

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      while ((this->i < this->source_len) && char_is_hex_digit(compiler_lexer_Lexer_cur(this))) {

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_inc(this);
      }
    } break;
    case 'b': {

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      compiler_lexer_Lexer_inc(this);

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      while (((this->i < this->source_len) && compiler_lexer_Lexer_cur(this)=='0') || compiler_lexer_Lexer_cur(this)=='1') {

#line 179 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_inc(this);
      }
    } break;
    default: {

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc:182:24: Assertion failed: `false`", "Invalid base for int literal"); exit(1); }
    } break;
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 len = (this->i - start);

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char *text = str_substring(this->source, start, len);

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  return compiler_tokens_Token_new(compiler_tokens_TokenType_IntLiteral, (std_span_Span){.start=start_loc, .end=this->loc}, text);
}


#line 189 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
compiler_tokens_Token *compiler_lexer_Lexer_lex_numeric_literal_helper(compiler_lexer_Lexer *this) {

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  std_span_Location start_loc = this->loc;

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (compiler_lexer_Lexer_cur(this)=='0') {

#line 192 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    switch (compiler_lexer_Lexer_peek(this, 1)) {
      case 'x':      case 'b': {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        return compiler_lexer_Lexer_lex_int_literal_different_base(this);
      } break;
      default: {
      } break;
    }
  }

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 start = this->i;

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_tokens_TokenType token_type;

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while (char_is_digit(compiler_lexer_Lexer_cur(this))) {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (compiler_lexer_Lexer_cur(this)=='.') {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    while (char_is_digit(compiler_lexer_Lexer_cur(this))) {

#line 209 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      compiler_lexer_Lexer_inc(this);
    }

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    token_type=compiler_tokens_TokenType_FloatLiteral;
  } else {

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    token_type=compiler_tokens_TokenType_IntLiteral;
  }

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  u32 len = (this->i - start);

#line 216 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  char *text = str_substring(this->source, start, len);

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  return compiler_tokens_Token_new(token_type, (std_span_Span){.start=start_loc, .end=this->loc}, text);
}


#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_lex_numeric_literal(compiler_lexer_Lexer *this) {

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_tokens_Token *token = compiler_lexer_Lexer_lex_numeric_literal_helper(this);

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if ((compiler_lexer_Lexer_cur(this)=='u' || compiler_lexer_Lexer_cur(this)=='i') || compiler_lexer_Lexer_cur(this)=='f') {

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    char initial_char = compiler_lexer_Lexer_cur(this);

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_span_Location start_loc = this->loc;

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    u32 start = this->i;

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    while ((this->i < this->source_len) && char_is_digit(compiler_lexer_Lexer_cur(this))) {

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      compiler_lexer_Lexer_inc(this);
    }

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    u32 len = (this->i - start);

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    char *suffix = ({ char *__yield_0;

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      if (len > 1) {
        __yield_0 = str_substring(this->source, start, len);
      } else if (initial_char=='i') {
        __yield_0 = "i32";
      } else if (initial_char=='u') {
        __yield_0 = "u32";
      } else {

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        std_vector_Vector__13_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=start_loc, .end=this->loc}, "Invalid numeric literal suffix"));

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        __yield_0 = str_substring(this->source, start, len);
      }

    __yield_0; });

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    token->suffix=compiler_tokens_Token_from_ident(suffix, (std_span_Span){.start=start_loc, .end=this->loc});
  }

#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_push(this, token);
}


#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
void compiler_lexer_Lexer_lex_comment(compiler_lexer_Lexer *this) {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while (compiler_lexer_Lexer_cur(this)=='/') {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  bool save_comment = false;

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if ((compiler_lexer_Lexer_cur(this)=='*' || compiler_lexer_Lexer_cur(this)=='.') || compiler_lexer_Lexer_cur(this)=='!') {

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    save_comment=true;

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    if (this->comment.size==0) {

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      this->comment_start=this->loc;
    }
  }

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (compiler_lexer_Lexer_cur(this)==' ' || compiler_lexer_Lexer_cur(this)=='\t') {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while ((this->i < this->source_len) && (compiler_lexer_Lexer_cur(this) != '\n')) {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    if (save_comment) {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
      std_buffer_Buffer_write_char(&this->comment, compiler_lexer_Lexer_cur(this));
    }

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    compiler_lexer_Lexer_inc(this);
  }

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  if (save_comment) {

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    std_buffer_Buffer_write_char(&this->comment, '\n');
  }
}


#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
std_vector_Vector__11 *compiler_lexer_Lexer_lex(compiler_lexer_Lexer *this) {

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  while (this->i < this->source_len) {

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    char c = compiler_lexer_Lexer_cur(this);

#line 277 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
    switch (c) {
      case ' ':      case '\t':      case '\v':      case '\r':      case '\b':      case '\n': {

#line 279 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_inc(this);
      } break;
      case ';': {

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Semicolon, 1);
      } break;
      case ',': {

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Comma, 1);
      } break;
      case '(': {

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenParen, 1);
      } break;
      case ')': {

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseParen, 1);
      } break;
      case '[': {

#line 285 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenSquare, 1);
      } break;
      case ']': {

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseSquare, 1);
      } break;
      case '{': {

#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_OpenCurly, 1);
      } break;
      case '}': {

#line 288 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_CloseCurly, 1);
      } break;
      case '@': {

#line 289 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_AtSign, 1);
      } break;
      case '%': {

#line 290 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Percent, 1);
      } break;
      case '^': {

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Caret, 1);
      } break;
      case '&': {

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Ampersand, 1);
      } break;
      case '|': {

#line 293 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Line, 1);
      } break;
      case '?': {

#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Question, 1);
      } break;
      case '~': {

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Tilde, 1);
      } break;
      case '.': {

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        if ((compiler_lexer_Lexer_peek(this, 1)=='.' && compiler_lexer_Lexer_peek(this, 2)=='.')) {

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Ellipsis, 3);
        } else {

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Dot, 1);
        }      } break;
      case '!': {

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_NotEquals, 2);
          } break;
          default: {

#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Exclamation, 1);
          } break;
        }
      } break;
      case ':': {

#line 304 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case ':': {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_ColonColon, 2);
          } break;
          default: {

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Colon, 1);
          } break;
        }
      } break;
      case '=': {

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_EqualEquals, 2);
          } break;
          case '>': {

#line 310 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_FatArrow, 2);
          } break;
          default: {

#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Equals, 1);
          } break;
        }
      } break;
      case '*': {

#line 313 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_StarEquals, 2);
          } break;
          default: {

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Star, 1);
          } break;
        }
      } break;
      case '+': {

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 318 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_PlusEquals, 2);
          } break;
          case '+': {

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_PlusPlus, 2);
          } break;
          default: {

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Plus, 1);
          } break;
        }
      } break;
      case '-': {

#line 322 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 323 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_MinusEquals, 2);
          } break;
          case '-': {

#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_MinusMinus, 2);
          } break;
          default: {

#line 325 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Minus, 1);
          } break;
        }
      } break;
      case '<': {

#line 327 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 328 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_LessThanEquals, 2);
          } break;
          default: {

#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_LessThan, 1);
          } break;
        }
      } break;
      case '>': {

#line 331 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '=': {

#line 332 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_GreaterThanEquals, 2);
          } break;
          default: {

#line 333 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_GreaterThan, 1);
          } break;
        }
      } break;
      case '/': {

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        switch (compiler_lexer_Lexer_peek(this, 1)) {
          case '/': {

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_lex_comment(this);
          } break;
          case '=': {

#line 337 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_SlashEquals, 2);
          } break;
          default: {

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_Slash, 1);
          } break;
        }
      } break;
      case '\'': {

#line 340 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_lex_char_literal(this);
      } break;
      case '"':      case '`': {

#line 341 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        compiler_lexer_Lexer_lex_string_literal(this, false);
      } break;
      default: {

#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        std_span_Location start_loc = this->loc;

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
        if (c=='f' && compiler_lexer_Lexer_peek(this, 1)=='"') {

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_inc(this);

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_lex_string_literal(this, true);
        } else if (c=='r' && compiler_lexer_Lexer_peek(this, 1)=='"') {

#line 351 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_inc(this);

#line 352 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_lex_raw_string_literal(this);
        } else if (char_is_digit(c)) {

#line 354 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_lex_numeric_literal(this);
        } else if (char_is_alpha(c) || c=='_') {

#line 356 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          u32 start = this->i;

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          while (char_is_alnum(compiler_lexer_Lexer_cur(this)) || compiler_lexer_Lexer_cur(this)=='_') {

#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
            compiler_lexer_Lexer_inc(this);
          }

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          u32 len = (this->i - start);

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          char *text = str_substring(this->source, start, len);

#line 363 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_push(this, compiler_tokens_Token_from_ident(text, (std_span_Span){.start=start_loc, .end=this->loc}));
        } else {

#line 366 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          std_vector_Vector__13_push(this->errors, compiler_errors_Error_new((std_span_Span){.start=this->loc, .end=this->loc}, std_format("Unrecognized char in lexer: '%c'", c)));

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
          compiler_lexer_Lexer_inc(this);
        }
      } break;
    }
  }

#line 375 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  this->seen_newline=true;

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  compiler_lexer_Lexer_push_type(this, compiler_tokens_TokenType_EOF, 0);

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/lexer.oc"
  return this->tokens;
}


#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_program_Namespace *compiler_ast_program_Namespace_new(compiler_ast_program_Namespace *parent, char *path) {

#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_program_Namespace *ns = std_mem_alloc__3(1);

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->parent=parent;

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_scopes_Scope *parent_scope = (((bool)parent) ? parent->scope : NULL);

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_program_Namespace *parent_root = (((bool)parent) ? parent->internal_project_root : NULL);

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->scope=NULL;

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->functions=std_vector_Vector__6_new(16);

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->structs=std_vector_Vector__14_new(16);

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->enums=std_vector_Vector__15_new(16);

#line 66 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->constants=std_vector_Vector__16_new(16);

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->variables=std_vector_Vector__16_new(16);

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->typedefs=std_map_Map__2_new(8);

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->namespaces=std_map_Map__3_new(8);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->imports=std_vector_Vector__16_new(16);

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->exported_symbols=std_map_Map__4_new(8);

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->unhandled_imports=std_vector_Vector__16_new(16);

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->path=path;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->is_a_file=false;

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  ns->internal_project_root=parent_root;

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return ns;
}


#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_scopes_Symbol *compiler_ast_program_Namespace_find_importable_symbol(compiler_ast_program_Namespace *this, char *name) {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_program_Namespace *item = std_map_Map__3_get(this->namespaces, name, NULL);

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)item)) {

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return item->sym;
  }

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__16 _i59 = std_vector_Vector__16_iter(this->constants); std_vector_Iterator__16_has_value(&_i59); std_vector_Iterator__16_next(&_i59)) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i59);

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (str_eq(var->sym->name, name)) {

#line 115 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        return var->sym;
      }
    }
  }

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__16 _i60 = std_vector_Vector__16_iter(this->variables); std_vector_Iterator__16_has_value(&_i60); std_vector_Iterator__16_next(&_i60)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_nodes_AST *node = std_vector_Iterator__16_cur(&_i60);

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      compiler_ast_nodes_Variable *var = node->u.var_decl;

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (str_eq(var->sym->name, name)) {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        return var->sym;
      }
    }
  }

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__6 _i61 = std_vector_Vector__6_iter(this->functions); std_vector_Iterator__6_has_value(&_i61); std_vector_Iterator__6_next(&_i61)) {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i61);

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        continue;
      }

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (str_eq(func->sym->name, name)) {

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        return func->sym;
      }
    }
  }

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__14 _i62 = std_vector_Vector__14_iter(this->structs); std_vector_Iterator__14_has_value(&_i62); std_vector_Iterator__14_next(&_i62)) {

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i62);

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (str_eq(struc->sym->name, name)) {

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        return struc->sym;
      }
    }
  }

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__15 _i63 = std_vector_Vector__15_iter(this->enums); std_vector_Iterator__15_has_value(&_i63); std_vector_Iterator__15_next(&_i63)) {

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i63);

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (str_eq(enom->sym->name, name)) {

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        return enom->sym;
      }
    }
  }

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (std_map_Map__4_contains(this->exported_symbols, name)) {

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return std_map_Map__4_at(this->exported_symbols, name);
  }

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_types_Type *td = std_map_Map__2_get(this->typedefs, name, NULL);

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)td)) {

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return td->sym;
  }

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return NULL;
}


#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_program_Namespace *compiler_ast_program_Namespace_get_project_root(compiler_ast_program_Namespace *this, std_span_Span span, compiler_ast_program_Program *program_for_errors) {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (!(((bool)this->internal_project_root))) {

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_program_Program_error(program_for_errors, compiler_errors_Error_new_note(span, "No project root found, can't use a Project Namespace import", "A project root is a top-level directory containing a `main.oc` file."));
  }

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return this->internal_project_root;
}


#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_program_Program *compiler_ast_program_Program_new(void) {

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_program_Program *prog = std_mem_alloc__4(1);

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->global=compiler_ast_program_Namespace_new(NULL, "");

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->ordered_symbols=std_vector_Vector__9_new(16);

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->global->sym=compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Namespace, prog->global, "", "", "", std_span_Span_default());

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->global->sym->u.ns=prog->global;

#line 209 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->error_level=1;

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->errors=std_vector_Vector__13_new(16);

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->c_includes=std_vector_Vector__8_new(16);

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->c_flags=std_vector_Vector__8_new(16);

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->c_embeds=std_map_Map__6_new(8);

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->sources=std_map_Map__6_new(8);

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->library_paths=std_vector_Vector__8_new(16);

#line 216 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->operator_overloads=std_map_Map__5_new(8);

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->err_jmp_stack=std_vector_Vector__17_new(16);

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->explicit_alive_symbols=std_vector_Vector__9_new(16);

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->closure_types=std_vector_Vector__0_new(16);

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->closures=std_vector_Vector__6_new(16);

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  prog->uid=0;

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return prog;
}


#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
jmp_buf *compiler_ast_program_Program_add_error_context(compiler_ast_program_Program *this) {

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_vector_Vector__17_resize(this->err_jmp_stack, (this->err_jmp_stack->size + 1));

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  this->err_jmp_stack->size+=1;

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return std_vector_Vector__17_back_ptr(this->err_jmp_stack, 0);
}


#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
jmp_buf *compiler_ast_program_Program_get_error_context(compiler_ast_program_Program *this) {

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return std_vector_Vector__17_back_ptr(this->err_jmp_stack, 0);
}


#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
void compiler_ast_program_Program_pop_error_context(compiler_ast_program_Program *this) {

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  this->err_jmp_stack->size-=1;
}


#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
void compiler_ast_program_Program_setup_library_paths(compiler_ast_program_Program *this) {

#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_vector_Vector__8_push(this->library_paths, "");

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  char *ocen_root = getenv("OCEN_ROOT");

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)ocen_root) && (strlen(ocen_root) > 0)) {

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    std_vector_Vector__8_push(this->library_paths, ocen_root);
  }

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  char *ocen_lib = getenv("OCEN_LIB");

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)ocen_lib)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    std_sv_SV oc_sv = std_sv_SV_from_str(ocen_lib);

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    for (std_sv_SVSplitIterator _i64 = std_sv_SV_split_str(oc_sv, ":"); std_sv_SVSplitIterator_has_value(&_i64); std_sv_SVSplitIterator_next(&_i64)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      std_sv_SV part = std_sv_SVSplitIterator_cur(&_i64);

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        std_vector_Vector__8_push(this->library_paths, std_sv_SV_copy_data_to_cstr(part));
      }
    }
  }
}


#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
void compiler_ast_program_Program_exit_with_errors_if_any(compiler_ast_program_Program *this) {

#line 256 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (!(std_vector_Vector__13_is_empty(this->errors))) {

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_errors_display_error_messages(this->errors, this->error_level);

#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    exit(1);
  }
}


#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
char *compiler_ast_program_Program_get_source_text(compiler_ast_program_Program *this, std_span_Span span) {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_span_Location start = span.start;

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_span_Location end = span.end;

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  char *contents = ((char *)std_map_Map__6_get(this->sources, start.filename, NULL));

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (!(((bool)contents))) {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return NULL;
  }

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  u32 len = (end.index - start.index);

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return str_substring(contents, start.index, len);
}


#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_errors_Error *compiler_ast_program_Program_error(compiler_ast_program_Program *this, compiler_errors_Error *err) {

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_vector_Vector__13_push(this->errors, err);

#line 275 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return err;
}


#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_types_Type *compiler_ast_program_Program_find_closure_type(compiler_ast_program_Program *this, std_vector_Vector__3 *params, compiler_types_Type *ret) {

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_vector_Iterator__0 _i65 = std_vector_Vector__0_iter(this->closure_types); std_vector_Iterator__0_has_value(&_i65); std_vector_Iterator__0_next(&_i65)) {

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_types_Type *c = std_vector_Iterator__0_cur(&_i65);

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 285 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      compiler_types_FunctionType clos = c->u.func;

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (clos.params->size != params->size) {

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        continue;
      }

#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (!(compiler_types_Type_eq(clos.return_type, ret, false))) {

#line 287 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        continue;
      }

#line 288 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      bool all_match = true;

#line 289 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      for (u32 i = 0; i < params->size; i+=1) {

#line 290 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        if (!(compiler_types_Type_eq(std_vector_Vector__3_at(clos.params, i)->type, std_vector_Vector__3_at(params, i)->type, false))) {

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
          all_match=false;

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
          break;
        }
      }

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      if (!(all_match)) {

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
        continue;
      }

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      return c;
    }
  }

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return NULL;
}


#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_nodes_Function *compiler_ast_program_Program_get_function_deep_copy(compiler_ast_program_Program *this, compiler_ast_nodes_Function *old, compiler_ast_program_Namespace *ns) {

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  char *func_text = compiler_ast_program_Program_get_source_text(this, old->span);

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (!(((bool)func_text))) {

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return NULL;
  }

#line 310 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(func_text, old->span.start.filename);

#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  lexer.loc=old->span.start;

#line 313 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_parser_Parser parser = compiler_parser_Parser_make(this, ns);

#line 316 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  parser.tokens=tokens;

#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  parser.curr=0;

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_nodes_Function *func = compiler_parser_Parser_parse_function(&parser);

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  func->operator_overloads=old->operator_overloads;

#line 321 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return func;
}


#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_nodes_Structure *compiler_ast_program_Program_get_struct_deep_copy(compiler_ast_program_Program *this, compiler_ast_nodes_Structure *old, compiler_ast_program_Namespace *ns) {

#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  char *text = compiler_ast_program_Program_get_source_text(this, old->span);

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (!(((bool)text))) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return NULL;
  }

#line 332 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_lexer_Lexer lexer = compiler_lexer_Lexer_make(text, old->span.start.filename);

#line 333 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  lexer.loc=old->span.start;

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  std_vector_Vector__11 *tokens = compiler_lexer_Lexer_lex(&lexer);

#line 336 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_parser_Parser parser = compiler_parser_Parser_make(this, ns);

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  parser.tokens=tokens;

#line 339 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  parser.curr=0;

#line 341 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_nodes_Structure *struc = compiler_parser_Parser_parse_struct(&parser);

#line 342 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return struc;
}


#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_types_Type *compiler_ast_program_Program_get_base_type(compiler_ast_program_Program *this, compiler_types_BaseType base, std_span_Span span) {

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_local(this->global->scope, compiler_types_BaseType_str(base));

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_TypeDef) {

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return sym->u.type_def;
  } else {

#line 350 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_program_Program_error(this, compiler_errors_Error_new(span, std_format("Internal compiler error, couldn't find base type %s", compiler_types_BaseType_dbg(base))));

#line 351 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return NULL;
  }
}


#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_types_Type *compiler_ast_program_Program_get_type_by_name(compiler_ast_program_Program *this, char *name, std_span_Span span) {

#line 356 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  compiler_ast_scopes_Symbol *sym = compiler_ast_scopes_Scope_lookup_local(this->global->scope, name);

#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_TypeDef) {

#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return sym->u.type_def;
  } else {

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_program_Program_error(this, compiler_errors_Error_new(span, std_format("Internal compiler error, couldn't find type %s", name)));

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    return NULL;
  }
}


#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_program_NSIterator compiler_ast_program_Program_iter_namespaces(compiler_ast_program_Program *this) {

#line 372 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  return (compiler_ast_program_NSIterator){.stack=std_vector_Vector__2_new(16), .curr=this->global};
}


#line 383 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
bool compiler_ast_program_NSIterator_has_value(compiler_ast_program_NSIterator *this) {
  return ((bool)this->curr);}


#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
void compiler_ast_program_NSIterator_next(compiler_ast_program_NSIterator *this) {

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  for (std_map_ValueIterator__3 _i66 = std_map_Map__3_iter_values(this->curr->namespaces); std_map_ValueIterator__3_has_value(&_i66); std_map_ValueIterator__3_next(&_i66)) {

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    compiler_ast_program_Namespace *ns = std_map_ValueIterator__3_cur(&_i66);

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    {

#line 387 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
      std_vector_Vector__2_push(this->stack, ns);
    }
  }

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
  if (std_vector_Vector__2_is_empty(this->stack)) {

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    this->curr=NULL;

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    std_vector_Vector__2_free(this->stack);
  } else {

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
    this->curr=std_vector_Vector__2_pop(this->stack);
  }
}


#line 398 "/Users/mustafa/ocen-lang/ocen/compiler/ast/program.oc"
compiler_ast_program_Namespace *compiler_ast_program_NSIterator_cur(compiler_ast_program_NSIterator *this) {
  return this->curr;}


#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_TemplateInstance *compiler_ast_scopes_TemplateInstance_new(std_vector_Vector__0 *args, compiler_ast_scopes_Symbol *parent, compiler_ast_scopes_Symbol *resolved) {

#line 37 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_TemplateInstance *instance = std_mem_alloc__5(1);

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  instance->args=args;

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  instance->parent=parent;

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  instance->resolved=resolved;

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return instance;
}


#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
bool compiler_ast_scopes_TemplateInstance_matches(compiler_ast_scopes_TemplateInstance *this, std_vector_Vector__0 *other) {

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if(!(other->size==this->args->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc:45:12: Assertion failed: `other.size == .args.size`", NULL); }

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  for (u32 i = 0; i < other->size; i++) {

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    compiler_types_Type *a = std_vector_Vector__0_at(this->args, i);

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    compiler_types_Type *b = std_vector_Vector__0_at(other, i);

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    if (!(compiler_types_Type_eq(a, b, true))) {

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
      return false;
    }
  }

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return true;
}


#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Template *compiler_ast_scopes_Template_new(std_vector_Vector__9 *params) {

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Template *templ = std_mem_alloc__6(1);

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  templ->params=params;

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  templ->instances=std_vector_Vector__4_new(16);

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return templ;
}


#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
char *compiler_ast_scopes_Symbol_out_name(compiler_ast_scopes_Symbol *this) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (this->is_extern) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return this->extern_name;
  }

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return this->full_name;
}


#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, char *name, char *display, char *full_name, std_span_Span span) {

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Symbol *item = std_mem_alloc__7(1);

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->name=name;

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->display=display;

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->references=std_vector_Vector__18_new(4);

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  u32 full_name_len = strlen(full_name);

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  for (u32 i = 0; i < full_name_len; i++) {

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    char c = full_name[i];

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    if ((i==0 && char_is_digit(c)) || (!(char_is_alnum(c)) && (c != '_'))) {

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
      full_name[i]='_';
    }
  }

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->full_name=full_name;

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->span=span;

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->type=type;

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->ns=ns;

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return item;
}


#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
char *compiler_ast_scopes_Symbol_join_display(char *a, char *b) {
  return (strlen(a)==0 ? b : std_format("%s::%s", a, b));}


#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
char *compiler_ast_scopes_Symbol_join_full_name(char *a, char *b) {
  return (strlen(a)==0 ? b : std_format("%s_%s", a, b));}


#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
bool compiler_ast_scopes_Symbol_is_templated(compiler_ast_scopes_Symbol *this) {
  return (((bool)this) && ((bool)this->template));}


#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_new_with_parent(compiler_ast_scopes_SymbolType type, compiler_ast_program_Namespace *ns, compiler_ast_scopes_Symbol *parent, char *name, std_span_Span span) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  char *display = compiler_ast_scopes_Symbol_join_display(parent->display, name);

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  char *full_name = compiler_ast_scopes_Symbol_join_full_name(parent->full_name, name);

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return compiler_ast_scopes_Symbol_new(type, ns, name, display, full_name, span);
}


#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
void compiler_ast_scopes_Symbol_update_parent(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_Symbol *parent) {

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  this->display=compiler_ast_scopes_Symbol_join_display(parent->display, this->name);

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (!(this->is_extern)) {

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    this->full_name=compiler_ast_scopes_Symbol_join_full_name(parent->full_name, this->name);
  }
}


#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_from_local_variable(char *name, compiler_ast_nodes_Variable *var, std_span_Span span) {

#line 179 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Symbol *item = compiler_ast_scopes_Symbol_new(compiler_ast_scopes_SymbolType_Variable, NULL, name, name, name, span);

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  item->u.var=var;

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return item;
}


#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Symbol_remove_alias(compiler_ast_scopes_Symbol *this) {
  return ({ compiler_ast_scopes_Symbol *__yield_0;

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    switch ((this->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_384_0:
        {

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
          if (this->u.type_def->sym != this) {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
            return compiler_ast_scopes_Symbol_remove_alias(this->u.type_def->sym);
          }

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
          return this;
        } break;
      default:
        {
          __yield_0 = this;
        } break;
    }

  __yield_0; });}


#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
void compiler_ast_scopes_Symbol_add_reference(compiler_ast_scopes_Symbol *this, compiler_ast_scopes_ReferenceType type, std_span_Span span) {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (!(((bool)this))) {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return;
  }

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  std_vector_Vector__18_push(this->references, (compiler_ast_scopes_Reference){.type=type, .span=span});

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (this->type==compiler_ast_scopes_SymbolType_TypeDef && (this->u.type_def->sym != this)) {

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    compiler_ast_scopes_Symbol_add_reference(this->u.type_def->sym, type, span);

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return;
  }

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_types_Type *parent_type = ({ compiler_types_Type *__yield_0;

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    switch ((this->type)) {
      case compiler_ast_scopes_SymbolType_Structure:
      m_385_0:
        {
          __yield_0 = this->u.struc->type;
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_385_1:
        {
          __yield_0 = this->u.func->type;
        } break;
      default:
        {
          __yield_0 = NULL;
        } break;
    }

  __yield_0; });

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (!(((bool)parent_type))) {

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return;
  }

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (!(((bool)parent_type->template_instance))) {

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return;
  }

#line 219 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Symbol *child_sym = parent_type->template_instance->parent;

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Symbol_add_reference(child_sym, type, span);
}


#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Scope *compiler_ast_scopes_Scope_new(compiler_ast_scopes_Scope *parent) {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Scope *scope = std_mem_alloc__8(1);

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  scope->items=std_map_Map__4_new(8);

#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  scope->defers=std_vector_Vector__16_new(16);

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (((bool)parent)) {

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    scope->loop_count=parent->loop_count;

#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    scope->can_yield=parent->can_yield;

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    scope->cur_func=parent->cur_func;

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    scope->parent=parent;
  }

#line 244 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return scope;
}


#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_recursive(compiler_ast_scopes_Scope *this, char *name) {

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  compiler_ast_scopes_Symbol *item = std_map_Map__4_get(this->items, name, NULL);

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (((bool)item)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return item;
  }

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  if (((bool)this->parent)) {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
    return compiler_ast_scopes_Scope_lookup_recursive(this->parent, name);
  }

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return NULL;
}


#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
compiler_ast_scopes_Symbol *compiler_ast_scopes_Scope_lookup_local(compiler_ast_scopes_Scope *this, char *name) {

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  return std_map_Map__4_get(this->items, name, NULL);
}


#line 258 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
void compiler_ast_scopes_Scope_insert(compiler_ast_scopes_Scope *this, char *name, compiler_ast_scopes_Symbol *symbol) {

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/ast/scopes.oc"
  std_map_Map__4_insert(this->items, name, symbol);
}


#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_operator_overload(char *s, std_vector_Vector__3 *params) {
  return ({ compiler_ast_operators_Operator __yield_0;

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    {
      char *__match_var_386 = s;
      if (str_eq(__match_var_386, "+")) {
        __yield_0 = compiler_ast_operators_Operator_Plus;
      } else if (str_eq(__match_var_386, "-")) {
        __yield_0 = ({ compiler_ast_operators_Operator __yield_1;

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
          switch (params->size) {
            case 1: {
              __yield_1 = compiler_ast_operators_Operator_Negate;
            } break;
            default: {
              __yield_1 = compiler_ast_operators_Operator_Minus;
            } break;
          }

        __yield_1; });
      } else if (str_eq(__match_var_386, "*")) {
        __yield_0 = compiler_ast_operators_Operator_Multiply;
      } else if (str_eq(__match_var_386, "/")) {
        __yield_0 = compiler_ast_operators_Operator_Divide;
      } else if (str_eq(__match_var_386, "==")) {
        __yield_0 = compiler_ast_operators_Operator_Equals;
      } else if (str_eq(__match_var_386, "!=")) {
        __yield_0 = compiler_ast_operators_Operator_NotEquals;
      } else if (str_eq(__match_var_386, "[]")) {
        __yield_0 = compiler_ast_operators_Operator_Index;
      } else if (str_eq(__match_var_386, "<<")) {
        __yield_0 = compiler_ast_operators_Operator_LeftShift;
      } else if (str_eq(__match_var_386, ">>")) {
        __yield_0 = compiler_ast_operators_Operator_RightShift;
      } else if (str_eq(__match_var_386, "&")) {
        __yield_0 = ({ compiler_ast_operators_Operator __yield_1;

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
          switch (params->size) {
            case 1: {
              __yield_1 = compiler_ast_operators_Operator_Address;
            } break;
            default: {
              __yield_1 = compiler_ast_operators_Operator_BitwiseAnd;
            } break;
          }

        __yield_1; });
      } else if (str_eq(__match_var_386, "|")) {
        __yield_0 = compiler_ast_operators_Operator_BitwiseOr;
      } else if (str_eq(__match_var_386, "+=")) {
        __yield_0 = compiler_ast_operators_Operator_PlusEquals;
      } else if (str_eq(__match_var_386, "-=")) {
        __yield_0 = compiler_ast_operators_Operator_MinusEquals;
      } else if (str_eq(__match_var_386, "*=")) {
        __yield_0 = compiler_ast_operators_Operator_MultiplyEquals;
      } else if (str_eq(__match_var_386, "/=")) {
        __yield_0 = compiler_ast_operators_Operator_DivideEquals;
      } else if (str_eq(__match_var_386, "[]=")) {
        __yield_0 = compiler_ast_operators_Operator_IndexAssign;
      } else if (str_eq(__match_var_386, "<<=")) {
        __yield_0 = compiler_ast_operators_Operator_LeftShiftEquals;
      } else if (str_eq(__match_var_386, ">>=")) {
        __yield_0 = compiler_ast_operators_Operator_RightShiftEquals;
      } else if (str_eq(__match_var_386, "%")) {
        __yield_0 = compiler_ast_operators_Operator_Modulus;
      } else if (str_eq(__match_var_386, "in")) {
        __yield_0 = compiler_ast_operators_Operator_In;
      } else if (str_eq(__match_var_386, "not")) {
        __yield_0 = compiler_ast_operators_Operator_Not;
      } else if (str_eq(__match_var_386, "?")) {
        __yield_0 = compiler_ast_operators_Operator_IsNotNull;
      } else  {
        __yield_0 = compiler_ast_operators_Operator_Error;
      }
    }

  __yield_0; });}


#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
compiler_ast_operators_Operator compiler_ast_operators_Operator_from_token(compiler_tokens_Token *tok) {
  return ({ compiler_ast_operators_Operator __yield_0;

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    switch ((tok->type)) {
      case compiler_tokens_TokenType_Ampersand:
      m_387_0:
        {
          __yield_0 = compiler_ast_operators_Operator_BitwiseAnd;
        } break;
      case compiler_tokens_TokenType_And:
      m_387_1:
        {
          __yield_0 = compiler_ast_operators_Operator_And;
        } break;
      case compiler_tokens_TokenType_Caret:
      m_387_2:
        {
          __yield_0 = compiler_ast_operators_Operator_BitwiseXor;
        } break;
      case compiler_tokens_TokenType_EqualEquals:
      m_387_3:
        {
          __yield_0 = compiler_ast_operators_Operator_Equals;
        } break;
      case compiler_tokens_TokenType_Equals:
      m_387_4:
        {
          __yield_0 = compiler_ast_operators_Operator_Assignment;
        } break;
      case compiler_tokens_TokenType_GreaterThan:
      m_387_5:
        {
          __yield_0 = compiler_ast_operators_Operator_GreaterThan;
        } break;
      case compiler_tokens_TokenType_GreaterThanEquals:
      m_387_6:
        {
          __yield_0 = compiler_ast_operators_Operator_GreaterThanEquals;
        } break;
      case compiler_tokens_TokenType_LessThan:
      m_387_7:
        {
          __yield_0 = compiler_ast_operators_Operator_LessThan;
        } break;
      case compiler_tokens_TokenType_LessThanEquals:
      m_387_8:
        {
          __yield_0 = compiler_ast_operators_Operator_LessThanEquals;
        } break;
      case compiler_tokens_TokenType_Line:
      m_387_9:
        {
          __yield_0 = compiler_ast_operators_Operator_BitwiseOr;
        } break;
      case compiler_tokens_TokenType_Minus:
      m_387_10:
        {
          __yield_0 = compiler_ast_operators_Operator_Minus;
        } break;
      case compiler_tokens_TokenType_MinusEquals:
      m_387_11:
        {
          __yield_0 = compiler_ast_operators_Operator_MinusEquals;
        } break;
      case compiler_tokens_TokenType_NotEquals:
      m_387_12:
        {
          __yield_0 = compiler_ast_operators_Operator_NotEquals;
        } break;
      case compiler_tokens_TokenType_Or:
      m_387_13:
        {
          __yield_0 = compiler_ast_operators_Operator_Or;
        } break;
      case compiler_tokens_TokenType_Percent:
      m_387_14:
        {
          __yield_0 = compiler_ast_operators_Operator_Modulus;
        } break;
      case compiler_tokens_TokenType_Plus:
      m_387_15:
        {
          __yield_0 = compiler_ast_operators_Operator_Plus;
        } break;
      case compiler_tokens_TokenType_PlusEquals:
      m_387_16:
        {
          __yield_0 = compiler_ast_operators_Operator_PlusEquals;
        } break;
      case compiler_tokens_TokenType_Slash:
      m_387_17:
        {
          __yield_0 = compiler_ast_operators_Operator_Divide;
        } break;
      case compiler_tokens_TokenType_SlashEquals:
      m_387_18:
        {
          __yield_0 = compiler_ast_operators_Operator_DivideEquals;
        } break;
      case compiler_tokens_TokenType_Star:
      m_387_19:
        {
          __yield_0 = compiler_ast_operators_Operator_Multiply;
        } break;
      case compiler_tokens_TokenType_StarEquals:
      m_387_20:
        {
          __yield_0 = compiler_ast_operators_Operator_MultiplyEquals;
        } break;
      case compiler_tokens_TokenType_Identifier:
      m_387_21:
        {
          __yield_0 = ({ compiler_ast_operators_Operator __yield_1;

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
            {
              char *__match_var_388 = tok->text;
              if (str_eq(__match_var_388, "in")) {
                __yield_1 = compiler_ast_operators_Operator_In;
              } else  std_panic(std_format("Unhandled identifier in Operator::from_token: %s", tok->text));
            }

          __yield_1; });
        } break;
      default:
        {
          std_panic(std_format("Unhandled token type in Operator::from_token: %s", compiler_tokens_TokenType_str(tok->type)));
        } break;
    }

  __yield_0; });}


#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
u32 compiler_ast_operators_Operator_num_overload_params(compiler_ast_operators_Operator this) {
  return ({ u32 __yield_0;

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    switch ((this)) {
      case compiler_ast_operators_Operator_Address:
      case compiler_ast_operators_Operator_Dereference:
      case compiler_ast_operators_Operator_Negate:
      case compiler_ast_operators_Operator_Not:
      case compiler_ast_operators_Operator_BitwiseNot:
      case compiler_ast_operators_Operator_IsNotNull:
      case compiler_ast_operators_Operator_PreIncrement:
      case compiler_ast_operators_Operator_PreDecrement:
      case compiler_ast_operators_Operator_PostIncrement:
      case compiler_ast_operators_Operator_PostDecrement:
      m_389_0:
        {
          __yield_0 = 1;
        } break;
      case compiler_ast_operators_Operator_And:
      case compiler_ast_operators_Operator_Assignment:
      case compiler_ast_operators_Operator_BitwiseAnd:
      case compiler_ast_operators_Operator_BitwiseOr:
      case compiler_ast_operators_Operator_LeftShiftEquals:
      case compiler_ast_operators_Operator_Divide:
      case compiler_ast_operators_Operator_RightShiftEquals:
      case compiler_ast_operators_Operator_BitwiseXor:
      case compiler_ast_operators_Operator_DivideEquals:
      case compiler_ast_operators_Operator_Equals:
      case compiler_ast_operators_Operator_GreaterThan:
      case compiler_ast_operators_Operator_GreaterThanEquals:
      case compiler_ast_operators_Operator_Index:
      case compiler_ast_operators_Operator_LeftShift:
      case compiler_ast_operators_Operator_LessThan:
      case compiler_ast_operators_Operator_LessThanEquals:
      case compiler_ast_operators_Operator_Minus:
      case compiler_ast_operators_Operator_MinusEquals:
      case compiler_ast_operators_Operator_Modulus:
      case compiler_ast_operators_Operator_Multiply:
      case compiler_ast_operators_Operator_MultiplyEquals:
      case compiler_ast_operators_Operator_Or:
      case compiler_ast_operators_Operator_Plus:
      case compiler_ast_operators_Operator_NotEquals:
      case compiler_ast_operators_Operator_PlusEquals:
      case compiler_ast_operators_Operator_RightShift:
      case compiler_ast_operators_Operator_In:
      m_389_1:
        {
          __yield_0 = 2;
        } break;
      case compiler_ast_operators_Operator_IndexAssign:
      m_389_2:
        {
          __yield_0 = 3;
        } break;
      case compiler_ast_operators_Operator_Error:
      m_389_3:
        {
          __yield_0 = 0;
        } break;
    }

  __yield_0; });}


#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
bool compiler_ast_operators_Operator_needs_lhs_pointer_for_overload(compiler_ast_operators_Operator this) {
  return ({ bool __yield_0;

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    switch ((this)) {
      case compiler_ast_operators_Operator_MultiplyEquals:
      m_390_0:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_DivideEquals:
      m_390_1:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_PlusEquals:
      m_390_2:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_MinusEquals:
      m_390_3:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_IndexAssign:
      m_390_4:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_LeftShiftEquals:
      m_390_5:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_operators_Operator_RightShiftEquals:
      m_390_6:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
u32 compiler_ast_operators_OperatorOverload_hash(compiler_ast_operators_OperatorOverload this) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  u32 hash = u32_hash(((u32)this.op));

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  if (((bool)this.type1)) {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    std_traits_hash_pair_hash(hash, ((u32)this.type1->base));
  }

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  if (((bool)this.type2)) {

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    std_traits_hash_pair_hash(hash, ((u32)this.type2->base));
  }

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  if (((bool)this.type3)) {

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
    std_traits_hash_pair_hash(hash, ((u32)this.type3->base));
  }

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  return hash;
}


#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
bool compiler_ast_operators_OperatorOverload_eq(compiler_ast_operators_OperatorOverload this, compiler_ast_operators_OperatorOverload other) {

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/ast/operators.oc"
  return ((this.op==other.op && compiler_types_Type_eq(this.type1, other.type1, true)) && compiler_types_Type_eq(this.type2, other.type2, true)) && compiler_types_Type_eq(this.type3, other.type3, true);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Variable *compiler_ast_nodes_Variable_new(compiler_types_Type *type) {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_Variable *var = std_mem_alloc__9(1);

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  var->type=type;

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  var->parsed_type=type;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return var;
}


#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Structure *compiler_ast_nodes_Structure_new(void) {

#line 89 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_Structure *struc = std_mem_alloc__10(1);

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  struc->fields=std_vector_Vector__3_new(16);

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return struc;
}


#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Variable *compiler_ast_nodes_Structure_get_field(compiler_ast_nodes_Structure *this, char *name) {

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  for (std_vector_Iterator__3 _i95 = std_vector_Vector__3_iter(this->fields); std_vector_Iterator__3_has_value(&_i95); std_vector_Iterator__3_next(&_i95)) {

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i95);

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    {

#line 96 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
      if (str_eq(field->sym->name, name)) {

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
        return field;
      }
    }
  }

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return NULL;
}


#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_Enum_get_variant(compiler_ast_nodes_Enum *this, char *name) {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  for (std_vector_Iterator__20 _i96 = std_vector_Vector__20_iter(this->variants); std_vector_Iterator__20_has_value(&_i96); std_vector_Iterator__20_next(&_i96)) {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i96);

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    {

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
      if (str_eq(variant->sym->name, name)) {

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
        return variant;
      }
    }
  }

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return NULL;
}


#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Variable *compiler_ast_nodes_Enum_get_shared_field(compiler_ast_nodes_Enum *this, char *name) {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  for (std_vector_Iterator__3 _i97 = std_vector_Vector__3_iter(this->shared_fields); std_vector_Iterator__3_has_value(&_i97); std_vector_Iterator__3_next(&_i97)) {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i97);

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    {

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
      if (str_eq(field->sym->name, name)) {

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
        return field;
      }
    }
  }

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return NULL;
}


#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Enum *compiler_ast_nodes_Enum_new(std_span_Span span) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_Enum *enom = std_mem_alloc__11(1);

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  enom->variants=std_vector_Vector__20_new(16);

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  enom->shared_fields=std_vector_Vector__3_new(16);

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  enom->span=span;

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return enom;
}


#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
u32 compiler_ast_nodes_EnumVariant_num_fields(compiler_ast_nodes_EnumVariant *this) {
  return (this->parent->shared_fields->size + this->specific_fields->size);}


#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_field_by_idx(compiler_ast_nodes_EnumVariant *this, u32 idx) {

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  if (idx < this->parent->shared_fields->size) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    return std_vector_Vector__3_at(this->parent->shared_fields, idx);
  } else {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    return std_vector_Vector__3_at(this->specific_fields, (idx - this->parent->shared_fields->size));
  }
}


#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Variable *compiler_ast_nodes_EnumVariant_get_specific_field(compiler_ast_nodes_EnumVariant *this, char *name) {

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  for (std_vector_Iterator__3 _i98 = std_vector_Vector__3_iter(this->specific_fields); std_vector_Iterator__3_has_value(&_i98); std_vector_Iterator__3_next(&_i98)) {

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i98);

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
      if (str_eq(field->sym->name, name)) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
        return field;
      }
    }
  }

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return NULL;
}


#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_EnumVariant *compiler_ast_nodes_EnumVariant_new(std_span_Span span) {

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_EnumVariant *variant = std_mem_alloc__12(1);

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  variant->specific_fields=std_vector_Vector__3_new(16);

#line 174 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return variant;
}


#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Function *compiler_ast_nodes_Function_new(void) {

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_Function *func = std_mem_alloc__13(1);

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  func->params=std_vector_Vector__3_new(16);

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return func;
}


#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
bool compiler_ast_nodes_Function_is_template_instance(compiler_ast_nodes_Function *this) {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  if (((bool)this->type) && ((bool)this->type->template_instance)) {

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    return true;
  }

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  if (((bool)this->parent_type) && ((bool)this->parent_type->template_instance)) {

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    return true;
  }

#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return false;
}


#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_Argument *compiler_ast_nodes_Argument_new(compiler_ast_nodes_AST *expr, compiler_tokens_Token *label_token) {

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_Argument *arg = std_mem_alloc__14(1);

#line 261 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  arg->expr=expr;

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  if (((bool)label_token)) {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    arg->label=label_token->text;
  }

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  if (((bool)label_token)) {

#line 263 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    arg->label_span=label_token->span;
  }

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return arg;
}


#line 317 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_ImportPart *compiler_ast_nodes_ImportPart_new(compiler_ast_nodes_ImportPartType type, std_span_Span span) {

#line 318 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_ImportPart *part = std_mem_alloc__15(1);

#line 319 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  part->type=type;

#line 320 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  part->span=span;

#line 321 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return part;
}


#line 433 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_MatchCond *compiler_ast_nodes_MatchCond_new(compiler_ast_nodes_AST *cond, std_vector_Vector__19 *args, compiler_ast_nodes_Function *cmp_fn) {

#line 434 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_MatchCond *mcond = std_mem_alloc__16(1);

#line 435 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  mcond->expr=cond;

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  mcond->args=args;

#line 437 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  mcond->cmp_fn=cmp_fn;

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return mcond;
}


#line 514 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType type, std_span_Span span) {

#line 515 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_AST *ast = std_mem_alloc__17(1);

#line 516 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->type=type;

#line 517 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->span=span;

#line 518 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return ast;
}


#line 521 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_unop(compiler_ast_operators_Operator op, std_span_Span span, compiler_ast_nodes_AST *expr) {

#line 522 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_AST *ast = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_UnaryOp, span);

#line 523 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.unary.op=op;

#line 524 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.unary.expr=expr;

#line 525 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return ast;
}


#line 528 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_nodes_AST *compiler_ast_nodes_AST_new_binop(compiler_ast_operators_Operator op, compiler_ast_nodes_AST *lhs, compiler_ast_nodes_AST *rhs, std_span_Span op_span) {

#line 529 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  std_span_Span span = std_span_Span_join(lhs->span, rhs->span);

#line 530 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  compiler_ast_nodes_AST *ast = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_BinaryOp, span);

#line 531 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.binary.op=op;

#line 532 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.binary.lhs=lhs;

#line 533 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.binary.rhs=rhs;

#line 534 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  ast->u.binary.op_span=op_span;

#line 535 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
  return ast;
}


#line 539 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
std_span_Span compiler_ast_nodes_AST_display_span(compiler_ast_nodes_AST *this) {
  return ({ std_span_Span __yield_0;

#line 539 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    switch ((this->type)) {
      case compiler_ast_nodes_ASTType_Match:
      m_391_0:
        {
          __yield_0 = this->u.match_stmt.match_span;
        } break;
      case compiler_ast_nodes_ASTType_If:
      m_391_1:
        {
          __yield_0 = this->u.if_stmt.if_span;
        } break;
      default:
        {
          __yield_0 = this->span;
        } break;
    }

  __yield_0; });}


#line 551 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
compiler_ast_scopes_Symbol *compiler_ast_nodes_AST_symbol(compiler_ast_nodes_AST *this) {
  return this->resolved_symbol;}


#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
bool compiler_ast_nodes_AST_is_lvalue(compiler_ast_nodes_AST *this) {
  return ({ bool __yield_0;

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
    switch ((this->type)) {
      case compiler_ast_nodes_ASTType_Identifier:
      m_392_0:
        {
          __yield_0 = !(this->u.ident.is_function);
        } break;
      case compiler_ast_nodes_ASTType_Member:
      m_392_1:
        {
          __yield_0 = true;
        } break;
      case compiler_ast_nodes_ASTType_UnaryOp:
      m_392_2:
        {
          __yield_0 = this->u.unary.op==compiler_ast_operators_Operator_Dereference;
        } break;
      case compiler_ast_nodes_ASTType_BinaryOp:
      m_392_3:
        {
          __yield_0 = this->u.binary.op==compiler_ast_operators_Operator_Index;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_392_4:
        {

#line 559 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
          compiler_ast_scopes_Symbol *sym = this->resolved_symbol;

#line 560 "/Users/mustafa/ocen-lang/ocen/compiler/ast/nodes.oc"
          return ((bool)sym) && sym->type==compiler_ast_scopes_SymbolType_Variable;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
compiler_attributes_AttributeType compiler_attributes_AttributeType_from_str(char *s) {
  return ({ compiler_attributes_AttributeType __yield_0;

#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
    {
      char *__match_var_393 = s;
      if (str_eq(__match_var_393, "extern")) {
        __yield_0 = compiler_attributes_AttributeType_Extern;
      } else if (str_eq(__match_var_393, "exits")) {
        __yield_0 = compiler_attributes_AttributeType_Exits;
      } else if (str_eq(__match_var_393, "variadic_format")) {
        __yield_0 = compiler_attributes_AttributeType_VariadicFormat;
      } else if (str_eq(__match_var_393, "export")) {
        __yield_0 = compiler_attributes_AttributeType_Export;
      } else if (str_eq(__match_var_393, "formatting")) {
        __yield_0 = compiler_attributes_AttributeType_Formatting;
      } else if (str_eq(__match_var_393, "operator")) {
        __yield_0 = compiler_attributes_AttributeType_Operator;
      } else if (str_eq(__match_var_393, "atomic")) {
        __yield_0 = compiler_attributes_AttributeType_Atomic;
      } else if (str_eq(__match_var_393, "alive")) {
        __yield_0 = compiler_attributes_AttributeType_Alive;
      } else  {
        __yield_0 = compiler_attributes_AttributeType_Invalid;
      }
    }

  __yield_0; });}


#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
compiler_attributes_Attribute *compiler_attributes_Attribute_new(compiler_attributes_AttributeType type, std_span_Span span) {

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  compiler_attributes_Attribute *attr = std_mem_alloc__18(1);

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  attr->type=type;

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  attr->args=std_vector_Vector__8_new(2);

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  attr->span=span;

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  return attr;
}


#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
bool compiler_attributes_Attribute_validate(compiler_attributes_Attribute *this, compiler_parser_Parser *parser_for_errors) {

#line 60 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  switch ((this->type)) {
    case compiler_attributes_AttributeType_Extern:
    m_394_0:
      {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        if (this->args->size > 1) {

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Extern attribute takes at most one argument"));

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          return false;
        }
      } break;
    case compiler_attributes_AttributeType_Formatting:
    m_394_1:
      {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        if ((this->args->size < 1) || (this->args->size > 2)) {

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new_note(this->span, "Incorrect number of arguments for formatting attribute", "Only one or two arguments are allowed"));

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          return false;
        }

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        if (this->args->size==2) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          bool found_dollar = false;

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          for (std_CharIterator _i208 = str_chars(std_vector_Vector__8_at(this->args, 1), 0); std_CharIterator_has_value(&_i208); std_CharIterator_next(&_i208)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
            char c = std_CharIterator_cur(&_i208);

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
            {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
              if (c=='$') {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
                found_dollar=true;
              }
            }
          }

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          if (!(found_dollar)) {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
            compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Second argument of formatting attribute must contain '$'"));

#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
            return false;
          }
        } else {

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          std_vector_Vector__8_push(this->args, "$");
        }
      } break;
    case compiler_attributes_AttributeType_Exits:
    case compiler_attributes_AttributeType_VariadicFormat:
    case compiler_attributes_AttributeType_Export:
    case compiler_attributes_AttributeType_Atomic:
    case compiler_attributes_AttributeType_Alive:
    m_394_2:
      {

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        if (this->args->size > 0) {

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, std_format("%s attribute takes no arguments", compiler_attributes_AttributeType_dbg(this->type))));

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          return false;
        }
      } break;
    case compiler_attributes_AttributeType_Invalid:
    m_394_3:
      {

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Invalid attribute"));

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        return false;
      } break;
    case compiler_attributes_AttributeType_Operator:
    m_394_4:
      {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
        if (this->args->size != 1) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          compiler_parser_Parser_error(parser_for_errors, compiler_errors_Error_new(this->span, "Operator attribute takes exactly one argument"));

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
          return false;
        }
      } break;
  }

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/attributes.oc"
  return true;
}


#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_typecheck_and_log_errors(compiler_ast_program_Program *program, char *path) {

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_passes_run_typecheck_passes(program);

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (program->errors->size==0) {

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    if (compiler_lsp_utils_verbose) {

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      printf("type-checked program successfully""\n");
    }

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    return;
  }

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  for (std_vector_Iterator__13 _i2 = std_vector_Vector__13_iter(program->errors); std_vector_Iterator__13_has_value(&_i2); std_vector_Iterator__13_next(&_i2)) {

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    compiler_errors_Error *err = std_vector_Iterator__13_cur(&_i2);

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    {

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      std_span_Location start = err->span1.start;

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      std_span_Location end = err->span1.end;

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      if (compiler_lsp_utils_verbose) {

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        printf("[-] ERROR: %s:%d:%d - %d:%d :: %s""\n", start.filename, start.line, start.col, end.line, end.col, err->msg1);
      }
    }
  }
}


#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_handle_validate(compiler_ast_program_Program *program, char *path) {

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_typecheck_and_log_errors(program, path);

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  for (std_vector_Iterator__13 _i3 = std_vector_Vector__13_iter(program->errors); std_vector_Iterator__13_has_value(&_i3); std_vector_Iterator__13_next(&_i3)) {

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    compiler_errors_Error *err = std_vector_Iterator__13_cur(&_i3);

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    {

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      if (!(((bool)err->span1.start.filename))) {

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        continue;
      }

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      if (!(str_eq(err->span1.start.filename, path))) {

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        continue;
      }

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      std_value_Value *err_value = compiler_lsp_utils_gen_error_json(err);

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      printf("%s\n", std_value_Value_dbg(err_value));
    }
  }
}


#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_handle_location_command(compiler_ast_program_Program *program, compiler_lsp_CommandType type, std_span_Location loc) {

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_typecheck_and_log_errors(program, loc.filename);

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (compiler_lsp_utils_verbose) {

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("[+] Looking for location: %s:%u:%u\n", (loc).filename, (loc).line, (loc).col);
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_finder_Finder finder = compiler_lsp_finder_Finder_make(type, loc);

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(compiler_lsp_finder_Finder_find(&finder, program))) {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    if (compiler_lsp_utils_verbose) {

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      printf("[-] No result found""\n");
    }

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    return;
  }

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  std_value_Value *resp = ({ std_value_Value *__yield_0;

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    switch ((type)) {
      case compiler_lsp_CommandType_Hover:
      m_395_0:
        {
          __yield_0 = compiler_lsp_utils_gen_hover_string_with_docs(finder.found_sym);
        } break;
      case compiler_lsp_CommandType_GoToDefinition:
      m_395_1:
        {

#line 78 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          compiler_ast_scopes_Symbol *usage = finder.found_sym;

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          std_span_Span jump_span = ({ std_span_Span __yield_1;

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
            switch ((usage->type)) {
              case compiler_ast_scopes_SymbolType_Namespace:
              m_396_0:
                {
                  __yield_1 = usage->u.ns->span;
                } break;
              default:
                {
                  __yield_1 = usage->span;
                } break;
            }

          __yield_1; });

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          __yield_0 = compiler_lsp_utils_gen_span_json_with_filename(jump_span, loc);
        } break;
      case compiler_lsp_CommandType_GoToType:
      m_395_2:
        {

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          compiler_types_Type *typ = compiler_lsp_utils_get_symbol_typedef(finder.found_sym);

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          if ((((bool)typ) && !(compiler_types_Type_can_have_methods(typ))) && typ->base==compiler_types_BaseType_Pointer) {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
            typ=typ->u.ptr;
          }

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          if (!(((bool)typ))) {

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
            return;
          }

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          __yield_0 = compiler_lsp_utils_gen_span_json_with_filename(typ->span, loc);
        } break;
      case compiler_lsp_CommandType_Completions:
      m_395_3:
        {
          __yield_0 = compiler_lsp_utils_gen_completions_json(&finder);
        } break;
      case compiler_lsp_CommandType_References:
      m_395_4:
        {
          __yield_0 = compiler_lsp_utils_gen_references_json(finder.found_sym, loc);
        } break;
      case compiler_lsp_CommandType_Renames:
      m_395_5:
        {
          __yield_0 = compiler_lsp_utils_gen_renames_json(finder.found_sym, loc);
        } break;
      case compiler_lsp_CommandType_SignatureHelp:
      m_395_6:
        {
          __yield_0 = compiler_lsp_utils_gen_signature_help(finder.call, finder.active_param);
        } break;
      default:
        {
          std_panic("Unhandled command type");
        } break;
    }

  __yield_0; });

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(((bool)resp))) {

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    return;
  }

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  std_buffer_Buffer resp_text = std_json_serialize(resp);

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("%.*s\n", (resp_text).size, (resp_text).data);
}


#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_handle_document_symbols(compiler_ast_program_Program *program, char *path) {

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_typecheck_and_log_errors(program, path);

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_ast_program_Namespace *doc_ns = NULL;

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  for (compiler_ast_program_NSIterator _i4 = compiler_ast_program_Program_iter_namespaces(program); compiler_ast_program_NSIterator_has_value(&_i4); compiler_ast_program_NSIterator_next(&_i4)) {

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    compiler_ast_program_Namespace *ns = compiler_ast_program_NSIterator_cur(&_i4);

#line 108 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    {

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      char *ns_filename = ns->span.start.filename;

#line 110 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      if (((bool)ns_filename) && str_eq(ns_filename, path)) {

#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        doc_ns=ns;

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        break;
      }
    }
  }

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(((bool)doc_ns))) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    if (compiler_lsp_utils_verbose) {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
      printf("No namespace found for path: %s\n", path);
    }

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("[]""\n");

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    return;
  }

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (compiler_lsp_utils_verbose) {

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("Got ns: %s\n", doc_ns->sym->name);
  }

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  std_value_Value *resp = compiler_lsp_utils_gen_namespace_json(doc_ns);

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(((bool)resp))) {

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    return;
  }

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  std_value_Value *children = std_value_Value_get(resp, "children", NULL);

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  std_buffer_Buffer resp_text = std_json_serialize(children);

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("%.*s\n", (resp_text).size, (resp_text).data);
}


#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
char *compiler_lsp_shift_args(i32 *argc, char ***argv) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if ((*argc)==0) {

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("Expected argument but got none\n");

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    exit(1);
  }

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  char *arg = (*argv)[0];

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  (*argv)=((*argv) + 1);

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  (*argc)=((*argc) - 1);

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  return arg;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_lsp_usage(i32 code, bool full) {

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("Symbol:""\n");

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("   ./ocen [--help] [compile-options] <file>""\n");

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("   ./ocen lsp [--help] [lsp-options] <file>""\n");

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(full)) {

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    exit(code);
  }

#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("--------------------------------------------------------""\n");

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("LSP Options:""\n");

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    --show-path path          Display this file path instead of actual one""\n");

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -h <line> <col>           Type hints for the given location""\n");

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -d <line> <col>           Find definition for the given location""\n");

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -t <line> <col>           Find type for the given location""\n");

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -c <line> <col>           Completions for the given location""\n");

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -r <line> <col>           References for the given location""\n");

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -s <line> <col>           Signature Help for the given location""\n");

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    --renames <line> <col>    Find all references for the given location""\n");

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    -v                        Verbose output""\n");

#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    --doc-symbols             List all symbols in the file""\n");

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  printf("    --validate                List all errors in the file""\n");

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  exit(code);
}


#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
void compiler_lsp_lsp_main(i32 argc, char **argv) {

#line 167 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_shift_args(&argc, &argv);

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  char *show_path = NULL;

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  char *file_path = NULL;

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  u32 line = 0;

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  u32 col = 0;

#line 173 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_lsp_CommandType cmd_type = compiler_lsp_CommandType_None;

#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  while (argc > 0) {

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    char *arg = compiler_lsp_shift_args(&argc, &argv);

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    {
      char *__match_var_397 = arg;
      if (str_eq(__match_var_397, "--help")) {

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        compiler_lsp_lsp_usage(0, true);
      } else if (str_eq(__match_var_397, "-h") || str_eq(__match_var_397, "-d") || str_eq(__match_var_397, "-t") || str_eq(__match_var_397, "-c") || str_eq(__match_var_397, "-r") || str_eq(__match_var_397, "-s") || str_eq(__match_var_397, "--refs") || str_eq(__match_var_397, "--renames")) {

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        cmd_type=({ compiler_lsp_CommandType __yield_0;

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          {
            char *__match_var_398 = arg;
            if (str_eq(__match_var_398, "-h")) {
              __yield_0 = compiler_lsp_CommandType_Hover;
            } else if (str_eq(__match_var_398, "-d")) {
              __yield_0 = compiler_lsp_CommandType_GoToDefinition;
            } else if (str_eq(__match_var_398, "-t")) {
              __yield_0 = compiler_lsp_CommandType_GoToType;
            } else if (str_eq(__match_var_398, "-c")) {
              __yield_0 = compiler_lsp_CommandType_Completions;
            } else if (str_eq(__match_var_398, "-s")) {
              __yield_0 = compiler_lsp_CommandType_SignatureHelp;
            } else if (str_eq(__match_var_398, "-r") || str_eq(__match_var_398, "--refs")) {
              __yield_0 = compiler_lsp_CommandType_References;
            } else if (str_eq(__match_var_398, "--renames")) {
              __yield_0 = compiler_lsp_CommandType_Renames;
            } else  std_panic("Invalid command type");
          }

        __yield_0; });

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        line=str_to_u32(compiler_lsp_shift_args(&argc, &argv));

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        col=str_to_u32(compiler_lsp_shift_args(&argc, &argv));
      } else if (str_eq(__match_var_397, "--validate")) {

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        cmd_type=compiler_lsp_CommandType_Validate;
      } else if (str_eq(__match_var_397, "--doc-symbols")) {

#line 194 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        cmd_type=compiler_lsp_CommandType_DocumentSymbols;
      } else if (str_eq(__match_var_397, "-v")) {

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        compiler_lsp_utils_verbose=true;
      } else if (str_eq(__match_var_397, "--show-path")) {

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        show_path=compiler_lsp_shift_args(&argc, &argv);
      } else  {

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        if (((bool)file_path)) {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          printf("Too many arguments, got: %s\n", arg);

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
          compiler_lsp_lsp_usage(1, false);
        }

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        file_path=arg;
      }
    }
  }

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(((bool)file_path))) {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("No file path provided""\n");

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    compiler_lsp_lsp_usage(1, false);
  }

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  file_path=std_fs_realpath(file_path);

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (cmd_type==compiler_lsp_CommandType_None) {

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    printf("No command type provided""\n");

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    compiler_lsp_lsp_usage(1, false);
  }

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  if (!(((bool)show_path))) {

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    show_path=file_path;
  } else {

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    show_path=std_fs_realpath(show_path);
  }

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_ast_program_Program *program = compiler_ast_program_Program_new();

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_ast_program_Program_setup_library_paths(program);

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  program->include_stdlib=true;

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  char *contents = std_buffer_Buffer_str(std_fs_read_file(file_path));

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  bool include_workspace_main = ({ bool __yield_0;

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
    switch ((cmd_type)) {
      case compiler_lsp_CommandType_References:
      case compiler_lsp_CommandType_Renames:
      m_399_0:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  compiler_parser_Parser_parse_toplevel(program, show_path, contents, include_workspace_main);

#line 237 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
  switch ((cmd_type)) {
    case compiler_lsp_CommandType_DocumentSymbols:
    m_400_0:
      {

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        compiler_lsp_handle_document_symbols(program, show_path);
      } break;
    case compiler_lsp_CommandType_Validate:
    m_400_1:
      {

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        compiler_lsp_handle_validate(program, show_path);
      } break;
    default:
      {

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        std_span_Location loc = (std_span_Location){.filename=show_path, .line=line, .col=col, .index=0};

#line 242 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/mod.oc"
        compiler_lsp_handle_location_command(program, cmd_type, loc);
      } break;
  }
}


#line 20 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
char *compiler_lsp_utils_gen_func_param_string(u32 i, compiler_ast_nodes_Variable *param, bool is_non_static_method) {

#line 21 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 22 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (i==0 && is_non_static_method) {

#line 23 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    if (param->type->base==compiler_types_BaseType_Pointer) {

#line 24 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, "&");
    }

#line 26 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_buffer_Buffer_write_str(&sb, "this");
  } else {

#line 28 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    if (!(str_eq(param->sym->name, ""))) {

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, param->sym->name);

#line 30 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, ": ");
    }

#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(param->type, false));
  }

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (((bool)param->default_value)) {

#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    char *expr_str = compiler_lsp_utils_try_gen_expr_string(param->default_value);

#line 37 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    if (((bool)expr_str)) {

#line 38 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, " = ");

#line 39 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, expr_str);
    }
  }

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return std_buffer_Buffer_str(sb);
}


#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
char *compiler_lsp_utils_gen_template_params(std_vector_Vector__0 *args) {

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 48 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer_write_str(&sb, "<");

#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (u32 i = 0; i < args->size; i+=1) {

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    if (i > 0) {

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_buffer_Buffer_write_str(&sb, ", ");
    }

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(std_vector_Vector__0_at(args, i), false));
  }

#line 55 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer_write_str(&sb, ">");

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return std_buffer_Buffer_str(sb);
}


#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
char *compiler_lsp_utils_gen_type_string(compiler_types_Type *type, bool full) {
  return ({ char *__yield_0;

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((type->base)) {
      case compiler_types_BaseType_Char:
      case compiler_types_BaseType_Bool:
      case compiler_types_BaseType_Void:
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_401_0:
        {
          __yield_0 = compiler_types_BaseType_str(type->base);
        } break;
      case compiler_types_BaseType_Pointer:
      m_401_1:
        {
          __yield_0 = ({ char *__yield_1;

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            switch ((type->u.ptr->base)) {
              case compiler_types_BaseType_Void:
              m_402_0:
                {
                  __yield_1 = "untyped_ptr";
                } break;
              case compiler_types_BaseType_Char:
              m_402_1:
                {
                  __yield_1 = "str";
                } break;
              default:
                {
                  __yield_1 = std_format("&%s", compiler_lsp_utils_gen_type_string(type->u.ptr, full));
                } break;
            }

          __yield_1; });
        } break;
      case compiler_types_BaseType_Array:
      m_401_2:
        {
          __yield_0 = std_format("&%s", compiler_lsp_utils_gen_type_string(type->u.arr.elem_type, full));
        } break;
      case compiler_types_BaseType_Structure:
      case compiler_types_BaseType_Alias:
      case compiler_types_BaseType_Enum:
      m_401_3:
        {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (!(((bool)type->template_instance))) {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            return ({ char *__yield_1;

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              if (full) {
                __yield_1 = type->sym->display;
              } else {
                __yield_1 = type->sym->name;
              }
            __yield_1; });
          }

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_scopes_TemplateInstance *instance = type->template_instance;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, (full ? instance->parent->display : instance->parent->name));

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str_f(&sb, compiler_lsp_utils_gen_template_params(instance->args));

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(sb);
        } break;
      case compiler_types_BaseType_Closure:
      case compiler_types_BaseType_FunctionPtr:
      m_401_4:
        {

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_types_FunctionType func_type = type->u.func;

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          bool is_non_static_method = false;

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (((bool)func_type.orig)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (func_type.orig->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              is_non_static_method=!(func_type.orig->is_static);
            }

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, "def ");

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_ast_nodes_Function *orig = func_type.orig;

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (((bool)orig->parent_type)) {

#line 92 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(orig->parent_type, false));

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, "::");

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, orig->sym->name);
            } else {

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, func_type.orig->sym->display);
            }

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (((bool)orig->sym->template)) {

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, "<");

#line 102 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_vector_Vector__9 *params = orig->sym->template->params;

#line 103 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              for (u32 i = 0; i < params->size; i+=1) {

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                if (i > 0) {

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                  std_buffer_Buffer_write_str(&sb, ", ");
                }

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                std_buffer_Buffer_write_str(&sb, std_vector_Vector__9_at(params, i)->name);
              }

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, ">");
            }
          } else {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (type->base==compiler_types_BaseType_Closure) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, "@");
            }

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, "fn");
          }

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, "(");

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          for (u32 i = 0; i < func_type.params->size; i+=1) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(func_type.params, i);

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (i > 0) {

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, ", ");
            }

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_func_param_string(i, param, is_non_static_method));
          }

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (func_type.is_variadic) {

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (func_type.params->size > 0) {

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&sb, ", ");
            }

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, "...");
          }

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, ")");

#line 131 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (func_type.return_type->base != compiler_types_BaseType_Void) {

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, ": ");

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(func_type.return_type, false));
          }

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(sb);
        } break;
      case compiler_types_BaseType_Unresolved:
      m_401_5:
        {

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_AST *unres = type->u.unresolved;

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = ({ char *__yield_1;

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            switch ((unres->type)) {
              case compiler_ast_nodes_ASTType_Identifier:
              m_403_0:
                {
                  __yield_1 = unres->u.ident.name;
                } break;
              default:
                {
                  __yield_1 = "<unresolved>";
                } break;
            }

          __yield_1; });
        } break;
      case compiler_types_BaseType_UnresolvedTemplate:
      m_401_6:
        {

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_types_UnresolvedTemplate unres = type->u.unresolved_spec;

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(unres.base, full));

#line 148 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str_f(&sb, compiler_lsp_utils_gen_template_params(unres.args));

#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(sb);
        } break;
      case compiler_types_BaseType_Error:
      case compiler_types_BaseType_NUM_BASE_TYPES:
      m_401_7:
        {
          __yield_0 = "ERROR";
        } break;
    }

  __yield_0; });}


#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
char *compiler_lsp_utils_try_gen_expr_string(compiler_ast_nodes_AST *expr) {
  return ({ char *__yield_0;

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((expr->type)) {
      case compiler_ast_nodes_ASTType_BoolLiteral:
      m_404_0:
                  __yield_0 = (expr->u.bool_literal ? "true" : "false");
         break;
      case compiler_ast_nodes_ASTType_IntLiteral:
      case compiler_ast_nodes_ASTType_FloatLiteral:
      m_404_1:
        {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_NumLiteral *literal = &expr->u.num_literal;

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = ({ char *__yield_1;

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (((bool)literal->suffix)) {
              __yield_1 = std_format("%s%s", literal->text, compiler_types_Type_str(literal->suffix));
            } else {
              __yield_1 = literal->text;
            }
          __yield_1; });
        } break;
      case compiler_ast_nodes_ASTType_StringLiteral:
      m_404_2:
        {
          __yield_0 = std_format("\"%s\"", expr->u.string_literal);
        } break;
      case compiler_ast_nodes_ASTType_CharLiteral:
      m_404_3:
        {
          __yield_0 = std_format("'%s'", expr->u.char_literal);
        } break;
      case compiler_ast_nodes_ASTType_Null:
      m_404_4:
        {
          __yield_0 = "null";
        } break;
      case compiler_ast_nodes_ASTType_Identifier:
      m_404_5:
        {
          __yield_0 = expr->u.ident.name;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_404_6:
        {

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          char *lhs_str = compiler_lsp_utils_try_gen_expr_string(expr->u.lookup.lhs);

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (!(((bool)lhs_str))) {

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            return NULL;
          }

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_format("%s::%s", lhs_str, expr->u.lookup.rhs_name);
        } break;
      default:
        {
          __yield_0 = NULL;
        } break;
    }

  __yield_0; });}


#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
char *compiler_lsp_utils_gen_hover_string(compiler_ast_scopes_Symbol *sym) {
  return ({ char *__yield_0;

#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_ClosureType:
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_405_0:
        {
          __yield_0 = compiler_lsp_utils_gen_type_string(sym->u.type_def, true);
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_405_1:
        {
          __yield_0 = compiler_lsp_utils_gen_type_string(sym->u.func->type, true);
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_405_2:
        {

#line 179 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, sym->display);

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, ": ");

#line 182 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(sym->u.var->type, true));

#line 183 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(sb);
        } break;
      case compiler_ast_scopes_SymbolType_Constant:
      m_405_3:
        {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, "const ");

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, sym->display);

#line 189 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, ": ");

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_type_string(sym->u.var->type, true));

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(sb);
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_405_4:
        {
          __yield_0 = std_format("struct %s", sym->display);
        } break;
      case compiler_ast_scopes_SymbolType_Namespace:
      m_405_5:
        {
          __yield_0 = std_format("namespace %s", sym->display);
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_405_6:
        {
          __yield_0 = std_format("enum %s", sym->display);
        } break;
      case compiler_ast_scopes_SymbolType_EnumVariant:
      m_405_7:
        {

#line 197 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_EnumVariant *variant = sym->u.enum_var;

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str_f(&buf, std_format("enum %s", variant->sym->display));

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          u32 num_fields = compiler_ast_nodes_EnumVariant_num_fields(variant);

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (num_fields > 0) {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&buf, "(");

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            for (u32 i = 0; i < num_fields; i+=1) {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              if (i > 0) {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                std_buffer_Buffer_write_str(&buf, ", ");
              }

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              compiler_ast_nodes_Variable *field = compiler_ast_nodes_EnumVariant_get_field_by_idx(variant, i);

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              if (((bool)field->sym) && (strlen(field->sym->name) > 0)) {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                std_buffer_Buffer_write_str(&buf, field->sym->name);

#line 208 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
                std_buffer_Buffer_write_str(&buf, ": ");
              }

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&buf, compiler_lsp_utils_gen_type_string(field->type, false));
            }

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&buf, ")");
          }

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(buf);
        } break;
      case compiler_ast_scopes_SymbolType_EnumField:
      m_405_8:
        {

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_scopes_EnumField field = sym->u.enum_field;

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_format("enum %s.%u", field.variant->sym->display, field.idx);
        } break;
      case compiler_ast_scopes_SymbolType_Closure:
      m_405_9:
        {
          __yield_0 = std_format("closure %s", sym->display);
        } break;
      case compiler_ast_scopes_SymbolType_ClosedVariable:
      m_405_10:
        {

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Variable *var = sym->u.closed_var.orig;

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&buf, var->sym->display);

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&buf, ": ");

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&buf, compiler_lsp_utils_gen_type_string(var->type, true));

#line 227 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = std_buffer_Buffer_str(buf);
        } break;
    }

  __yield_0; });}


#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
compiler_types_Type *compiler_lsp_utils_get_symbol_typedef(compiler_ast_scopes_Symbol *sym) {
  return ({ compiler_types_Type *__yield_0;

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((sym->type)) {
      case compiler_ast_scopes_SymbolType_TypeDef:
      m_406_0:
        {
          __yield_0 = sym->u.type_def;
        } break;
      case compiler_ast_scopes_SymbolType_Function:
      m_406_1:
        {
          __yield_0 = sym->u.func->type;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_406_2:
        {
          __yield_0 = sym->u.var->type;
        } break;
      case compiler_ast_scopes_SymbolType_Constant:
      m_406_3:
        {
          __yield_0 = sym->u.var->type;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_406_4:
        {
          __yield_0 = sym->u.struc->type;
        } break;
      case compiler_ast_scopes_SymbolType_Namespace:
      m_406_5:
        {
          __yield_0 = NULL;
        } break;
      case compiler_ast_scopes_SymbolType_Enum:
      m_406_6:
        {
          __yield_0 = sym->u.enom->type;
        } break;
      case compiler_ast_scopes_SymbolType_EnumVariant:
      m_406_7:
        {
          __yield_0 = sym->u.enum_var->parent->type;
        } break;
      case compiler_ast_scopes_SymbolType_EnumField:
      m_406_8:
        {
          __yield_0 = sym->u.enum_field.variant->parent->type;
        } break;
      case compiler_ast_scopes_SymbolType_ClosureType:
      m_406_9:
        {
          __yield_0 = sym->u.type_def;
        } break;
      case compiler_ast_scopes_SymbolType_Closure:
      m_406_10:
        {
          __yield_0 = sym->u.func->type;
        } break;
      case compiler_ast_scopes_SymbolType_ClosedVariable:
      m_406_11:
        {
          __yield_0 = sym->u.closed_var.orig->type;
        } break;
    }

  __yield_0; });}


#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_error_json(compiler_errors_Error *err) {

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "severity", "Error");

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "span", compiler_lsp_utils_gen_span_json(err->span1));

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "message", err->msg1);

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  switch ((err->type)) {
    case compiler_errors_ErrorType_WithHint:
    case compiler_errors_ErrorType_WithNote:
    m_407_0:
      {

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value *extra_info = std_value_Value_new(std_value_ValueType_Dictionary);

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_span_Span extra_span = ({ std_span_Span __yield_0;

#line 255 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          switch ((err->type)) {
            case compiler_errors_ErrorType_WithHint:
            m_408_0:
                              __yield_0 = (std_span_Span_is_valid(err->span2) ? err->span2 : err->span1);
               break;
            default:
              {
                __yield_0 = err->span1;
              } break;
          }

        __yield_0; });

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert(extra_info, "span", compiler_lsp_utils_gen_span_json(extra_span));

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(extra_info, "message", err->msg2);

#line 261 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert(obj, "extra_info", extra_info);
      } break;
    case compiler_errors_ErrorType_Standard:
    m_407_1:
      {
      } break;
  }

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_span_json(std_span_Span span) {

#line 269 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "start_line", std_value_Value_new_int(((i64)span.start.line)));

#line 271 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "start_col", std_value_Value_new_int(((i64)span.start.col)));

#line 272 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "end_line", std_value_Value_new_int(((i64)span.end.line)));

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "end_col", std_value_Value_new_int(((i64)span.end.col)));

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 277 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_span_json_with_filename(std_span_Span span, std_span_Location search_loc) {

#line 278 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = compiler_lsp_utils_gen_span_json(span);

#line 279 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (!(str_eq(span.start.filename, search_loc.filename))) {

#line 280 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_value_Value_insert_str(obj, "file", span.start.filename);
  }

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_hover_string_with_docs(compiler_ast_scopes_Symbol *sym) {

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 293 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_buffer_Buffer_write_str(&sb, compiler_lsp_utils_gen_hover_string(sym));

#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (((bool)sym->comment)) {

#line 295 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_buffer_Buffer_write_str(&sb, "\n");

#line 296 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_buffer_Buffer_write_str(&sb, sym->comment);
  }

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "hover", std_buffer_Buffer_str(sb));

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 304 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
void compiler_lsp_utils_gen_type_methods_into(std_value_Value *obj, compiler_types_Type *type) {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (!(((bool)type)) || !(((bool)type->methods))) {

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    return;
  }

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_map_Iterator__8 _i5 = std_map_Map__8_iter(type->methods); std_map_Iterator__8_has_value(&_i5); std_map_Iterator__8_next(&_i5)) {

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_map_Item__8 *it = std_map_Iterator__8_cur(&_i5);

#line 306 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_ast_nodes_Function *func = it->value;

#line 308 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value *func_doc = std_value_Value_new(std_value_ValueType_Dictionary);

#line 309 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert_str(func_doc, "name", it->key);

#line 310 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert_str(func_doc, "detail", compiler_lsp_utils_gen_hover_string(func->sym));

#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert_str(func_doc, "kind", "method");

#line 312 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert(func_doc, "range", compiler_lsp_utils_gen_span_json(func->sym->span));

#line 313 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert(func_doc, "selection_range", compiler_lsp_utils_gen_span_json(func->sym->span));

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_insert(func_doc, "children", std_value_Value_new(std_value_ValueType_List));

#line 315 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(obj, func_doc);
    }
  }
}


#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_struct_json(compiler_ast_nodes_Structure *struc) {

#line 344 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "name", struc->sym->name);

#line 346 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "detail", compiler_lsp_utils_gen_hover_string(struc->sym));

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "kind", "struct");

#line 348 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "range", compiler_lsp_utils_gen_span_json(struc->sym->span));

#line 349 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "selection_range", compiler_lsp_utils_gen_span_json(struc->sym->span));

#line 351 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *children = std_value_Value_new(std_value_ValueType_List);

#line 352 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_lsp_utils_gen_type_methods_into(children, struc->type);

#line 353 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "children", children);

#line 355 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_variable_json(compiler_ast_nodes_Variable *var) {

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "name", var->sym->name);

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "detail", compiler_lsp_utils_gen_hover_string(var->sym));

#line 362 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "kind", "variable");

#line 363 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "range", compiler_lsp_utils_gen_span_json(var->sym->span));

#line 364 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "selection_range", compiler_lsp_utils_gen_span_json(var->sym->span));

#line 365 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "children", std_value_Value_new(std_value_ValueType_List));

#line 366 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 369 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_function_json(compiler_ast_nodes_Function *func) {

#line 370 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "name", func->sym->name);

#line 372 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "detail", compiler_lsp_utils_gen_hover_string(func->sym));

#line 373 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "kind", "function");

#line 374 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "range", compiler_lsp_utils_gen_span_json(func->sym->span));

#line 375 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "selection_range", compiler_lsp_utils_gen_span_json(func->sym->span));

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "children", std_value_Value_new(std_value_ValueType_List));

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 380 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_namespace_json(compiler_ast_program_Namespace *ns) {

#line 381 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 382 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "name", ns->sym->name);

#line 383 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "detail", compiler_lsp_utils_gen_hover_string(ns->sym));

#line 384 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(obj, "kind", "namespace");

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "range", compiler_lsp_utils_gen_span_json(ns->span));

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "selection_range", compiler_lsp_utils_gen_span_json(ns->span));

#line 388 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *children = std_value_Value_new(std_value_ValueType_List);

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__14 _i7 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i7); std_vector_Iterator__14_next(&_i7)) {

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i7);

#line 390 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(children, compiler_lsp_utils_gen_struct_json(struc));
    }
  }

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__16 _i8 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i8); std_vector_Iterator__16_next(&_i8)) {

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_AST *var = std_vector_Iterator__16_cur(&_i8);

#line 394 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(children, compiler_lsp_utils_gen_variable_json(var->u.var_decl));
    }
  }

#line 398 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__16 _i9 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i9); std_vector_Iterator__16_next(&_i9)) {

#line 398 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_AST *var = std_vector_Iterator__16_cur(&_i9);

#line 398 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 399 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(children, compiler_lsp_utils_gen_variable_json(var->u.var_decl));
    }
  }

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__6 _i10 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i10); std_vector_Iterator__6_next(&_i10)) {

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i10);

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (func->kind==compiler_ast_nodes_FunctionKind_Method) {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        continue;
      }

#line 404 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(children, compiler_lsp_utils_gen_function_json(func));
    }
  }

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_map_ValueIterator__3 _i11 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i11); std_map_ValueIterator__3_next(&_i11)) {

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_program_Namespace *it = std_map_ValueIterator__3_cur(&_i11);

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 408 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (!(it->is_a_file) && !(it->is_dir_with_mod)) {

#line 409 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_push(children, compiler_lsp_utils_gen_namespace_json(it));
      }
    }
  }

#line 413 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "children", children);

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
void compiler_lsp_utils_insert_completion_item(std_value_Value *completions, compiler_ast_scopes_Symbol *sym, std_set_Set__2 *seen) {

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (std_set_Set__2_contains(seen, sym->display)) {

#line 418 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    return;
  }

#line 419 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__2_add(seen, sym->display);

#line 421 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Dictionary);

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(val, "label", sym->name);

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_str(val, "detail", compiler_lsp_utils_gen_hover_string(sym));

#line 426 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Function:
    m_409_0:
      {

#line 428 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "insertText", sym->name);

#line 429 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "kind", "function");

#line 430 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_utils_gen_hover_string(sym));

#line 431 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)sym->comment)) {

#line 432 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
    case compiler_ast_scopes_SymbolType_Variable:
    m_409_1:
      {

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "insertText", sym->name);

#line 437 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "kind", "field");

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_utils_gen_hover_string(sym));

#line 439 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)sym->comment)) {

#line 440 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
    default:
      {

#line 444 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "insertText", sym->name);

#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "kind", "field");

#line 447 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_value_Value_insert_str(val, "labelDetails", compiler_lsp_utils_gen_hover_string(sym));

#line 448 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)sym->comment)) {

#line 449 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(val, "documentation", sym->comment);
        }
      } break;
  }

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_push(completions, val);
}


#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_vector_Vector__25 *compiler_lsp_utils_get_unique_reference_spans(compiler_ast_scopes_Symbol *sym, bool for_rename) {

#line 457 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__3 *set = std_set_Set__3_new();

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__18 _i12 = std_vector_Vector__18_iter(sym->references); std_vector_Iterator__18_has_value(&_i12); std_vector_Iterator__18_next(&_i12)) {

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_scopes_Reference ref = std_vector_Iterator__18_cur(&_i12);

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 459 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (for_rename && (ref.type != compiler_ast_scopes_ReferenceType_Normal)) {

#line 459 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        continue;
      }

#line 460 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_set_Set__3_add(set, ref.span);
    }
  }

#line 462 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__3_add(set, sym->span);

#line 463 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_vector_Vector__25 *vec = std_vector_Vector__25_new(16);

#line 464 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_set_Iterator__3 _i13 = std_set_Set__3_iter(set); std_set_Iterator__3_has_value(&_i13); std_set_Iterator__3_next(&_i13)) {

#line 464 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_span_Span span = std_set_Iterator__3_cur(&_i13);

#line 464 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_vector_Vector__25_push(vec, span);
    }
  }

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__3_free(set);

#line 468 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return vec;
}


#line 471 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_references_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc) {

#line 472 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_List);

#line 473 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_vector_Vector__25 *spans = compiler_lsp_utils_get_unique_reference_spans(sym, false);

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__25 _i14 = std_vector_Vector__25_iter(spans); std_vector_Iterator__25_has_value(&_i14); std_vector_Iterator__25_next(&_i14)) {

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_span_Span ref = std_vector_Iterator__25_cur(&_i14);

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 475 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(obj, compiler_lsp_utils_gen_span_json_with_filename(ref, loc));
    }
  }

#line 477 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_vector_Vector__25_free(spans);

#line 478 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 481 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_signature_help(compiler_ast_nodes_AST *node, u32 active_param) {

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 483 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_ast_scopes_Symbol *callee_sym = node->u.call.callee->resolved_symbol;

#line 485 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  bool is_non_static_method = false;

#line 486 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_vector_Vector__3 *params = ({ std_vector_Vector__3 *__yield_0;

#line 486 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((callee_sym->type)) {
      case compiler_ast_scopes_SymbolType_Function:
      m_410_0:
        {

#line 488 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Function *func = callee_sym->u.func;

#line 489 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(obj, "label", compiler_lsp_utils_gen_type_string(func->type, true));

#line 490 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          is_non_static_method=(func->kind==compiler_ast_nodes_FunctionKind_Method && !(func->is_static));

#line 491 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = func->params;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_410_1:
        {

#line 494 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Variable *var = callee_sym->u.var;

#line 495 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (var->type->base != compiler_types_BaseType_FunctionPtr) {

#line 496 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (compiler_lsp_utils_verbose) {

#line 496 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              printf("gen_signature_help: variable is not a function: %p\n", var->type);
            }

#line 497 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            return obj;
          }

#line 499 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(obj, "label", compiler_lsp_utils_gen_type_string(var->type, true));

#line 500 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = var->type->u.func.params;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_410_2:
        {

#line 503 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Structure *struc = callee_sym->u.struc;

#line 504 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer struc_func_label = std_buffer_Buffer_make(16);

#line 508 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&struc_func_label, "struct ");

#line 509 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&struc_func_label, compiler_lsp_utils_gen_type_string(struc->type, true));

#line 510 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&struc_func_label, "(");

#line 512 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_vector_Vector__3 *params = struc->fields;

#line 513 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          for (u32 i = 0; i < params->size; i+=1) {

#line 514 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(params, i);

#line 515 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            if (i != 0) {

#line 516 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              std_buffer_Buffer_write_str(&struc_func_label, ", ");
            }

#line 518 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            std_buffer_Buffer_write_str(&struc_func_label, compiler_lsp_utils_gen_func_param_string(i, param, false));
          }

#line 520 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_buffer_Buffer_write_str(&struc_func_label, ")");

#line 522 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(obj, "label", std_buffer_Buffer_str(struc_func_label));

#line 523 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          __yield_0 = struc->fields;
        } break;
      default:
        {

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (compiler_lsp_utils_verbose) {

#line 526 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            printf("gen_signature_help: unhandled symbol type: %s\n", compiler_ast_scopes_SymbolType_dbg(callee_sym->type));
          }

#line 527 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          return obj;
        } break;
    }

  __yield_0; });

#line 531 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *params_obj = std_value_Value_new(std_value_ValueType_List);

#line 533 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (u32 i = 0; i < params->size; i+=1) {

#line 534 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(params, i);

#line 535 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_value_Value *param_obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 536 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_value_Value_insert_str(param_obj, "label", compiler_lsp_utils_gen_func_param_string(i, param, is_non_static_method));

#line 537 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_value_Value_push(params_obj, param_obj);
  }

#line 539 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "parameters", params_obj);

#line 541 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *sig_help = std_value_Value_new(std_value_ValueType_Dictionary);

#line 542 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(sig_help, "signatures", std_value_Value_new(std_value_ValueType_List));

#line 543 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_push(std_value_Value_at_key(sig_help, "signatures"), obj);

#line 545 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_u32(sig_help, "activeSignature", 0);

#line 546 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert_u32(sig_help, "activeParameter", active_param);

#line 547 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return sig_help;
}


#line 550 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_renames_json(compiler_ast_scopes_Symbol *sym, std_span_Location loc) {

#line 551 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_List);

#line 552 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_vector_Vector__25 *spans = compiler_lsp_utils_get_unique_reference_spans(sym, true);

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__25 _i15 = std_vector_Vector__25_iter(spans); std_vector_Iterator__25_has_value(&_i15); std_vector_Iterator__25_next(&_i15)) {

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    std_span_Span ref = std_vector_Iterator__25_cur(&_i15);

#line 553 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 554 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      u32 size = (ref.end.index - ref.start.index);

#line 559 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (str_eq(sym->name, "this") && size==1) {

#line 560 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        ref=(std_span_Span){.start=ref.start, .end=ref.start};
      }

#line 563 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_value_Value_push(obj, compiler_lsp_utils_gen_span_json_with_filename(ref, loc));
    }
  }

#line 565 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  return obj;
}


#line 568 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
void compiler_lsp_utils_gen_completions_from_scope(compiler_ast_scopes_Scope *scope, std_value_Value *completions, compiler_types_Type *hint_type, std_set_Set__2 *seen) {

#line 569 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (!(((bool)scope))) {

#line 569 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    return;
  }

#line 570 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (((bool)hint_type) && hint_type->base==compiler_types_BaseType_Enum) {

#line 572 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Enum *enom = hint_type->u.enom;

#line 573 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    for (std_vector_Iterator__20 _i16 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i16); std_vector_Iterator__20_next(&_i16)) {

#line 573 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i16);

#line 573 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      {

#line 574 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_lsp_utils_insert_completion_item(completions, variant->sym, seen);
      }
    }
  }

#line 577 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_map_ValueIterator__4 _i17 = std_map_Map__4_iter_values(scope->items); std_map_ValueIterator__4_has_value(&_i17); std_map_ValueIterator__4_next(&_i17)) {

#line 577 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_scopes_Symbol *item = std_map_ValueIterator__4_cur(&_i17);

#line 577 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 578 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_types_Type *item_type = compiler_lsp_utils_get_symbol_typedef(item);

#line 579 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (((bool)hint_type) && !(compiler_types_Type_eq(item_type, hint_type, false))) {

#line 579 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        continue;
      }

#line 581 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_lsp_utils_insert_completion_item(completions, item, seen);
    }
  }

#line 583 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_lsp_utils_gen_completions_from_scope(scope->parent, completions, hint_type, seen);
}


#line 586 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
void compiler_lsp_utils_gen_completion_items_from_ns(std_value_Value *completions, compiler_ast_program_Namespace *ns, std_set_Set__2 *seen) {

#line 587 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_map_ValueIterator__3 _i18 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i18); std_map_ValueIterator__3_next(&_i18)) {

#line 587 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_program_Namespace *it = std_map_ValueIterator__3_cur(&_i18);

#line 587 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 588 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_set_Set__2_add(seen, it->sym->name);

#line 589 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_lsp_utils_insert_completion_item(completions, it->sym, seen);
    }
  }

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__14 _i19 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i19); std_vector_Iterator__14_next(&_i19)) {

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Structure *it = std_vector_Iterator__14_cur(&_i19);

#line 591 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 592 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_set_Set__2_add(seen, it->sym->name);

#line 593 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      compiler_lsp_utils_insert_completion_item(completions, it->sym, seen);
    }
  }

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__16 _i20 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i20); std_vector_Iterator__16_next(&_i20)) {

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_AST *it = std_vector_Iterator__16_cur(&_i20);

#line 595 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 596 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (((bool)it->resolved_symbol)) {

#line 597 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_set_Set__2_add(seen, it->resolved_symbol->name);

#line 598 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_lsp_utils_insert_completion_item(completions, it->resolved_symbol, seen);
      }
    }
  }

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__16 _i21 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i21); std_vector_Iterator__16_next(&_i21)) {

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_AST *it = std_vector_Iterator__16_cur(&_i21);

#line 601 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 602 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (((bool)it->resolved_symbol)) {

#line 603 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_set_Set__2_add(seen, it->resolved_symbol->name);

#line 604 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_lsp_utils_insert_completion_item(completions, it->resolved_symbol, seen);
      }
    }
  }

#line 607 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  for (std_vector_Iterator__6 _i22 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i22); std_vector_Iterator__6_next(&_i22)) {

#line 607 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_ast_nodes_Function *it = std_vector_Iterator__6_cur(&_i22);

#line 607 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    {

#line 608 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      if (it->kind != compiler_ast_nodes_FunctionKind_Method) {

#line 609 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        std_set_Set__2_add(seen, it->sym->name);

#line 610 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_lsp_utils_insert_completion_item(completions, it->sym, seen);
      }
    }
  }

#line 616 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (!((ns->is_a_file && !(ns->is_dir_with_mod)))) {

#line 617 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    char *ns_path = ns->path;

#line 618 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    for (std_fs_DirectoryIterator _i23 = std_fs_iterate_directory(ns_path, true); std_fs_DirectoryIterator_has_value(&_i23); std_fs_DirectoryIterator_next(&_i23)) {

#line 618 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      std_fs_DirectoryEntry entry = std_fs_DirectoryIterator_cur(&_i23);

#line 618 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
      {

#line 619 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (std_set_Set__2_contains(seen, entry.name)) {

#line 619 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          continue;
        }

#line 621 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        char *path = std_format("%s/%s", ns_path, entry.name);

#line 622 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"

#line 624 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (std_fs_file_exists(path) && str_ends_with(path, ".oc")) {

#line 625 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          char *name = strdup(entry.name);

#line 626 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          name[(strlen(name) - 3)]='\0';

#line 627 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          if (str_eq(name, "mod") || std_set_Set__2_contains(seen, name)) {

#line 627 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            /* defers */

#line 622 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            str_free(&path);
            continue;
          }

#line 629 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value *item = std_value_Value_new(std_value_ValueType_Dictionary);

#line 630 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "label", name);

#line 631 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "kind", "field");

#line 632 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "insertText", name);

#line 633 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "detail", "(file)");

#line 634 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_push(completions, item);
        }

#line 637 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (std_fs_directory_exists(path)) {

#line 638 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value *item = std_value_Value_new(std_value_ValueType_Dictionary);

#line 639 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "label", entry.name);

#line 640 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "kind", "field");

#line 641 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "insertText", entry.name);

#line 642 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_insert_str(item, "detail", "(directory)");

#line 643 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          std_value_Value_push(completions, item);
        }
        /* defers */

#line 622 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        str_free(&path);
      }
    }
  }
}


#line 649 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
void compiler_lsp_utils_gen_completions_from_symbol(compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node, std_value_Value *completions, std_set_Set__2 *seen) {

#line 650 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  switch ((sym->type)) {
    case compiler_ast_scopes_SymbolType_Structure:
    m_411_0:
      {

#line 652 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)node) && (node->type != compiler_ast_nodes_ASTType_NSLookup)) {

#line 653 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          for (std_vector_Iterator__3 _i24 = std_vector_Vector__3_iter(sym->u.struc->fields); std_vector_Iterator__3_has_value(&_i24); std_vector_Iterator__3_next(&_i24)) {

#line 653 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i24);

#line 653 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            {

#line 654 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              compiler_lsp_utils_insert_completion_item(completions, field->sym, seen);
            }
          }
        }

#line 657 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        for (std_map_ValueIterator__8 _i25 = std_map_Map__8_iter_values(sym->u.struc->type->methods); std_map_ValueIterator__8_has_value(&_i25); std_map_ValueIterator__8_next(&_i25)) {

#line 657 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__8_cur(&_i25);

#line 657 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          {

#line 658 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_lsp_utils_insert_completion_item(completions, mth->sym, seen);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_TypeDef:
    m_411_1:
      {

#line 662 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        for (std_map_ValueIterator__8 _i26 = std_map_Map__8_iter_values(sym->u.type_def->methods); std_map_ValueIterator__8_has_value(&_i26); std_map_ValueIterator__8_next(&_i26)) {

#line 662 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__8_cur(&_i26);

#line 662 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          {

#line 663 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_lsp_utils_insert_completion_item(completions, mth->sym, seen);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Enum:
    m_411_2:
      {

#line 667 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)node) && node->type==compiler_ast_nodes_ASTType_NSLookup) {

#line 668 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          for (std_vector_Iterator__20 _i27 = std_vector_Vector__20_iter(sym->u.enom->variants); std_vector_Iterator__20_has_value(&_i27); std_vector_Iterator__20_next(&_i27)) {

#line 668 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i27);

#line 668 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            {

#line 669 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
              compiler_lsp_utils_insert_completion_item(completions, variant->sym, seen);
            }
          }
        }

#line 672 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        for (std_map_ValueIterator__8 _i28 = std_map_Map__8_iter_values(sym->u.enom->type->methods); std_map_ValueIterator__8_has_value(&_i28); std_map_ValueIterator__8_next(&_i28)) {

#line 672 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_ast_nodes_Function *mth = std_map_ValueIterator__8_cur(&_i28);

#line 672 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          {

#line 673 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
            compiler_lsp_utils_insert_completion_item(completions, mth->sym, seen);
          }
        }
      } break;
    case compiler_ast_scopes_SymbolType_Variable:
    m_411_3:
      {

#line 677 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_types_Type *typ = compiler_lsp_utils_get_symbol_typedef(sym);

#line 678 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if ((((bool)typ) && !(compiler_types_Type_can_have_methods(typ))) && typ->base==compiler_types_BaseType_Pointer) {

#line 679 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          typ=typ->u.ptr;
        }

#line 681 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (((bool)typ) && ((bool)typ->sym)) {

#line 682 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          compiler_lsp_utils_gen_completions_from_symbol(typ->sym, node, completions, seen);
        }
      } break;
    case compiler_ast_scopes_SymbolType_Namespace:
    m_411_4:
      {

#line 685 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        compiler_lsp_utils_gen_completion_items_from_ns(completions, sym->u.ns, seen);
      } break;
    default:
      {

#line 687 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
        if (compiler_lsp_utils_verbose) {

#line 687 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
          printf("gen_completions_json: unhandled symbol type: %s\n", compiler_ast_scopes_SymbolType_dbg(sym->type));
        }
      } break;
  }
}


#line 692 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
std_value_Value *compiler_lsp_utils_gen_completions_json(compiler_lsp_finder_Finder *finder) {

#line 693 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_ast_nodes_AST *node = finder->found_node;

#line 694 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (!(((bool)node))) {

#line 694 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    return NULL;
  }

#line 696 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *completions = std_value_Value_new(std_value_ValueType_List);

#line 697 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_types_Type *hint_type = node->hint;

#line 699 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  compiler_ast_scopes_Symbol *sym = ({ compiler_ast_scopes_Symbol *__yield_0;

#line 699 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    switch ((node->type)) {
      case compiler_ast_nodes_ASTType_Member:
      m_412_0:
        {
          __yield_0 = node->u.member.lhs->resolved_symbol;
        } break;
      case compiler_ast_nodes_ASTType_NSLookup:
      m_412_1:
        {
          __yield_0 = node->u.lookup.lhs->resolved_symbol;
        } break;
      case compiler_ast_nodes_ASTType_Import:
      m_412_2:
        {
          __yield_0 = finder->found_import_ns->sym;
        } break;
      default:
        {
          __yield_0 = NULL;
        } break;
    }

  __yield_0; });

#line 706 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__2 *seen = std_set_Set__2_new();

#line 707 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"

#line 708 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  if (((bool)sym)) {

#line 710 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_lsp_utils_gen_completions_from_symbol(sym, node, completions, seen);
  } else {

#line 713 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
    compiler_lsp_utils_gen_completions_from_scope(finder->found_scope, completions, hint_type, seen);
  }
#line 716 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value *obj = std_value_Value_new(std_value_ValueType_Dictionary);

#line 717 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_value_Value_insert(obj, "completions", completions);

#line 718 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  /* defers */

#line 707 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/utils.oc"
  std_set_Set__2_free(seen);
  return obj;
}


#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
compiler_lsp_finder_Finder compiler_lsp_finder_Finder_make(compiler_lsp_CommandType cmd, std_span_Location loc) {

#line 42 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  compiler_lsp_finder_Finder finder = {0};

#line 43 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  finder.cmd=cmd;

#line 44 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  finder.loc=loc;

#line 45 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  finder.scopes=std_vector_Vector__1_new(16);

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return finder;
}


#line 49 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_identifier(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node) {

#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  compiler_ast_nodes_Identifier *ident = &node->u.ident;

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (std_span_Span_contains_loc(node->span, this->loc)) {

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return compiler_lsp_finder_Finder_set_usage(this, node->resolved_symbol, node);
  }

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_var(compiler_lsp_finder_Finder *this, compiler_ast_nodes_Variable *var, compiler_ast_nodes_AST *node) {

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (((bool)var->sym) && std_span_Span_contains_loc(var->sym->span, this->loc)) {

#line 59 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return compiler_lsp_finder_Finder_set_usage(this, var->sym, node);
  }

#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (((bool)var->parsed_type) && compiler_lsp_finder_Finder_find_in_type(this, var->parsed_type)) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return true;
  }

#line 64 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_set_usage(compiler_lsp_finder_Finder *this, compiler_ast_scopes_Symbol *sym, compiler_ast_nodes_AST *node) {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  this->found_sym=sym;

#line 69 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  this->found_node=node;

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if(!(this->scopes->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc:71:12: Assertion failed: `.scopes.size > 0`", "No scopes to set"); }

#line 72 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  this->found_scope=std_vector_Vector__1_back(this->scopes, 0);

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (this->cmd==compiler_lsp_CommandType_Completions) {

#line 77 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return true;
  }

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return ((bool)sym);
}


#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_literal(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (std_span_Span_contains_loc(node->span, this->loc)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (((bool)node->etype)) {

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return compiler_lsp_finder_Finder_set_usage(this, node->etype->sym, node);
    }
  }

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_signature_help(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__7 *args, u32 param_idx) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (this->cmd != compiler_lsp_CommandType_SignatureHelp) {

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (!(std_span_Span_contains_loc(node->span, this->loc))) {

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  compiler_ast_scopes_Symbol *func = node->u.call.callee->resolved_symbol;

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (!(((bool)func))) {

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__3 *params = ({ std_vector_Vector__3 *__yield_0;

#line 100 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    switch ((func->type)) {
      case compiler_ast_scopes_SymbolType_Function:
      m_413_0:
        {
          __yield_0 = func->u.func->params;
        } break;
      case compiler_ast_scopes_SymbolType_Structure:
      m_413_1:
        {
          __yield_0 = func->u.struc->fields;
        } break;
      case compiler_ast_scopes_SymbolType_Variable:
      m_413_2:
        {

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_types_Type *var_type = func->u.var->type;

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (!(((bool)var_type)) || (var_type->base != compiler_types_BaseType_FunctionPtr)) {

#line 105 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return false;
          }

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          __yield_0 = func->u.var->type->u.func.params;
        } break;
      default:
        {

#line 109 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return false;
        } break;
    }

  __yield_0; });

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (param_idx > params->size) {

#line 113 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 116 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (param_idx==0) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    std_span_Span open_paren_span = node->u.call.open_paren_span;

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    open_paren_span.end.col+=1;

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (std_span_Span_contains_loc(open_paren_span, this->loc)) {

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->active_param=0;

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->call=node;

#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }
  } else {

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Argument *prev_arg = std_vector_Vector__7_at(args, (param_idx - 1));

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    std_span_Span arg_span = (((bool)prev_arg->label) ? std_span_Span_join(prev_arg->label_span, prev_arg->expr->span) : prev_arg->expr->span);

#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (std_span_Span_contains_loc(arg_span, this->loc)) {

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->active_param=(param_idx - 1);

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->call=node;

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    std_span_Span close_paren_span = node->u.call.close_paren_span;

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    std_span_Span mid_span = (std_span_Span){.start=arg_span.end, .end=close_paren_span.start};

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (std_span_Span_contains_loc(mid_span, this->loc)) {

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->active_param=param_idx;

#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      this->call=node;

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }
  }

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 149 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_call_args(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node, std_vector_Vector__7 *args) {

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (compiler_lsp_finder_Finder_find_signature_help(this, node, args, args->size)) {

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return true;
  }

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (u32 i = 0; i < args->size; i+=1) {

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Argument *arg = std_vector_Vector__7_at(args, i);

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (((bool)arg->label) && std_span_Span_contains_loc(arg->label_span, this->loc)) {

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      compiler_types_Type *callee_type = node->u.call.callee->etype;

#line 158 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (((bool)callee_type)) {

#line 159 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Variable *found = NULL;

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__3 _i29 = std_vector_Vector__3_iter(callee_type->sym->u.func->params); std_vector_Iterator__3_has_value(&_i29); std_vector_Iterator__3_next(&_i29)) {

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i29);

#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (str_eq(param->sym->name, arg->label)) {

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              found=param;

#line 163 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              break;
            }
          }
        }

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_lsp_finder_Finder_set_usage(this, found->sym, node);
      }

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (compiler_lsp_finder_Finder_find_in_expression(this, arg->expr)) {

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }
  }

#line 172 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 175 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_expression(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node) {

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (!(((bool)node))) {

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_IntLiteral:
    case compiler_ast_nodes_ASTType_FloatLiteral:
    case compiler_ast_nodes_ASTType_BoolLiteral:
    case compiler_ast_nodes_ASTType_StringLiteral:
    case compiler_ast_nodes_ASTType_CharLiteral:
    case compiler_ast_nodes_ASTType_Null:
    m_414_0:
      {

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_CreateNew:
    m_414_1:
      {

#line 181 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_FormatStringLiteral:
    m_414_2:
      {

#line 184 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_FormatString *fmt = &node->u.fmt_str;

#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (u32 i = 0; i < fmt->exprs->size; i+=1) {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (compiler_lsp_finder_Finder_find_in_expression(this, std_vector_Vector__16_at(fmt->exprs, i))) {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return true;
          }
        }

#line 188 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_literal(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Identifier:
    m_414_3:
      {

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_identifier(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Member:
    m_414_4:
      {

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        char *rhs = node->u.member.rhs_name;

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if ((!(((bool)rhs)) && this->cmd==compiler_lsp_CommandType_Completions) && std_span_Span_contains_loc(node->span, this->loc)) {

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, node->u.member.lhs->resolved_symbol, node);
        }

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, node->u.member.lhs)) {

#line 199 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(node->u.member.rhs_span, this->loc)) {

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_CreateClosure:
    m_414_5:
      {

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_function(this, node->u.closure);
      } break;
    case compiler_ast_nodes_ASTType_NSLookup:
    m_414_6:
      {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, node->u.lookup.lhs)) {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        char *rhs = node->u.member.rhs_name;

#line 211 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (!(((bool)rhs)) && std_span_Span_contains_loc(node->span, this->loc)) {

#line 212 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          bool res = compiler_lsp_finder_Finder_set_usage(this, node->u.member.lhs->resolved_symbol, node);

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return res;
        }

#line 216 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(node->u.member.rhs_span, this->loc)) {

#line 217 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_BinaryOp:
    m_414_7:
      {

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_AST *lhs = node->u.binary.lhs;

#line 222 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_AST *rhs = node->u.binary.rhs;

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, lhs) || compiler_lsp_finder_Finder_find_in_expression(this, rhs);
      } break;
    case compiler_ast_nodes_ASTType_UnaryOp:
    m_414_8:
      {

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, node->u.unary.expr);
      } break;
    case compiler_ast_nodes_ASTType_Defer:
    case compiler_ast_nodes_ASTType_Yield:
    m_414_9:
      {

#line 226 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, node->u.child);
      } break;
    case compiler_ast_nodes_ASTType_Call:
    m_414_10:
      {

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_FuncCall *call = &node->u.call;

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, call->callee)) {

#line 229 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_call_args(this, node, call->args)) {

#line 230 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Cast:
    m_414_11:
      {

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, node->u.cast.lhs)) {

#line 233 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 234 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_type(this, node->u.cast.parsed_to);
      } break;
    case compiler_ast_nodes_ASTType_SizeOf:
    m_414_12:
      {

#line 236 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_type(this, node->u.size_of_type);
      } break;
    case compiler_ast_nodes_ASTType_If:
    m_414_13:
      {

#line 238 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_IfStatement *stmt = &node->u.if_stmt;

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__23 _i30 = std_vector_Vector__23_iter(stmt->branches); std_vector_Iterator__23_has_value(&_i30); std_vector_Iterator__23_next(&_i30)) {

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_IfBranch branch = std_vector_Iterator__23_cur(&_i30);

#line 239 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_expression(this, branch.cond)) {

#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_statement(this, branch.body)) {

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }
          }
        }

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)stmt->els) && compiler_lsp_finder_Finder_find_in_statement(this, stmt->els)) {

#line 243 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Match:
    m_414_14:
      {

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Match *stmt = &node->u.match_stmt;

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, stmt->expr)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__24 _i31 = std_vector_Vector__24_iter(stmt->cases); std_vector_Iterator__24_has_value(&_i31); std_vector_Iterator__24_next(&_i31)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_MatchCase _case = std_vector_Iterator__24_cur(&_i31);

#line 248 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            for (std_vector_Iterator__10 _i32 = std_vector_Vector__10_iter(_case.conds); std_vector_Iterator__10_has_value(&_i32); std_vector_Iterator__10_next(&_i32)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              compiler_ast_nodes_MatchCond *cond = std_vector_Iterator__10_cur(&_i32);

#line 249 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                if (compiler_lsp_finder_Finder_find_in_expression(this, cond->expr)) {

#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                  return true;
                }

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                if (((bool)cond->args)) {

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                  for (std_vector_Iterator__19 _i33 = std_vector_Vector__19_iter(cond->args); std_vector_Iterator__19_has_value(&_i33); std_vector_Iterator__19_next(&_i33)) {

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                    compiler_ast_nodes_MatchCondArg *arg = std_vector_Iterator__19_cur(&_i33);

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                    {

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                      if (compiler_lsp_finder_Finder_find_in_var(this, arg->var, node)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                        return true;
                      }
                    }
                  }
                }
              }
            }

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (((bool)_case.body) && compiler_lsp_finder_Finder_find_in_statement(this, _case.body)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }
          }
        }

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)stmt->defolt) && compiler_lsp_finder_Finder_find_in_statement(this, stmt->defolt)) {

#line 259 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Break:
    case compiler_ast_nodes_ASTType_Continue:
    m_414_15:
      {
      } break;
    case compiler_ast_nodes_ASTType_Assert:
    m_414_16:
      {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, node->u.assertion.expr);
      } break;
    case compiler_ast_nodes_ASTType_Specialization:
    m_414_17:
      {

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Specialization *spec = &node->u.spec;

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_expression(this, spec->base)) {

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__0 _i34 = std_vector_Vector__0_iter(spec->parsed_template_args); std_vector_Iterator__0_has_value(&_i34); std_vector_Iterator__0_next(&_i34)) {

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_types_Type *ty = std_vector_Iterator__0_cur(&_i34);

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_type(this, ty)) {

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }
          }
        }
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_414_18:
      {

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_block(this, node);
      } break;
    case compiler_ast_nodes_ASTType_OverloadedOperator:
    m_414_19:
      {

#line 272 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        std_span_Span op_span = node->u.operator_span;

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(op_span, this->loc)) {

#line 274 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    case compiler_ast_nodes_ASTType_Error:
    m_414_20:
      {

#line 278 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(node->span, this->loc)) {

#line 279 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, node->resolved_symbol, node);
        }
      } break;
    default:
      {

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_utils_verbose) {

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          printf("Unhandled node type in Finder::find_in_expression: %s""\n", compiler_ast_nodes_ASTType_dbg(node->type));
        }
      } break;
  }

#line 286 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 289 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_import_part(compiler_lsp_finder_Finder *this, compiler_ast_scopes_Symbol *base, compiler_ast_nodes_ImportPart *part, compiler_ast_nodes_AST *node) {
  return ({ bool __yield_0;

#line 289 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    switch ((part->type)) {
      case compiler_ast_nodes_ImportPartType_Single:
      m_415_0:
        {

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (std_span_Span_contains_loc(part->span, this->loc)) {

#line 292 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return compiler_lsp_finder_Finder_set_usage(this, part->resolved_symbol, node);
          }

#line 294 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Multiple:
      m_415_1:
        {

#line 297 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_ImportPartMultiple *multi = &part->u.multiple;

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          for (std_vector_Iterator__22 _i35 = std_vector_Vector__22_iter(multi->paths); std_vector_Iterator__22_has_value(&_i35); std_vector_Iterator__22_next(&_i35)) {

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            std_vector_Vector__5 *subpath = std_vector_Iterator__22_cur(&_i35);

#line 298 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            {

#line 299 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              compiler_ast_scopes_Symbol *prev = base;

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              for (std_vector_Iterator__5 _i36 = std_vector_Vector__5_iter(subpath); std_vector_Iterator__5_has_value(&_i36); std_vector_Iterator__5_next(&_i36)) {

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                compiler_ast_nodes_ImportPart *subpart = std_vector_Iterator__5_cur(&_i36);

#line 300 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                {

#line 301 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                  if (compiler_lsp_finder_Finder_find_in_import_part(this, prev, subpart, node)) {

#line 302 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                    if (((bool)prev) && prev->type==compiler_ast_scopes_SymbolType_Namespace) {

#line 303 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                      this->found_import_ns=prev->u.ns;
                    }

#line 305 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                    return true;
                  }

#line 307 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                  prev=subpart->resolved_symbol;
                }
              }
            }
          }

#line 310 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          std_span_Span multi_span = std_span_Span_join(multi->open_curly_span, multi->close_curly_span);

#line 311 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (std_span_Span_contains_loc(multi_span, this->loc)) {

#line 312 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            compiler_lsp_finder_Finder_set_usage(this, NULL, node);

#line 313 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (((bool)base) && base->type==compiler_ast_scopes_SymbolType_Namespace) {

#line 314 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              this->found_import_ns=base->u.ns;
            }

#line 316 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return true;
          }

#line 318 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return false;
        } break;
      case compiler_ast_nodes_ImportPartType_Wildcard:
      m_415_2:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 323 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_statement(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node) {

#line 324 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  switch ((node->type)) {
    case compiler_ast_nodes_ASTType_While:
    case compiler_ast_nodes_ASTType_For:
    m_416_0:
      {

#line 326 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Loop *loop = &node->u.loop;

#line 327 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)loop->init) && compiler_lsp_finder_Finder_find_in_statement(this, loop->init)) {

#line 327 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 328 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)loop->cond) && compiler_lsp_finder_Finder_find_in_expression(this, loop->cond)) {

#line 328 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)loop->step) && compiler_lsp_finder_Finder_find_in_expression(this, loop->step)) {

#line 329 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)loop->body) && compiler_lsp_finder_Finder_find_in_statement(this, loop->body)) {

#line 330 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_VarDeclaration:
    m_416_1:
      {

#line 333 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Variable *decl = node->u.var_decl;

#line 334 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)decl) && compiler_lsp_finder_Finder_find_in_var(this, decl, node)) {

#line 334 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)decl->default_value) && compiler_lsp_finder_Finder_find_in_expression(this, decl->default_value)) {

#line 335 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }
      } break;
    case compiler_ast_nodes_ASTType_Block:
    m_416_2:
      {

#line 337 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_block(this, node);
      } break;
    case compiler_ast_nodes_ASTType_Return:
    m_416_3:
      {

#line 338 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return ((bool)node->u.ret.expr) && compiler_lsp_finder_Finder_find_in_expression(this, node->u.ret.expr);
      } break;
    case compiler_ast_nodes_ASTType_Import:
    m_416_4:
      {

#line 340 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Import path = node->u.import_path;

#line 341 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_scopes_Symbol *prev = path.root_sym;

#line 342 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__5 _i37 = std_vector_Vector__5_iter(path.parts); std_vector_Iterator__5_has_value(&_i37); std_vector_Iterator__5_next(&_i37)) {

#line 342 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_ImportPart *part = std_vector_Iterator__5_cur(&_i37);

#line 342 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 343 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_import_part(this, prev, part, node)) {

#line 344 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              if (((bool)prev) && prev->type==compiler_ast_scopes_SymbolType_Namespace) {

#line 345 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                this->found_import_ns=prev->u.ns;
              }

#line 347 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }

#line 349 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            prev=part->resolved_symbol;
          }
        }
      } break;
    default:
      {

#line 352 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, node);
      } break;
  }

#line 354 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 357 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_block(compiler_lsp_finder_Finder *this, compiler_ast_nodes_AST *node) {

#line 358 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_push(this->scopes, node->u.block.scope);

#line 359 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__16 *stmts = node->u.block.statements;

#line 360 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (u32 i = 0; i < stmts->size; i+=1) {

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    if (compiler_lsp_finder_Finder_find_in_statement(this, std_vector_Vector__16_at(stmts, i))) {

#line 361 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      return true;
    }
  }

#line 367 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (this->cmd==compiler_lsp_CommandType_Completions && std_span_Span_contains_loc(node->span, this->loc)) {

#line 368 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return compiler_lsp_finder_Finder_set_usage(this, NULL, node);
  }

#line 371 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_pop(this->scopes);

#line 372 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 375 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_type(compiler_lsp_finder_Finder *this, compiler_types_Type *type) {

#line 376 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  switch ((type->base)) {
    case compiler_types_BaseType_Pointer:
    m_417_0:
      {

#line 377 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_type(this, type->u.ptr);
      } break;
    case compiler_types_BaseType_Array:
    m_417_1:
      {

#line 379 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)type->u.arr.size_expr) && compiler_lsp_finder_Finder_find_in_expression(this, type->u.arr.size_expr)) {

#line 379 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 380 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_type(this, type->u.arr.elem_type);
      } break;
    case compiler_types_BaseType_Unresolved:
    m_417_2:
      {

#line 382 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_find_in_expression(this, type->u.unresolved);
      } break;
    case compiler_types_BaseType_UnresolvedTemplate:
    m_417_3:
      {

#line 384 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_types_UnresolvedTemplate spec = type->u.unresolved_spec;

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (compiler_lsp_finder_Finder_find_in_type(this, spec.base)) {

#line 385 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__0 _i38 = std_vector_Vector__0_iter(spec.args); std_vector_Iterator__0_has_value(&_i38); std_vector_Iterator__0_next(&_i38)) {

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_types_Type *ty = std_vector_Iterator__0_cur(&_i38);

#line 386 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 387 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_type(this, ty)) {

#line 387 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }
          }
        }
      } break;
    case compiler_types_BaseType_FunctionPtr:
    case compiler_types_BaseType_Closure:
    m_417_4:
      {

#line 391 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_types_FunctionType func = type->u.func;

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        for (std_vector_Iterator__3 _i39 = std_vector_Vector__3_iter(func.params); std_vector_Iterator__3_has_value(&_i39); std_vector_Iterator__3_next(&_i39)) {

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i39);

#line 392 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          {

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            if (compiler_lsp_finder_Finder_find_in_var(this, param, NULL)) {

#line 393 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              return true;
            }
          }
        }

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (((bool)func.return_type) && compiler_lsp_finder_Finder_find_in_type(this, func.return_type)) {

#line 395 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return true;
        }

#line 396 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(type->span, this->loc)) {

#line 397 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
    default:
      {

#line 402 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        if (std_span_Span_contains_loc(type->span, this->loc)) {

#line 403 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          return compiler_lsp_finder_Finder_set_usage(this, type->sym, NULL);
        }
      } break;
  }

#line 407 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 410 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_function(compiler_lsp_finder_Finder *this, compiler_ast_nodes_Function *func) {

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (compiler_ast_nodes_Function_is_template_instance(func)) {

#line 414 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return false;
  }

#line 416 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (std_span_Span_contains_loc(func->sym->span, this->loc)) {

#line 417 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return compiler_lsp_finder_Finder_set_usage(this, func->sym, NULL);
  }

#line 419 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (compiler_lsp_finder_Finder_find_in_expression(this, func->name_ast)) {

#line 419 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return true;
  }

#line 421 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_push(this->scopes, func->scope);

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__3 _i40 = std_vector_Vector__3_iter(func->params); std_vector_Iterator__3_has_value(&_i40); std_vector_Iterator__3_next(&_i40)) {

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i40);

#line 422 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (compiler_lsp_finder_Finder_find_in_var(this, param, NULL)) {

#line 423 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 426 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  compiler_types_Type *ret_type = func->parsed_return_type;

#line 427 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  if (((bool)ret_type) && compiler_lsp_finder_Finder_find_in_type(this, ret_type)) {

#line 427 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    return true;
  }

#line 429 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  bool res = (((bool)func->body) && compiler_lsp_finder_Finder_find_in_statement(this, func->body));

#line 430 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_pop(this->scopes);

#line 432 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return res;
}


#line 435 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find_in_program(compiler_lsp_finder_Finder *this, compiler_ast_program_Namespace *ns) {

#line 436 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_push(this->scopes, ns->scope);

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__14 _i41 = std_vector_Vector__14_iter(ns->structs); std_vector_Iterator__14_has_value(&_i41); std_vector_Iterator__14_next(&_i41)) {

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Structure *struc = std_vector_Iterator__14_cur(&_i41);

#line 438 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 442 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (((bool)struc->type) && ((bool)struc->type->template_instance)) {

#line 442 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        continue;
      }

#line 444 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(struc->sym->span, this->loc)) {

#line 444 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, struc->sym, NULL);
      }

#line 445 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      for (std_vector_Iterator__3 _i42 = std_vector_Vector__3_iter(struc->fields); std_vector_Iterator__3_has_value(&_i42); std_vector_Iterator__3_next(&_i42)) {

#line 445 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i42);

#line 445 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        {

#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (compiler_lsp_finder_Finder_find_in_var(this, field, NULL)) {

#line 446 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return true;
          }
        }
      }
    }
  }

#line 450 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__15 _i43 = std_vector_Vector__15_iter(ns->enums); std_vector_Iterator__15_has_value(&_i43); std_vector_Iterator__15_next(&_i43)) {

#line 450 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Enum *enom = std_vector_Iterator__15_cur(&_i43);

#line 450 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 451 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(enom->sym->span, this->loc)) {

#line 451 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, enom->sym, NULL);
      }

#line 452 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      for (std_vector_Iterator__3 _i44 = std_vector_Vector__3_iter(enom->shared_fields); std_vector_Iterator__3_has_value(&_i44); std_vector_Iterator__3_next(&_i44)) {

#line 452 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i44);

#line 452 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        {

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (compiler_lsp_finder_Finder_find_in_var(this, field, NULL)) {

#line 453 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return true;
          }
        }
      }

#line 455 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      for (std_vector_Iterator__20 _i45 = std_vector_Vector__20_iter(enom->variants); std_vector_Iterator__20_has_value(&_i45); std_vector_Iterator__20_next(&_i45)) {

#line 455 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        compiler_ast_nodes_EnumVariant *variant = std_vector_Iterator__20_cur(&_i45);

#line 455 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        {

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (std_span_Span_contains_loc(variant->sym->span, this->loc)) {

#line 456 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            return compiler_lsp_finder_Finder_set_usage(this, variant->sym, NULL);
          }

#line 457 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
          if (((bool)variant->specific_fields)) {

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
            for (std_vector_Iterator__3 _i46 = std_vector_Vector__3_iter(variant->specific_fields); std_vector_Iterator__3_has_value(&_i46); std_vector_Iterator__3_next(&_i46)) {

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              compiler_ast_nodes_Variable *field = std_vector_Iterator__3_cur(&_i46);

#line 458 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
              {

#line 459 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                if (compiler_lsp_finder_Finder_find_in_var(this, field, NULL)) {

#line 459 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__6 _i47 = std_vector_Vector__6_iter(ns->functions); std_vector_Iterator__6_has_value(&_i47); std_vector_Iterator__6_next(&_i47)) {

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_Function *func = std_vector_Iterator__6_cur(&_i47);

#line 465 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 466 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(func->sym->span, this->loc)) {

#line 466 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, func->sym, NULL);
      }

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (compiler_lsp_finder_Finder_find_in_function(this, func)) {

#line 467 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 470 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__16 _i48 = std_vector_Vector__16_iter(ns->imports); std_vector_Iterator__16_has_value(&_i48); std_vector_Iterator__16_next(&_i48)) {

#line 470 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_AST *import_ = std_vector_Iterator__16_cur(&_i48);

#line 470 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 471 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (compiler_lsp_finder_Finder_find_in_statement(this, import_)) {

#line 471 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__16 _i49 = std_vector_Vector__16_iter(ns->variables); std_vector_Iterator__16_has_value(&_i49); std_vector_Iterator__16_next(&_i49)) {

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_AST *vardecl = std_vector_Iterator__16_cur(&_i49);

#line 474 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 475 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      compiler_ast_nodes_Variable *var = vardecl->u.var_decl;

#line 476 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(var->sym->span, this->loc)) {

#line 476 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, var->sym, NULL);
      }

#line 478 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      compiler_ast_nodes_AST *init = vardecl->u.var_decl->default_value;

#line 479 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (((bool)init) && compiler_lsp_finder_Finder_find_in_expression(this, init)) {

#line 479 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_vector_Iterator__16 _i50 = std_vector_Vector__16_iter(ns->constants); std_vector_Iterator__16_has_value(&_i50); std_vector_Iterator__16_next(&_i50)) {

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_nodes_AST *vardecl = std_vector_Iterator__16_cur(&_i50);

#line 482 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 483 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      compiler_ast_nodes_Variable *var = vardecl->u.var_decl;

#line 484 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(var->sym->span, this->loc)) {

#line 484 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, var->sym, NULL);
      }

#line 486 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      compiler_ast_nodes_AST *init = vardecl->u.var_decl->default_value;

#line 487 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (((bool)init) && compiler_lsp_finder_Finder_find_in_expression(this, init)) {

#line 487 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 490 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_pop(this->scopes);

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  for (std_map_ValueIterator__3 _i51 = std_map_Map__3_iter_values(ns->namespaces); std_map_ValueIterator__3_has_value(&_i51); std_map_ValueIterator__3_next(&_i51)) {

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    compiler_ast_program_Namespace *child = std_map_ValueIterator__3_cur(&_i51);

#line 492 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
    {

#line 493 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (std_span_Span_contains_loc(child->sym->span, this->loc)) {

#line 493 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return compiler_lsp_finder_Finder_set_usage(this, child->sym, NULL);
      }

#line 494 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
      if (compiler_lsp_finder_Finder_find_in_program(this, child)) {

#line 494 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
        return true;
      }
    }
  }

#line 497 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return false;
}


#line 500 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
bool compiler_lsp_finder_Finder_find(compiler_lsp_finder_Finder *this, compiler_ast_program_Program *program) {

#line 501 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  std_vector_Vector__1_push(this->scopes, program->global->scope);

#line 502 "/Users/mustafa/ocen-lang/ocen/compiler/lsp/finder.oc"
  return compiler_lsp_finder_Finder_find_in_program(this, program->global);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
compiler_tokens_Token *compiler_tokens_Token_new(compiler_tokens_TokenType type, std_span_Span span, char *text) {

#line 19 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
  compiler_tokens_Token *tok = std_mem_alloc__19(1);

#line 20 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
  (*tok)=(compiler_tokens_Token){.type=type, .span=span, .text=text, .suffix=NULL, .seen_newline=false, .comment=NULL, .comment_loc=std_span_Location_default()};

#line 29 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
  return tok;
}


#line 32 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
compiler_tokens_Token *compiler_tokens_Token_from_type(compiler_tokens_TokenType type, std_span_Span span) {
  return compiler_tokens_Token_new(type, span, "");}


#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
compiler_tokens_Token *compiler_tokens_Token_from_ident(char *text, std_span_Span span) {

#line 35 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
  compiler_tokens_TokenType type = compiler_tokens_TokenType_from_text(text);

#line 36 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
  return compiler_tokens_Token_new(type, span, text);
}


#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
bool compiler_tokens_Token_is_word(compiler_tokens_Token this) {
  return ({ bool __yield_0;

#line 41 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
    switch ((this.type)) {
      case compiler_tokens_TokenType_Identifier:
      m_418_0:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = (((u64)this.type) > ((u64)compiler_tokens_TokenType_BEGIN_KEYWORDS));
        } break;
    }

  __yield_0; });}


#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
bool compiler_tokens_Token_is_identifier(compiler_tokens_Token this, char *name) {
  return ({ bool __yield_0;

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
    switch ((this.type)) {
      case compiler_tokens_TokenType_Identifier:
      m_419_0:
        {
          __yield_0 = str_eq(name, this.text);
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
compiler_tokens_TokenType compiler_tokens_TokenType_from_text(char *text) {
  return ({ compiler_tokens_TokenType __yield_0;

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
    {
      char *__match_var_420 = text;
      if (str_eq(__match_var_420, "and")) {
        __yield_0 = compiler_tokens_TokenType_And;
      } else if (str_eq(__match_var_420, "as")) {
        __yield_0 = compiler_tokens_TokenType_As;
      } else if (str_eq(__match_var_420, "assert")) {
        __yield_0 = compiler_tokens_TokenType_Assert;
      } else if (str_eq(__match_var_420, "break")) {
        __yield_0 = compiler_tokens_TokenType_Break;
      } else if (str_eq(__match_var_420, "const")) {
        __yield_0 = compiler_tokens_TokenType_Const;
      } else if (str_eq(__match_var_420, "continue")) {
        __yield_0 = compiler_tokens_TokenType_Continue;
      } else if (str_eq(__match_var_420, "def")) {
        __yield_0 = compiler_tokens_TokenType_Def;
      } else if (str_eq(__match_var_420, "defer")) {
        __yield_0 = compiler_tokens_TokenType_Defer;
      } else if (str_eq(__match_var_420, "else")) {
        __yield_0 = compiler_tokens_TokenType_Else;
      } else if (str_eq(__match_var_420, "enum")) {
        __yield_0 = compiler_tokens_TokenType_Enum;
      } else if (str_eq(__match_var_420, "extern")) {
        __yield_0 = compiler_tokens_TokenType_Extern;
      } else if (str_eq(__match_var_420, "false")) {
        __yield_0 = compiler_tokens_TokenType_False;
      } else if (str_eq(__match_var_420, "for")) {
        __yield_0 = compiler_tokens_TokenType_For;
      } else if (str_eq(__match_var_420, "fn")) {
        __yield_0 = compiler_tokens_TokenType_Fn;
      } else if (str_eq(__match_var_420, "if")) {
        __yield_0 = compiler_tokens_TokenType_If;
      } else if (str_eq(__match_var_420, "let")) {
        __yield_0 = compiler_tokens_TokenType_Let;
      } else if (str_eq(__match_var_420, "match")) {
        __yield_0 = compiler_tokens_TokenType_Match;
      } else if (str_eq(__match_var_420, "namespace")) {
        __yield_0 = compiler_tokens_TokenType_Namespace;
      } else if (str_eq(__match_var_420, "not")) {
        __yield_0 = compiler_tokens_TokenType_Not;
      } else if (str_eq(__match_var_420, "null")) {
        __yield_0 = compiler_tokens_TokenType_Null;
      } else if (str_eq(__match_var_420, "or")) {
        __yield_0 = compiler_tokens_TokenType_Or;
      } else if (str_eq(__match_var_420, "return")) {
        __yield_0 = compiler_tokens_TokenType_Return;
      } else if (str_eq(__match_var_420, "sizeof")) {
        __yield_0 = compiler_tokens_TokenType_SizeOf;
      } else if (str_eq(__match_var_420, "struct")) {
        __yield_0 = compiler_tokens_TokenType_Struct;
      } else if (str_eq(__match_var_420, "true")) {
        __yield_0 = compiler_tokens_TokenType_True;
      } else if (str_eq(__match_var_420, "then")) {
        __yield_0 = compiler_tokens_TokenType_Then;
      } else if (str_eq(__match_var_420, "typedef")) {
        __yield_0 = compiler_tokens_TokenType_TypeDef;
      } else if (str_eq(__match_var_420, "union")) {
        __yield_0 = compiler_tokens_TokenType_Union;
      } else if (str_eq(__match_var_420, "import")) {
        __yield_0 = compiler_tokens_TokenType_Import;
      } else if (str_eq(__match_var_420, "void")) {
        __yield_0 = compiler_tokens_TokenType_Void;
      } else if (str_eq(__match_var_420, "yield")) {
        __yield_0 = compiler_tokens_TokenType_Yield;
      } else if (str_eq(__match_var_420, "while")) {
        __yield_0 = compiler_tokens_TokenType_While;
      } else  {
        __yield_0 = compiler_tokens_TokenType_Identifier;
      }
    }

  __yield_0; });}


#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
char *compiler_tokens_TokenType_str(compiler_tokens_TokenType this) {
  return ({ char *__yield_0;

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/tokens.oc"
    switch ((this)) {
      case compiler_tokens_TokenType_And:
      m_421_0:
        {
          __yield_0 = "and";
        } break;
      case compiler_tokens_TokenType_As:
      m_421_1:
        {
          __yield_0 = "as";
        } break;
      case compiler_tokens_TokenType_Assert:
      m_421_2:
        {
          __yield_0 = "assert";
        } break;
      case compiler_tokens_TokenType_Break:
      m_421_3:
        {
          __yield_0 = "break";
        } break;
      case compiler_tokens_TokenType_Const:
      m_421_4:
        {
          __yield_0 = "const";
        } break;
      case compiler_tokens_TokenType_Continue:
      m_421_5:
        {
          __yield_0 = "continue";
        } break;
      case compiler_tokens_TokenType_Def:
      m_421_6:
        {
          __yield_0 = "def";
        } break;
      case compiler_tokens_TokenType_Defer:
      m_421_7:
        {
          __yield_0 = "defer";
        } break;
      case compiler_tokens_TokenType_Else:
      m_421_8:
        {
          __yield_0 = "else";
        } break;
      case compiler_tokens_TokenType_Enum:
      m_421_9:
        {
          __yield_0 = "enum";
        } break;
      case compiler_tokens_TokenType_Extern:
      m_421_10:
        {
          __yield_0 = "extern";
        } break;
      case compiler_tokens_TokenType_False:
      m_421_11:
        {
          __yield_0 = "false";
        } break;
      case compiler_tokens_TokenType_For:
      m_421_12:
        {
          __yield_0 = "for";
        } break;
      case compiler_tokens_TokenType_Fn:
      m_421_13:
        {
          __yield_0 = "fn";
        } break;
      case compiler_tokens_TokenType_If:
      m_421_14:
        {
          __yield_0 = "if";
        } break;
      case compiler_tokens_TokenType_Let:
      m_421_15:
        {
          __yield_0 = "let";
        } break;
      case compiler_tokens_TokenType_Match:
      m_421_16:
        {
          __yield_0 = "match";
        } break;
      case compiler_tokens_TokenType_Namespace:
      m_421_17:
        {
          __yield_0 = "namespace";
        } break;
      case compiler_tokens_TokenType_Not:
      m_421_18:
        {
          __yield_0 = "not";
        } break;
      case compiler_tokens_TokenType_Null:
      m_421_19:
        {
          __yield_0 = "null";
        } break;
      case compiler_tokens_TokenType_Or:
      m_421_20:
        {
          __yield_0 = "or";
        } break;
      case compiler_tokens_TokenType_Return:
      m_421_21:
        {
          __yield_0 = "return";
        } break;
      case compiler_tokens_TokenType_SizeOf:
      m_421_22:
        {
          __yield_0 = "sizeof";
        } break;
      case compiler_tokens_TokenType_Struct:
      m_421_23:
        {
          __yield_0 = "struct";
        } break;
      case compiler_tokens_TokenType_True:
      m_421_24:
        {
          __yield_0 = "true";
        } break;
      case compiler_tokens_TokenType_Then:
      m_421_25:
        {
          __yield_0 = "then";
        } break;
      case compiler_tokens_TokenType_TypeDef:
      m_421_26:
        {
          __yield_0 = "typedef";
        } break;
      case compiler_tokens_TokenType_Union:
      m_421_27:
        {
          __yield_0 = "union";
        } break;
      case compiler_tokens_TokenType_Import:
      m_421_28:
        {
          __yield_0 = "import";
        } break;
      case compiler_tokens_TokenType_Void:
      m_421_29:
        {
          __yield_0 = "void";
        } break;
      case compiler_tokens_TokenType_Yield:
      m_421_30:
        {
          __yield_0 = "yield";
        } break;
      case compiler_tokens_TokenType_While:
      m_421_31:
        {
          __yield_0 = "while";
        } break;
      default:
        {
          __yield_0 = compiler_tokens_TokenType_dbg(this);
        } break;
    }

  __yield_0; });}


#line 16 "compiler/main.oc"
void usage(i32 code, bool full) {

#line 17 "compiler/main.oc"
  printf("Usage:""\n");

#line 18 "compiler/main.oc"
  printf("   ./ocen [--help] [compile-options] <file>""\n");

#line 19 "compiler/main.oc"
  printf("   ./ocen lsp [--help] [lsp-options] <file>""\n");

#line 20 "compiler/main.oc"
  if (!(full)) {

#line 20 "compiler/main.oc"
    exit(code);
  }

#line 22 "compiler/main.oc"
  printf("--------------------------------------------------------""\n");

#line 23 "compiler/main.oc"
  printf("Compile Options:""\n");

#line 24 "compiler/main.oc"
  printf("    -o path        Output executable (default: ./out)""\n");

#line 25 "compiler/main.oc"
  printf("    -c path        Output C code (default: {out}.c)""\n");

#line 26 "compiler/main.oc"
  printf("    --no-stdlid    Don't include the standard library""\n");

#line 27 "compiler/main.oc"
  printf("    -e0            Minimal one-line errors""\n");

#line 28 "compiler/main.oc"
  printf("    -e1            Error messages with source code (default)""\n");

#line 29 "compiler/main.oc"
  printf("    -e2            Error messages with source / hints""\n");

#line 30 "compiler/main.oc"
  printf("    -s             Silent mode (no debug output)""\n");

#line 31 "compiler/main.oc"
  printf("    -n             Don't compile C code (default: false)""\n");

#line 32 "compiler/main.oc"
  printf("    --no-dce       Don't perform dead code elimination""\n");

#line 33 "compiler/main.oc"
  printf("    -d             Emit debug information (default: false)""\n");

#line 34 "compiler/main.oc"
  printf("    -l path        Directory to search for libraries (can be used multiple times)""\n");

#line 35 "compiler/main.oc"
  printf("    --docs path    Output documentation JSON (default: none)""\n");

#line 36 "compiler/main.oc"
  printf("    --cflags flags Additional C flags (can be used multiple times)""\n");

#line 37 "compiler/main.oc"
  printf("    -h             Display this information""\n");

#line 38 "compiler/main.oc"
  printf("    -r <args>      Run executable with arguments (can only be at the end)""\n");

#line 39 "compiler/main.oc"
  exit(code);
}


#line 54 "compiler/main.oc"
void save_and_compile_code(compiler_ast_program_Program *program, char *code) {

#line 55 "compiler/main.oc"
  if (!(((bool)c_path))) {

#line 56 "compiler/main.oc"
    c_path=std_format("%s.c", exec_path);
  }

#line 59 "compiler/main.oc"
  std_fs_write_file_str(c_path, code);

#line 61 "compiler/main.oc"
  if (!(compile_c)) {

#line 61 "compiler/main.oc"
    return;
  }

#line 63 "compiler/main.oc"
  std_buffer_Buffer cmd = std_buffer_Buffer_make(16);

#line 64 "compiler/main.oc"
  char *c_compiler = getenv("CC");

#line 65 "compiler/main.oc"
  if (!(((bool)c_compiler))) {

#line 65 "compiler/main.oc"
    c_compiler="gcc";
  }

#line 67 "compiler/main.oc"
  std_buffer_Buffer_write_str_f(&cmd, std_format("%s -o %s %s", c_compiler, exec_path, c_path));

#line 69 "compiler/main.oc"
  for (std_vector_Iterator__8 _i0 = std_vector_Vector__8_iter(program->c_flags); std_vector_Iterator__8_has_value(&_i0); std_vector_Iterator__8_next(&_i0)) {

#line 69 "compiler/main.oc"
    char *flag = std_vector_Iterator__8_cur(&_i0);

#line 69 "compiler/main.oc"
    {

#line 70 "compiler/main.oc"
      std_buffer_Buffer_write_str(&cmd, " ");

#line 71 "compiler/main.oc"
      std_buffer_Buffer_write_str(&cmd, flag);
    }
  }

#line 73 "compiler/main.oc"
  for (std_vector_Iterator__8 _i1 = std_vector_Vector__8_iter(extra_c_flags); std_vector_Iterator__8_has_value(&_i1); std_vector_Iterator__8_next(&_i1)) {

#line 73 "compiler/main.oc"
    char *flag = std_vector_Iterator__8_cur(&_i1);

#line 73 "compiler/main.oc"
    {

#line 74 "compiler/main.oc"
      std_buffer_Buffer_write_str(&cmd, " ");

#line 75 "compiler/main.oc"
      std_buffer_Buffer_write_str(&cmd, flag);
    }
  }

#line 77 "compiler/main.oc"
  if (debug) {

#line 77 "compiler/main.oc"
    std_buffer_Buffer_write_str(&cmd, " -ggdb3");
  }

#line 79 "compiler/main.oc"
  std_logging_log(std_logging_LogLevel_Info, "%.*s", (cmd).size, (cmd).data);

#line 80 "compiler/main.oc"
  i32 exit_code = system(std_buffer_Buffer_str(cmd));

#line 81 "compiler/main.oc"
  if (exit_code != 0) {

#line 82 "compiler/main.oc"
    std_logging_log(std_logging_LogLevel_Error, "Failed to compile C code");

#line 83 "compiler/main.oc"
    exit(1);
  }
}


#line 87 "compiler/main.oc"
void run_executable(i32 argc, char **argv) {

#line 88 "compiler/main.oc"
  std_buffer_Buffer cmd = std_buffer_Buffer_make(16);

#line 89 "compiler/main.oc"
  std_buffer_Buffer_write_str(&cmd, exec_path);

#line 90 "compiler/main.oc"
  for (i32 i = 0; i < argc; i++) {

#line 91 "compiler/main.oc"
    std_buffer_Buffer_write_str(&cmd, " ");

#line 92 "compiler/main.oc"
    std_buffer_Buffer_write_str(&cmd, argv[i]);
  }

#line 95 "compiler/main.oc"
  std_logging_log(std_logging_LogLevel_Info, "%.*s", (cmd).size, (cmd).data);

#line 96 "compiler/main.oc"
  i32 ret = system(std_buffer_Buffer_str(cmd));

#line 97 "compiler/main.oc"
  i32 exit_code = ((ret >> 8) & 0xFF);

#line 98 "compiler/main.oc"
  std_logging_log(std_logging_LogLevel_Info, "Exited with code: %d", exit_code);

#line 99 "compiler/main.oc"
  exit(exit_code);
}


#line 102 "compiler/main.oc"
void parse_args(i32 *argc, char ***argv, compiler_ast_program_Program *program) {

#line 103 "compiler/main.oc"
  extra_c_flags=std_vector_Vector__8_new(16);

#line 105 "compiler/main.oc"
  while ((*argc) > 0) {

#line 106 "compiler/main.oc"
    char *arg = std_shift_args(argc, argv, "here");

#line 107 "compiler/main.oc"
    {
      char *__match_var_422 = arg;
      if (str_eq(__match_var_422, "--help")) {

#line 108 "compiler/main.oc"
        usage(0, true);
      } else if (str_eq(__match_var_422, "-s")) {

#line 109 "compiler/main.oc"
        silent=true;
      } else if (str_eq(__match_var_422, "-d")) {

#line 110 "compiler/main.oc"
        debug=true;
      } else if (str_eq(__match_var_422, "-n")) {

#line 112 "compiler/main.oc"
        compile_c=false;
      } else if (str_eq(__match_var_422, "--no-dce")) {

#line 114 "compiler/main.oc"
        program->keep_all_code=true;
      } else if (str_eq(__match_var_422, "-o")) {

#line 115 "compiler/main.oc"
        exec_path=std_shift_args(argc, argv, "here");
      } else if (str_eq(__match_var_422, "-c")) {

#line 116 "compiler/main.oc"
        c_path=std_shift_args(argc, argv, "here");
      } else if (str_eq(__match_var_422, "-l")) {

#line 117 "compiler/main.oc"
        std_vector_Vector__8_push(program->library_paths, std_shift_args(argc, argv, "here"));
      } else if (str_eq(__match_var_422, "-e0")) {

#line 118 "compiler/main.oc"
        error_level=0;
      } else if (str_eq(__match_var_422, "-e1")) {

#line 119 "compiler/main.oc"
        error_level=1;
      } else if (str_eq(__match_var_422, "-e2")) {

#line 120 "compiler/main.oc"
        error_level=2;
      } else if (str_eq(__match_var_422, "--docs")) {

#line 122 "compiler/main.oc"
        docs_path=std_shift_args(argc, argv, "here");

#line 123 "compiler/main.oc"
        program->check_doc_links=true;
      } else if (str_eq(__match_var_422, "--no-stdlib")) {

#line 125 "compiler/main.oc"
        include_stdlib=false;
      } else if (str_eq(__match_var_422, "--cflags") || str_eq(__match_var_422, "-cf")) {

#line 126 "compiler/main.oc"
        std_vector_Vector__8_push(extra_c_flags, std_shift_args(argc, argv, "here"));
      } else if (str_eq(__match_var_422, "-r") || str_eq(__match_var_422, "--run")) {

#line 128 "compiler/main.oc"
        run_after_compile=true;

#line 130 "compiler/main.oc"
        break;
      } else  {

#line 133 "compiler/main.oc"
        if (arg[0]=='-') {

#line 134 "compiler/main.oc"
          printf("Unknown option: %s""\n", arg);

#line 135 "compiler/main.oc"
          usage(1, true);
        } else if (!(((bool)filename))) {

#line 137 "compiler/main.oc"
          filename=arg;
        } else {

#line 139 "compiler/main.oc"
          printf("Unknown option/argument: '%s'""\n", arg);

#line 140 "compiler/main.oc"
          usage(1, true);
        }
      }
    }
  }

#line 146 "compiler/main.oc"
  if (!(((bool)filename))) {

#line 147 "compiler/main.oc"
    printf("No file specified""\n");

#line 148 "compiler/main.oc"
    usage(1, false);
  }

#line 150 "compiler/main.oc"
  if (run_after_compile && !(compile_c)) {

#line 151 "compiler/main.oc"
    printf("Cannot run without compiling""\n");

#line 152 "compiler/main.oc"
    usage(1, false);
  }
}


#line 156 "compiler/main.oc"
i32 main(i32 argc, char **argv) {

#line 157 "compiler/main.oc"
  std_shift_args(&argc, &argv, "here");

#line 158 "compiler/main.oc"
  if ((argc > 1) && str_eq(argv[0], "lsp")) {

#line 159 "compiler/main.oc"
    compiler_lsp_lsp_main(argc, argv);

#line 160 "compiler/main.oc"
    exit(0);
  }

#line 163 "compiler/main.oc"
  compiler_ast_program_Program *program = compiler_ast_program_Program_new();

#line 164 "compiler/main.oc"
  compiler_ast_program_Program_setup_library_paths(program);

#line 166 "compiler/main.oc"
  parse_args(&argc, &argv, program);

#line 168 "compiler/main.oc"
  std_logging_LogLevel level = ({ std_logging_LogLevel __yield_0;

#line 168 "compiler/main.oc"
    if (silent) {
      __yield_0 = std_logging_LogLevel_Error;
    } else {
      __yield_0 = std_logging_LogLevel_Info;
    }
  __yield_0; });

#line 173 "compiler/main.oc"
  std_logging_init_logging(level, NULL);

#line 175 "compiler/main.oc"
  program->error_level=error_level;

#line 176 "compiler/main.oc"
  program->gen_debug_info=debug;

#line 177 "compiler/main.oc"
  program->include_stdlib=include_stdlib;

#line 178 "compiler/main.oc"
  compiler_parser_Parser_parse_toplevel(program, filename, NULL, true);

#line 180 "compiler/main.oc"
  compiler_passes_run_typecheck_passes(program);

#line 182 "compiler/main.oc"
  compiler_ast_program_Program_exit_with_errors_if_any(program);

#line 183 "compiler/main.oc"
  if (((bool)docs_path)) {

#line 184 "compiler/main.oc"
    compiler_docgen_generate_doc_json(program, docs_path);
  } else {

#line 187 "compiler/main.oc"
    char *code = compiler_passes_run_codegen_passes(program);

#line 189 "compiler/main.oc"
    compiler_ast_program_Program_exit_with_errors_if_any(program);

#line 190 "compiler/main.oc"
    save_and_compile_code(program, code);

#line 192 "compiler/main.oc"
    if (run_after_compile) {

#line 192 "compiler/main.oc"
      run_executable(argc, argv);
    }
  }
}


#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
char *compiler_types_BaseType_str(compiler_types_BaseType this) {
  return ({ char *__yield_0;

#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this)) {
      case compiler_types_BaseType_Char:
      m_423_0:
        {
          __yield_0 = "char";
        } break;
      case compiler_types_BaseType_Bool:
      m_423_1:
        {
          __yield_0 = "bool";
        } break;
      case compiler_types_BaseType_Void:
      m_423_2:
        {
          __yield_0 = "void";
        } break;
      case compiler_types_BaseType_I8:
      m_423_3:
        {
          __yield_0 = "i8";
        } break;
      case compiler_types_BaseType_I16:
      m_423_4:
        {
          __yield_0 = "i16";
        } break;
      case compiler_types_BaseType_I32:
      m_423_5:
        {
          __yield_0 = "i32";
        } break;
      case compiler_types_BaseType_I64:
      m_423_6:
        {
          __yield_0 = "i64";
        } break;
      case compiler_types_BaseType_U8:
      m_423_7:
        {
          __yield_0 = "u8";
        } break;
      case compiler_types_BaseType_U16:
      m_423_8:
        {
          __yield_0 = "u16";
        } break;
      case compiler_types_BaseType_U32:
      m_423_9:
        {
          __yield_0 = "u32";
        } break;
      case compiler_types_BaseType_U64:
      m_423_10:
        {
          __yield_0 = "u64";
        } break;
      case compiler_types_BaseType_F32:
      m_423_11:
        {
          __yield_0 = "f32";
        } break;
      case compiler_types_BaseType_F64:
      m_423_12:
        {
          __yield_0 = "f64";
        } break;
      default:
        {
          __yield_0 = compiler_types_BaseType_dbg(this);
        } break;
    }

  __yield_0; });}


#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_BaseType_is_callable(compiler_types_BaseType this) {
  return (this==compiler_types_BaseType_FunctionPtr || this==compiler_types_BaseType_Closure);}


#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_shallow_copy(compiler_types_Type *old) {

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_types_Type *new = std_mem_alloc__20(1);

#line 119 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  (*new)=(*old);

#line 120 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return new;
}


#line 123 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_new_resolved(compiler_types_BaseType base, std_span_Span span) {

#line 124 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_types_Type *type = std_mem_alloc__20(1);

#line 125 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->base=base;

#line 126 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->span=span;

#line 127 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->name=compiler_types_BaseType_str(base);

#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->methods=std_map_Map__8_new(8);

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return type;
}


#line 132 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_new_unresolved(char *name, std_span_Span span) {

#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_Unresolved, span);

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->name=name;

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return type;
}


#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_new_unresolved_base(compiler_types_BaseType base, std_span_Span span) {

#line 139 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_ast_nodes_AST *ident = compiler_ast_nodes_AST_new(compiler_ast_nodes_ASTType_Identifier, span);

#line 140 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  ident->u.ident.name=compiler_types_BaseType_str(base);

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_types_Type *type = compiler_types_Type_new_resolved(compiler_types_BaseType_Unresolved, span);

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  type->u.unresolved=ident;

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return type;
}


#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_integer(compiler_types_Type *this) {
  return ({ bool __yield_0;

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      m_424_0:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_float(compiler_types_Type *this) {
  return (this->base==compiler_types_BaseType_F32 || this->base==compiler_types_BaseType_F64);}


#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_numeric(compiler_types_Type *this) {
  return ({ bool __yield_0;

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this->base)) {
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      m_425_0:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_numeric_or_char(compiler_types_Type *this) {
  return (compiler_types_Type_is_numeric(this) || this->base==compiler_types_BaseType_Char);}


#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_can_have_methods(compiler_types_Type *this) {
  return ({ bool __yield_0;

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this->base)) {
      case compiler_types_BaseType_Char:
      case compiler_types_BaseType_Bool:
      case compiler_types_BaseType_Void:
      case compiler_types_BaseType_I8:
      case compiler_types_BaseType_I16:
      case compiler_types_BaseType_I32:
      case compiler_types_BaseType_I64:
      case compiler_types_BaseType_U8:
      case compiler_types_BaseType_U16:
      case compiler_types_BaseType_U32:
      case compiler_types_BaseType_U64:
      case compiler_types_BaseType_F32:
      case compiler_types_BaseType_F64:
      case compiler_types_BaseType_Structure:
      case compiler_types_BaseType_Alias:
      case compiler_types_BaseType_Enum:
      m_426_0:
        {
          __yield_0 = true;
        } break;
      default:
        {
          __yield_0 = false;
        } break;
    }

  __yield_0; });}


#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_resolved(compiler_types_Type *this) {
  return ({ bool __yield_0;

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this->base)) {
      case compiler_types_BaseType_Unresolved:
      m_427_0:
        {
          __yield_0 = false;
        } break;
      case compiler_types_BaseType_Alias:
      m_427_1:
        {
          __yield_0 = compiler_types_Type_is_resolved(this->u.ptr);
        } break;
      case compiler_types_BaseType_Pointer:
      m_427_2:
        {
          __yield_0 = compiler_types_Type_is_resolved(this->u.ptr);
        } break;
      case compiler_types_BaseType_FunctionPtr:
      m_427_3:
        {

#line 176 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          bool resolved = compiler_types_Type_is_resolved(this->u.func.return_type);

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          for (std_vector_Iterator__3 _i52 = std_vector_Vector__3_iter(this->u.func.params); std_vector_Iterator__3_has_value(&_i52); std_vector_Iterator__3_next(&_i52)) {

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            compiler_ast_nodes_Variable *param = std_vector_Iterator__3_cur(&_i52);

#line 177 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            {

#line 178 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
              resolved=(resolved && compiler_types_Type_is_resolved(param->type));
            }
          }

#line 180 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          __yield_0 = resolved;
        } break;
      default:
        {
          __yield_0 = true;
        } break;
    }

  __yield_0; });}


#line 185 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_eq(compiler_types_Type *this, compiler_types_Type *other, bool strict) {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this==NULL && other==NULL) {

#line 186 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return true;
  }

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this==NULL || other==NULL) {

#line 187 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return false;
  }

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this->base==compiler_types_BaseType_Alias) {

#line 190 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return compiler_types_Type_eq(this->u.ptr, other, strict);
  }

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (other->base==compiler_types_BaseType_Alias) {

#line 191 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return compiler_types_Type_eq(this, other->u.ptr, strict);
  }

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this->base != other->base) {

#line 193 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return false;
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  switch ((this->base)) {
    case compiler_types_BaseType_Error:
    case compiler_types_BaseType_Unresolved:
    case compiler_types_BaseType_UnresolvedTemplate:
    m_428_0:
      {

#line 196 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return false;
      } break;
    case compiler_types_BaseType_Closure:
    m_428_1:
      {

#line 198 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return str_eq(this->sym->full_name, other->sym->full_name);
      } break;
    case compiler_types_BaseType_FunctionPtr:
    m_428_2:
      {

#line 200 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        compiler_types_FunctionType af = this->u.func;

#line 201 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        compiler_types_FunctionType bf = other->u.func;

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (!(compiler_types_Type_eq(af.return_type, bf.return_type, true))) {

#line 202 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return false;
        }

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (af.params->size != bf.params->size) {

#line 203 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return false;
        }

#line 204 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        for (u32 i = 0; i < af.params->size; i+=1) {

#line 205 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          compiler_ast_nodes_Variable *a = std_vector_Vector__3_at(af.params, i);

#line 206 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          compiler_ast_nodes_Variable *b = std_vector_Vector__3_at(bf.params, i);

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          if (!(compiler_types_Type_eq(a->type, b->type, true))) {

#line 207 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            return false;
          }
        }

#line 210 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return true;
      } break;
    case compiler_types_BaseType_Pointer:
    m_428_3:
      {

#line 213 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (!(strict)) {

#line 214 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          if (this->u.ptr->base==compiler_types_BaseType_Void || other->u.ptr->base==compiler_types_BaseType_Void) {

#line 215 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            return true;
          }
        }

#line 218 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return compiler_types_Type_eq(this->u.ptr, other->u.ptr, true);
      } break;
    case compiler_types_BaseType_Structure:
    m_428_4:
      {

#line 220 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return this->u.struc==other->u.struc;
      } break;
    case compiler_types_BaseType_Enum:
    m_428_5:
      {

#line 221 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return this->u.enom==other->u.enom;
      } break;
    case compiler_types_BaseType_Array:
    m_428_6:
      {

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (!(compiler_types_Type_eq(this->u.arr.elem_type, other->u.arr.elem_type, true))) {

#line 223 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return false;
        }

#line 224 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (this->u.arr.size_known && other->u.arr.size_known) {

#line 225 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return this->u.arr.size==other->u.arr.size;
        }

#line 228 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        return true;
      } break;
    default:
      {

#line 231 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if (((u32)this->base) < ((u32)compiler_types_BaseType_NUM_BASE_TYPES)) {

#line 232 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return true;
        }

#line 235 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
        if(!(false)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/compiler/types.oc:235:20: Assertion failed: `false`", std_format("Unhandled case in Type::eq(), base = %s", compiler_types_BaseType_dbg(this->base))); exit(1); }
      } break;
  }
}


#line 240 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
bool compiler_types_Type_is_str(compiler_types_Type *this) {

#line 241 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return this->base==compiler_types_BaseType_Alias && str_eq(this->sym->full_name, "str");
}


#line 245 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_unaliased(compiler_types_Type *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this->base != compiler_types_BaseType_Alias) {

#line 246 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return this;
  }

#line 247 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return compiler_types_Type_unaliased(this->u.ptr);
}


#line 250 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
compiler_types_Type *compiler_types_Type_decay_array(compiler_types_Type *this) {

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  if (this->base != compiler_types_BaseType_Array) {

#line 251 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    return this;
  }

#line 252 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  compiler_types_Type *res = compiler_types_Type_new_resolved(compiler_types_BaseType_Pointer, this->span);

#line 253 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  res->u.ptr=this->u.arr.elem_type;

#line 254 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
  return res;
}


#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
char *compiler_types_Type_str(compiler_types_Type *this) {
  return ({ char *__yield_0;

#line 257 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
    switch ((this->base)) {
      case compiler_types_BaseType_Pointer:
      m_429_0:
        {
          __yield_0 = std_format("&%s", compiler_types_Type_str(this->u.ptr));
        } break;
      case compiler_types_BaseType_Closure:
      case compiler_types_BaseType_FunctionPtr:
      m_429_1:
        {

#line 260 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 261 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          if (this->base==compiler_types_BaseType_Closure) {

#line 262 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            std_buffer_Buffer_write_str(&buf, "@");
          }

#line 264 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, "fn(");

#line 265 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          for (u32 i = 0; i < this->u.func.params->size; i+=1) {

#line 266 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            compiler_ast_nodes_Variable *param = std_vector_Vector__3_at(this->u.func.params, i);

#line 267 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            if (((bool)param->type)) {

#line 268 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
              std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(param->type));
            } else {

#line 270 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
              std_buffer_Buffer_write_str(&buf, "<unknown>");
            }

#line 272 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            if (i < (this->u.func.params->size - 1)) {

#line 273 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
              std_buffer_Buffer_write_str(&buf, ", ");
            }
          }

#line 276 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, "): ");

#line 277 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(this->u.func.return_type));

#line 278 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return std_buffer_Buffer_str(buf);
        } break;
      case compiler_types_BaseType_Array:
      m_429_2:
        {

#line 281 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer buf = std_buffer_Buffer_make(16);

#line 282 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, compiler_types_Type_str(this->u.arr.elem_type));

#line 283 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, "[");

#line 284 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          if (this->u.arr.size_known) {

#line 285 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            std_buffer_Buffer_write_str(&buf, std_format("%u", this->u.arr.size));
          } else {

#line 288 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
            std_buffer_Buffer_write_str(&buf, std_format("?%p", this));
          }

#line 290 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          std_buffer_Buffer_write_str(&buf, "]");

#line 291 "/Users/mustafa/ocen-lang/ocen/compiler/types.oc"
          return std_buffer_Buffer_str(buf);
        } break;
      case compiler_types_BaseType_Structure:
      m_429_3:
        {
          __yield_0 = this->u.struc->sym->display;
        } break;
      case compiler_types_BaseType_Enum:
      m_429_4:
        {
          __yield_0 = this->u.enom->sym->display;
        } break;
      case compiler_types_BaseType_Alias:
      m_429_5:
        {
          __yield_0 = this->name;
        } break;
      default:
        {
          __yield_0 = compiler_types_BaseType_str(this->base);
        } break;
    }

  __yield_0; });}


#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
char *compiler_errors_MessageType_to_color(compiler_errors_MessageType this) {
  return ({ char *__yield_0;

#line 34 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    switch ((this)) {
      case compiler_errors_MessageType_Error:
      m_430_0:
        {
          __yield_0 = "\x1b[31m";
        } break;
      case compiler_errors_MessageType_Warning:
      m_430_1:
        {
          __yield_0 = "\x1b[33m";
        } break;
      case compiler_errors_MessageType_Note:
      m_430_2:
        {
          __yield_0 = "\x1b[32m";
        } break;
    }

  __yield_0; });}


#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
char *compiler_errors_MessageType_str(compiler_errors_MessageType this) {
  return ({ char *__yield_0;

#line 40 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    switch ((this)) {
      case compiler_errors_MessageType_Error:
      m_431_0:
        {
          __yield_0 = "Error";
        } break;
      case compiler_errors_MessageType_Warning:
      m_431_1:
        {
          __yield_0 = "Warning";
        } break;
      case compiler_errors_MessageType_Note:
      m_431_2:
        {
          __yield_0 = "Note";
        } break;
    }

  __yield_0; });}


#line 46 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_display_line(void) {

#line 47 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  printf("--------------------------------------------------------------------------------""\n");
}


#line 50 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_display_message(compiler_errors_MessageType type, std_span_Span span, char *msg) {

#line 51 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_display_line();

#line 52 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  char *filename = span.start.filename;

#line 53 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  if (str_eq(filename, "<default>") || span.start.line==0) {

#line 54 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    printf("%s: %s""\n", compiler_errors_MessageType_str(type), msg);
  } else {

#line 56 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    printf("%s: %s: %s""\n", std_span_Location_str(&span.start), compiler_errors_MessageType_str(type), msg);
  }

#line 58 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_display_line();
}


#line 61 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_display_message_span(compiler_errors_MessageType type, std_span_Span span, char *msg, bool line_after) {

#line 62 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  char *color = compiler_errors_MessageType_to_color(type);

#line 63 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  char *reset = "\x1b[0m";

#line 65 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_display_message(type, span, msg);

#line 67 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  char *filename = span.start.filename;

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  if (!(std_fs_file_exists(filename))) {

#line 68 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    return;
  }

#line 70 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  std_buffer_Buffer contents = std_fs_read_file(filename);

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"

#line 73 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 around_offset = 1;

#line 74 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 min_line = u32_max((span.start.line - around_offset), 1);

#line 75 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 max_line = (span.end.line + around_offset);

#line 76 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  max_line=u32_min(max_line, (min_line + 10));

#line 79 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 line_no = 1;

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  for (std_sv_SVLineIterator _i93 = std_sv_SV_lines(std_buffer_Buffer_sv(contents)); std_sv_SVLineIterator_has_value(&_i93); std_sv_SVLineIterator_next(&_i93)) {

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    std_sv_SV line = std_sv_SVLineIterator_cur(&_i93);

#line 80 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
      if (line_no > max_line) {

#line 81 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        break;
      }

#line 82 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
      if (line_no >= min_line) {

#line 83 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        printf("%4d | ", line_no);

#line 84 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        if (line_no==span.start.line) {

#line 85 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          u32 start_col = (span.start.col - 1);

#line 86 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          u32 end_col = (span.end.col - 1);

#line 87 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          if (span.end.line != span.start.line) {

#line 88 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
            end_col=line.len;
          }

#line 90 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          for (u32 i = 0; i < start_col; i+=1) {

#line 91 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
            printf("%c", std_sv_SV_at(line, i));
          }

#line 93 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          printf("%s", color);

#line 94 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          for (u32 i = start_col; i < end_col; i+=1) {

#line 95 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
            printf("%c", std_sv_SV_at(line, i));
          }

#line 97 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          std_sv_SV remaining_line = std_sv_SV_slice(line, end_col, 0);

#line 98 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          printf("%s%.*s\n", reset, (remaining_line).len, (remaining_line).data);

#line 99 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          printf("%*s%s^ %s%s""\n", (start_col + 7), "", color, msg, reset);
        } else {

#line 101 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
          printf("%.*s\n", (line).len, (line).data);
        }
      }

#line 104 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
      line_no+=1;
    }
  }

#line 106 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  if (line_after) {

#line 107 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    compiler_errors_display_line();
  }
  /* defers */

#line 71 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  std_buffer_Buffer_free(&contents);
}


#line 111 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_Error_display(compiler_errors_Error *this) {

#line 112 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  switch ((this->type)) {
    case compiler_errors_ErrorType_Standard:
    m_432_0:
      {

#line 114 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, true);
      } break;
    case compiler_errors_ErrorType_WithNote:
    m_432_1:
      {

#line 117 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, false);

#line 118 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message(compiler_errors_MessageType_Note, this->span1, this->msg2);
      } break;
    case compiler_errors_ErrorType_WithHint:
    m_432_2:
      {

#line 121 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, this->span1, this->msg1, false);

#line 122 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message_span(compiler_errors_MessageType_Note, this->span2, this->msg2, true);
      } break;
  }
}


#line 128 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_Error_panic(compiler_errors_Error *this) {

#line 129 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_Error_display(this);

#line 130 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  exit(1);
}


#line 133 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
compiler_errors_Error *compiler_errors_Error_new(std_span_Span span, char *msg) {

#line 134 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_Error *err = std_mem_alloc__21(1);

#line 135 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->type=compiler_errors_ErrorType_Standard;

#line 136 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->msg1=msg;

#line 137 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->span1=span;

#line 138 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  return err;
}


#line 141 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
compiler_errors_Error *compiler_errors_Error_new_note(std_span_Span span, char *msg, char *note) {

#line 142 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_Error *err = std_mem_alloc__21(1);

#line 143 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->type=compiler_errors_ErrorType_WithNote;

#line 144 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->msg1=msg;

#line 145 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->span1=span;

#line 146 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->msg2=note;

#line 147 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  return err;
}


#line 150 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
compiler_errors_Error *compiler_errors_Error_new_hint(std_span_Span span, char *msg, std_span_Span span2, char *hint) {

#line 151 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  compiler_errors_Error *err = std_mem_alloc__21(1);

#line 152 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->type=compiler_errors_ErrorType_WithHint;

#line 153 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->msg1=msg;

#line 154 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->span1=span;

#line 155 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->msg2=hint;

#line 156 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  err->span2=span2;

#line 157 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  return err;
}


#line 160 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
void compiler_errors_display_error_messages(std_vector_Vector__13 *errors, u32 detail_level) {

#line 161 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  char *num_errors_env = getenv("OCEN_NUM_ERRORS");

#line 162 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 max_num_errors = (((bool)num_errors_env) ? str_to_u32(num_errors_env) : 10);

#line 164 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  u32 num_errors = u32_min(errors->size, max_num_errors);

#line 165 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
  for (u32 i = 0; i < num_errors; i+=1) {

#line 166 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    compiler_errors_Error *err = std_vector_Vector__13_at(errors, ((num_errors - i) - 1));

#line 168 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
    switch (detail_level) {
      case 0: {

#line 169 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        printf("%s: %s""\n", std_span_Location_str(&err->span1.start), err->msg1);
      } break;
      case 1: {

#line 170 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_display_message_span(compiler_errors_MessageType_Error, err->span1, err->msg1, true);
      } break;
      case 2: {

#line 171 "/Users/mustafa/ocen-lang/ocen/compiler/errors.oc"
        compiler_errors_Error_display(err);
      } break;
      default: std_panic("invalid detail level"); break;
    }
  }
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
void std_panic(char *msg) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  dump_backtrace();

#line 14 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  printf("--------------------------------------------------------------------------------""\n");

#line 15 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  printf("%s""\n", msg);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  oc_trap();

#line 17 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  exit(1);
}


#line 22 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
u32 str_to_u32(char *this) {
  return ((u32)atoi(this));}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool str_eq(char *this, char *other) {

#line 33 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  void *a = ((void *)this);

#line 34 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  void *b = ((void *)other);

#line 35 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  if (a==b) {

#line 35 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    return true;
  }

#line 36 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  if (!((((bool)a) && ((bool)b)))) {

#line 36 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    return false;
  }

#line 37 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return strcmp(this, other)==0;
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
char *std_format(char *fmt, ...) {

#line 45 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"

#line 47 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  va_list args = {0};

#line 48 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  va_start(args, fmt);

#line 49 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  u32 size = vsnprintf(NULL, 0, fmt, args);

#line 50 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  va_end(args);

#line 52 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  va_start(args, fmt);

#line 53 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  char *s = std_mem_alloc__22(((u32)(size + 1)));

#line 54 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  vsnprintf(s, (size + 1), fmt, args);

#line 55 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  s[size]='\0';

#line 56 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  va_end(args);

#line 57 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return s;
}


#line 60 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
char *str_substring(char *this, u32 start, u32 len) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  char *new_str = std_mem_alloc__22(((u32)(len + 1)));

#line 62 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  memcpy(new_str, &this[start], len);

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return new_str;
}


#line 66 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool str_ends_with(char *this, char *suffix) {

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  u32 suffix_len = strlen(suffix);

#line 68 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  u32 len = strlen(this);

#line 69 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  if (suffix_len > len) {

#line 70 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    return false;
  }

#line 72 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  for (u32 i = 0; i < suffix_len; i+=1) {

#line 73 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    if (this[((len - suffix_len) + i)] != suffix[i]) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
      return false;
    }
  }

#line 77 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return true;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool str_starts_with(char *this, char *prefix) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  u32 prefix_len = strlen(prefix);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  u32 len = strlen(this);

#line 83 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  if (prefix_len > len) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    return false;
  }

#line 86 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  for (u32 i = 0; i < prefix_len; i+=1) {

#line 87 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    if (this[i] != prefix[i]) {

#line 88 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
      return false;
    }
  }

#line 91 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return true;
}


#line 94 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
void str_strip_trailing_whitespace(char *this) {

#line 95 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  for (u32 i = (strlen(this) - 1); i >= 0; i-=1) {

#line 96 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    if (this[i] != ' ') {

#line 96 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
      break;
    }

#line 97 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    this[i]='\0';
  }
}


#line 105 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
void str_replace_with(char **this, char *other) {

#line 106 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  std_mem_free((*this));

#line 107 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  (*this)=other;
}


#line 110 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
void str_free(char **this) {

#line 111 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  std_mem_free((*this));

#line 112 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  (*this)=NULL;
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
std_CharIterator str_chars(char *this, u32 start) {
  return (std_CharIterator){.data=this, .len=strlen(this), .pos=start};}


#line 123 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool std_CharIterator_has_value(std_CharIterator *this) {
  return (this->pos < this->len);}


#line 124 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
u32 std_CharIterator_next(std_CharIterator *this) {
  return this->pos++;}


#line 125 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
char std_CharIterator_cur(std_CharIterator *this) {
  return this->data[this->pos];}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool char_is_digit(char this) {
  return isdigit(this);}


#line 128 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool char_is_hex_digit(char this) {
  return isxdigit(this);}


#line 137 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool char_is_alpha(char this) {
  return isalpha(this);}


#line 138 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool char_is_alnum(char this) {
  return isalnum(this);}


#line 139 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
bool char_is_print(char this) {
  return isprint(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
u32 u32_min(u32 this, u32 other) {
  return ((this < other) ? this : other);}


#line 152 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
u32 u32_max(u32 this, u32 other) {
  return ((this > other) ? this : other);}


#line 164 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
char *std_shift_args(i32 *argc, char ***argv, char *where) {

#line 165 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  if ((*argc)==0) {

#line 166 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    printf("Expected argument but got none\n");

#line 167 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
    exit(1);
  }

#line 169 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  char *arg = (*argv)[0];

#line 170 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  (*argv)=((*argv) + 1);

#line 171 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  (*argc)=((*argc) - 1);

#line 172 "/Users/mustafa/ocen-lang/ocen/std/mod.oc"
  return arg;
}


#line 19 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
bool std_sv_SV_is_empty(std_sv_SV *this) {
  return this->len==0;}


#line 22 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_from_str(char *s) {
  return (std_sv_SV){.data=s, .len=strlen(s)};}


#line 25 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_get(std_sv_SV this, u32 n) {
  return (std_sv_SV){.data=this.data, .len=n};}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
char std_sv_SV_at(std_sv_SV this, u32 n) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  if(!(n < this.len)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/sv.oc:30:12: Assertion failed: `n < .len`", "Index out of bounds in SV::at"); }

#line 31 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  return this.data[n];
}


#line 81 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_chop_by_delim(std_sv_SV *this, char delim) {

#line 82 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  u32 i = 0;

#line 83 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  while ((i < this->len) && (this->data[i] != delim)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    i+=1;
  }

#line 86 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  std_sv_SV res = std_sv_SV_get((*this), i);

#line 87 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  if (i==this->len) {

#line 88 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    this->data=(this->data + i);

#line 89 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    this->len-=i;
  } else {

#line 91 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    this->data=((this->data + i) + 1);

#line 92 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    this->len-=(i + 1);
  }

#line 94 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  return res;
}


#line 98 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_chop_by_sv(std_sv_SV *this, std_sv_SV delim) {

#line 99 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  for (u32 i = 0; i < ((this->len - delim.len) + 1); i++) {

#line 100 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    if (memcmp((this->data + i), delim.data, delim.len)==0) {

#line 101 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
      std_sv_SV res = std_sv_SV_get((*this), i);

#line 102 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
      this->data=((this->data + i) + delim.len);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
      this->len-=(i + delim.len);

#line 104 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
      return res;
    }
  }

#line 107 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  std_sv_SV res = std_sv_SV_get((*this), this->len);

#line 108 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  this->data=(this->data + this->len);

#line 109 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  this->len=0;

#line 110 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  return res;
}


#line 187 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_chop_line(std_sv_SV *this) {
  return std_sv_SV_chop_by_delim(this, '\n');}


#line 248 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SV_slice(std_sv_SV this, u32 off, u32 end) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  if (end==0) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    end=this.len;
  }

#line 250 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  if (end > this.len) {

#line 250 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    end=this.len;
  }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  if (off >= end) {

#line 251 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
    off=end;
  }

#line 252 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  return (std_sv_SV){.data=(this.data + off), .len=(end - off)};
}


#line 268 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SVLineIterator std_sv_SV_lines(std_sv_SV this) {
  return (std_sv_SVLineIterator){.sv=this};}


#line 272 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SVSplitIterator std_sv_SV_split_str(std_sv_SV this, char *delim) {
  return (std_sv_SVSplitIterator){.sv=this, .delim=std_sv_SV_from_str(delim)};}


#line 289 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
char *std_sv_SV_copy_data_to_cstr(std_sv_SV this) {

#line 290 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  char *buf = std_mem_alloc__22((this.len + 1));

#line 291 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  memcpy(buf, this.data, this.len);

#line 292 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  buf[this.len]='\0';

#line 293 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
  return buf;
}


#line 300 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
bool std_sv_SVLineIterator_has_value(std_sv_SVLineIterator *this) {
  return !(std_sv_SV_is_empty(&this->sv));}


#line 301 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SVLineIterator_cur(std_sv_SVLineIterator *this) {
  return std_sv_SV_chop_line(&this->sv);}


#line 302 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
void std_sv_SVLineIterator_next(std_sv_SVLineIterator *this) {
}


#line 309 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
bool std_sv_SVSplitIterator_has_value(std_sv_SVSplitIterator *this) {
  return !(std_sv_SV_is_empty(&this->sv));}


#line 310 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
std_sv_SV std_sv_SVSplitIterator_cur(std_sv_SVSplitIterator *this) {
  return std_sv_SV_chop_by_sv(&this->sv, this->delim);}


#line 311 "/Users/mustafa/ocen-lang/ocen/std/sv.oc"
void std_sv_SVSplitIterator_next(std_sv_SVSplitIterator *this) {
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_passes_mark_dead_code_MarkDeadCode *std_mem_alloc__0(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_passes_mark_dead_code_MarkDeadCode *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_mark_dead_code_MarkDeadCode)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_passes_generic_pass_GenericPass *std_mem_alloc__1(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_passes_generic_pass_GenericPass *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_generic_pass_GenericPass)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_passes_reorder_symbols_ReorderSymbols *std_mem_alloc__2(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_passes_reorder_symbols_ReorderSymbols *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_passes_reorder_symbols_ReorderSymbols)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_program_Namespace *std_mem_alloc__3(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_program_Namespace *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Namespace)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_program_Program *std_mem_alloc__4(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_program_Program *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Program)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_TemplateInstance *std_mem_alloc__5(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_TemplateInstance *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Template *std_mem_alloc__6(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Template *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Template)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Symbol *std_mem_alloc__7(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Symbol *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Symbol)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Scope *std_mem_alloc__8(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Scope *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Scope)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Variable *std_mem_alloc__9(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Variable *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Variable)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Structure *std_mem_alloc__10(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Structure *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Structure)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Enum *std_mem_alloc__11(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Enum *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Enum)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_EnumVariant *std_mem_alloc__12(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_EnumVariant *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_EnumVariant)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Function *std_mem_alloc__13(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Function *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Function)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Argument *std_mem_alloc__14(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Argument *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Argument)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_ImportPart *std_mem_alloc__15(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_ImportPart *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_ImportPart)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCond *std_mem_alloc__16(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_MatchCond *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCond)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_AST *std_mem_alloc__17(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_AST *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_AST)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_attributes_Attribute *std_mem_alloc__18(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_attributes_Attribute *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_attributes_Attribute)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_tokens_Token *std_mem_alloc__19(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_tokens_Token *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_tokens_Token)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_types_Type *std_mem_alloc__20(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_types_Type *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_types_Type)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_errors_Error *std_mem_alloc__21(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_errors_Error *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_errors_Error)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
char *std_mem_alloc__22(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((char *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(char)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
i32 *std_mem_alloc__23(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((i32 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(i32)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Map__0 *std_mem_alloc__24(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_compact_map_Map__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Map__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Map__1 *std_mem_alloc__25(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_compact_map_Map__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Map__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
u8 *std_mem_alloc__26(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((u8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(u8)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_set_Set__0 *std_mem_alloc__27(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_set_Set__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_set_Set__1 *std_mem_alloc__28(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_set_Set__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_set_Set__2 *std_mem_alloc__29(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_set_Set__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__2)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_set_Set__3 *std_mem_alloc__30(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_set_Set__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_set_Set__3)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_value_Value *std_mem_alloc__31(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_value_Value *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_value_Value)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__0 *std_mem_alloc__32(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__0 **std_mem_alloc__33(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__0 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__0 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__0 *std_mem_alloc__34(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__1 *std_mem_alloc__35(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__1 **std_mem_alloc__36(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__1 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__1 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__1 *std_mem_alloc__37(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__2 *std_mem_alloc__38(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__2)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__2 **std_mem_alloc__39(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__2 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__2 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__2 *std_mem_alloc__40(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__2)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__3 *std_mem_alloc__41(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__3)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__3 **std_mem_alloc__42(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__3 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__3 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__3 *std_mem_alloc__43(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__3)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__4 *std_mem_alloc__44(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__4)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__4 **std_mem_alloc__45(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__4 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__4 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__4 *std_mem_alloc__46(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__4)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__5 *std_mem_alloc__47(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__5)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__5 **std_mem_alloc__48(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__5 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__5 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__5 *std_mem_alloc__49(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__5)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__6 *std_mem_alloc__50(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__6)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__6 **std_mem_alloc__51(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__6 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__6 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__6 *std_mem_alloc__52(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__6)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__7 *std_mem_alloc__53(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__7)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__7 **std_mem_alloc__54(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__7 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__7 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__7 *std_mem_alloc__55(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__7)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__8 *std_mem_alloc__56(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__8)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__8 **std_mem_alloc__57(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__8 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__8 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__8 *std_mem_alloc__58(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__8)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__9 *std_mem_alloc__59(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__9)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__9 **std_mem_alloc__60(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__9 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__9 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__9 *std_mem_alloc__61(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__9)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__10 *std_mem_alloc__62(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__10)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__10 **std_mem_alloc__63(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__10 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__10 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__10 *std_mem_alloc__64(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__10)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__11 *std_mem_alloc__65(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__11)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__11 **std_mem_alloc__66(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__11 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__11 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__11 *std_mem_alloc__67(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__11)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__12 *std_mem_alloc__68(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__12)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__12 **std_mem_alloc__69(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__12 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__12 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__12 *std_mem_alloc__70(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__12)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__13 *std_mem_alloc__71(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__13)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Item__13 **std_mem_alloc__72(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Item__13 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Item__13 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_map_Map__13 *std_mem_alloc__73(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_map_Map__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_map_Map__13)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__0 *std_mem_alloc__74(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_types_Type **std_mem_alloc__75(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_types_Type **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_types_Type *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__1 *std_mem_alloc__76(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Scope **std_mem_alloc__77(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Scope **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Scope *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__2 *std_mem_alloc__78(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__2 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__2)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_program_Namespace **std_mem_alloc__79(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_program_Namespace **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_program_Namespace *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__3 *std_mem_alloc__80(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__3 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__3)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Variable **std_mem_alloc__81(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Variable **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Variable *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__4 *std_mem_alloc__82(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__4 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__4)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_TemplateInstance **std_mem_alloc__83(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_TemplateInstance **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__5 *std_mem_alloc__84(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__5 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__5)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_ImportPart **std_mem_alloc__85(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_ImportPart **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__6 *std_mem_alloc__86(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__6 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__6)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Function **std_mem_alloc__87(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Function **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Function *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__7 *std_mem_alloc__88(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__7 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__7)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Argument **std_mem_alloc__89(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Argument **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Argument *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__8 *std_mem_alloc__90(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__8 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__8)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
char **std_mem_alloc__91(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((char **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(char *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__9 *std_mem_alloc__92(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__9 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__9)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Symbol **std_mem_alloc__93(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Symbol **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Symbol *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__10 *std_mem_alloc__94(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__10 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__10)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCond **std_mem_alloc__95(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_MatchCond **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__11 *std_mem_alloc__96(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__11 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__11)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_tokens_Token **std_mem_alloc__97(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_tokens_Token **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_tokens_Token *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__12 *std_mem_alloc__98(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__12 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__12)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_attributes_Attribute **std_mem_alloc__99(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_attributes_Attribute **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_attributes_Attribute *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__13 *std_mem_alloc__100(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__13 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__13)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_errors_Error **std_mem_alloc__101(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_errors_Error **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_errors_Error *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__14 *std_mem_alloc__102(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__14 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__14)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Structure **std_mem_alloc__103(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Structure **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Structure *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__15 *std_mem_alloc__104(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__15 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__15)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Enum **std_mem_alloc__105(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_Enum **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_Enum *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__16 *std_mem_alloc__106(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__16 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__16)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_AST **std_mem_alloc__107(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_AST **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_AST *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__17 *std_mem_alloc__108(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__17 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__17)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
jmp_buf *std_mem_alloc__109(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((jmp_buf *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(jmp_buf)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__18 *std_mem_alloc__110(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__18 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__18)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Reference *std_mem_alloc__111(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_scopes_Reference *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_scopes_Reference)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__19 *std_mem_alloc__112(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__19 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__19)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCondArg **std_mem_alloc__113(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_MatchCondArg **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__20 *std_mem_alloc__114(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__20 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__20)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_EnumVariant **std_mem_alloc__115(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_EnumVariant **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__21 *std_mem_alloc__116(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__21 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__21)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_operators_Operator *std_mem_alloc__117(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_operators_Operator *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_operators_Operator)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__22 *std_mem_alloc__118(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__22 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__22)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__5 **std_mem_alloc__119(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__5 **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__5 *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__23 *std_mem_alloc__120(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__23 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__23)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_IfBranch *std_mem_alloc__121(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_IfBranch *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_IfBranch)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__24 *std_mem_alloc__122(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__24 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__24)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCase *std_mem_alloc__123(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((compiler_ast_nodes_MatchCase *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(compiler_ast_nodes_MatchCase)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__25 *std_mem_alloc__124(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__25 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__25)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_span_Span *std_mem_alloc__125(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_span_Span *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_span_Span)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__26 *std_mem_alloc__126(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__26 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__26)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_value_Value **std_mem_alloc__127(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_value_Value **)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_value_Value *)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__27 *std_mem_alloc__128(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__27 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__27)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Item__0 *std_mem_alloc__129(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_compact_map_Item__0 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Item__0)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__28 *std_mem_alloc__130(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__28 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__28)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Item__1 *std_mem_alloc__131(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_compact_map_Item__1 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_compact_map_Item__1)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__29 *std_mem_alloc__132(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((std_vector_Vector__29 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(std_vector_Vector__29)))));
}


#line 44 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
u32 *std_mem_alloc__133(u32 count) {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return ((u32 *)std_mem_state_alloc_fn(std_mem_state_allocator, (count * ((u32)sizeof(u32)))));
}


#line 49 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
void std_mem_free(void *ptr) {

#line 50 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_free_fn != NULL) {

#line 51 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    std_mem_state_free_fn(std_mem_state_allocator, ptr);

#line 52 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return;
  }
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
u8 *std_mem_realloc__0(u8 *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(u8)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(u8)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u8 *new_ptr = std_mem_alloc__26(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_types_Type **std_mem_realloc__1(compiler_types_Type **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_types_Type *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_types_Type *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_types_Type **new_ptr = std_mem_alloc__75(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Scope **std_mem_realloc__2(compiler_ast_scopes_Scope **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Scope *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Scope *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_scopes_Scope **new_ptr = std_mem_alloc__77(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_program_Namespace **std_mem_realloc__3(compiler_ast_program_Namespace **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_program_Namespace *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_program_Namespace *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_program_Namespace **new_ptr = std_mem_alloc__79(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Variable **std_mem_realloc__4(compiler_ast_nodes_Variable **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Variable *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Variable *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_Variable **new_ptr = std_mem_alloc__81(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_TemplateInstance **std_mem_realloc__5(compiler_ast_scopes_TemplateInstance **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_TemplateInstance *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_scopes_TemplateInstance **new_ptr = std_mem_alloc__83(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_ImportPart **std_mem_realloc__6(compiler_ast_nodes_ImportPart **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_ImportPart *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_ImportPart **new_ptr = std_mem_alloc__85(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Function **std_mem_realloc__7(compiler_ast_nodes_Function **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Function *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Function *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_Function **new_ptr = std_mem_alloc__87(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Argument **std_mem_realloc__8(compiler_ast_nodes_Argument **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Argument *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Argument *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_Argument **new_ptr = std_mem_alloc__89(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
char **std_mem_realloc__9(char **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(char *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(char *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  char **new_ptr = std_mem_alloc__91(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Symbol **std_mem_realloc__10(compiler_ast_scopes_Symbol **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Symbol *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Symbol *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_scopes_Symbol **new_ptr = std_mem_alloc__93(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCond **std_mem_realloc__11(compiler_ast_nodes_MatchCond **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCond *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_MatchCond **new_ptr = std_mem_alloc__95(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_tokens_Token **std_mem_realloc__12(compiler_tokens_Token **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_tokens_Token *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_tokens_Token *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_tokens_Token **new_ptr = std_mem_alloc__97(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_attributes_Attribute **std_mem_realloc__13(compiler_attributes_Attribute **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_attributes_Attribute *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_attributes_Attribute *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_attributes_Attribute **new_ptr = std_mem_alloc__99(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_errors_Error **std_mem_realloc__14(compiler_errors_Error **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_errors_Error *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_errors_Error *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_errors_Error **new_ptr = std_mem_alloc__101(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Structure **std_mem_realloc__15(compiler_ast_nodes_Structure **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Structure *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Structure *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_Structure **new_ptr = std_mem_alloc__103(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_Enum **std_mem_realloc__16(compiler_ast_nodes_Enum **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_Enum *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_Enum *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_Enum **new_ptr = std_mem_alloc__105(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_AST **std_mem_realloc__17(compiler_ast_nodes_AST **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_AST *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_AST *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_AST **new_ptr = std_mem_alloc__107(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
jmp_buf *std_mem_realloc__18(jmp_buf *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(jmp_buf)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(jmp_buf)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  jmp_buf *new_ptr = std_mem_alloc__109(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_scopes_Reference *std_mem_realloc__19(compiler_ast_scopes_Reference *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_scopes_Reference)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_scopes_Reference)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_scopes_Reference *new_ptr = std_mem_alloc__111(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCondArg **std_mem_realloc__20(compiler_ast_nodes_MatchCondArg **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCondArg *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_MatchCondArg **new_ptr = std_mem_alloc__113(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_EnumVariant **std_mem_realloc__21(compiler_ast_nodes_EnumVariant **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_EnumVariant *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_EnumVariant **new_ptr = std_mem_alloc__115(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_operators_Operator *std_mem_realloc__22(compiler_ast_operators_Operator *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_operators_Operator)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_operators_Operator)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_operators_Operator *new_ptr = std_mem_alloc__117(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_vector_Vector__5 **std_mem_realloc__23(std_vector_Vector__5 **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(std_vector_Vector__5 *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(std_vector_Vector__5 *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_vector_Vector__5 **new_ptr = std_mem_alloc__119(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_IfBranch *std_mem_realloc__24(compiler_ast_nodes_IfBranch *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_IfBranch)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_IfBranch)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_IfBranch *new_ptr = std_mem_alloc__121(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
compiler_ast_nodes_MatchCase *std_mem_realloc__25(compiler_ast_nodes_MatchCase *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(compiler_ast_nodes_MatchCase)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(compiler_ast_nodes_MatchCase)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  compiler_ast_nodes_MatchCase *new_ptr = std_mem_alloc__123(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_span_Span *std_mem_realloc__26(std_span_Span *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(std_span_Span)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(std_span_Span)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_span_Span *new_ptr = std_mem_alloc__125(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_value_Value **std_mem_realloc__27(std_value_Value **ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(std_value_Value *)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(std_value_Value *)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_value_Value **new_ptr = std_mem_alloc__127(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Item__0 *std_mem_realloc__28(std_compact_map_Item__0 *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(std_compact_map_Item__0)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(std_compact_map_Item__0)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_compact_map_Item__0 *new_ptr = std_mem_alloc__129(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
std_compact_map_Item__1 *std_mem_realloc__29(std_compact_map_Item__1 *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(std_compact_map_Item__1)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(std_compact_map_Item__1)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_compact_map_Item__1 *new_ptr = std_mem_alloc__131(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 57 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
u32 *std_mem_realloc__30(u32 *ptr, u32 old_count, u32 new_count) {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 old_size = (old_count * ((u32)sizeof(u32)));

#line 59 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 new_size = (new_count * ((u32)sizeof(u32)));

#line 60 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if (std_mem_state_realloc_fn != NULL) {

#line 61 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
    return std_mem_state_realloc_fn(std_mem_state_allocator, ptr, old_size, new_size);
  }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  if(!(new_size >= old_size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/mem.oc:63:12: Assertion failed: `new_size >= old_size`", "Cannot shrink memory in default allocator"); }

#line 64 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  u32 *new_ptr = std_mem_alloc__133(new_count);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  memcpy(new_ptr, ptr, old_size);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  std_mem_free(ptr);

#line 67 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  return new_ptr;
}


#line 16 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
void *std_mem_impl_my_calloc(void *state, u32 size) {
  return calloc(size, 1);}


#line 17 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
void *std_mem_impl_my_realloc(void *state, void *ptr, u32 old_size, u32 size) {
  return realloc(ptr, size);}


#line 18 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
void std_mem_impl_my_free(void *state, void *ptr) {
  
#line 18 "/Users/mustafa/ocen-lang/ocen/std/mem.oc"
  free(ptr);
}


#line 7 "/Users/mustafa/ocen-lang/ocen/std/libc/errno.oc"
char *std_libc_errno_get_err(void) {
  return ((char *)strerror(errno));}


#line 179 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
bool std_compact_map_Map__0_contains(std_compact_map_Map__0 *this, char *key) {

#line 180 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 hash = str_hash(key);

#line 181 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);

#line 182 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return this->indices[index] >= 0;
}


#line 199 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Iterator__0 std_compact_map_Map__0_iter(std_compact_map_Map__0 *this) {
  return (std_compact_map_Iterator__0){.iter=std_vector_Vector__27_iter(this->items)};}


#line 208 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Item__0 std_compact_map_Iterator__0_cur(std_compact_map_Iterator__0 *this) {
  return std_vector_Iterator__27_cur(&this->iter);}


#line 207 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Iterator__0_next(std_compact_map_Iterator__0 *this) {

#line 207 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_vector_Iterator__27_next(&this->iter);
}


#line 206 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
bool std_compact_map_Iterator__0_has_value(std_compact_map_Iterator__0 *this) {
  return std_vector_Iterator__27_has_value(&this->iter);}


#line 132 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__0_insert(std_compact_map_Map__0 *this, char *key, std_value_Value *value) {

#line 133 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 hash = str_hash(key);

#line 134 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);

#line 136 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (this->indices[index] < 0) {

#line 137 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->indices[index]=((i32)this->items->size);

#line 138 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_vector_Vector__27_push(this->items, (std_compact_map_Item__0){.hash=hash, .key=key, .value=value});

#line 139 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Map__0_resize_if_necessary(this);
  } else {

#line 142 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[index]==std_compact_map_INDEX_DELETED) {

#line 143 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      this->num_tombstones-=1;
    }

#line 145 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    u32 item_index = ((u32)this->indices[index]);

#line 146 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->items->data[item_index].value=value;
  }
}


#line 46 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
u32 std_compact_map_Map__0_get_index(std_compact_map_Map__0 *this, char *key, u32 hash) {

#line 47 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 perturb = hash;

#line 48 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 j = (hash % this->capacity);

#line 49 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 i = j;

#line 51 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 first_deleted = -1;

#line 52 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  while (this->indices[i] != std_compact_map_INDEX_FREE) {

#line 53 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[i]==std_compact_map_INDEX_DELETED) {

#line 54 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      if (first_deleted < 0) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
        first_deleted=((i32)i);
      }
    } else {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      std_compact_map_Item__0 item = this->items->data[this->indices[i]];

#line 59 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      if (item.hash==hash && str_eq(item.key, key)) {

#line 60 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
        return i;
      }
    }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    j=(((5 * j) + perturb) + 1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    i=(j % this->capacity);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    perturb=(perturb >> 5);
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (first_deleted < 0) {

#line 69 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    return i;
  }

#line 71 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return ((u32)first_deleted);
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_value_Value *std_compact_map_Map__0_get(std_compact_map_Map__0 *this, char *key, std_value_Value *defolt) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_compact_map_Item__0 *item = std_compact_map_Map__0_get_item(this, key);

#line 163 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (!(((bool)item))) {

#line 163 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    return defolt;
  }

#line 164 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return item->value;
}


#line 190 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
bool std_compact_map_Map__0_is_empty(std_compact_map_Map__0 *this) {
  return this->items->size==0;}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__0_resize(std_compact_map_Map__0 *this, u32 new_capacity) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 *old_indices = this->indices;

#line 108 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->indices=std_mem_alloc__23(new_capacity);

#line 109 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->capacity=new_capacity;

#line 110 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < new_capacity; i++) {

#line 111 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->indices[i]=std_compact_map_INDEX_FREE;
  }

#line 113 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < this->items->size; i++) {

#line 114 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Item__0 item = std_vector_Vector__27_at(this->items, i);

#line 115 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    u32 index = std_compact_map_Map__0_get_index(this, item.key, item.hash);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[index]==std_compact_map_INDEX_FREE) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      this->indices[index]=((i32)i);
    }
  }

#line 121 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->num_tombstones=0;

#line 122 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_mem_free(old_indices);
}


#line 150 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Item__0 *std_compact_map_Map__0_get_item(std_compact_map_Map__0 *this, char *key) {

#line 151 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 hash = str_hash(key);

#line 152 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 index = std_compact_map_Map__0_get_index(this, key, hash);

#line 153 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (this->indices[index] < 0) {

#line 154 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    return NULL;
  }

#line 157 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 idx = ((u32)this->indices[index]);

#line 158 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return &this->items->data[idx];
}


#line 25 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Map__0 *std_compact_map_Map__0_new(u32 capacity) {

#line 26 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_vector_Vector__27 *items = std_vector_Vector__27_new(capacity);

#line 27 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 *indices = std_mem_alloc__23(capacity);

#line 28 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < capacity; i++) {

#line 29 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    indices[i]=std_compact_map_INDEX_FREE;
  }

#line 31 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_compact_map_Map__0 *map = std_mem_alloc__24(1);

#line 32 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->items=items;

#line 33 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->indices=indices;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->capacity=capacity;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->num_tombstones=0;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return map;
}


#line 125 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__0_resize_if_necessary(std_compact_map_Map__0 *this) {

#line 126 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if ((this->num_tombstones + ((u32)this->items->size)) >= ((this->capacity * 3) / 4)) {

#line 127 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Map__0_resize(this, (this->capacity * 2));
  }
}


#line 132 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__1_insert(std_compact_map_Map__1 *this, char *key, std_span_Span value) {

#line 133 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 hash = str_hash(key);

#line 134 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 index = std_compact_map_Map__1_get_index(this, key, hash);

#line 136 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (this->indices[index] < 0) {

#line 137 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->indices[index]=((i32)this->items->size);

#line 138 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_vector_Vector__28_push(this->items, (std_compact_map_Item__1){.hash=hash, .key=key, .value=value});

#line 139 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Map__1_resize_if_necessary(this);
  } else {

#line 142 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[index]==std_compact_map_INDEX_DELETED) {

#line 143 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      this->num_tombstones-=1;
    }

#line 145 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    u32 item_index = ((u32)this->indices[index]);

#line 146 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->items->data[item_index].value=value;
  }
}


#line 46 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
u32 std_compact_map_Map__1_get_index(std_compact_map_Map__1 *this, char *key, u32 hash) {

#line 47 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 perturb = hash;

#line 48 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 j = (hash % this->capacity);

#line 49 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 i = j;

#line 51 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 first_deleted = -1;

#line 52 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  while (this->indices[i] != std_compact_map_INDEX_FREE) {

#line 53 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[i]==std_compact_map_INDEX_DELETED) {

#line 54 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      if (first_deleted < 0) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
        first_deleted=((i32)i);
      }
    } else {

#line 58 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      std_compact_map_Item__1 item = this->items->data[this->indices[i]];

#line 59 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      if (item.hash==hash && str_eq(item.key, key)) {

#line 60 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
        return i;
      }
    }

#line 63 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    j=(((5 * j) + perturb) + 1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    i=(j % this->capacity);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    perturb=(perturb >> 5);
  }

#line 68 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (first_deleted < 0) {

#line 69 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    return i;
  }

#line 71 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return ((u32)first_deleted);
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__1_resize(std_compact_map_Map__1 *this, u32 new_capacity) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 *old_indices = this->indices;

#line 108 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->indices=std_mem_alloc__23(new_capacity);

#line 109 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->capacity=new_capacity;

#line 110 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < new_capacity; i++) {

#line 111 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    this->indices[i]=std_compact_map_INDEX_FREE;
  }

#line 113 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < this->items->size; i++) {

#line 114 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Item__1 item = std_vector_Vector__28_at(this->items, i);

#line 115 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    u32 index = std_compact_map_Map__1_get_index(this, item.key, item.hash);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    if (this->indices[index]==std_compact_map_INDEX_FREE) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
      this->indices[index]=((i32)i);
    }
  }

#line 121 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  this->num_tombstones=0;

#line 122 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_mem_free(old_indices);
}


#line 150 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Item__1 *std_compact_map_Map__1_get_item(std_compact_map_Map__1 *this, char *key) {

#line 151 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 hash = str_hash(key);

#line 152 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 index = std_compact_map_Map__1_get_index(this, key, hash);

#line 153 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if (this->indices[index] < 0) {

#line 154 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    return NULL;
  }

#line 157 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  u32 idx = ((u32)this->indices[index]);

#line 158 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return &this->items->data[idx];
}


#line 25 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
std_compact_map_Map__1 *std_compact_map_Map__1_new(u32 capacity) {

#line 26 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_vector_Vector__28 *items = std_vector_Vector__28_new(capacity);

#line 27 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  i32 *indices = std_mem_alloc__23(capacity);

#line 28 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  for (u32 i = 0; i < capacity; i++) {

#line 29 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    indices[i]=std_compact_map_INDEX_FREE;
  }

#line 31 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  std_compact_map_Map__1 *map = std_mem_alloc__25(1);

#line 32 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->items=items;

#line 33 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->indices=indices;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->capacity=capacity;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  map->num_tombstones=0;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  return map;
}


#line 125 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
void std_compact_map_Map__1_resize_if_necessary(std_compact_map_Map__1 *this) {

#line 126 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
  if ((this->num_tombstones + ((u32)this->items->size)) >= ((this->capacity * 3) / 4)) {

#line 127 "/Users/mustafa/ocen-lang/ocen/std/compact_map.oc"
    std_compact_map_Map__1_resize(this, (this->capacity * 2));
  }
}


#line 20 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
std_buffer_Buffer std_buffer_Buffer_make(u32 capacity) {

#line 21 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  return (std_buffer_Buffer){.data=std_mem_alloc__26(capacity), .size=0, .capacity=capacity};
}


#line 28 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
std_buffer_Buffer std_buffer_Buffer_from_str(char *s) {

#line 29 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  return (std_buffer_Buffer){.data=((u8 *)s), .size=((u32)strlen(s)), .capacity=((u32)strlen(s))};
}


#line 55 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_resize_if_necessary(std_buffer_Buffer *this, u32 new_size) {

#line 59 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  if ((new_size + 1) >= this->capacity) {

#line 60 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
    u32 new_capacity = u32_max(((this->capacity * 3) / 2), (new_size + 1));

#line 61 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
    this->data=std_mem_realloc__0(this->data, this->capacity, new_capacity);

#line 63 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
    memset((this->data + this->capacity), ((u8)0), (new_capacity - this->capacity));

#line 64 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
    this->capacity=((u32)new_capacity);

#line 65 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
    if(!(((bool)this->data))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/buffer.oc:65:16: Assertion failed: `.data?`", "Out of memory!"); }
  }
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_write_str(std_buffer_Buffer *this, char *s) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  u32 len = ((u32)strlen(s));

#line 117 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_buffer_Buffer_resize_if_necessary(this, (this->size + len));

#line 118 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  memcpy((this->data + this->size), s, len);

#line 119 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  this->size+=len;
}


#line 124 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_write_str_f(std_buffer_Buffer *this, char *s) {

#line 125 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_buffer_Buffer_write_str(this, s);

#line 126 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_mem_free(s);
}


#line 130 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_write_char(std_buffer_Buffer *this, char c) {
  
#line 130 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_buffer_Buffer_write_u8(this, ((u8)c));
}


#line 186 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_write_u8(std_buffer_Buffer *this, u8 value) {

#line 187 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_buffer_Buffer_resize_if_necessary(this, (this->size + 1));

#line 188 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  this->data[this->size]=value;

#line 189 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  this->size+=1;
}


#line 196 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
char *std_buffer_Buffer_new_str(std_buffer_Buffer this) {
  return strdup(((char *)this.data));}


#line 198 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
char *std_buffer_Buffer_str(std_buffer_Buffer this) {
  return ((char *)this.data);}


#line 200 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
std_sv_SV std_buffer_Buffer_sv(std_buffer_Buffer this) {
  return (std_sv_SV){.data=((char *)this.data), .len=this.size};}


#line 212 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_clear(std_buffer_Buffer *this) {

#line 213 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  this->size=0;

#line 214 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  memset(this->data, ((u8)0), this->capacity);
}


#line 217 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
void std_buffer_Buffer_free(std_buffer_Buffer *this) {

#line 218 "/Users/mustafa/ocen-lang/ocen/std/buffer.oc"
  std_mem_free(this->data);
}


#line 14 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
void std_logging_init_logging(std_logging_LogLevel level, char *time_format) {

#line 15 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  std_logging_log_level=level;

#line 16 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  std_logging_log_time_format=time_format;

#line 19 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  char *s = getenv("LOG");

#line 20 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  if (!(((bool)s))) {

#line 20 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    return;
  }

#line 22 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  {
    char *__match_var_433 = s;
    if (str_eq(__match_var_433, "debug") || str_eq(__match_var_433, "DEBUG")) {

#line 23 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
      std_logging_log_level=std_logging_LogLevel_Debug;
    } else if (str_eq(__match_var_433, "info") || str_eq(__match_var_433, "INFO")) {

#line 24 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
      std_logging_log_level=std_logging_LogLevel_Info;
    } else if (str_eq(__match_var_433, "warn") || str_eq(__match_var_433, "WARN")) {

#line 25 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
      std_logging_log_level=std_logging_LogLevel_Warn;
    } else if (str_eq(__match_var_433, "error") || str_eq(__match_var_433, "ERROR")) {

#line 26 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
      std_logging_log_level=std_logging_LogLevel_Error;
    } else  {
    }
  }
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
void std_logging_vlog(std_logging_LogLevel level, char *fmt, va_list vargs) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  if (((u32)level) < ((u32)std_logging_log_level)) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    return;
  }

#line 34 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  if (((bool)std_logging_log_time_format)) {

#line 35 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    char time_buf[64] = {0};

#line 36 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    time_t timer = time(NULL);

#line 37 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    struct tm *tm_info = localtime(&timer);

#line 38 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    strftime(time_buf, 64, std_logging_log_time_format, tm_info);

#line 39 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
    printf("(%s) ", time_buf);
  }

#line 42 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  switch ((level)) {
    case std_logging_LogLevel_Debug:
    m_434_0:
      {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
        printf("[DEBUG] ");
      } break;
    case std_logging_LogLevel_Info:
    m_434_1:
      {

#line 44 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
        printf("[INFO] ");
      } break;
    case std_logging_LogLevel_Warn:
    m_434_2:
      {

#line 45 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
        printf("[WARN] ");
      } break;
    case std_logging_LogLevel_Error:
    m_434_3:
      {

#line 46 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
        printf("[ERROR] ");
      } break;
  }

#line 48 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  vprintf(fmt, vargs);

#line 49 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  printf("\n");
}


#line 53 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
void std_logging_log(std_logging_LogLevel level, char *fmt, ...) {

#line 54 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  va_list args = {0};

#line 55 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  va_start(args, fmt);

#line 56 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  std_logging_vlog(level, fmt, args);

#line 57 "/Users/mustafa/ocen-lang/ocen/std/logging.oc"
  va_end(args);
}


#line 54 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__0_free(std_set_Set__0 *this) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__0_free(this->map);

#line 56 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_mem_free(this);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__0_add(std_set_Set__0 *this, u64 key) {

#line 19 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__0_insert(this->map, key, true);

#line 20 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  this->size=this->map->size;
}


#line 49 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
bool std_set_Set__0_contains(std_set_Set__0 *this, u64 key) {
  return std_map_Map__0_contains(this->map, key);}


#line 11 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Set__0 *std_set_Set__0_new(void) {

#line 12 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_set_Set__0 *set = std_mem_alloc__27(1);

#line 13 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  set->map=std_map_Map__0_new(8);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  return set;
}


#line 54 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__1_free(std_set_Set__1 *this) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__1_free(this->map);

#line 56 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_mem_free(this);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__1_add(std_set_Set__1 *this, void *key) {

#line 19 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__1_insert(this->map, key, true);

#line 20 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  this->size=this->map->size;
}


#line 49 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
bool std_set_Set__1_contains(std_set_Set__1 *this, void *key) {
  return std_map_Map__1_contains(this->map, key);}


#line 11 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Set__1 *std_set_Set__1_new(void) {

#line 12 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_set_Set__1 *set = std_mem_alloc__28(1);

#line 13 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  set->map=std_map_Map__1_new(8);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  return set;
}


#line 54 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__2_free(std_set_Set__2 *this) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__7_free(this->map);

#line 56 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_mem_free(this);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__2_add(std_set_Set__2 *this, char *key) {

#line 19 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__7_insert(this->map, key, true);

#line 20 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  this->size=this->map->size;
}


#line 49 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
bool std_set_Set__2_contains(std_set_Set__2 *this, char *key) {
  return std_map_Map__7_contains(this->map, key);}


#line 11 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Set__2 *std_set_Set__2_new(void) {

#line 12 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_set_Set__2 *set = std_mem_alloc__29(1);

#line 13 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  set->map=std_map_Map__7_new(8);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  return set;
}


#line 54 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__3_free(std_set_Set__3 *this) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__13_free(this->map);

#line 56 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_mem_free(this);
}


#line 18 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Set__3_add(std_set_Set__3 *this, std_span_Span key) {

#line 19 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Map__13_insert(this->map, key, true);

#line 20 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  this->size=this->map->size;
}


#line 11 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Set__3 *std_set_Set__3_new(void) {

#line 12 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_set_Set__3 *set = std_mem_alloc__30(1);

#line 13 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  set->map=std_map_Map__13_new(8);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  return set;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Iterator__3 std_set_Set__3_iter(std_set_Set__3 *this) {
  return std_set_Iterator__3_make(this);}


#line 65 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_span_Span std_set_Iterator__3_cur(std_set_Iterator__3 *this) {
  return std_map_Iterator__13_cur(&this->map_iter)->key;}


#line 66 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
void std_set_Iterator__3_next(std_set_Iterator__3 *this) {

#line 67 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
  std_map_Iterator__13_next(&this->map_iter);
}


#line 64 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
bool std_set_Iterator__3_has_value(std_set_Iterator__3 *this) {
  return std_map_Iterator__13_has_value(&this->map_iter);}


#line 63 "/Users/mustafa/ocen-lang/ocen/std/set.oc"
std_set_Iterator__3 std_set_Iterator__3_make(std_set_Set__3 *set) {
  return (std_set_Iterator__3){.map_iter=std_map_Map__13_iter(set->map)};}


#line 15 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
std_span_Location std_span_Location_default(void) {

#line 16 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  std_span_Location loc = {0};

#line 17 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  loc.filename="<default>";

#line 18 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  loc.line=0;

#line 19 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  loc.col=0;

#line 20 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  loc.index=0;

#line 21 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return loc;
}


#line 24 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
u32 std_span_Location_hash(std_span_Location this) {
  return std_traits_hash_pair_hash(str_hash(this.filename), u32_hash(this.index));}


#line 27 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Location_eq(std_span_Location this, std_span_Location other) {
  return (str_eq(this.filename, other.filename) && this.index==other.index);}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
char *std_span_Location_str(std_span_Location *this) {

#line 29 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return std_format("%s:%u:%u", this->filename, this->line, this->col);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Location_is_valid(std_span_Location *this) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return ((this->line > 0) && (this->col > 0)) && (this->index >= 0);
}


#line 36 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Location_is_before(std_span_Location *this, std_span_Location other) {

#line 37 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (this->line > other.line) {

#line 37 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return false;
  }

#line 38 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (this->line < other.line) {

#line 38 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return true;
  }

#line 39 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return this->col <= other.col;
}


#line 54 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
std_span_Span std_span_Span_default(void) {

#line 55 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  std_span_Span span = {0};

#line 56 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  span.start=(std_span_Location){.filename="<default>", .line=0, .col=0, .index=0};

#line 57 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  span.end=(std_span_Location){.filename="<default>", .line=0, .col=0, .index=0};

#line 58 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return span;
}


#line 61 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
u32 std_span_Span_hash(std_span_Span this) {
  return std_traits_hash_pair_hash(std_span_Location_hash(this.start), u32_hash(this.end.index));}


#line 64 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Span_eq(std_span_Span this, std_span_Span other) {
  return (std_span_Location_eq(this.start, other.start) && std_span_Location_eq(this.end, other.end));}


#line 66 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Span_is_valid(std_span_Span this) {

#line 67 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return std_span_Location_is_valid(&this.start) && std_span_Location_is_valid(&this.end);
}


#line 72 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
std_span_Span std_span_Span_join(std_span_Span this, std_span_Span other) {

#line 73 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  std_span_Span span = {0};

#line 74 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  span.start=this.start;

#line 75 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  span.end=other.end;

#line 76 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return span;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Span_contains_loc(std_span_Span this, std_span_Location loc) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (!(std_span_Span_is_valid(this))) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return false;
  }

#line 82 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (!(str_eq(this.start.filename, loc.filename))) {

#line 82 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return false;
  }

#line 83 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return std_span_Location_is_before(&this.start, loc) && std_span_Location_is_before(&loc, this.end);
}


#line 87 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
bool std_span_Span_starts_right_after(std_span_Span this, std_span_Span other) {

#line 88 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (!(std_span_Span_is_valid(this))) {

#line 88 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return false;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  if (!(str_eq(this.start.filename, other.start.filename))) {

#line 89 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
    return false;
  }

#line 90 "/Users/mustafa/ocen-lang/ocen/std/span.oc"
  return this.start.index==other.end.index;
}


#line 10 "/Users/mustafa/ocen-lang/ocen/std/traits/eq.oc"
bool u64_eq(u64 this, u64 other) {
  return this==other;}


#line 15 "/Users/mustafa/ocen-lang/ocen/std/traits/eq.oc"
bool untyped_ptr_eq(void *this, void *other) {
  return this==other;}


#line 3 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 std_traits_hash_hash_bytes(u8 *data, u32 len) {

#line 4 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
  u32 hash = 5381;

#line 5 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
  for (u32 i = 0; i < len; i+=1) {

#line 6 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
    hash=((hash * 33) ^ ((u32)data[i]));
  }

#line 8 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
  return hash;
}


#line 11 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 std_traits_hash_pair_hash(u32 a, u32 b) {
  return ((a * 33) ^ b);}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 std_traits_hash_ptr_hash(void *ptr) {
  return u64_hash(((u64)ptr));}


#line 13 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 untyped_ptr_hash(void *this) {
  return std_traits_hash_ptr_hash(this);}


#line 16 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 str_hash(char *this) {
  return std_traits_hash_hash_bytes(((u8 *)this), strlen(this));}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 u32_hash(u32 this) {
  return (((u32)this) * 7817);}


#line 23 "/Users/mustafa/ocen-lang/ocen/std/traits/hash.oc"
u32 u64_hash(u64 this) {
  return std_traits_hash_pair_hash(u32_hash(((u32)this)), u32_hash(((u32)(this >> ((u64)32)))));}


#line 37 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_new(std_value_ValueType type) {

#line 38 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value *val = std_mem_alloc__31(1);

#line 39 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  val->type=type;

#line 40 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  switch ((type)) {
    case std_value_ValueType_Dictionary:
    m_435_0:
      {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
        val->u.as_dict=std_compact_map_Map__0_new(16);
      } break;
    case std_value_ValueType_List:
    m_435_1:
      {

#line 42 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
        val->u.as_list=std_vector_Vector__26_new(16);
      } break;
    default:
      {
      } break;
  }

#line 45 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  val->span=std_span_Span_default();

#line 46 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return val;
}


#line 55 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_new_str(char *s) {

#line 56 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value *val = std_value_Value_new(std_value_ValueType_String);

#line 57 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  val->u.as_str=std_buffer_Buffer_from_str(s);

#line 58 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return val;
}


#line 61 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_new_bool(bool bul) {

#line 62 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Bool);

#line 63 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  val->u.as_bool=bul;

#line 64 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return val;
}


#line 67 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_new_int(i64 num) {

#line 68 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value *val = std_value_Value_new(std_value_ValueType_Integer);

#line 69 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  val->u.as_int=num;

#line 70 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return val;
}


#line 93 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
void std_value_Value_ensure(std_value_Value *this, std_value_ValueType type) {

#line 94 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  if (this->type != type) {

#line 95 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
    printf("%s:%u:%u: Value type mismatch, expected %s but got %s\n", (this->span.start).filename, (this->span.start).line, (this->span.start).col, std_value_ValueType_dbg(this->type), std_value_ValueType_dbg(type));

#line 96 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
    exit(1);
  }
}


#line 113 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_at_key(std_value_Value *this, char *key) {

#line 114 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);

#line 115 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  if (!(std_compact_map_Map__0_contains(this->u.as_dict, key))) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
    printf("%s:%u:%u: Key not found: %s\n", (this->span.start).filename, (this->span.start).line, (this->span.start).col, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
    exit(1);
  }

#line 119 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return std_compact_map_Map__0_get(this->u.as_dict, key, NULL);
}


#line 139 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
void std_value_Value_push(std_value_Value *this, std_value_Value *value) {

#line 140 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_ensure(this, std_value_ValueType_List);

#line 141 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_vector_Vector__26_push(this->u.as_list, value);
}


#line 159 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_value_Value *std_value_Value_get(std_value_Value *this, char *key, std_value_Value *defolt) {

#line 160 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);

#line 161 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return std_compact_map_Map__0_get(this->u.as_dict, key, defolt);
}


#line 165 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
void std_value_Value_insert(std_value_Value *this, char *key, std_value_Value *value) {

#line 166 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);

#line 167 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_compact_map_Map__0_insert(this->u.as_dict, key, value);
}


#line 170 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
void std_value_Value_insert_str(std_value_Value *this, char *key, char *s) {
  
#line 170 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_insert(this, key, std_value_Value_new_str(s));
}


#line 172 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
void std_value_Value_insert_u32(std_value_Value *this, char *key, u32 i) {
  
#line 172 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_insert(this, key, std_value_Value_new_int(((i64)i)));
}


#line 216 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
std_compact_map_Map__0 *std_value_Value_as_dict(std_value_Value *this) {

#line 217 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_value_Value_ensure(this, std_value_ValueType_Dictionary);

#line 218 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return this->u.as_dict;
}


#line 221 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
char *std_value_Value_dbg(std_value_Value *this) {

#line 222 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  std_buffer_Buffer buf = std_json_serialize(this);

#line 223 "/Users/mustafa/ocen-lang/ocen/std/value.oc"
  return std_buffer_Buffer_str(buf);
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
char *std_fs_realpath(char *path) {
  return realpath(path, NULL);}


#line 145 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
bool std_fs_file_exists(char *path) {

#line 146 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  FILE *file = fopen(path, "r");

#line 147 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (!(((bool)file))) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    return false;
  }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  fclose(file);

#line 149 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  return true;
}


#line 152 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
void std_fs_write_file_bytes(char *path, void *data, u32 size) {

#line 153 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  FILE *file = fopen(path, "wb");

#line 154 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (!(((bool)file))) {

#line 154 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    std_panic(std_format("[-] Failed to open file: %s", path));
  }

#line 155 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  i32 written = fwrite(data, 1, size, file);

#line 156 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (((u32)written) != size) {

#line 157 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    std_panic(std_format("[-] Failed to write to file: %s", path));
  }

#line 159 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  fclose(file);
}


#line 162 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
void std_fs_write_file_str(char *path, char *data) {

#line 163 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_fs_write_file_bytes(path, data, strlen(data));
}


#line 166 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
void std_fs_write_file(char *path, std_buffer_Buffer data) {

#line 167 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_fs_write_file_bytes(path, data.data, data.size);
}


#line 170 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
std_buffer_Buffer std_fs_read_file(char *path) {

#line 171 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  FILE *file = fopen(path, "r");

#line 172 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (!(((bool)file))) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    std_panic(std_format("[-] Failed to open file: %s: %s", path, std_libc_errno_get_err()));
  }

#line 173 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  fseek(file, ((i64)0), SEEK_END);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  u32 size = ((u32)ftell(file));

#line 175 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  fseek(file, ((i64)0), SEEK_SET);

#line 176 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_buffer_Buffer data = std_buffer_Buffer_make((size + 1));

#line 177 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  i32 read = fread(data.data, 1, size, file);

#line 178 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (((u32)read) != size) {

#line 179 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    std_panic(std_format("[-] Failed to read from file: %s", path));
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  fclose(file);

#line 182 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  data.size=((u32)size);

#line 183 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  data.data[size]=((u8)0);

#line 184 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  return data;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
bool std_fs_directory_exists(char *path) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  DIR *dir = opendir(path);

#line 212 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (dir==NULL) {

#line 212 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    return false;
  }

#line 213 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  closedir(dir);

#line 214 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  return true;
}


#line 227 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
std_fs_DirectoryIterator std_fs_iterate_directory(char *path, bool skip_self_and_parent) {

#line 228 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  DIR *dir = opendir(path);

#line 229 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  if (dir==NULL) {

#line 230 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    std_panic(std_format("[-] Failed to open directory: %s", path));
  }

#line 233 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_fs_DirectoryIterator iter = {0};

#line 234 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  iter.dir=dir;

#line 235 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  iter.skip_self_and_parent=skip_self_and_parent;

#line 236 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_fs_DirectoryIterator_next(&iter);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  return iter;
}


#line 259 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
bool std_fs_DirectoryIterator_has_value(std_fs_DirectoryIterator *this) {
  return ((bool)this->dp);}


#line 261 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
void std_fs_DirectoryIterator_next(std_fs_DirectoryIterator *this) {

#line 262 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  this->dp=readdir(this->dir);

#line 263 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  while (((bool)this->dp) && this->skip_self_and_parent) {

#line 264 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    {
      char *__match_var_436 = this->dp->d_name;
      if (str_eq(__match_var_436, ".") || str_eq(__match_var_436, "..")) {

#line 265 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
        this->dp=readdir(this->dir);
      } else  {

#line 266 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
        break;
      }
    }
  }
}


#line 271 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
std_fs_DirectoryEntry std_fs_DirectoryIterator_cur(std_fs_DirectoryIterator *this) {

#line 272 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  char *name = this->dp->d_name;

#line 273 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  std_fs_EntryType type = ({ std_fs_EntryType __yield_0;

#line 273 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
    switch (this->dp->d_type) {
      case DT_DIR: {
        __yield_0 = std_fs_EntryType_Directory;
      } break;
      case DT_REG: {
        __yield_0 = std_fs_EntryType_File;
      } break;
      case DT_LNK: {
        __yield_0 = std_fs_EntryType_SymbolicLink;
      } break;
      default: {
        __yield_0 = std_fs_EntryType_Unknown;
      } break;
    }

  __yield_0; });

#line 279 "/Users/mustafa/ocen-lang/ocen/std/fs.oc"
  return (std_fs_DirectoryEntry){.type=type, .name=name};
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__0 *std_map_Item__0_new(u64 key, bool value, std_map_Item__0 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__0 *node = std_mem_alloc__32(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__0_free_list(std_map_Item__0 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__0 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__0 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__0_free(std_map_Map__0 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__0_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__0_insert(std_map_Map__0 *this, u64 key, bool value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__0 *node = std_map_Map__0_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__0_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__0 *new_node = std_map_Item__0_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__0_resize(this);
    }
  }
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__0_contains(std_map_Map__0 *this, u64 key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__0_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__0_resize(std_map_Map__0 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__0 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__33(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__0 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__0_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__0 *new_node = std_map_Item__0_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__0_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__0_hash(std_map_Map__0 *this, u64 key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = u64_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__0 *std_map_Map__0_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__0 *map = std_mem_alloc__34(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__33(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__0 *std_map_Map__0_get_item(std_map_Map__0 *this, u64 key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__0_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__0 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (u64_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__1 *std_map_Item__1_new(void *key, bool value, std_map_Item__1 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__1 *node = std_mem_alloc__35(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__1_free_list(std_map_Item__1 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__1 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__1 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__1_free(std_map_Map__1 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__1_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__1_insert(std_map_Map__1 *this, void *key, bool value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__1 *node = std_map_Map__1_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__1_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__1 *new_node = std_map_Item__1_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__1_resize(this);
    }
  }
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__1_contains(std_map_Map__1 *this, void *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__1_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__1_resize(std_map_Map__1 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__1 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__36(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__1 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__1_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__1 *new_node = std_map_Item__1_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__1_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__1_hash(std_map_Map__1 *this, void *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = untyped_ptr_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__1 *std_map_Map__1_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__1 *map = std_mem_alloc__37(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__36(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__1 *std_map_Map__1_get_item(std_map_Map__1 *this, void *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__1_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__1 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (untyped_ptr_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__2 *std_map_Item__2_new(char *key, compiler_types_Type *value, std_map_Item__2 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 *node = std_mem_alloc__38(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__2_free_list(std_map_Item__2 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__2 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__2_insert(std_map_Map__2 *this, char *key, compiler_types_Type *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 *node = std_map_Map__2_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__2_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__2 *new_node = std_map_Item__2_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__2_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_types_Type *std_map_Map__2_get(std_map_Map__2 *this, char *key, compiler_types_Type *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 *node = std_map_Map__2_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__2 *std_map_Iterator__2_cur(std_map_Iterator__2 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__2_next(std_map_Iterator__2 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__2 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__2_has_value(std_map_Iterator__2 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__2 std_map_Iterator__2_make(std_map_Map__2 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__2 it = (std_map_Iterator__2){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__2_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 188 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__2_is_empty(std_map_Map__2 *this) {
  return this->size==0;}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__2_resize(std_map_Map__2 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__39(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__2 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__2_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__2 *new_node = std_map_Item__2_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__2_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__2_hash(std_map_Map__2 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__2 *std_map_Map__2_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__2 *map = std_mem_alloc__40(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__39(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__2 *std_map_Map__2_get_item(std_map_Map__2 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__2_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__2 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 200 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__2_clear(std_map_Map__2 *this) {

#line 201 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 202 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__2_free_list(this->buckets[i]);

#line 203 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[i]=NULL;
  }

#line 205 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->size=0;

#line 206 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__2 std_map_Map__2_iter(std_map_Map__2 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__2_make(this);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__3 *std_map_Item__3_new(char *key, compiler_ast_program_Namespace *value, std_map_Item__3 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *node = std_mem_alloc__41(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__3_free_list(std_map_Item__3 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__3 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 94 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_program_Namespace *std_map_Map__3_at(std_map_Map__3 *this, char *key) {

#line 95 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *node = std_map_Map__3_get_item(this, key);

#line 96 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }

#line 97 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__3_insert(std_map_Map__3 *this, char *key, compiler_ast_program_Namespace *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *node = std_map_Map__3_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__3_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__3 *new_node = std_map_Item__3_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__3_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_program_Namespace *std_map_Map__3_get(std_map_Map__3 *this, char *key, compiler_ast_program_Namespace *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *node = std_map_Map__3_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__3 *std_map_Iterator__3_cur(std_map_Iterator__3 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__3_next(std_map_Iterator__3 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__3 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__3_has_value(std_map_Iterator__3 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__3 std_map_Iterator__3_make(std_map_Map__3 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__3 it = (std_map_Iterator__3){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__3_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 188 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__3_is_empty(std_map_Map__3 *this) {
  return this->size==0;}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__3_contains(std_map_Map__3 *this, char *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__3_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__3_resize(std_map_Map__3 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__42(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__3 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__3_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__3 *new_node = std_map_Item__3_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__3_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__3_hash(std_map_Map__3 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 218 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_ValueIterator__3 std_map_Map__3_iter_values(std_map_Map__3 *this) {
  return (std_map_ValueIterator__3){.map_iter=std_map_Map__3_iter(this)};}


#line 276 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_program_Namespace *std_map_ValueIterator__3_cur(std_map_ValueIterator__3 *this) {
  return std_map_Iterator__3_cur(&this->map_iter)->value;}


#line 277 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_ValueIterator__3_next(std_map_ValueIterator__3 *this) {

#line 278 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__3_next(&this->map_iter);
}


#line 275 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_ValueIterator__3_has_value(std_map_ValueIterator__3 *this) {
  return std_map_Iterator__3_has_value(&this->map_iter);}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__3 *std_map_Map__3_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__3 *map = std_mem_alloc__43(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__42(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__3 *std_map_Map__3_get_item(std_map_Map__3 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__3_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__3 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__3 std_map_Map__3_iter(std_map_Map__3 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__3_make(this);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__4 *std_map_Item__4_new(char *key, compiler_ast_scopes_Symbol *value, std_map_Item__4 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *node = std_mem_alloc__44(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__4_free_list(std_map_Item__4 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__4 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 94 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_scopes_Symbol *std_map_Map__4_at(std_map_Map__4 *this, char *key) {

#line 95 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);

#line 96 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }

#line 97 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__4_insert(std_map_Map__4 *this, char *key, compiler_ast_scopes_Symbol *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__4_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__4 *new_node = std_map_Item__4_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__4_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_scopes_Symbol *std_map_Map__4_get(std_map_Map__4 *this, char *key, compiler_ast_scopes_Symbol *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *node = std_map_Map__4_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__4 *std_map_Iterator__4_cur(std_map_Iterator__4 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__4_next(std_map_Iterator__4 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__4 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__4_has_value(std_map_Iterator__4 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__4 std_map_Iterator__4_make(std_map_Map__4 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__4 it = (std_map_Iterator__4){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__4_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__4_contains(std_map_Map__4 *this, char *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__4_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__4_resize(std_map_Map__4 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__45(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__4 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__4_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__4 *new_node = std_map_Item__4_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__4_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__4_hash(std_map_Map__4 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 218 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_ValueIterator__4 std_map_Map__4_iter_values(std_map_Map__4 *this) {
  return (std_map_ValueIterator__4){.map_iter=std_map_Map__4_iter(this)};}


#line 276 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_scopes_Symbol *std_map_ValueIterator__4_cur(std_map_ValueIterator__4 *this) {
  return std_map_Iterator__4_cur(&this->map_iter)->value;}


#line 277 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_ValueIterator__4_next(std_map_ValueIterator__4 *this) {

#line 278 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__4_next(&this->map_iter);
}


#line 275 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_ValueIterator__4_has_value(std_map_ValueIterator__4 *this) {
  return std_map_Iterator__4_has_value(&this->map_iter);}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__4 *std_map_Map__4_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__4 *map = std_mem_alloc__46(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__45(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__4 *std_map_Map__4_get_item(std_map_Map__4 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__4_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__4 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__4 std_map_Map__4_iter(std_map_Map__4 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__4_make(this);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__5 *std_map_Item__5_new(compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value, std_map_Item__5 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 *node = std_mem_alloc__47(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__5_free_list(std_map_Item__5 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__5 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__5_insert(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 *node = std_map_Map__5_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__5_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__5 *new_node = std_map_Item__5_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__5_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_nodes_Function *std_map_Map__5_get(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key, compiler_ast_nodes_Function *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 *node = std_map_Map__5_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__5_resize(std_map_Map__5 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__48(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__5 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__5_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__5 *new_node = std_map_Item__5_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__5_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__5_hash(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = compiler_ast_operators_OperatorOverload_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__5 *std_map_Map__5_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__5 *map = std_mem_alloc__49(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__48(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__5 *std_map_Map__5_get_item(std_map_Map__5 *this, compiler_ast_operators_OperatorOverload key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__5_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__5 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (compiler_ast_operators_OperatorOverload_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__6 *std_map_Item__6_new(char *key, char *value, std_map_Item__6 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 *node = std_mem_alloc__50(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__6_free_list(std_map_Item__6 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__6 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__6_insert(std_map_Map__6 *this, char *key, char *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 *node = std_map_Map__6_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__6_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__6 *new_node = std_map_Item__6_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__6_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
char *std_map_Map__6_get(std_map_Map__6 *this, char *key, char *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 *node = std_map_Map__6_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__6 *std_map_Iterator__6_cur(std_map_Iterator__6 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__6_next(std_map_Iterator__6 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__6 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__6_has_value(std_map_Iterator__6 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__6 std_map_Iterator__6_make(std_map_Map__6 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__6 it = (std_map_Iterator__6){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__6_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__6_contains(std_map_Map__6 *this, char *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__6_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__6_resize(std_map_Map__6 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__51(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__6 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__6_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__6 *new_node = std_map_Item__6_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__6_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__6_hash(std_map_Map__6 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__6 *std_map_Map__6_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__6 *map = std_mem_alloc__52(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__51(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__6 *std_map_Map__6_get_item(std_map_Map__6 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__6_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__6 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__6 std_map_Map__6_iter(std_map_Map__6 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__6_make(this);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__7 *std_map_Item__7_new(char *key, bool value, std_map_Item__7 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__7 *node = std_mem_alloc__53(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__7_free_list(std_map_Item__7 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__7 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__7 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__7_free(std_map_Map__7 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__7_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__7_insert(std_map_Map__7 *this, char *key, bool value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__7 *node = std_map_Map__7_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__7_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__7 *new_node = std_map_Item__7_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__7_resize(this);
    }
  }
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__7_contains(std_map_Map__7 *this, char *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__7_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__7_resize(std_map_Map__7 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__7 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__54(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__7 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__7_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__7 *new_node = std_map_Item__7_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__7_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__7_hash(std_map_Map__7 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__7 *std_map_Map__7_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__7 *map = std_mem_alloc__55(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__54(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__7 *std_map_Map__7_get_item(std_map_Map__7 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__7_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__7 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__8 *std_map_Item__8_new(char *key, compiler_ast_nodes_Function *value, std_map_Item__8 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *node = std_mem_alloc__56(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__8_free_list(std_map_Item__8 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__8 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 94 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_nodes_Function *std_map_Map__8_at(std_map_Map__8 *this, char *key) {

#line 95 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *node = std_map_Map__8_get_item(this, key);

#line 96 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if(!(((bool)node))) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/map.oc:96:12: Assertion failed: `node?`", "Key not found"); }

#line 97 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__8_insert(std_map_Map__8 *this, char *key, compiler_ast_nodes_Function *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *node = std_map_Map__8_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__8_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__8 *new_node = std_map_Item__8_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__8_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_nodes_Function *std_map_Map__8_get(std_map_Map__8 *this, char *key, compiler_ast_nodes_Function *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *node = std_map_Map__8_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__8 *std_map_Iterator__8_cur(std_map_Iterator__8 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__8_next(std_map_Iterator__8 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__8 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__8_has_value(std_map_Iterator__8 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__8 std_map_Iterator__8_make(std_map_Map__8 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__8 it = (std_map_Iterator__8){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__8_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__8_resize(std_map_Map__8 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__57(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__8 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__8_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__8 *new_node = std_map_Item__8_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__8_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__8_hash(std_map_Map__8 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 218 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_ValueIterator__8 std_map_Map__8_iter_values(std_map_Map__8 *this) {
  return (std_map_ValueIterator__8){.map_iter=std_map_Map__8_iter(this)};}


#line 276 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_nodes_Function *std_map_ValueIterator__8_cur(std_map_ValueIterator__8 *this) {
  return std_map_Iterator__8_cur(&this->map_iter)->value;}


#line 277 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_ValueIterator__8_next(std_map_ValueIterator__8 *this) {

#line 278 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__8_next(&this->map_iter);
}


#line 275 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_ValueIterator__8_has_value(std_map_ValueIterator__8 *this) {
  return std_map_Iterator__8_has_value(&this->map_iter);}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__8 *std_map_Map__8_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__8 *map = std_mem_alloc__58(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__57(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__8 *std_map_Map__8_get_item(std_map_Map__8 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__8_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__8 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__8 std_map_Map__8_iter(std_map_Map__8 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__8_make(this);
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__9 *std_map_Item__9_new(char *key, compiler_ast_nodes_Argument *value, std_map_Item__9 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__9 *node = std_mem_alloc__59(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__9_free_list(std_map_Item__9 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__9 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__9 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__9_free(std_map_Map__9 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__9_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__9_insert(std_map_Map__9 *this, char *key, compiler_ast_nodes_Argument *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__9 *node = std_map_Map__9_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__9_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__9 *new_node = std_map_Item__9_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__9_resize(this);
    }
  }
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__9_resize(std_map_Map__9 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__9 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__60(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__9 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__9_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__9 *new_node = std_map_Item__9_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__9_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__9_hash(std_map_Map__9 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__9 *std_map_Map__9_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__9 *map = std_mem_alloc__61(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__60(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__9 *std_map_Map__9_get_item(std_map_Map__9 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__9_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__9 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__10 *std_map_Item__10_new(char *key, compiler_ast_nodes_Variable *value, std_map_Item__10 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__10 *node = std_mem_alloc__62(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__10_free_list(std_map_Item__10 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__10 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__10 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__10_free(std_map_Map__10 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__10_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__10_insert(std_map_Map__10 *this, char *key, compiler_ast_nodes_Variable *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__10 *node = std_map_Map__10_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__10_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__10 *new_node = std_map_Item__10_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__10_resize(this);
    }
  }
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__10_resize(std_map_Map__10 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__10 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__63(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__10 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__10_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__10 *new_node = std_map_Item__10_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__10_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__10_hash(std_map_Map__10 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__10 *std_map_Map__10_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__10 *map = std_mem_alloc__64(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__63(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__10 *std_map_Map__10_get_item(std_map_Map__10 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__10_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__10 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__11 *std_map_Item__11_new(char *key, compiler_ast_nodes_MatchCond *value, std_map_Item__11 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 *node = std_mem_alloc__65(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__11_free_list(std_map_Item__11 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__11 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__11_free(std_map_Map__11 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__11_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__11_insert(std_map_Map__11 *this, char *key, compiler_ast_nodes_MatchCond *value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 *node = std_map_Map__11_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__11_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__11 *new_node = std_map_Item__11_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__11_resize(this);
    }
  }
}


#line 101 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
compiler_ast_nodes_MatchCond *std_map_Map__11_get(std_map_Map__11 *this, char *key, compiler_ast_nodes_MatchCond *defolt) {

#line 102 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 *node = std_map_Map__11_get_item(this, key);

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (!(((bool)node))) {

#line 103 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    return defolt;
  }

#line 104 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node->value;
}


#line 109 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Map__11_contains(std_map_Map__11 *this, char *key) {

#line 110 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return ((bool)std_map_Map__11_get_item(this, key));
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__11_resize(std_map_Map__11 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__66(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__11 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__11_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__11 *new_node = std_map_Item__11_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__11_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__11_hash(std_map_Map__11 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__11 *std_map_Map__11_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__11 *map = std_mem_alloc__67(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__66(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__11 *std_map_Map__11_get_item(std_map_Map__11 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__11_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__11 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__12 *std_map_Item__12_new(char *key, std_span_Span value, std_map_Item__12 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__12 *node = std_mem_alloc__68(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__12_free_list(std_map_Item__12 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__12 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__12 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__12_free(std_map_Map__12 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__12_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__12_insert(std_map_Map__12 *this, char *key, std_span_Span value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__12 *node = std_map_Map__12_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__12_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__12 *new_node = std_map_Item__12_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__12_resize(this);
    }
  }
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__12_resize(std_map_Map__12 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__12 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__69(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__12 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__12_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__12 *new_node = std_map_Item__12_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__12_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__12_hash(std_map_Map__12 *this, char *key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = str_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__12 *std_map_Map__12_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__12 *map = std_mem_alloc__70(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__69(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__12 *std_map_Map__12_get_item(std_map_Map__12 *this, char *key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__12_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__12 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (str_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 31 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__13 *std_map_Item__13_new(std_span_Span key, bool value, std_map_Item__13 *next) {

#line 32 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__13 *node = std_mem_alloc__71(1);

#line 33 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->key=key;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->value=value;

#line 35 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  node->next=next;

#line 36 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return node;
}


#line 40 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Item__13_free_list(std_map_Item__13 *this) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__13 *cur = this;

#line 42 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)cur)) {

#line 43 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__13 *next = cur->next;

#line 44 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_mem_free(cur);

#line 45 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    cur=next;
  }
}


#line 191 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__13_free(std_map_Map__13 *this) {

#line 192 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < this->num_buckets; i+=1) {

#line 193 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__13_free_list(this->buckets[i]);
  }

#line 195 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this->buckets);

#line 196 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(this);
}


#line 115 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__13_insert(std_map_Map__13 *this, std_span_Span key, bool value) {

#line 116 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__13 *node = std_map_Map__13_get_item(this, key);

#line 117 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (((bool)node)) {

#line 118 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node->value=value;
  } else {

#line 120 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    u32 hash = std_map_Map__13_hash(this, key);

#line 121 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__13 *new_node = std_map_Item__13_new(key, value, this->buckets[hash]);

#line 122 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->buckets[hash])) {

#line 123 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->num_collisions+=1;
    }

#line 125 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->buckets[hash]=new_node;

#line 126 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->size+=1;

#line 127 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (this->size > this->num_buckets) {

#line 128 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Map__13_resize(this);
    }
  }
}


#line 243 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__13 *std_map_Iterator__13_cur(std_map_Iterator__13 *this) {
  return this->node;}


#line 245 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Iterator__13_next(std_map_Iterator__13 *this) {

#line 246 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (this->idx < ((i32)this->map->num_buckets)) {

#line 247 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)this->node)) {

#line 248 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->node=this->node->next;

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->node)) {

#line 249 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        return;
      }
    }

#line 251 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->idx+=1;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    this->node=({ std_map_Item__13 *__yield_0;

#line 252 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (this->idx < ((i32)this->map->num_buckets)) {

#line 253 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = this->map->buckets[this->idx];
      } else {

#line 255 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        __yield_0 = NULL;
      }

    __yield_0; });

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (((bool)this->node)) {

#line 257 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return;
    }
  }
}


#line 241 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
bool std_map_Iterator__13_has_value(std_map_Iterator__13 *this) {
  return ((bool)this->node);}


#line 235 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__13 std_map_Iterator__13_make(std_map_Map__13 *map) {

#line 236 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__13 it = (std_map_Iterator__13){.idx=-1, .node=NULL, .map=map};

#line 237 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Iterator__13_next(&it);

#line 238 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return it;
}


#line 161 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
void std_map_Map__13_resize(std_map_Map__13 *this) {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__13 **old_buckets = this->buckets;

#line 163 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_num_buckets = this->num_buckets;

#line 164 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 old_size = this->size;

#line 165 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_collisions=0;

#line 166 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets*=2;

#line 167 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->num_buckets=u32_max(this->num_buckets, 16);

#line 168 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  this->buckets=std_mem_alloc__72(this->num_buckets);

#line 169 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__13 *node = old_buckets[i];

#line 171 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    while (((bool)node)) {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      u32 new_hash = std_map_Map__13_hash(this, node->key);

#line 173 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      std_map_Item__13 *new_node = std_map_Item__13_new(node->key, node->value, this->buckets[new_hash]);

#line 174 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      if (((bool)this->buckets[new_hash])) {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
        this->num_collisions+=1;
      }

#line 177 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      this->buckets[new_hash]=new_node;

#line 178 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      node=node->next;
    }
  }

#line 181 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  for (u32 i = 0; i < old_num_buckets; i+=1) {

#line 182 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    std_map_Item__13_free_list(old_buckets[i]);
  }

#line 184 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_mem_free(old_buckets);
}


#line 70 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
u32 std_map_Map__13_hash(std_map_Map__13 *this, std_span_Span key) {

#line 71 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_span_Span_hash(key);

#line 72 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  hash=(hash % this->num_buckets);

#line 73 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  if (hash < 0) {

#line 74 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    hash+=this->num_buckets;
  }

#line 76 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return hash;
}


#line 62 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Map__13 *std_map_Map__13_new(u32 capacity) {

#line 63 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Map__13 *map = std_mem_alloc__73(1);

#line 64 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->num_buckets=capacity;

#line 65 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  map->buckets=std_mem_alloc__72(map->num_buckets);

#line 66 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return map;
}


#line 80 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Item__13 *std_map_Map__13_get_item(std_map_Map__13 *this, std_span_Span key) {

#line 81 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  u32 hash = std_map_Map__13_hash(this, key);

#line 82 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  std_map_Item__13 *node = this->buckets[hash];

#line 83 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  while (((bool)node)) {

#line 84 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    if (std_span_Span_eq(node->key, key)) {

#line 85 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
      return node;
    }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
    node=node->next;
  }

#line 89 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return NULL;
}


#line 210 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
std_map_Iterator__13 std_map_Map__13_iter(std_map_Map__13 *this) {

#line 211 "/Users/mustafa/ocen-lang/ocen/std/map.oc"
  return std_map_Iterator__13_make(this);
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__0 std_vector_Vector__0_iter(std_vector_Vector__0 *this) {
  return std_vector_Iterator__0_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_types_Type *std_vector_Iterator__0_cur(std_vector_Iterator__0 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__0_next(std_vector_Iterator__0 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__0_has_value(std_vector_Iterator__0 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__0 std_vector_Iterator__0_make(std_vector_Vector__0 *vec) {
  return (std_vector_Iterator__0){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_types_Type *std_vector_Vector__0_at(std_vector_Vector__0 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__0_resize(std_vector_Vector__0 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__1(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__0 *std_vector_Vector__0_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__0 *list = std_mem_alloc__74(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__75(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__0_push(std_vector_Vector__0 *this, compiler_types_Type *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__0_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Scope *std_vector_Vector__1_pop(std_vector_Vector__1 *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:52:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }

#line 53 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size-=1;

#line 54 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[this->size];
}


#line 85 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Scope *std_vector_Vector__1_back(std_vector_Vector__1 *this, u32 i) {

#line 86 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:86:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:87:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }

#line 88 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[((this->size - i) - 1)];
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Scope *std_vector_Vector__1_at(std_vector_Vector__1 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__1_resize(std_vector_Vector__1 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__2(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__1 *std_vector_Vector__1_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__1 *list = std_mem_alloc__76(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__77(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__1_push(std_vector_Vector__1 *this, compiler_ast_scopes_Scope *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__1_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_program_Namespace *std_vector_Vector__2_pop(std_vector_Vector__2 *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:52:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }

#line 53 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size-=1;

#line 54 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[this->size];
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_program_Namespace *std_vector_Vector__2_at(std_vector_Vector__2 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__2_free(std_vector_Vector__2 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__2_is_empty(std_vector_Vector__2 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__2_resize(std_vector_Vector__2 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__3(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__2 *std_vector_Vector__2_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__2 *list = std_mem_alloc__78(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__79(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__2_push(std_vector_Vector__2 *this, compiler_ast_program_Namespace *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__2_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 85 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Variable *std_vector_Vector__3_back(std_vector_Vector__3 *this, u32 i) {

#line 86 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:86:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:87:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }

#line 88 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[((this->size - i) - 1)];
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__3 std_vector_Vector__3_iter(std_vector_Vector__3 *this) {
  return std_vector_Iterator__3_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Variable *std_vector_Iterator__3_cur(std_vector_Iterator__3 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__3_next(std_vector_Iterator__3 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__3_has_value(std_vector_Iterator__3 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__3 std_vector_Iterator__3_make(std_vector_Vector__3 *vec) {
  return (std_vector_Iterator__3){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Variable *std_vector_Vector__3_at(std_vector_Vector__3 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__3_free(std_vector_Vector__3 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__3_is_empty(std_vector_Vector__3 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__3_resize(std_vector_Vector__3 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__4(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__3 *std_vector_Vector__3_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__3 *list = std_mem_alloc__80(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__81(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__3_push(std_vector_Vector__3 *this, compiler_ast_nodes_Variable *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__3_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 123 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__3_clear(std_vector_Vector__3 *this) {

#line 124 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size=0;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__4 std_vector_Vector__4_iter(std_vector_Vector__4 *this) {
  return std_vector_Iterator__4_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_TemplateInstance *std_vector_Iterator__4_cur(std_vector_Iterator__4 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__4_next(std_vector_Iterator__4 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__4_has_value(std_vector_Iterator__4 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__4 std_vector_Iterator__4_make(std_vector_Vector__4 *vec) {
  return (std_vector_Iterator__4){.vec=vec, .index=0};}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__4_resize(std_vector_Vector__4 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__5(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__4 *std_vector_Vector__4_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__4 *list = std_mem_alloc__82(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__83(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__4_push(std_vector_Vector__4 *this, compiler_ast_scopes_TemplateInstance *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__4_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__5 std_vector_Vector__5_iter(std_vector_Vector__5 *this) {
  return std_vector_Iterator__5_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_ImportPart *std_vector_Iterator__5_cur(std_vector_Iterator__5 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__5_next(std_vector_Iterator__5 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__5_has_value(std_vector_Iterator__5 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__5 std_vector_Iterator__5_make(std_vector_Vector__5 *vec) {
  return (std_vector_Iterator__5){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_ImportPart *std_vector_Vector__5_at(std_vector_Vector__5 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__5_resize(std_vector_Vector__5 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__6(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__5 *std_vector_Vector__5_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__5 *list = std_mem_alloc__84(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__85(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__5_push(std_vector_Vector__5 *this, compiler_ast_nodes_ImportPart *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__5_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Function *std_vector_Vector__6_pop(std_vector_Vector__6 *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:52:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }

#line 53 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size-=1;

#line 54 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[this->size];
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__6 std_vector_Vector__6_iter(std_vector_Vector__6 *this) {
  return std_vector_Iterator__6_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Function *std_vector_Iterator__6_cur(std_vector_Iterator__6 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__6_next(std_vector_Iterator__6 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__6_has_value(std_vector_Iterator__6 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__6 std_vector_Iterator__6_make(std_vector_Vector__6 *vec) {
  return (std_vector_Iterator__6){.vec=vec, .index=0};}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__6_is_empty(std_vector_Vector__6 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__6_resize(std_vector_Vector__6 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__7(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__6 *std_vector_Vector__6_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__6 *list = std_mem_alloc__86(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__87(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__6_push(std_vector_Vector__6 *this, compiler_ast_nodes_Function *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__6_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 39 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__7_push_front(std_vector_Vector__7 *this, compiler_ast_nodes_Argument *value) {

#line 40 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 41 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__7_resize(this, (this->capacity * 2));
  }

#line 43 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  for (u32 i = this->size; i > 0; i-=1) {

#line 44 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    this->data[i]=this->data[(i - 1)];
  }

#line 46 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[0]=value;

#line 47 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__7 std_vector_Vector__7_iter(std_vector_Vector__7 *this) {
  return std_vector_Iterator__7_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Argument *std_vector_Iterator__7_cur(std_vector_Iterator__7 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__7_next(std_vector_Iterator__7 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__7_has_value(std_vector_Iterator__7 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__7 std_vector_Iterator__7_make(std_vector_Vector__7 *vec) {
  return (std_vector_Iterator__7){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Argument *std_vector_Vector__7_at(std_vector_Vector__7 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__7_free(std_vector_Vector__7 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__7_resize(std_vector_Vector__7 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__8(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__7 *std_vector_Vector__7_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__7 *list = std_mem_alloc__88(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__89(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__7_push(std_vector_Vector__7 *this, compiler_ast_nodes_Argument *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__7_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
char *std_vector_Vector__8_pop(std_vector_Vector__8 *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:52:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }

#line 53 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size-=1;

#line 54 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[this->size];
}


#line 85 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
char *std_vector_Vector__8_back(std_vector_Vector__8 *this, u32 i) {

#line 86 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:86:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }

#line 87 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:87:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }

#line 88 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[((this->size - i) - 1)];
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__8 std_vector_Vector__8_iter(std_vector_Vector__8 *this) {
  return std_vector_Iterator__8_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
char *std_vector_Iterator__8_cur(std_vector_Iterator__8 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__8_next(std_vector_Iterator__8 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__8_has_value(std_vector_Iterator__8 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__8 std_vector_Iterator__8_make(std_vector_Vector__8 *vec) {
  return (std_vector_Iterator__8){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
char *std_vector_Vector__8_at(std_vector_Vector__8 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__8_free(std_vector_Vector__8 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__8_resize(std_vector_Vector__8 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__9(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__8 *std_vector_Vector__8_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__8 *list = std_mem_alloc__90(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__91(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__8_push(std_vector_Vector__8 *this, char *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__8_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__9 std_vector_Vector__9_iter(std_vector_Vector__9 *this) {
  return std_vector_Iterator__9_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Symbol *std_vector_Iterator__9_cur(std_vector_Iterator__9 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__9_next(std_vector_Iterator__9 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__9_has_value(std_vector_Iterator__9 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__9 std_vector_Iterator__9_make(std_vector_Vector__9 *vec) {
  return (std_vector_Iterator__9){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Symbol *std_vector_Vector__9_at(std_vector_Vector__9 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__9_free(std_vector_Vector__9 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__9_is_empty(std_vector_Vector__9 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__9_resize(std_vector_Vector__9 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__10(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__9 *std_vector_Vector__9_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__9 *list = std_mem_alloc__92(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__93(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__9_push(std_vector_Vector__9 *this, compiler_ast_scopes_Symbol *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__9_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__10 std_vector_Vector__10_iter(std_vector_Vector__10 *this) {
  return std_vector_Iterator__10_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCond *std_vector_Iterator__10_cur(std_vector_Iterator__10 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__10_next(std_vector_Iterator__10 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__10_has_value(std_vector_Iterator__10 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__10 std_vector_Iterator__10_make(std_vector_Vector__10 *vec) {
  return (std_vector_Iterator__10){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCond *std_vector_Vector__10_at(std_vector_Vector__10 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__10_resize(std_vector_Vector__10 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__11(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__10 *std_vector_Vector__10_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__10 *list = std_mem_alloc__94(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__95(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__10_push(std_vector_Vector__10 *this, compiler_ast_nodes_MatchCond *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__10_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_tokens_Token *std_vector_Vector__11_at(std_vector_Vector__11 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__11_free(std_vector_Vector__11 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 119 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_tokens_Token *std_vector_Vector__11_unchecked_at(std_vector_Vector__11 *this, u32 i) {
  return this->data[i];}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__11_resize(std_vector_Vector__11 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__12(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__11 *std_vector_Vector__11_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__11 *list = std_mem_alloc__96(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__97(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__11_push(std_vector_Vector__11 *this, compiler_tokens_Token *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__11_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__12 std_vector_Vector__12_iter(std_vector_Vector__12 *this) {
  return std_vector_Iterator__12_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_attributes_Attribute *std_vector_Iterator__12_cur(std_vector_Iterator__12 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__12_next(std_vector_Iterator__12 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__12_has_value(std_vector_Iterator__12 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__12 std_vector_Iterator__12_make(std_vector_Vector__12 *vec) {
  return (std_vector_Iterator__12){.vec=vec, .index=0};}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__12_free(std_vector_Vector__12 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__12_resize(std_vector_Vector__12 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__13(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__12 *std_vector_Vector__12_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__12 *list = std_mem_alloc__98(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__99(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__12_push(std_vector_Vector__12 *this, compiler_attributes_Attribute *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__12_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 123 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__12_clear(std_vector_Vector__12 *this) {

#line 124 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size=0;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__13 std_vector_Vector__13_iter(std_vector_Vector__13 *this) {
  return std_vector_Iterator__13_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_errors_Error *std_vector_Iterator__13_cur(std_vector_Iterator__13 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__13_next(std_vector_Iterator__13 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__13_has_value(std_vector_Iterator__13 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__13 std_vector_Iterator__13_make(std_vector_Vector__13 *vec) {
  return (std_vector_Iterator__13){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_errors_Error *std_vector_Vector__13_at(std_vector_Vector__13 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__13_free(std_vector_Vector__13 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__13_is_empty(std_vector_Vector__13 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__13_resize(std_vector_Vector__13 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__14(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__13 *std_vector_Vector__13_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__13 *list = std_mem_alloc__100(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__101(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__13_push(std_vector_Vector__13 *this, compiler_errors_Error *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__13_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__14 std_vector_Vector__14_iter(std_vector_Vector__14 *this) {
  return std_vector_Iterator__14_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Structure *std_vector_Iterator__14_cur(std_vector_Iterator__14 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__14_next(std_vector_Iterator__14 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__14_has_value(std_vector_Iterator__14 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__14 std_vector_Iterator__14_make(std_vector_Vector__14 *vec) {
  return (std_vector_Iterator__14){.vec=vec, .index=0};}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__14_is_empty(std_vector_Vector__14 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__14_resize(std_vector_Vector__14 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__15(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__14 *std_vector_Vector__14_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__14 *list = std_mem_alloc__102(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__103(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__14_push(std_vector_Vector__14 *this, compiler_ast_nodes_Structure *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__14_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__15 std_vector_Vector__15_iter(std_vector_Vector__15 *this) {
  return std_vector_Iterator__15_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_Enum *std_vector_Iterator__15_cur(std_vector_Iterator__15 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__15_next(std_vector_Iterator__15 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__15_has_value(std_vector_Iterator__15 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__15 std_vector_Iterator__15_make(std_vector_Vector__15 *vec) {
  return (std_vector_Iterator__15){.vec=vec, .index=0};}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__15_is_empty(std_vector_Vector__15 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__15_resize(std_vector_Vector__15 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__16(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__15 *std_vector_Vector__15_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__15 *list = std_mem_alloc__104(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__105(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__15_push(std_vector_Vector__15 *this, compiler_ast_nodes_Enum *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__15_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 51 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_AST *std_vector_Vector__16_pop(std_vector_Vector__16 *this) {

#line 52 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:52:12: Assertion failed: `.size > 0`", "Empty vector in Vector::pop"); }

#line 53 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size-=1;

#line 54 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[this->size];
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__16 std_vector_Vector__16_iter(std_vector_Vector__16 *this) {
  return std_vector_Iterator__16_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_AST *std_vector_Iterator__16_cur(std_vector_Iterator__16 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__16_next(std_vector_Iterator__16 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__16_has_value(std_vector_Iterator__16 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__16 std_vector_Iterator__16_make(std_vector_Vector__16 *vec) {
  return (std_vector_Iterator__16){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_AST *std_vector_Vector__16_at(std_vector_Vector__16 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__16_free(std_vector_Vector__16 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 127 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Vector__16_is_empty(std_vector_Vector__16 *this) {
  return this->size==0;}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__16_resize(std_vector_Vector__16 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__17(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__16 *std_vector_Vector__16_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__16 *list = std_mem_alloc__106(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__107(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__16_push(std_vector_Vector__16 *this, compiler_ast_nodes_AST *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__16_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 92 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
jmp_buf *std_vector_Vector__17_back_ptr(std_vector_Vector__17 *this, u32 i) {

#line 93 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->size > 0)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:93:12: Assertion failed: `.size > 0`", "Empty vector in Vector::back"); }

#line 94 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:94:12: Assertion failed: `i < .size`", "Out of bounds in Vector::back"); }

#line 95 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return &this->data[((this->size - i) - 1)];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__17_resize(std_vector_Vector__17 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__18(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__17 *std_vector_Vector__17_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__17 *list = std_mem_alloc__108(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__109(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__18 std_vector_Vector__18_iter(std_vector_Vector__18 *this) {
  return std_vector_Iterator__18_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_scopes_Reference std_vector_Iterator__18_cur(std_vector_Iterator__18 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__18_next(std_vector_Iterator__18 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__18_has_value(std_vector_Iterator__18 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__18 std_vector_Iterator__18_make(std_vector_Vector__18 *vec) {
  return (std_vector_Iterator__18){.vec=vec, .index=0};}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__18_resize(std_vector_Vector__18 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__19(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__18 *std_vector_Vector__18_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__18 *list = std_mem_alloc__110(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__111(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__18_push(std_vector_Vector__18 *this, compiler_ast_scopes_Reference value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__18_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__19 std_vector_Vector__19_iter(std_vector_Vector__19 *this) {
  return std_vector_Iterator__19_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCondArg *std_vector_Iterator__19_cur(std_vector_Iterator__19 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__19_next(std_vector_Iterator__19 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__19_has_value(std_vector_Iterator__19 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__19 std_vector_Iterator__19_make(std_vector_Vector__19 *vec) {
  return (std_vector_Iterator__19){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCondArg *std_vector_Vector__19_at(std_vector_Vector__19 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__19_resize(std_vector_Vector__19 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__20(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__19 *std_vector_Vector__19_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__19 *list = std_mem_alloc__112(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__113(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__19_push(std_vector_Vector__19 *this, compiler_ast_nodes_MatchCondArg *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__19_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__20 std_vector_Vector__20_iter(std_vector_Vector__20 *this) {
  return std_vector_Iterator__20_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_EnumVariant *std_vector_Iterator__20_cur(std_vector_Iterator__20 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__20_next(std_vector_Iterator__20 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__20_has_value(std_vector_Iterator__20 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__20 std_vector_Iterator__20_make(std_vector_Vector__20 *vec) {
  return (std_vector_Iterator__20){.vec=vec, .index=0};}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__20_resize(std_vector_Vector__20 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__21(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__20 *std_vector_Vector__20_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__20 *list = std_mem_alloc__114(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__115(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__20_push(std_vector_Vector__20 *this, compiler_ast_nodes_EnumVariant *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__20_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__21 std_vector_Vector__21_iter(std_vector_Vector__21 *this) {
  return std_vector_Iterator__21_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_operators_Operator std_vector_Iterator__21_cur(std_vector_Iterator__21 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__21_next(std_vector_Iterator__21 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__21_has_value(std_vector_Iterator__21 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__21 std_vector_Iterator__21_make(std_vector_Vector__21 *vec) {
  return (std_vector_Iterator__21){.vec=vec, .index=0};}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__21_resize(std_vector_Vector__21 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__22(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__21 *std_vector_Vector__21_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__21 *list = std_mem_alloc__116(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__117(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__21_push(std_vector_Vector__21 *this, compiler_ast_operators_Operator value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__21_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__22 std_vector_Vector__22_iter(std_vector_Vector__22 *this) {
  return std_vector_Iterator__22_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__5 *std_vector_Iterator__22_cur(std_vector_Iterator__22 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__22_next(std_vector_Iterator__22 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__22_has_value(std_vector_Iterator__22 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__22 std_vector_Iterator__22_make(std_vector_Vector__22 *vec) {
  return (std_vector_Iterator__22){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__5 *std_vector_Vector__22_at(std_vector_Vector__22 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__22_resize(std_vector_Vector__22 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__23(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__22 *std_vector_Vector__22_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__22 *list = std_mem_alloc__118(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__119(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__22_push(std_vector_Vector__22 *this, std_vector_Vector__5 *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__22_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__23 std_vector_Vector__23_iter(std_vector_Vector__23 *this) {
  return std_vector_Iterator__23_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_IfBranch std_vector_Iterator__23_cur(std_vector_Iterator__23 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__23_next(std_vector_Iterator__23 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__23_has_value(std_vector_Iterator__23 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__23 std_vector_Iterator__23_make(std_vector_Vector__23 *vec) {
  return (std_vector_Iterator__23){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_IfBranch std_vector_Vector__23_at(std_vector_Vector__23 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__23_resize(std_vector_Vector__23 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__24(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__23 *std_vector_Vector__23_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__23 *list = std_mem_alloc__120(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__121(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__23_push(std_vector_Vector__23 *this, compiler_ast_nodes_IfBranch value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__23_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__24 std_vector_Vector__24_iter(std_vector_Vector__24 *this) {
  return std_vector_Iterator__24_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCase std_vector_Iterator__24_cur(std_vector_Iterator__24 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__24_next(std_vector_Iterator__24 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__24_has_value(std_vector_Iterator__24 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__24 std_vector_Iterator__24_make(std_vector_Vector__24 *vec) {
  return (std_vector_Iterator__24){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
compiler_ast_nodes_MatchCase std_vector_Vector__24_at(std_vector_Vector__24 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__24_resize(std_vector_Vector__24 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__25(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__24 *std_vector_Vector__24_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__24 *list = std_mem_alloc__122(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__123(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__24_push(std_vector_Vector__24 *this, compiler_ast_nodes_MatchCase value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__24_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__25 std_vector_Vector__25_iter(std_vector_Vector__25 *this) {
  return std_vector_Iterator__25_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_span_Span std_vector_Iterator__25_cur(std_vector_Iterator__25 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__25_next(std_vector_Iterator__25 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__25_has_value(std_vector_Iterator__25 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__25 std_vector_Iterator__25_make(std_vector_Vector__25 *vec) {
  return (std_vector_Iterator__25){.vec=vec, .index=0};}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__25_free(std_vector_Vector__25 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__25_resize(std_vector_Vector__25 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__26(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__25 *std_vector_Vector__25_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__25 *list = std_mem_alloc__124(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__125(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__25_push(std_vector_Vector__25 *this, std_span_Span value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__25_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_value_Value *std_vector_Vector__26_at(std_vector_Vector__26 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__26_resize(std_vector_Vector__26 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__27(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__26 *std_vector_Vector__26_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__26 *list = std_mem_alloc__126(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__127(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__26_push(std_vector_Vector__26 *this, std_value_Value *value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__26_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 129 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__27 std_vector_Vector__27_iter(std_vector_Vector__27 *this) {
  return std_vector_Iterator__27_make(this);}


#line 151 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_compact_map_Item__0 std_vector_Iterator__27_cur(std_vector_Iterator__27 *this) {

#line 152 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:152:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::current"); }

#line 153 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->vec->data[this->index];
}


#line 146 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Iterator__27_next(std_vector_Iterator__27 *this) {

#line 147 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(this->index < this->vec->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:147:12: Assertion failed: `.index < .vec.size`", "Out of bounds in Iterator::next"); }

#line 148 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->index+=1;
}


#line 144 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
bool std_vector_Iterator__27_has_value(std_vector_Iterator__27 *this) {
  return (this->index < this->vec->size);}


#line 142 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Iterator__27 std_vector_Iterator__27_make(std_vector_Vector__27 *vec) {
  return (std_vector_Iterator__27){.vec=vec, .index=0};}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_compact_map_Item__0 std_vector_Vector__27_at(std_vector_Vector__27 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__27_resize(std_vector_Vector__27 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__28(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__27 *std_vector_Vector__27_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__27 *list = std_mem_alloc__128(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__129(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__27_push(std_vector_Vector__27 *this, std_compact_map_Item__0 value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__27_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_compact_map_Item__1 std_vector_Vector__28_at(std_vector_Vector__28 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__28_resize(std_vector_Vector__28 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__29(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__28 *std_vector_Vector__28_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__28 *list = std_mem_alloc__130(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__131(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__28_push(std_vector_Vector__28 *this, std_compact_map_Item__1 value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__28_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 106 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
u32 std_vector_Vector__29_at(std_vector_Vector__29 *this, u32 i) {

#line 107 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if(!(i < this->size)) { ae_assert_fail("/Users/mustafa/ocen-lang/ocen/std/vector.oc:107:12: Assertion failed: `i < .size`", "Out of bounds in Vector::at"); }

#line 108 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return this->data[i];
}


#line 131 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__29_free(std_vector_Vector__29 *this) {

#line 132 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this->data);

#line 133 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_mem_free(this);
}


#line 21 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__29_resize(std_vector_Vector__29 *this, u32 new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->capacity >= new_capacity) {

#line 22 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    return;
  }

#line 23 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data=std_mem_realloc__30(this->data, this->capacity, new_capacity);

#line 24 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->capacity=new_capacity;
}


#line 12 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
std_vector_Vector__29 *std_vector_Vector__29_new(u32 capacity) {

#line 13 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  std_vector_Vector__29 *list = std_mem_alloc__132(1);

#line 14 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->capacity=capacity;

#line 15 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->data=std_mem_alloc__133(capacity);

#line 16 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  list->size=0;

#line 17 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  return list;
}


#line 29 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
void std_vector_Vector__29_push(std_vector_Vector__29 *this, u32 value) {

#line 30 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  if (this->size==this->capacity) {

#line 31 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
    std_vector_Vector__29_resize(this, (this->capacity * 2));
  }

#line 33 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->data[this->size]=value;

#line 34 "/Users/mustafa/ocen-lang/ocen/std/vector.oc"
  this->size+=1;
}


#line 160 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
void std_json_serialize_into(std_value_Value *val, std_buffer_Buffer *sb) {

#line 161 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  switch ((val->type)) {
    case std_value_ValueType_Null:
    m_437_0:
      {

#line 162 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "null");
      } break;
    case std_value_ValueType_Bool:
    m_437_1:
      {

#line 163 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, (val->u.as_bool ? "true" : "false"));
      } break;
    case std_value_ValueType_Integer:
    m_437_2:
      {

#line 164 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str_f(sb, std_format("%" PRId64 "", val->u.as_int));
      } break;
    case std_value_ValueType_Float:
    m_437_3:
      {

#line 165 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str_f(sb, std_format("%f", val->u.as_float));
      } break;
    case std_value_ValueType_String:
    m_437_4:
      {

#line 167 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "\"");

#line 168 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer buf = val->u.as_str;

#line 169 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        for (u32 i = 0; i < buf.size; i+=1) {

#line 170 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          char c = ((char)buf.data[i]);

#line 171 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          switch (c) {
            case '\b': {

#line 172 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\b");
            } break;
            case '\f': {

#line 173 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\f");
            } break;
            case '\n': {

#line 174 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\n");
            } break;
            case '\r': {

#line 175 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\r");
            } break;
            case '\t': {

#line 176 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\t");
            } break;
            case '\\': {

#line 177 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\\\");
            } break;
            case '"': {

#line 178 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, "\\\"");
            } break;
            default: {

#line 180 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              if (char_is_print(c)) {

#line 181 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
                std_buffer_Buffer_write_char(sb, c);
              } else {

#line 183 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
                std_buffer_Buffer_write_str_f(sb, std_format("\\x%02x", buf.data[i]));
              }
            } break;
          }
        }

#line 188 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "\"");
      } break;
    case std_value_ValueType_List:
    m_437_5:
      {

#line 191 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "[");

#line 192 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_vector_Vector__26 *lst = val->u.as_list;

#line 193 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        for (u32 i = 0; i < lst->size; i+=1) {

#line 194 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          std_value_Value *value = std_vector_Vector__26_at(lst, i);

#line 195 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          if (i > 0) {

#line 196 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_buffer_Buffer_write_str(sb, ",");
          }

#line 198 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          std_json_serialize_into(value, sb);
        }

#line 200 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "]");
      } break;
    case std_value_ValueType_Dictionary:
    m_437_6:
      {

#line 203 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "{");

#line 204 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        bool first = true;

#line 205 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        for (std_compact_map_Iterator__0 _i228 = std_compact_map_Map__0_iter(val->u.as_dict); std_compact_map_Iterator__0_has_value(&_i228); std_compact_map_Iterator__0_next(&_i228)) {

#line 205 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          std_compact_map_Item__0 iter = std_compact_map_Iterator__0_cur(&_i228);

#line 205 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
          {

#line 206 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            if (!(first)) {

#line 207 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
              std_buffer_Buffer_write_str(sb, ",");
            }

#line 209 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            first=false;

#line 210 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_buffer_Buffer_write_str(sb, "\"");

#line 211 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_buffer_Buffer_write_str(sb, iter.key);

#line 212 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_buffer_Buffer_write_str(sb, "\":");

#line 213 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_value_Value *value = iter.value;

#line 214 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
            std_json_serialize_into(value, sb);
          }
        }

#line 216 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
        std_buffer_Buffer_write_str(sb, "}");
      } break;
  }
}


#line 222 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
std_buffer_Buffer std_json_serialize(std_value_Value *val) {

#line 223 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  std_buffer_Buffer sb = std_buffer_Buffer_make(16);

#line 224 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  std_json_serialize_into(val, &sb);

#line 225 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  return sb;
}


#line 229 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
void std_json_write_to_file(std_value_Value *val, char *filename) {

#line 230 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  std_buffer_Buffer sb = std_json_serialize(val);

#line 231 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  std_fs_write_file(filename, sb);

#line 232 "/Users/mustafa/ocen-lang/ocen/std/json.oc"
  std_buffer_Buffer_free(&sb);
}

